<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="c,c++,java,python,leetcode,algorithm,reading,life,moods,machine-learning,data-mining,deep-learning,AI" />
   
  <meta name="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    leetcode Tree 整理版 |  一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-leetcode-tree"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  leetcode Tree 整理版
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/leetcode-tree/" class="article-date">
  <time datetime="2015-03-02T03:10:45.000Z" itemprop="datePublished">2015-03-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/Leetcode/">Leetcode</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">14k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">78 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本次题解为 leetcode tree 的整理，包括</p>
<ul>
<li>依照leetcode定义 自己写的createTree方法，便于测试中序遍历的下标和</li>
<li><strong>94</strong> Binary Tree Inorder Traversal</li>
<li><strong>95</strong> Unique Binary Search Trees II</li>
<li><strong>96</strong> Unique Binary Search Trees</li>
<li><strong>98</strong> Validate Binary Search Tree</li>
<li><strong>99</strong> Recover Binary Search Tree</li>
<li><strong>100</strong> Same Tree</li>
<li><strong>101</strong> Symmetric Tree</li>
<li><strong>102</strong> Binary Tree Level Order Traversal</li>
<li><strong>103</strong> Binary Tree Zigzag Level Order Traversal</li>
<li><strong>104</strong> Maximum Depth of Binary Tree</li>
<li><strong>105</strong> Construct Binary Tree from Preorder and Inorder Traversal</li>
<li><strong>106</strong> Construct Binary Tree from Inorder and Postorder Traversal</li>
<li><strong>107</strong> Binary Tree Level Order Traversal II</li>
<li><strong>108</strong> Convert Sorted Array to Binary Search Tree</li>
<li><strong>109</strong> Convert Sorted List to Binary Search Tree</li>
<li><strong>110</strong> Balanced Binary Tree</li>
<li><strong>111</strong> Minimum Depth of Binary Tree</li>
<li><strong>112</strong> Path Sum</li>
<li><strong>113</strong> Path Sum II</li>
<li><strong>114</strong> Flatten Binary Tree to Linked List</li>
<li><strong>116</strong> Populating Next Right Pointers in Each Node</li>
<li><strong>117</strong> Populating Next Right Pointers in Each Node II</li>
<li><strong>124</strong> Binary Tree Maximum Path Sum</li>
<li><strong>129</strong> Sum Root to Leaf Numbers</li>
<li><strong>144</strong> Binary Tree Preorder Traversal</li>
<li><strong>145</strong> Binary Tree Postorder Traversal</li>
<li><strong>173</strong> Binary Search Tree Iterator</li>
<li><strong>199</strong> Binary Tree Right Side View</li>
<li><strong>222</strong> Count Complete Tree Nodes</li>
<li><strong>226</strong> Invert Binary Tree</li>
<li><strong>230</strong> Kth Smallest Element in a BST</li>
<li><strong>235</strong> Lowest Common Ancestor of a Binary Search Tree</li>
<li><strong>236</strong> Lowest Common Ancestor of a Binary Tree</li>
<li><strong>257</strong> Binary Tree Paths</li>
<li><strong>297</strong> Serialize and Deserialize Binary Tree</li>
<li><strong>449</strong>. Serialize and Deserialize BST</li>
</ul>
<a id="more"></a>
<h2 id="1-首先是leetcode对于树的表示方法：">1.首先是leetcode对于树的表示方法：</h2>
<blockquote>
<p><strong>OJ’s Binary Tree Serialization:</strong></p>
<p>The serialization of a binary tree follows a level order traversal, where ‘#’ signifies a path terminator where no node exists below.</p>
<p>Here’s an example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br><span class="line">   \</span><br><span class="line">    5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The above binary tree is serialized as <code>&quot;&#123;1,2,3,null,null,4,null,null,5&#125;&quot;</code>.</p>
</blockquote>
<p>树结点表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br></pre></td></tr></table></figure>
<p>我的建树方法见297题 Serialize and Deserialize Binary Tree的方法一</p>
<h2 id="2-题解归类">2.题解归类</h2>
<h3 id="1-构建树">1.构建树</h3>
<ul>
<li>用前序和中序建树105</li>
<li>用后序和中序建树106</li>
<li>数组构建BST 108</li>
<li>链表构建BST 109</li>
</ul>
<h3 id="2-树的遍历">2.树的遍历</h3>
<ul>
<li>前序 144</li>
<li>中序 94</li>
<li>后序 145</li>
<li>层次 102 103 107</li>
</ul>
<h3 id="3-树的属性">3.树的属性</h3>
<ul>
<li>求深度 104</li>
<li>是否平衡是平衡树 110</li>
<li>最小深度 111</li>
</ul>
<h3 id="4-bst树">4.BST树</h3>
<ul>
<li>判断BST是否合法 98</li>
<li>恢复BST 99</li>
<li>BST实现迭代：173（用到某一遍历）</li>
</ul>
<p></p>
<h2 id="3-题解代码-按题号顺序">3.题解代码（按题号顺序）</h2>
<h3 id="94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</h3>
<blockquote>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>
Given binary tree <code>&#123;1,#,2,3&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return <code>[1,3,2]</code>.</p>
</blockquote>
<p>题目地址:<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">leetcode 94 Binary Tree Inorder Traversal</a></p>
<p>题意：给定一棵树，求它的中序遍历。</p>
<p>思路：中序遍历和前序、后序不同地方在于是先输出左子结点然后根结点，最后右子结点。</p>
<p>递归版本很好理解。</p>
<p>非递归版本先将所有左子树入栈，之后将所有右子树的左子树入栈。（看代码吧~）</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        ans&#x3D;[]</span><br><span class="line">        self.dfs(root,ans)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def dfs(self,root,ans):</span><br><span class="line">        if not root : return</span><br><span class="line">        self.dfs(root.left,ans)</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.dfs(root.right,ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Python非递归版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        if not root: return []</span><br><span class="line">        ans,q&#x3D;[],[]</span><br><span class="line">        self.allLeftIntoStack(root,q)</span><br><span class="line">        while q:</span><br><span class="line">            t&#x3D;q.pop()</span><br><span class="line">            ans.append(t.val)</span><br><span class="line">            if t.right:self.allLeftIntoStack(t.right,q)</span><br><span class="line"></span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def allLeftIntoStack(self,root,q):</span><br><span class="line">        while root:</span><br><span class="line">            q.append(root)</span><br><span class="line">            root&#x3D;root.left</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="95-unique-binary-search-trees-ii">95. Unique Binary Search Trees II</h3>
<blockquote>
<p>Given <em>n</em>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>.</p>
<p>For example,<br>
Given <em>n</em> = 3, your program should return all 5 unique BST’s shown below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">leetcode Unique Binary Search Trees II</a></p>
<p>题目大意：给定n，求1~n共n个数，能组成几棵不一样的BST，建立这些树并且返回所有不同BST的根结点。</p>
<p>思路：</p>
<p>分治，对于1~n这n个数，都有可能成为根结点。枚举1~n，对于 1&lt;=i&lt;=n，有i的左结点为[1,i-1]  (i-1 &gt;=1),右结点是[i+1,n] i+1 &lt;=n</p>
<p>递归的获取左右子结点，然后只需要建立根结点，使根结点的左右子结点指向获取的左右子结点即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">vector&lt;TreeNode*&gt; build(int s, int e) &#123;</span><br><span class="line">vector&lt;TreeNode*&gt; ans;</span><br><span class="line">if (s &gt; e) &#123;</span><br><span class="line">ans.push_back(nullptr);</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int k &#x3D; s; k &lt;&#x3D; e; ++k) &#123;</span><br><span class="line">vector&lt;TreeNode*&gt; left &#x3D; build(s, k - 1);</span><br><span class="line">vector&lt;TreeNode*&gt; right &#x3D; build(k + 1, e);</span><br><span class="line">for (int i &#x3D; 0; i &lt; left.size(); ++i) &#123;</span><br><span class="line">for (int j &#x3D; 0; j &lt; right.size(); ++j) &#123;</span><br><span class="line">TreeNode *root &#x3D; new TreeNode(k);</span><br><span class="line">root-&gt;left &#x3D; left[i];</span><br><span class="line">root-&gt;right &#x3D; right[j];</span><br><span class="line">ans.push_back(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</span><br><span class="line">return n &gt;&#x3D; 1 ? build(1, n) : vector&lt;TreeNode *&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def generateTrees(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[TreeNode]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.dfs(1, n) if n &gt;&#x3D; 1 else []</span><br><span class="line"></span><br><span class="line">    def dfs(self, s, e):</span><br><span class="line">        if s &gt; e: return [None]</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        for i in range(s, e + 1):</span><br><span class="line">            L &#x3D; self.dfs(s, i - 1)</span><br><span class="line">            R &#x3D; self.dfs(i + 1, e)</span><br><span class="line">            for left in L:</span><br><span class="line">                for right in R:</span><br><span class="line">                    root &#x3D; TreeNode(i)</span><br><span class="line">                    root.left, root.right &#x3D; left, right</span><br><span class="line">                    ans.append(root)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="96-unique-binary-search-trees">96. Unique Binary Search Trees</h3>
<blockquote>
<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1…<em>n</em>?</p>
<p>For example,<br>
Given <em>n</em> = 3, there are a total of 5 unique BST’s.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1         3     3      2      1</span><br><span class="line"> \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">  3     2     1      1   3      2</span><br><span class="line"> &#x2F;     &#x2F;       \                 \</span><br><span class="line">2     1         2                 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p></p>
<p>题目大意：给定n，求1~n共n个数，能组成几棵不一样的BST</p>
<p>思路：</p>
<p>可以类似95题写dfs+记忆化搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">int dfs(int n, vector&lt;int&gt; &amp;dp) &#123;</span><br><span class="line">if (n &#x3D;&#x3D; 0) return 0;</span><br><span class="line">if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">if (dp[n] !&#x3D; -1) return dp[n];</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int k &#x3D; 1; k &lt;&#x3D; n; ++k) &#123;</span><br><span class="line">int left &#x3D; dfs(k - 1, dp);</span><br><span class="line">int right &#x3D; dfs(n - k, dp);</span><br><span class="line">if (left &#x3D;&#x3D; 0) cnt +&#x3D; right;</span><br><span class="line">else if (right &#x3D;&#x3D; 0) cnt +&#x3D; left;</span><br><span class="line">else cnt +&#x3D; right * left;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n] &#x3D; cnt;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int numTrees(int n) &#123;</span><br><span class="line">vector&lt;int&gt; dp(n + 1, -1);</span><br><span class="line">return dfs(n, dp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以写成非递归的形式：</p>
<p>设dp[n]为n个数组成的不同BST总数。</p>
<p>如果左儿子个数为j，有儿子显然为n-1-j个，那么总共显然有 dp[j] * dp[n-1-j]种</p>
<p>故枚举j从0~n-1然后相加既可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int numTrees(int n) &#123;</span><br><span class="line">vector&lt;int&gt; dp(n + 1, 0);</span><br><span class="line">dp[0] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">for (int j &#x3D; 0; j &lt; i; ++j)</span><br><span class="line">dp[i] +&#x3D; dp[j] * dp[i - j - 1];</span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numTrees(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; [0] * (n + 1)</span><br><span class="line">        dp[0] &#x3D; 1</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                dp[i] +&#x3D; dp[j] * dp[i - 1 - j]</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="98-validate-binary-search-tree">98. Validate Binary Search Tree</h3>
<blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">leetcode 98 Validate Binary Search Tree</a></p>
<p>题意：给定一棵BST，判断其是否合法。合法需要满足：</p>
<ul>
<li>根结点大于左子树结点， 根结点小于右子树结点。</li>
<li>左右子树是合法的BST</li>
</ul>
<p>思路:</p>
<ol>
<li>递归判断左右子树。需要用出现过的最大、最小值来判断。 如左子树最大值不可能超过根，右子树最小值不可能小于根</li>
<li>中序遍历。 合法的BST中序遍历必为有序序列。</li>
</ol>
<p><strong>方法一</strong></p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    bool dfs(TreeNode *root, long min_v, long max_v)&#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        if(root-&gt;val &lt;&#x3D; min_v  root-&gt;val &gt;&#x3D; max_v)</span><br><span class="line">            return false;</span><br><span class="line">        return dfs(root-&gt;left, min_v, root-&gt;val) &amp;&amp; dfs(root-&gt;right, root-&gt;val, max_v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return dfs(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a boolean</span><br><span class="line">    def isValidBST(self, root):</span><br><span class="line">        INF &#x3D; float(&#39;inf&#39;)</span><br><span class="line">        return self.judge(root,-INF,INF)</span><br><span class="line">    def judge(self,root,minV,maxV):</span><br><span class="line">        if not root: return True   </span><br><span class="line">        if root.val &lt;&#x3D; minV or root.val &gt;&#x3D; maxV: return False      </span><br><span class="line">        return self.judge(root.left,minV,root.val) and \</span><br><span class="line">            self.judge(root.right,root.val,maxV)</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    bool dfs(TreeNode *root, TreeNode * &amp;pre)&#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        bool left &#x3D; dfs(root-&gt;left, pre);</span><br><span class="line">        if(!left  pre &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        pre &#x3D; root;</span><br><span class="line">        return dfs(root-&gt;right, pre);            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *pre &#x3D; nullptr;</span><br><span class="line">        return dfs(root, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isValidBST(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        pre &#x3D; [None]</span><br><span class="line">        return self.dfs(root, pre)</span><br><span class="line">    </span><br><span class="line">    def dfs(self, root, pre):</span><br><span class="line">        if not root: return True</span><br><span class="line">        if not self.dfs(root.left, pre) or pre[0] and root.val &lt;&#x3D; pre[0].val:</span><br><span class="line">            return False</span><br><span class="line">        pre[0] &#x3D; root</span><br><span class="line">        return self.dfs(root.right, pre)</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="99-recover-binary-search-tree">99. Recover Binary Search Tree</h3>
<blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p><strong>Note:</strong><br>
A solution using O(<em>n</em>) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/recover-binary-search-tree/">leetcode 99 Recover Binary Search Tree</a></p>
<p>题意：一棵BST中有两个元素被调换了，求在不破坏BST情况下，将其恢复。</p>
<p>思路：对于此问题，关键是要找到被调换的两个元素。我们知道，对于中序遍历，合法的BST数必为有序，故进行中序遍历，如果pre.val &gt;root.val说明有误。注意区分第一次和第二次，标记即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(TreeNode *root, TreeNode *&amp;pre, TreeNode *&amp;first, TreeNode *&amp;second)&#123;</span><br><span class="line">        if(!root)  return;</span><br><span class="line">        dfs(root-&gt;left, pre, first, second);</span><br><span class="line">        if(pre &amp;&amp; root-&gt;val &lt;&#x3D; pre-&gt;val)&#123;</span><br><span class="line">            if(!first)  first &#x3D; pre;</span><br><span class="line">            second &#x3D; root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre &#x3D; root;</span><br><span class="line">        dfs(root-&gt;right, pre, first, second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">        TreeNode *first &#x3D; nullptr, *second &#x3D; nullptr, *pre &#x3D; nullptr;</span><br><span class="line">        dfs(root, pre, first, second);</span><br><span class="line">        swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a tree node</span><br><span class="line">    def recoverTree(self, root):</span><br><span class="line">        self.pre,self.first,self.second&#x3D;None,None,None</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        t&#x3D;self.first.val</span><br><span class="line">        self.first.val,self.second.val &#x3D; self.second.val,t</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def dfs(self,root):</span><br><span class="line">        if not root: return</span><br><span class="line">        if root.left:  self.dfs(root.left)</span><br><span class="line">        </span><br><span class="line">        if self.pre:</span><br><span class="line">            if self.pre.val &gt; root.val : </span><br><span class="line">                if not self.first :self.first,self.second&#x3D;self.pre,root</span><br><span class="line">                else:   self.second&#x3D;root</span><br><span class="line"></span><br><span class="line">        self.pre&#x3D;root</span><br><span class="line">        if root.right: self.dfs(root.right)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="100-same-tree">100. Same Tree</h3>
<blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">leetcode Same Tree</a></p>
<p>题目大意：给定两棵树，判断他们是否相等（结构和值都相等）</p>
<p>思路：递归判断即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">if (!p &amp;&amp; !q) return true;</span><br><span class="line">if (p &amp;&amp; !q  !p &amp;&amp; q) return false;</span><br><span class="line">if (p-&gt;val !&#x3D; q-&gt;val) return false;</span><br><span class="line">return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param p, a tree node</span><br><span class="line">    # @param q, a tree node</span><br><span class="line">    # @return a boolean</span><br><span class="line">    def isSameTree(self, p, q):</span><br><span class="line">        if not p and not q: return True</span><br><span class="line">        if p and q:</span><br><span class="line">            return p.val&#x3D;&#x3D;q.val and self.isSameTree(p.left,q.left) \</span><br><span class="line">                and self.isSameTree(p.right,q.right)</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="101-symmetric-tree">101. Symmetric Tree</h3>
<blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>But the following is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong><br>
Bonus points if you could solve it both recursively and iteratively.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">leetcode Symmetric Tree</a></p>
<p>题目大意：给定一棵树，判断它是否关于root对称。</p>
<p>思路：继续递归吧。。。水</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    bool judge(TreeNode* a, TreeNode *b)&#123;</span><br><span class="line">        if(!a &amp;&amp; !b) return true;</span><br><span class="line">        if(!a &amp;&amp; b  a &amp;&amp; !b) return false;</span><br><span class="line">        if(a-&gt;val !&#x3D; b-&gt;val) return false;</span><br><span class="line">        return judge(a-&gt;left, b-&gt;right) &amp;&amp; judge(a-&gt;right, b-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        return !root  judge(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a boolean</span><br><span class="line">    def isSymmetric(self, root):</span><br><span class="line">        if not root: return True</span><br><span class="line">        return self.judge(root.left,root.right)</span><br><span class="line"></span><br><span class="line">    def judge(self,L,R):</span><br><span class="line">        if not L and not R: return True</span><br><span class="line">        if L and R:</span><br><span class="line">            return L.val&#x3D;&#x3D;R.val and self.judge(L.left,R.right) \</span><br><span class="line">            and self.judge(L.right,R.left)</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以用BFS的方式做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return true;</span><br><span class="line">        vector&lt;TreeNode *&gt; cur_level&#123;root-&gt;left, root-&gt;right&#125;;</span><br><span class="line">        </span><br><span class="line">        while(!cur_level.empty())&#123;</span><br><span class="line">            int n &#x3D; cur_level.size();</span><br><span class="line">            for(int i &#x3D; 0, j &#x3D; n - 1; i &lt; j; ++i, --j)&#123;</span><br><span class="line">                TreeNode *a &#x3D; cur_level[i];</span><br><span class="line">                TreeNode *b &#x3D; cur_level[j];</span><br><span class="line">                if(!a &amp;&amp; b  a &amp;&amp; !b) return false;</span><br><span class="line">                if(a &amp;&amp; b &amp;&amp; a-&gt;val !&#x3D; b-&gt;val) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;TreeNode *&gt; next_level;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; n; ++i)&#123;</span><br><span class="line">                if(!cur_level[i]) continue;</span><br><span class="line">                next_level.push_back(cur_level[i]-&gt;left);</span><br><span class="line">                next_level.push_back(cur_level[i]-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            cur_level &#x3D; next_level;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal</h3>
<blockquote>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>
Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">leetcode Binary Tree Level Order Traversal</a></p>
<p>题目大意：给定一棵树，返回其层次遍历</p>
<p>思路：</p>
<p>方法一: 用队列进行层次遍历</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(!root) return ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            vector&lt;int&gt; cur_level;</span><br><span class="line">            int n &#x3D; q.size();</span><br><span class="line">            while(n--)&#123;</span><br><span class="line">                TreeNode *cur &#x3D; q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                cur_level.push_back(cur-&gt;val);</span><br><span class="line">                if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cur_level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def levelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return []</span><br><span class="line">        q, ans &#x3D; collections.deque([root]), []</span><br><span class="line">        while q:</span><br><span class="line">            cur_level &#x3D; []</span><br><span class="line">            n &#x3D; len(q)</span><br><span class="line">            for _ in range(n):</span><br><span class="line">                cur &#x3D; q.popleft()</span><br><span class="line">                cur_level.append(cur.val)</span><br><span class="line">                if cur.left: q.append(cur.left)</span><br><span class="line">                if cur.right: q.append(cur.right)</span><br><span class="line">            ans.append(cur_level)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p>方法二 先序遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(int h, TreeNode *root, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        if(h &gt;&#x3D; ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt;&#123;&#125;);</span><br><span class="line">        ans[h].push_back(root-&gt;val);</span><br><span class="line">        dfs(h + 1, root-&gt;left, ans);</span><br><span class="line">        dfs(h + 1, root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        dfs(0, root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="103-binary-tree-zigzag-level-order-traversal">103. Binary Tree Zigzag Level Order Traversal</h3>
<blockquote>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>
Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode Binary Tree Zigzag Level Order Traversal</a></p>
<p>题目大意：给定一棵树，返回其层次遍历（要求第一行从左到右，第二行从右到左）</p>
<p>思路：和上面一题差不多，加个判断奇偶即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(!root) return ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        for(int level &#x3D; 0; !q.empty(); ++level)&#123;</span><br><span class="line">            int t &#x3D; q.size();</span><br><span class="line">            vector&lt;int&gt; cur_level;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; t; ++i)&#123;</span><br><span class="line">                TreeNode *cur &#x3D; q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                cur_level.push_back(cur-&gt;val);</span><br><span class="line">                if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            if(level &amp; 1)</span><br><span class="line">                reverse(cur_level.begin(), cur_level.end());</span><br><span class="line">            ans.push_back(cur_level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def zigzagLevelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return []</span><br><span class="line">        q &#x3D; collections.deque([root])</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        level &#x3D; 0</span><br><span class="line">        while q:</span><br><span class="line">            cur_level &#x3D; []</span><br><span class="line">            cur_size &#x3D; len(q)</span><br><span class="line">            for i in range(cur_size):</span><br><span class="line">                cur &#x3D; q.popleft()</span><br><span class="line">                if cur.left: q.append(cur.left)</span><br><span class="line">                if cur.right: q.append(cur.right)</span><br><span class="line">                cur_level.append(cur.val)</span><br><span class="line">            ans.append(cur_level[::-1] if level &amp; 1 else cur_level)</span><br><span class="line">            level +&#x3D; 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p>当然还可以不逆序，直接输出到对应位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def zigzagLevelOrder(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return []</span><br><span class="line">        q &#x3D; collections.deque([root])</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        level &#x3D; 0</span><br><span class="line">        while q:</span><br><span class="line">            cur_size &#x3D; len(q)</span><br><span class="line">            cur_level &#x3D; [0] * cur_size</span><br><span class="line">            for i in range(cur_size):</span><br><span class="line">                cur &#x3D; q.popleft()</span><br><span class="line">                if cur.left: q.append(cur.left)</span><br><span class="line">                if cur.right: q.append(cur.right)</span><br><span class="line">                index &#x3D; (cur_size - i - 1) if level &amp; 1 else i</span><br><span class="line">                cur_level[index] &#x3D; cur.val</span><br><span class="line">            ans.append(cur_level)</span><br><span class="line">            level +&#x3D; 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="104-maximum-depth-of-binary-tree">104. Maximum Depth of Binary Tree</h3>
<blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">leetcode Maximum Depth of Binary Tree</a></p>
<p>题目大意：给定一棵树，返回其最大深度。</p>
<p>思路：思路，dfs.</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(int cur, int &amp;max_depth, TreeNode *root)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        if(++cur &gt; max_depth)</span><br><span class="line">            max_depth &#x3D; cur;</span><br><span class="line">        </span><br><span class="line">        dfs(cur, max_depth, root-&gt;left);</span><br><span class="line">        dfs(cur, max_depth, root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        dfs(0, ans, root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种更简洁写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int dfs(int cur, TreeNode *root)&#123;</span><br><span class="line">        if(!root) return cur;</span><br><span class="line">        return max(dfs(cur + 1, root-&gt;left), dfs(cur + 1, root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        return dfs(0, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def dfs(self, cur, root):</span><br><span class="line">        if not root: return cur</span><br><span class="line">        return max(self.dfs(cur + 1, root.left), self.dfs(cur + 1, root.right))</span><br><span class="line">    </span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.dfs(0, root)</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="105-construct-binary-tree-from-preorder-and-inorder-traversal">105 . Construct Binary Tree from Preorder and Inorder Traversal</h3>
<blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>
You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<p></p>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<p>题意：给定一棵树的前序和中序遍历，构建这棵树</p>
<p>思路：以下面的例子为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>前序遍历为： 3,9,20,15,7</p>
<p>中序遍历为： 9,3,15,20,7</p>
<p>前序遍历的第一个一定是根结点，而中序遍历的根结点把树准确的分为左子树和右子树。</p>
<p>所以，在中序遍历中查找3，发现下标为1，那么[0,1)为左子树，[2,5)为右子树。</p>
<p>递归的往下查找即可。</p>
<p>可以写出简洁的code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def buildTree(self, preorder, inorder):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not preorder: return None</span><br><span class="line">        root &#x3D; TreeNode(preorder[0])</span><br><span class="line">        index &#x3D; inorder.index(preorder[0])</span><br><span class="line">        root.left &#x3D; self.buildTree(preorder[1: index + 1], inorder[:index])</span><br><span class="line">        root.right &#x3D; self.buildTree(preorder[index + 1:], inorder[index + 1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>
<p>不过这样每次都需要切片，效率比较低。</p>
<p>我们可以设前序遍历开始为pb,结束pe，中序遍历开始为ib,结束为ie。前序遍历的第pb个元素（即当前根结点）在中序遍历中下标为index</p>
<p>则长度为len = index - ib</p>
<p>那么有，</p>
<ul>
<li>左子树，每次递归的下标为：[pb + 1, pb + len + 1)   [ ib, ib+len)</li>
<li>右子树：[pb + len + 1, pe)  [ib + len + 1, ie)</li>
</ul>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def _build(self, pb, pe, ib, ie, preorder, inorder):</span><br><span class="line">        if pb &gt;&#x3D; pe or ib &gt;&#x3D; ie: return None</span><br><span class="line">        root &#x3D; TreeNode(preorder[pb])</span><br><span class="line">        len_left &#x3D; inorder.index(preorder[pb]) - ib</span><br><span class="line">        root.left &#x3D; self._build(pb + 1, pb + len_left + 1, ib, ib + len_left, preorder, inorder)</span><br><span class="line">        root.right &#x3D; self._build(pb + len_left + 1, pe, ib + len_left + 1, ie, preorder, inorder)</span><br><span class="line">        return root</span><br><span class="line">        </span><br><span class="line">    def buildTree(self, preorder, inorder):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._build(0, len(preorder), 0, len(inorder), preorder, inorder)</span><br></pre></td></tr></table></figure>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode* build(int pb, int pe, int ib, int ie, const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder)&#123;</span><br><span class="line">        if(pb &gt;&#x3D; pe  ib &gt;&#x3D; ie) return nullptr;</span><br><span class="line">        TreeNode *root &#x3D; new TreeNode(preorder[pb]);</span><br><span class="line">        int len &#x3D; find(inorder.begin() + ib, inorder.begin() + ie, preorder[pb]) - inorder.begin() - ib;</span><br><span class="line">        root-&gt;left &#x3D; build(pb + 1, pb + len + 1, ib, ib + len, preorder, inorder);</span><br><span class="line">        root-&gt;right &#x3D; build(pb + len + 1, pe, ib + len + 1, ie, preorder, inorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)&#123;</span><br><span class="line">        return build(0, preorder.size(), 0, inorder.size(), preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">106. Construct Binary Tree from Inorder and Postorder Traversal</h3>
<blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br>
You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<p></p>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode 106 Construct Binary Tree from Inorder and Postorder Traversal</a></p>
<p>题意：给定一棵树的中序和后序遍历，构建这棵树。</p>
<p>思路：</p>
<p>思路：以下面的例子为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>后序遍历为： 9,15,7,20,3</p>
<p>中序遍历为： 9,3,15,20,7</p>
<p>后序遍历的最后一个一定是根结点，而中序遍历的根结点把树准确的分为左子树和右子树。</p>
<p>和105题差不多，我们可以看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def buildTree(self, preorder, inorder):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not preorder: return None</span><br><span class="line">        root &#x3D; TreeNode(preorder[0])</span><br><span class="line">        index &#x3D; inorder.index(preorder[0])</span><br><span class="line">        root.left &#x3D; self.buildTree(preorder[1: index + 1], inorder[:index])</span><br><span class="line">        root.right &#x3D; self.buildTree(preorder[index + 1:], inorder[index + 1:])</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>
<p>我们可以设后序遍历开始为pb,结束pe，中序遍历开始为ib,结束为ie。前序遍历的第pb个元素（即当前根结点）在中序遍历中下标为index</p>
<p>则长度为len = index - ib</p>
<p>那么有，</p>
<ul>
<li>左子树，每次递归的下标为：[pb,  pb + len)   [ ib, ib+len)</li>
<li>右子树：[pb + len, pe - 1)  [ib + len + 1, ie)</li>
</ul>
<p>可以看出中序遍历的下标和上面一题是一样的</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def _build(self, ib, ie, pb, pe, inorder, preorder):</span><br><span class="line">        if ib &gt;&#x3D; ie or pb &gt; pe: return None</span><br><span class="line">        root &#x3D; TreeNode(preorder[pe - 1])</span><br><span class="line">        len_left &#x3D; inorder.index(preorder[pe - 1]) - ib</span><br><span class="line">        root.left &#x3D; self._build(ib, ib + len_left, pb, pb + len_left, inorder, preorder)</span><br><span class="line">        root.right &#x3D; self._build(ib + len_left + 1, ie, pb + len_left, pe - 1, inorder, preorder)</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line">    def buildTree(self, inorder, postorder):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :type postorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self._build(0, len(inorder), 0, len(postorder), inorder, postorder)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode* build(int is, int ie, int ps, int pe, const vector&lt;int&gt;&amp; inorder, const vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        if(is &gt;&#x3D; ie  ps &gt;&#x3D; pe) return nullptr;</span><br><span class="line">        TreeNode *root &#x3D; new TreeNode(postorder[pe - 1]);</span><br><span class="line">        int len &#x3D; find(inorder.begin() + is, inorder.begin() + ie, postorder[pe - 1]) - inorder.begin() - is;</span><br><span class="line">        root-&gt;left &#x3D; build(is, is + len, ps, ps + len, inorder, postorder);</span><br><span class="line">        root-&gt;right &#x3D; build(is + len + 1, ie, ps + len, pe - 1, inorder, postorder);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">        return build(0, inorder.size(), 0, postorder.size(), inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="107-binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II</h3>
<blockquote>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>
Given binary tree <code>&#123;3,9,20,#,#,15,7&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p></p>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">leetcode Binary Tree Level Order Traversal II</a></p>
<p>题目大意：给定一棵树，返回其层次遍历的逆序。</p>
<p>思路：和102题其实一样，最后结果逆序即可。太水了</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(!root) return ans;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int pre_size &#x3D; q.size();</span><br><span class="line">            vector&lt;int&gt; cur_level;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; pre_size; ++i)&#123;</span><br><span class="line">                TreeNode *cur &#x3D; q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                cur_level.push_back(cur-&gt;val);</span><br><span class="line">                if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">                if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(cur_level);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def levelOrderBottom(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return [] </span><br><span class="line">        q, ans &#x3D; collections.deque([root]), [] </span><br><span class="line">        while q: </span><br><span class="line">            cur_level &#x3D; [] </span><br><span class="line">            n &#x3D; len(q) </span><br><span class="line">            for _ in range(n): </span><br><span class="line">                cur &#x3D; q.popleft() </span><br><span class="line">                cur_level.append(cur.val) </span><br><span class="line">                if cur.left: </span><br><span class="line">                    q.append(cur.left) </span><br><span class="line">                if cur.right: </span><br><span class="line">                    q.append(cur.right) </span><br><span class="line">            ans.append(cur_level) </span><br><span class="line">        return ans[::-1]</span><br></pre></td></tr></table></figure>
<p>还可以DFS做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(int level, TreeNode* root, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        if(level &gt;&#x3D; ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt;&#123;&#125;);</span><br><span class="line">        </span><br><span class="line">        ans[level].push_back(root-&gt;val);</span><br><span class="line">        dfs(level + 1, root-&gt;left, ans);</span><br><span class="line">        dfs(level + 1, root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        dfs(0, root, ans);</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="108-convert-sorted-array-to-binary-search-tree">108. Convert Sorted Array to Binary Search Tree</h3>
<blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">leetcode 108 Convert Sorted Array to Binary Search Tree</a></p>
<p>题意：给定一个排好序的数组，要求建造BST树（高度要平衡）</p>
<p>思路：每次二分，递归建立左右子树</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">TreeNode* BuildTree(int L, int R, const vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">if (L &gt; R) return nullptr;</span><br><span class="line">int mid &#x3D; L + ((R - L) &gt;&gt; 1);</span><br><span class="line">TreeNode *root &#x3D; new TreeNode(nums[mid]);</span><br><span class="line">root-&gt;left &#x3D; BuildTree(L, mid - 1, nums);</span><br><span class="line">root-&gt;right &#x3D; BuildTree(mid + 1, R, nums);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">return BuildTree(0, nums.size() - 1, nums);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode BuildTree(int L, int R, final int[] nums) &#123;</span><br><span class="line">        if (L &gt; R) return null;</span><br><span class="line">        int mid &#x3D; L + ((R - L) &gt;&gt; 1);</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(nums[mid]);</span><br><span class="line">        root.left &#x3D; BuildTree(L, mid - 1, nums);</span><br><span class="line">        root.right &#x3D; BuildTree(mid + 1, R, nums);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        return BuildTree(0, nums.length - 1, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def sortedArrayToBST(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        def build_tree(L, R):</span><br><span class="line">            if L &gt; R: return None</span><br><span class="line">            mid &#x3D; (L + R) &gt;&gt; 1</span><br><span class="line">            root &#x3D; TreeNode(nums[mid])</span><br><span class="line">            root.left &#x3D; build_tree(L, mid - 1)</span><br><span class="line">            root.right &#x3D; build_tree(mid + 1, R)</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        return build_tree(0, len(nums) - 1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="109-convert-sorted-list-to-binary-search-tree">109 Convert Sorted List to Binary Search Tree</h3>
<blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<p></p>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">leetcode 109 Convert Sorted List to Binary Search Tree</a></p>
<p>题意：给定一个排好序的链表，要求建造BST树（高度要平衡）</p>
<p>思路：</p>
<p><strong>方法一</strong></p>
<p>每次将链表分为左右两部分即可。</p>
<ul>
<li>使用快慢指针</li>
<li>复杂度O(nlogn)</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">TreeNode* createTree(ListNode* head, ListNode* end) &#123;</span><br><span class="line">if (head &#x3D;&#x3D; end) return nullptr;</span><br><span class="line">ListNode *fast &#x3D; head, *slow &#x3D; head;</span><br><span class="line">while (fast !&#x3D; end &amp;&amp; fast-&gt;next !&#x3D; end) &#123;</span><br><span class="line">slow &#x3D; slow-&gt;next;</span><br><span class="line">fast &#x3D; fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode *root &#x3D; new TreeNode(slow-&gt;val);</span><br><span class="line">root-&gt;left &#x3D; createTree(head, slow);</span><br><span class="line">root-&gt;right &#x3D; createTree(slow-&gt;next, end);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">return createTree(head, nullptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode buildTree(ListNode head, ListNode end) &#123;</span><br><span class="line">        if (head &#x3D;&#x3D; end) return null;</span><br><span class="line">        ListNode slow &#x3D; head, fast &#x3D; head;</span><br><span class="line">        while (fast !&#x3D; end &amp;&amp; fast.next !&#x3D; end) &#123;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            fast &#x3D; fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(slow.val);</span><br><span class="line">        root.left &#x3D; buildTree(head, slow);</span><br><span class="line">        root.right &#x3D; buildTree(slow.next, end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        return buildTree(head,null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def sortedListToBST(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        def build_tree(head, end):</span><br><span class="line">            if head &#x3D;&#x3D; end: return None</span><br><span class="line">            fast &#x3D; slow &#x3D; head</span><br><span class="line">            while fast !&#x3D; end and fast.next !&#x3D; end:</span><br><span class="line">                slow, fast &#x3D; slow.next, fast.next.next</span><br><span class="line">            root &#x3D; TreeNode(slow.val)</span><br><span class="line">            root.left &#x3D; build_tree(head, slow)</span><br><span class="line">            root.right &#x3D; build_tree(slow.next, end)</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        return build_tree(head, None)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之前的python，计数的，不如快慢指针优雅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param head, a list node</span><br><span class="line">    # @return a tree node</span><br><span class="line">    def sortedListToBST(self, head):</span><br><span class="line">        if not head: return None</span><br><span class="line">        tail ,length &#x3D;head ,0</span><br><span class="line">        while tail: tail,length&#x3D;tail.next,length+1</span><br><span class="line">        return self.dfs(head,0,length-1)</span><br><span class="line"></span><br><span class="line">    def dfs(self,head,L,R):</span><br><span class="line">        if L &#x3D;&#x3D; R : return TreeNode(head.val)</span><br><span class="line">        if L &gt;  R : return None</span><br><span class="line">        mid ,cnt ,tmp&#x3D; (L+R)&gt;&gt;1,L,head</span><br><span class="line">        while cnt &lt; mid: cnt , tmp &#x3D; cnt + 1,tmp.next</span><br><span class="line">        root &#x3D; TreeNode(tmp.val)</span><br><span class="line">        root.left,root.right&#x3D;self.dfs(head,L,mid-1),self.dfs(tmp.next,mid+1,R)</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong></p>
<p>BST利用中序遍历为有序的性质，来建树。</p>
<ul>
<li>相当于链表保存的为中序遍历</li>
<li>要让建出来的树尽可能的平衡，那么用二分，mid = (L + R)/2，左边的就是[L,mid-1]，右边[mid+1,R]</li>
<li>中序遍历先遍历左子树，保存全局的链表head指针，每次向后移动即可。</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">ListNode *head;</span><br><span class="line"></span><br><span class="line">TreeNode* inorderBuildTree(int L, int R) &#123;</span><br><span class="line">if (L &gt; R) return nullptr;</span><br><span class="line">int mid &#x3D; L + ((R - L) &gt;&gt; 1);</span><br><span class="line">TreeNode *left &#x3D; inorderBuildTree(L, mid - 1);</span><br><span class="line">TreeNode *root &#x3D; new TreeNode(head-&gt;val);</span><br><span class="line">head &#x3D; head-&gt;next;</span><br><span class="line">root-&gt;left &#x3D; left;</span><br><span class="line">root-&gt;right &#x3D; inorderBuildTree(mid + 1,R);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">int n &#x3D; 0;</span><br><span class="line">this-&gt;head &#x3D; head;</span><br><span class="line">for (; head; head &#x3D; head-&gt;next) n++;</span><br><span class="line">return inorderBuildTree(0, n - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private ListNode head &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private TreeNode inorderBuildTree(int L, int R) &#123;</span><br><span class="line">        if (L &gt; R) return null;</span><br><span class="line">        int mid &#x3D; L + ((R - L) &gt;&gt; 1);</span><br><span class="line">        TreeNode left &#x3D; inorderBuildTree(L, mid - 1);</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">        root.left &#x3D; left;</span><br><span class="line">        root.right &#x3D; inorderBuildTree(mid + 1, R);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        int n &#x3D; 0;</span><br><span class="line">        this.head &#x3D; head;</span><br><span class="line">        for (; head !&#x3D; null; head &#x3D; head.next) n++;</span><br><span class="line">        return inorderBuildTree(0, n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def sortedListToBST(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        def inorder_build_tree(L, R):</span><br><span class="line">            if L &gt; R: return None</span><br><span class="line">            mid &#x3D; (L + R) &gt;&gt; 1</span><br><span class="line">            left &#x3D; inorder_build_tree(L, mid - 1)</span><br><span class="line">            root &#x3D; TreeNode(self.head.val)</span><br><span class="line">            self.head &#x3D; self.head.next</span><br><span class="line">            root.left &#x3D; left</span><br><span class="line">            root.right &#x3D; inorder_build_tree(mid + 1, R)</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        p &#x3D; self.head &#x3D; head</span><br><span class="line">        n &#x3D; 0</span><br><span class="line">        while p:</span><br><span class="line">            n +&#x3D; 1</span><br><span class="line">            p &#x3D; p.next</span><br><span class="line">        return inorder_build_tree(0, n - 1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="110-balanced-binary-tree">110. Balanced Binary Tree</h3>
<blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">leetcode Balanced Binary Tree</a></p>
<p>题目大意：给定一棵树，判断其是否是平衡树（要求左右子树高度差不能超过1）</p>
<p>思路：用DFS来计算高度，若高度差超过1，则返回-1.否则，返回高度。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int dfs(TreeNode* root)&#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        </span><br><span class="line">        int left &#x3D; dfs(root-&gt;left);</span><br><span class="line">        if(left &#x3D;&#x3D; -1) </span><br><span class="line">            return -1;</span><br><span class="line">        int right &#x3D; dfs(root-&gt;right);</span><br><span class="line">        if(right &#x3D;&#x3D; -1) </span><br><span class="line">            return -1;</span><br><span class="line">        </span><br><span class="line">        if(abs(left - right) &gt; 1) return -1;</span><br><span class="line">        return max(left, right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        return dfs(root) !&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isBalanced(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.dfs(root) !&#x3D; -1</span><br><span class="line"></span><br><span class="line">    def dfs(self, root):</span><br><span class="line">        if not root: return 0</span><br><span class="line">        left, right &#x3D; self.dfs(root.left), self.dfs(root.right)</span><br><span class="line">        if left &lt; 0 or right &lt; 0 or abs(left - right) &gt;1 :</span><br><span class="line">            return -1</span><br><span class="line">        return max(left, right) + 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="111-minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree</h3>
<blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode Minimum Depth of Binary Tree</a></p>
<p>题目大意：给定二叉树，求其最小的高度。（从根结点到叶结点的距离）</p>
<p>思路：DFS。注意叶结点的判断。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return 0;</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;right)</span><br><span class="line">            return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;</span><br><span class="line">        else if(root-&gt;left)</span><br><span class="line">            return minDepth(root-&gt;left) + 1;</span><br><span class="line">        else if(root-&gt;right)</span><br><span class="line">            return minDepth(root-&gt;right) + 1;</span><br><span class="line">        else</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return an integer</span><br><span class="line">    def minDepth(self, root):</span><br><span class="line">        if not root : return 0</span><br><span class="line">        return self.dfs(root,0)</span><br><span class="line"></span><br><span class="line">    def dfs(self,root,depth):</span><br><span class="line">        if not root : return depth</span><br><span class="line">        if not root.left and root.right: return self.dfs(root.right,depth+1)</span><br><span class="line">        if root.left and not root.right: return self.dfs(root.left,depth+1)</span><br><span class="line">        if not root.left and not root.right: return depth + 1</span><br><span class="line">        L , R &#x3D; self.dfs(root.left,depth+1),self.dfs(root.right,depth+1)    </span><br><span class="line">        return min(L,R)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="112-path-sum">112. Path Sum</h3>
<blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>
Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">leetcode Path Sum</a></p>
<p>题目大意：给定一棵树，判断是否有从根结点到叶结点和为sum的情况。</p>
<p>思路：继续深搜。。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        if(!root) return false;</span><br><span class="line">        sum -&#x3D; root-&gt;val;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            return sum &#x3D;&#x3D; 0;</span><br><span class="line">        return hasPathSum(root-&gt;left, sum )  hasPathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def hasPathSum(self, root, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return False</span><br><span class="line">        target -&#x3D; root.val</span><br><span class="line">        if not root.left and not root.right:</span><br><span class="line">            return target &#x3D;&#x3D; 0</span><br><span class="line">        return self.hasPathSum(root.left, target) or self.hasPathSum(root.right, target)</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="113-path-sum-ii">113. Path Sum II</h3>
<blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>
Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">leetcode Path Sum II</a></p>
<p>题目大意：给定二叉树，要求返回其和为sum的所有路径</p>
<p>思路：DFS。。。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;cur, TreeNode *root, int sum, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123;</span><br><span class="line">        if(!root)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        cur.push_back(root-&gt;val);</span><br><span class="line">        sum -&#x3D; root-&gt;val;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; 0)</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">        </span><br><span class="line">        dfs(cur, root-&gt;left, sum, ans);</span><br><span class="line">        dfs(cur, root-&gt;right, sum, ans);</span><br><span class="line">        cur.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; cur;</span><br><span class="line">        dfs(cur, root, sum, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @param sum, an integer</span><br><span class="line">    # @return a list of lists of integers</span><br><span class="line">    def pathSum(self, root, sum):</span><br><span class="line">        ans ,path&#x3D;[] ,[]</span><br><span class="line">        self.dfs(0,root,sum,path,ans)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def dfs(self,cur,root,sum,path,ans):</span><br><span class="line">        if not root: return;</span><br><span class="line">        if not root.left and not root.right: #leaf</span><br><span class="line">            if cur+root.val &#x3D;&#x3D; sum:</span><br><span class="line">                path.append(root.val)</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                path.pop()</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        path.append(root.val)    </span><br><span class="line">        self.dfs(cur+root.val,root.left,sum,path,ans)</span><br><span class="line">        self.dfs(cur+root.val,root.right,sum,path,ans)</span><br><span class="line">        path.pop()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @param sum, an integer</span><br><span class="line">    # @return a list of lists of integers</span><br><span class="line">    def pathSum(self, root, sum):</span><br><span class="line">        if not root:return []</span><br><span class="line">        ans ,path&#x3D;[] ,[root.val]</span><br><span class="line">        self.dfs(root.val,root,sum,path,ans)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def dfs(self,cur,root,sum,path,ans):       </span><br><span class="line">        if not root.left and not root.right: #leaf</span><br><span class="line">            if cur &#x3D;&#x3D; sum:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if root.left:</span><br><span class="line">            path.append(root.left.val)  </span><br><span class="line">            self.dfs(cur+root.left.val,root.left,sum,path,ans)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        if root.right:</span><br><span class="line">            path.append(root.right.val)  </span><br><span class="line">            self.dfs(cur+root.right.val,root.right,sum,path,ans)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="114-flatten-binary-tree-to-linked-list">114. Flatten Binary Tree to Linked List</h3>
<blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>
Given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Hints:</strong></p>
<p>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">leetcode Flatten Binary Tree to Linked List</a></p>
<p>题目大意：给定一棵二叉树，要求将其变为一条链（按照前序遍历的顺序）</p>
<p>思路：递归，设root左右子结点为L和R，把L和R分别变为链，L最后一个元素指向R即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line">        TreeNode *left &#x3D; root-&gt;left;</span><br><span class="line">        if(left)&#123;</span><br><span class="line">            while(left-&gt;right)</span><br><span class="line">                left &#x3D; left-&gt;right;</span><br><span class="line">            left-&gt;right &#x3D; root-&gt;right;</span><br><span class="line">            root-&gt;right &#x3D; root-&gt;left;</span><br><span class="line">            root-&gt;left &#x3D; nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def flatten(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return</span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        left &#x3D; root.left</span><br><span class="line">        if not left: return</span><br><span class="line">        while left.right:</span><br><span class="line">            left &#x3D; left.right</span><br><span class="line">        left.right &#x3D; root.right</span><br><span class="line">        root.right &#x3D; root.left</span><br><span class="line">        root.left &#x3D; None</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="116-117-populating-next-right-pointers-in-each-node">116.  117 Populating Next Right Pointers in Each Node</h3>
<blockquote>
<p>Given a binary tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct TreeLinkNode &#123;</span><br><span class="line">  TreeLinkNode *left;</span><br><span class="line">  TreeLinkNode *right;</span><br><span class="line">  TreeLinkNode *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Note:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>For example,<br>
Given the following perfect binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4  5  6  7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">leetcode 116 Populating Next Right Pointers in Each Node</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">leetcode 117 Populating Next Right Pointers in Each Node II</a></li>
</ul>
<p>题意：给定一棵树，要求将其每一层的子结点连接起来。</p>
<p>思路：117比116的区别在于，116是满二叉树，117不一定。</p>
<p>一个思路是层次遍历，这样不管是不是满二叉树，都不会错，但是空间并不是O(1)的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return nothing</span><br><span class="line">    def connect(self, root):</span><br><span class="line">        if not root:return</span><br><span class="line">        pre,q&#x3D;[],[]</span><br><span class="line">        pre.append(root)</span><br><span class="line">        while pre:</span><br><span class="line">            n &#x3D; len(pre)</span><br><span class="line">            for i in range(n):</span><br><span class="line">                if i &#x3D;&#x3D; n - 1 : pre[i].next &#x3D; None</span><br><span class="line">                else : pre[i].next&#x3D;pre[i+1]</span><br><span class="line">                node&#x3D;pre[i]</span><br><span class="line">                if node.left: q.append(node.left)</span><br><span class="line">                if node.right: q.append(node.right)</span><br><span class="line"></span><br><span class="line">            pre &#x3D; q[:]</span><br><span class="line">            q&#x3D;[]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p>有没有其他的方法呢?</p>
<p>我们先来看看116题，对于满二叉树，我们每次遍历一层的时候,将左儿子的next设置为右儿子，将右儿子设置为兄弟节点的左儿子。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void connect(TreeLinkNode *root) &#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        while(root-&gt;left)&#123;</span><br><span class="line">            TreeLinkNode *cur &#x3D; root, *p &#x3D; nullptr;</span><br><span class="line">            while(cur)&#123;</span><br><span class="line">                cur-&gt;left-&gt;next &#x3D; cur-&gt;right;</span><br><span class="line">                p &#x3D; cur-&gt;next;</span><br><span class="line">                if(!p) break;</span><br><span class="line">                cur-&gt;right-&gt;next &#x3D; p-&gt;left;</span><br><span class="line">                cur &#x3D; p;</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def connect(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while root:</span><br><span class="line">            t &#x3D; root</span><br><span class="line">            while t:</span><br><span class="line">                if t.left:</span><br><span class="line">                    t.left.next &#x3D; t.right</span><br><span class="line">                if t.right and t.next:</span><br><span class="line">                    t.right.next &#x3D; t.next.left</span><br><span class="line">                t &#x3D; t.next</span><br><span class="line">            root &#x3D; root.left</span><br></pre></td></tr></table></figure>
<p>那么117题并不是满二叉树，这就需要另外一个指针，指向每一层的最左边的节点，然后父节点不断的遍历其兄弟节点，而该节点对next赋值并不断的移动到刚赋值的next节点即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void connect(TreeLinkNode *root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeLinkNode *cur &#x3D; root, *first &#x3D; nullptr, *p &#x3D; first;</span><br><span class="line">            while(cur)&#123;</span><br><span class="line">                if(cur-&gt;left)&#123;</span><br><span class="line">                    if(!p)</span><br><span class="line">                        first &#x3D; p &#x3D; cur-&gt;left;</span><br><span class="line">                    else</span><br><span class="line">                        p &#x3D; p-&gt;next &#x3D; cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur-&gt;right)&#123;</span><br><span class="line">                    if(!p)</span><br><span class="line">                        first &#x3D; p &#x3D; cur-&gt;right;</span><br><span class="line">                    else</span><br><span class="line">                        p &#x3D; p-&gt;next &#x3D; cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                cur &#x3D; cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            root &#x3D; first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def connect(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        while root:</span><br><span class="line">            t, head &#x3D; root, root.left if root.left else root.right</span><br><span class="line">            while not head:</span><br><span class="line">                t &#x3D; root &#x3D; root.next</span><br><span class="line">                if not root: return</span><br><span class="line">                head &#x3D; root.left if root.left else root.right</span><br><span class="line"></span><br><span class="line">            while t:</span><br><span class="line">                if t.left and head !&#x3D; t.left:</span><br><span class="line">                    head.next &#x3D; head &#x3D; t.left #head.next &#x3D; t.left #head &#x3D; head.next</span><br><span class="line">                if t.right and head !&#x3D; t.right:</span><br><span class="line">                    head.next &#x3D; head &#x3D; t.right</span><br><span class="line">                t &#x3D; t.next</span><br><span class="line">            root &#x3D; root.left if root.left else root.right</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可用如下代码检验此题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def printTreeByLeavesNext(root):</span><br><span class="line">    print [root.val]</span><br><span class="line">    while root:</span><br><span class="line">        L &#x3D; root.left if root.left else root.right</span><br><span class="line">        while not L:</span><br><span class="line">            root &#x3D; root.next</span><br><span class="line">            if not root: return</span><br><span class="line">            L &#x3D; root.left if root.left else root.right</span><br><span class="line">        line &#x3D; []</span><br><span class="line">        while L:</span><br><span class="line">            line.append(L.val)</span><br><span class="line">            L &#x3D; L.next</span><br><span class="line">        print line</span><br><span class="line">        root &#x3D; root.left</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="124-binary-tree-maximum-path-sum">124. Binary Tree Maximum Path Sum</h3>
<blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>
Given the below binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Return <code>6</code>.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">leetcode Binary Tree Maximum Path Sum</a></p>
<p>题意：给定一棵二叉树，要求返回其路径中和最大值。（可以从任意起点开始到任意起点结束）</p>
<p>思路：DFS,设dfs(root)返回的是包括root这个结点的单一路径上的最大值。设L=dfs(root.left) ,R=dfs(root.right)如题目样例中的{1,2,3,}就是L=2,R=3</p>
<p>则可能的结果有：</p>
<ul>
<li>L+R+root.val (左右子树和根构成路径为最大值，就是题目的情况）</li>
<li>max(L,R) + root.val(左或者右子树和根构成最大值）</li>
<li>root.val本身为最大值</li>
</ul>
<p>和全局变量ans比较更新即可。</p>
<p>需要注意的是dfs返回值，可能是</p>
<ul>
<li>max(L,R) + root.val 某一条路径</li>
<li>root.val  只是该结点（下面都是负的了）</li>
</ul>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return an integer</span><br><span class="line">    def maxPathSum(self, root):</span><br><span class="line">        if not root:return 0</span><br><span class="line">        self.INF,self.ans&#x3D;-0x7ffffff,-0x7ffffff       </span><br><span class="line">        self.dfs(root)</span><br><span class="line">        return self.ans</span><br><span class="line"></span><br><span class="line">    def dfs(self,root):</span><br><span class="line">        if not root:return self.INF</span><br><span class="line">        L , R &#x3D; self.dfs(root.left) ,self.dfs(root.right)    </span><br><span class="line">        if L + R + root.val &gt; self.ans: self.ans&#x3D;  L + R + root.val</span><br><span class="line">        if max(L,R) + root.val&gt; self.ans: self.ans&#x3D; max(L,R)+ root.val     </span><br><span class="line">        if root.val &gt; self.ans: self.ans&#x3D;root.val     </span><br><span class="line">        return max(max(L,R) + root.val,root.val)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers</h3>
<blockquote>
<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br>
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.</p>
<p>Return the sum = 12 + 13 = <code>25</code>.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">leetcode 129 Sum Root to Leaf Numbers</a></p>
<p>题意：给定一棵仅由数字0~9组成的二叉树，求根到叶子结点各个路径数字组成的字符串之和</p>
<p>思路：继续DFS</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def sumNumbers(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ans &#x3D; [0]</span><br><span class="line">        self.dfs(root, 0, ans)</span><br><span class="line">        return ans[0]</span><br><span class="line">    </span><br><span class="line">    def dfs(self, root, cur, ans):</span><br><span class="line">        if not root: return</span><br><span class="line">        if not root.left and not root.right:</span><br><span class="line">            ans[0] +&#x3D; cur * 10 + root.val</span><br><span class="line">        else:</span><br><span class="line">            if root.left:</span><br><span class="line">                self.dfs(root.left, cur * 10 + root.val, ans)</span><br><span class="line">            if root.right:</span><br><span class="line">                self.dfs(root.right, cur * 10 + root.val, ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(TreeNode *root, int cur, int &amp;ans)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            ans +&#x3D; cur * 10 + root-&gt;val;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left)</span><br><span class="line">            dfs(root-&gt;left, cur * 10 + root-&gt;val, ans);</span><br><span class="line">        if(root-&gt;right)</span><br><span class="line">            dfs(root-&gt;right, cur * 10 + root-&gt;val, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    int sumNumbers(TreeNode* root) &#123;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        dfs(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="144-binary-tree-preorder-traversal">144. Binary Tree Preorder Traversal</h3>
<blockquote>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>
Given binary tree <code>&#123;1,#,2,3&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return <code>[1,2,3]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">leetcode Binary Tree Preorder Traversal</a></p>
<p>题意：给定二叉树，返回其前序遍历</p>
<p>思路：</p>
<ol>
<li>直接递归。没难度。</li>
<li>用栈，记得应先右子树入栈。（why?递归的时候是先左子树的，而栈后进先出，故左子树要放后面入栈）</li>
</ol>
<p><strong>递归版</strong></p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(TreeNode *root, vector&lt;int&gt; &amp;ans)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, ans);</span><br><span class="line">        dfs(root-&gt;right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        self.dfs(root,ans)</span><br><span class="line">        return ans</span><br><span class="line">        </span><br><span class="line">    def dfs(self,root,ans):</span><br><span class="line">        if not root: return</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.dfs(root.left,ans)</span><br><span class="line">        self.dfs(root.right,ans)</span><br></pre></td></tr></table></figure>
<p><strong>迭代版</strong></p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if(!root) return ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode *cur &#x3D; q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans.push_back(cur-&gt;val);</span><br><span class="line">            if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">            if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def preorderTraversal(self, root):</span><br><span class="line">        if not root: return []</span><br><span class="line">        ans, q &#x3D; [],[]</span><br><span class="line">        q.append(root)</span><br><span class="line">        while q:</span><br><span class="line">            cur&#x3D;q.pop()</span><br><span class="line">            if cur.right: q.append(cur.right)</span><br><span class="line">            if cur.left: q.append(cur.left)</span><br><span class="line">            ans.append(cur.val)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="145-binary-tree-postorder-traversal">145. Binary Tree Postorder Traversal</h3>
<blockquote>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:<br>
Given binary tree <code>&#123;1,#,2,3&#125;</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>return <code>[3,2,1]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/">leetcode Binary Tree Postorder Traversal</a></p>
<p>题意：给定二叉树，返回其后序遍历</p>
<p>思路：递归就不说了。说说非递归版本。</p>
<p>我们做过，从前序和中序遍历构造出树，也做过从后序和中序遍历构造树的（见105和106题）</p>
<p>做完前序和中序的那时候我就想，前序和后序能否直接倒序得到？（想偷懒）</p>
<p>答案是否定的，我们来看看前序遍历：根-左子树-右子树</p>
<p>后序遍历：左子树-右子树-根 把前序遍历倒过来：右子树-左子树-根 ！左右子树相反，不能直接倒！</p>
<p>但是这题，哼哼哼，先左子树入栈，在右子树入栈！(和前序遍历相反，也就是颠倒了左右子树），最后输出颠倒一下即可！</p>
<p><strong>非递归版本</strong></p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        if(!root) return ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode *cur &#x3D; q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans.push_back(cur-&gt;val);</span><br><span class="line">            if(cur-&gt;left) q.push(cur-&gt;left);</span><br><span class="line">            if(cur-&gt;right) q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def postorderTraversal(self, root):</span><br><span class="line">        if not root: return []</span><br><span class="line">        ans,q&#x3D;[],[]</span><br><span class="line">        q.append(root)</span><br><span class="line">        while q:</span><br><span class="line">            cur&#x3D;q.pop()          </span><br><span class="line">            if cur.left: q.append(cur.left)</span><br><span class="line">            if cur.right: q.append(cur.right)</span><br><span class="line">            ans.append(cur.val)</span><br><span class="line">        return ans[::-1]</span><br></pre></td></tr></table></figure>
<p>递归版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    void dfs(TreeNode *root, vector&lt;int&gt; &amp;ans)&#123;</span><br><span class="line">        if(!root) return;</span><br><span class="line">        dfs(root-&gt;left, ans);</span><br><span class="line">        dfs(root-&gt;right, ans);</span><br><span class="line">        ans.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        dfs(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="173-binary-search-tree-iterator">173. Binary Search Tree Iterator</h3>
<blockquote>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p><strong>Note:</strong> <code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-search-tree-iterator/">leetcode 173 Binary Search Tree Iterator</a></p>
<p>题目：写一个二叉搜索树（BST），要求实现hasnext和next函数。调用时会这么调用：while i.hasNext(): v.append(i.next())</p>
<p>思路:我们知道中序遍历结果就是有序的序列。只要用非递归的实现中序遍历即可。（见94题）</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class BSTIterator:</span><br><span class="line">    # @param root, a binary search tree&#39;s root node</span><br><span class="line">    def __init__(self, root):</span><br><span class="line">        self.q&#x3D;[]</span><br><span class="line">        self.allLeftIntoStack(root)</span><br><span class="line"></span><br><span class="line">    # @return a boolean, whether we have a next smallest number</span><br><span class="line">    def hasNext(self):</span><br><span class="line">        if not self.q:return False</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    # @return an integer, the next smallest number</span><br><span class="line">    def next(self):</span><br><span class="line">        cur &#x3D; self.q.pop()</span><br><span class="line">        self.allLeftIntoStack(cur.right)</span><br><span class="line">        return cur.val</span><br><span class="line"></span><br><span class="line">    def allLeftIntoStack(self,root):</span><br><span class="line">        while root:</span><br><span class="line">            self.q.append(root)</span><br><span class="line">            root&#x3D;root.left</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="199-binary-tree-right-side-view">199. Binary Tree Right Side View</h3>
<blockquote>
<p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>
Given the following binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1            ---1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         ---3</span><br><span class="line"> \     \</span><br><span class="line">  5     4       ---4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>You should return <code>[1, 3, 4]</code>.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">leetcode 199 Binary Tree Right Side View</a></p>
<p>题目：给定一颗二叉树，求每一层最右边的结点。</p>
<p>思路: 两种方法，我用的是DFS</p>
<ul>
<li>BFS，直接求得每一层最右边的，很好理解，我就不想写了。</li>
<li>DFS：先求深度，然后dfs，每次将找到的放在相应的层上。由于右面放的一定是右边的结点，所以能保证正确。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param root, a tree node</span><br><span class="line">    # @return a list of integers</span><br><span class="line">    def rightSideView(self, root):</span><br><span class="line">        ans&#x3D;[0] * self.depth(0,root)</span><br><span class="line">        self.dfs(0,root,ans)</span><br><span class="line">        return ans</span><br><span class="line">    </span><br><span class="line">    def depth(self,cur,root):</span><br><span class="line">        if not root:return cur</span><br><span class="line">        return max(self.depth(cur+1,root.left),self.depth(cur+1,root.right))</span><br><span class="line"></span><br><span class="line">    def dfs(self,cur,root,ans):</span><br><span class="line">        if not root:return </span><br><span class="line">        ans[cur]&#x3D;root.val</span><br><span class="line">        self.dfs(cur+1,root.left,ans)</span><br><span class="line">        self.dfs(cur+1,root.right,ans)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="222-count-complete-tree-nodes">222. Count Complete Tree Nodes</h3>
<blockquote>
<p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Definition of a complete binary tree from <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a>:</strong><br>
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2hnodes inclusive at the last level h.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-complete-tree-nodes/">leetcode 222 Count Complete Tree Nodes</a></p>
<p>题意：给定一个完全二叉树（它的所有非叶子结点都有左和右子结点），求它的结点数</p>
<p>思路: 直接深搜O(n) TLE了。所以采用别的方法。</p>
<p>对于一个结点，计算其左子树和右子树的高度。如果相等，那么为满二叉树，结点数为2^h -1 否则递归计算</p>
<p><strong>C</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int countNodes(struct TreeNode* root) &#123;</span><br><span class="line">    if(!root) return 0;</span><br><span class="line">    int depth_left &#x3D;0, depth_right &#x3D;0;</span><br><span class="line">    for(struct TreeNode* left &#x3D; root;left;left&#x3D;left-&gt;left) depth_left++;</span><br><span class="line">    for(struct TreeNode* right &#x3D; root;right;right&#x3D;right-&gt;right) depth_right++;</span><br><span class="line">    if(depth_left &#x3D;&#x3D; depth_right) return (1&lt;&lt;depth_left) -1;</span><br><span class="line">    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;TreeNode&#125; root</span><br><span class="line">    # @return &#123;integer&#125;</span><br><span class="line">    def countNodes(self, root):</span><br><span class="line">        if not root : return 0</span><br><span class="line">        depth_left &#x3D; depth_right &#x3D; 0</span><br><span class="line">        left &#x3D; right &#x3D; root </span><br><span class="line">        while left  : left ,  depth_left &#x3D; left.left,depth_left+1</span><br><span class="line">        while right : right , depth_right &#x3D; right.right,depth_right+1</span><br><span class="line">        if depth_left &#x3D;&#x3D; depth_right : return (1&lt;&lt;depth_left)-1</span><br><span class="line">        return  self.countNodes(root.left) + self.countNodes(root.right) + 1</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="226-invert-binary-tree">226. Invert Binary Tree</h3>
<blockquote>
<p>Invert a binary tree.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">leetcode 226 Invert Binary Tree</a></p>
<p>题意：给定一个二叉树，让你把它倒过来</p>
<p>思路：DFS的时候交换左右结点即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;TreeNode&#125; root</span><br><span class="line">    # @return &#123;TreeNode&#125;</span><br><span class="line">    def invertTree(self, root):</span><br><span class="line">        def dfs(root):</span><br><span class="line">            if not root : return</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            t &#x3D; root.left</span><br><span class="line">            root.left &#x3D; root.right </span><br><span class="line">            root.right &#x3D; t</span><br><span class="line">        dfs(root)</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="230-kth-smallest-element-in-a-bst">230. Kth Smallest Element in a BST</h3>
<blockquote>
<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note:</strong><br>
You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p><strong>Follow up:</strong><br>
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">leetcode 230 Kth Smallest Element in a BST</a></p>
<p>题意：给定BST，求BST中第k小的元素</p>
<p>思路: BST中序遍历为有序，所以直接中序遍历即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;TreeNode&#125; root</span><br><span class="line">    # @param &#123;integer&#125; k</span><br><span class="line">    # @return &#123;integer&#125;</span><br><span class="line">    def kthSmallest(self, root, k):</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        def dfs(root):</span><br><span class="line">            if not root :  return;</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            if len(ans) &#x3D;&#x3D; k: return;</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        return ans[k-1]</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</h3>
<blockquote>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    &#x2F;              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">&#x2F;      \        &#x2F;      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      &#x2F;  \</span><br><span class="line">      3   5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes <code>2</code> and <code>8</code> is <code>6</code>. Another example is LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Lowest 235 Common Ancestor of a Binary Search Tree</a></p>
<p>题意：给定一颗二叉搜索树，求最近公共祖先(LCA)</p>
<p>思路：</p>
<p>LCA问题可以见我博客 <a target="_blank" rel="noopener" href="https://www.hrwhisper.me/algorithm-lowest-common-ancestor-of-a-binary-tree/">二叉树最近公共祖先详解（LCA问题详解）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:return root;</span><br><span class="line">        if p.val &gt; q.val:return self.lowestCommonAncestor(root, q, p)</span><br><span class="line">        if root.val &gt;&#x3D; p.val and root.val &lt;&#x3D; q.val: return root;</span><br><span class="line">        if root.val &lt; p.val:return self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        if root.val &gt; q.val:return self.lowestCommonAncestor(root.left, p, q)</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="236-lowest-common-ancestor-of-a-binary-tree">236. Lowest Common Ancestor of a Binary Tree</h3>
<blockquote>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    &#x2F;              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">&#x2F;      \        &#x2F;      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      &#x2F;  \</span><br><span class="line">      7   4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode 236 Lowest Common Ancestor of a Binary Tree</a></p>
<p>题意：给定一颗二叉树，求最近公共祖先(LCA)</p>
<p>思路：</p>
<p>LCA问题可以见我博客 <a target="_blank" rel="noopener" href="https://www.hrwhisper.me/algorithm-lowest-common-ancestor-of-a-binary-tree/">二叉树最近公共祖先详解（LCA问题详解）</a></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lowestCommonAncestor(self, root, p, q):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root or root &#x3D;&#x3D; p or root &#x3D;&#x3D; q: return root</span><br><span class="line">        left &#x3D; self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right &#x3D; self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        if left and right:</span><br><span class="line">            return root</span><br><span class="line">        return left if left else right</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="257-binary-tree-paths">257. Binary Tree Paths</h3>
<blockquote>
<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>For example, given the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   1</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>All root-to-leaf paths are:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/">leetcode Binary Tree Paths</a></p>
<p>题意：给定一棵二叉树，求它所有从根节点到叶子结点的路径。</p>
<p>思路：DFS。。。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;TreeNode&#125; root</span><br><span class="line">    # @return &#123;string[]&#125;</span><br><span class="line">    def binaryTreePaths(self, root):</span><br><span class="line">        if not root: return []</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        self.dfs(root, ans, str(root.val))</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def dfs(self, root, ans, cur):</span><br><span class="line">        if root.left:</span><br><span class="line">            self.dfs(root.left, ans, cur + &quot;-&gt;&quot; + str(root.left.val))</span><br><span class="line">        if root.right:</span><br><span class="line">            self.dfs(root.right, ans, cur + &quot;-&gt;&quot; + str(root.right.val))</span><br><span class="line"></span><br><span class="line">        if not root.left and not root.right:</span><br><span class="line">            ans.append(cur)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="297-serialize-and-deserialize-binary-tree">297. Serialize and Deserialize Binary Tree</h3>
<blockquote>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>as <code>&quot;[1,2,3,null,null,4,5]&quot;</code>, just the same as <a target="_blank" rel="noopener" href="https://leetcode.com/faq/#binary-tree">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">leetcode 297 Serialize and Deserialize Binary Tree</a></p>
<p>题意：给定根节点，将树进行序列化为字符串，然后反序列化回来。</p>
<p>思路:</p>
<p>方法一：</p>
<p>采用和leetcode的序列化方法一样的。</p>
<p>BFS：</p>
<ul>
<li>对于序列化，只需要首先将根放入队列，然后每次从队列取第一个cur。如果cur为空，输出&quot;null,&quot;，否则输出cur-&gt;val + “,”。这里我用都好分隔符</li>
<li>对于反序列化，按分隔符&quot;,“分割，每次取出。如果当前字符串t不为&quot;null”,则创建一个值为t的TreeNode，把当前结点的left或者right指向它。详见代码。</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F; Encodes a tree to a single string.</span><br><span class="line">string serialize(TreeNode* root) &#123;</span><br><span class="line">if (!root) return &quot;&quot;;</span><br><span class="line">string res;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">TreeNode *cur &#x3D; q.front(); q.pop();</span><br><span class="line">if (!cur)</span><br><span class="line">res.append(&quot;null,&quot;);</span><br><span class="line">else &#123;</span><br><span class="line">res.append(to_string(cur-&gt;val) + &quot;,&quot;);</span><br><span class="line">q.push(cur-&gt;left);</span><br><span class="line">q.push(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res.substr(0, res.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">TreeNode* deserialize(string data) &#123;</span><br><span class="line">if (data.empty()) return nullptr;</span><br><span class="line">queue&lt;TreeNode*&gt; q;</span><br><span class="line">TreeNode *root &#x3D; nullptr, *cur &#x3D; nullptr;</span><br><span class="line">bool isLeft &#x3D; true;</span><br><span class="line">for (string::iterator s &#x3D; data.begin(), e; s !&#x3D; data.end(); s &#x3D; e !&#x3D; data.end() ? next(e) : data.end()) &#123;</span><br><span class="line">e &#x3D; find(s, data.end(), &#39;,&#39;);</span><br><span class="line">string sub &#x3D; string(s, e);</span><br><span class="line">TreeNode *t &#x3D; nullptr;</span><br><span class="line">if (sub !&#x3D; &quot;null&quot;) &#123;</span><br><span class="line">t &#x3D; new TreeNode(stoi(sub));</span><br><span class="line">q.push(t);</span><br><span class="line">&#125;</span><br><span class="line">if (root &#x3D;&#x3D; nullptr) &#123;</span><br><span class="line">root &#x3D; cur &#x3D; t;</span><br><span class="line">if (q.empty()) return root;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (isLeft)</span><br><span class="line">cur-&gt;left &#x3D; t;</span><br><span class="line">else &#123;</span><br><span class="line">cur-&gt;right &#x3D; t;</span><br><span class="line">if (q.empty()) return root;</span><br><span class="line">cur &#x3D; q.front(); q.pop();</span><br><span class="line">&#125;</span><br><span class="line">isLeft &#x3D; !isLeft;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class Codec &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Encodes a tree to a single string.</span><br><span class="line">    public String serialize(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return &quot;&quot;;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur &#x3D; q.pollFirst();</span><br><span class="line">            if (cur !&#x3D; null) &#123;</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">                res.append(cur.val);</span><br><span class="line">            &#125; else</span><br><span class="line">                res.append(&quot;null&quot;);</span><br><span class="line">            res.append(&#39;,&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length()-1);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        if (data.isEmpty()) return null;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode root &#x3D; null, cur &#x3D; null;</span><br><span class="line">        boolean isLeft &#x3D; true;</span><br><span class="line">        for (String s : data.split(&quot;,&quot;)) &#123;</span><br><span class="line">            TreeNode t &#x3D; null;</span><br><span class="line">            if (!s.equals(&quot;null&quot;)) &#123;</span><br><span class="line">                t &#x3D; new TreeNode(Integer.parseInt(s));</span><br><span class="line">                q.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">                cur &#x3D; root &#x3D; q.pollFirst();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (isLeft)</span><br><span class="line">                    cur.left &#x3D; t;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cur.right &#x3D; t;</span><br><span class="line">                    cur &#x3D; q.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                isLeft &#x3D; !isLeft;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Codec:</span><br><span class="line">    def serialize(self, root):</span><br><span class="line">        &quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="line"></span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return &quot;&quot;</span><br><span class="line">        q &#x3D; collections.deque([root])</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while q:</span><br><span class="line">            cur &#x3D; q.popleft()</span><br><span class="line">            if cur:</span><br><span class="line">                res.append(str(cur.val))</span><br><span class="line">                q.append(cur.left)</span><br><span class="line">                q.append(cur.right)</span><br><span class="line">            else:</span><br><span class="line">                res.append(&quot;null&quot;)</span><br><span class="line">        return &quot;,&quot;.join(res)</span><br><span class="line"></span><br><span class="line">    def deserialize(self, data):</span><br><span class="line">        &quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="line"></span><br><span class="line">        :type data: str</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not data: return None</span><br><span class="line">        q &#x3D; collections.deque()</span><br><span class="line">        root &#x3D; cur &#x3D; None</span><br><span class="line">        is_left &#x3D; True</span><br><span class="line">        for s in data.split(&quot;,&quot;):</span><br><span class="line">            t &#x3D; None</span><br><span class="line">            if s !&#x3D; &quot;null&quot;:</span><br><span class="line">                t &#x3D; TreeNode(int(s))</span><br><span class="line">                q.append(t)</span><br><span class="line">            if root:</span><br><span class="line">                if is_left:</span><br><span class="line">                    cur.left &#x3D; t</span><br><span class="line">                else:</span><br><span class="line">                    cur.right &#x3D; t</span><br><span class="line">                    if not q: return root</span><br><span class="line">                    cur &#x3D; q.popleft()</span><br><span class="line">                is_left &#x3D; not is_left</span><br><span class="line">            else:</span><br><span class="line">                if not q: return root</span><br><span class="line">                root &#x3D; cur &#x3D; q.popleft()</span><br><span class="line">        return root</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>方法二</strong></p>
<p>按前序遍历的方式建树</p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Codec &#123;</span><br><span class="line">    public String serialize(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return &quot;&quot;;</span><br><span class="line">        Deque&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur &#x3D; q.pollLast();</span><br><span class="line">            if (cur !&#x3D; null) &#123;</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">                res.append(cur.val);</span><br><span class="line">            &#125; else</span><br><span class="line">                res.append(&quot;null&quot;);</span><br><span class="line">            res.append(&#39;,&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - 1);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode deserializeHelper(final Deque&lt;String&gt; q) &#123;</span><br><span class="line">        if (q.isEmpty() ) return null;</span><br><span class="line">        String s &#x3D; q.pollFirst();</span><br><span class="line">        if(s.equals(&quot;null&quot;)) return null;</span><br><span class="line">        TreeNode cur &#x3D; new TreeNode(Integer.parseInt(s));</span><br><span class="line">        cur.left &#x3D; deserializeHelper(q);</span><br><span class="line">        cur.right &#x3D; deserializeHelper(q);</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        if (data.isEmpty()) return null;</span><br><span class="line">        Deque&lt;String&gt; q&#x3D; new LinkedList&lt;&gt;(Arrays.asList(data.split(&quot;,&quot;)));</span><br><span class="line">        return deserializeHelper( q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="449-serialize-and-deserialize-bst">449. Serialize and Deserialize BST</h3>
<blockquote>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p><strong>The encoded string should be as compact as possible.</strong></p>
<p><strong>Note:</strong> Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/serialize-and-deserialize-bst/">leetcode Serialize and Deserialize BST</a></p>
<p>题目大意：给定一棵BST，要求进行序列化和反序列化。要求序列化后的字符串尽可能的短。</p>
<p><strong>思路</strong>：</p>
<p>和297. Serialize and Deserialize Binary Tree题的区别在于，这题是BST。</p>
<p>BST和其他的有啥用呢？在297题中，我们用null表示节点为空。但是这题不需要。我们可以根据节点的大小来判断应该在左子树还是右子树。</p>
<p>其实就是说BST可以直接用前序遍历恢复。而二叉树需要至少两种遍历的存储才行，不然就要加入额外的信息，如297用的null。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F; Encodes a tree to a single string.</span><br><span class="line">string serialize(TreeNode* root) &#123;</span><br><span class="line">if (!root) return &quot;&quot;;</span><br><span class="line">string res;</span><br><span class="line">stack&lt;TreeNode*&gt; q;</span><br><span class="line">q.push(root);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">TreeNode *cur &#x3D; q.top(); q.pop();</span><br><span class="line">if (cur) &#123;</span><br><span class="line">q.push(cur-&gt;right);</span><br><span class="line">q.push(cur-&gt;left);</span><br><span class="line">res.append(to_string(cur-&gt;val) + &quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res.substr(0, res.size() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">TreeNode* deserialize(string data) &#123;</span><br><span class="line">if (data.empty()) return nullptr;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for (auto s &#x3D; data.begin(), e &#x3D; s; s !&#x3D; data.end(); s &#x3D; (e !&#x3D; data.end() ? next(e) : data.end())) &#123;</span><br><span class="line">e &#x3D; find(s, data.end(), &#39;,&#39;);</span><br><span class="line">q.push(stoi(string(s, e)));</span><br><span class="line">&#125;</span><br><span class="line">return buildTree(0x7fffffff, q);;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">TreeNode* buildTree(int maxV, queue&lt;int&gt; &amp;q) &#123;</span><br><span class="line">if (q.empty()) return nullptr;</span><br><span class="line">TreeNode* root &#x3D; new TreeNode(q.front());</span><br><span class="line">q.pop();</span><br><span class="line">if (!q.empty() &amp;&amp; q.front() &lt; root-&gt;val)</span><br><span class="line">root-&gt;left &#x3D; buildTree(root-&gt;val, q);</span><br><span class="line">if (!q.empty() &amp;&amp; root-&gt;val &lt; q.front() &amp;&amp; q.front() &lt; maxV)</span><br><span class="line">root-&gt;right &#x3D; buildTree(maxV, q);</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Codec &#123;</span><br><span class="line">    public String serialize(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return &quot;&quot;;</span><br><span class="line">        Deque&lt;TreeNode&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        StringBuilder res &#x3D; new StringBuilder();</span><br><span class="line">        while (!q.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur &#x3D; q.pollLast();</span><br><span class="line">            if (cur !&#x3D; null) &#123;</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">                res.append(cur.val).append(&#39;,&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - 1);</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TreeNode deserializeHelper(int max, final Deque&lt;Integer&gt; q) &#123;</span><br><span class="line">        if (q.isEmpty()) return null;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(q.pollFirst());</span><br><span class="line">        if (!q.isEmpty() &amp;&amp; q.peekFirst() &lt; root.val)</span><br><span class="line">            root.left &#x3D; deserializeHelper(root.val, q);</span><br><span class="line">        if (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; root.val &amp;&amp; max &gt; q.peekFirst())</span><br><span class="line">            root.right &#x3D; deserializeHelper(max, q);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        if (data.isEmpty()) return null;</span><br><span class="line">        Deque&lt;Integer&gt; q &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        for (String s : data.split(&quot;,&quot;))</span><br><span class="line">            q.add(Integer.parseInt(s));</span><br><span class="line">        return deserializeHelper(Integer.MAX_VALUE, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Codec:</span><br><span class="line">    def serialize(self, root):</span><br><span class="line">        &quot;&quot;&quot;Encodes a tree to a single string.</span><br><span class="line"></span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root: return &quot;&quot;</span><br><span class="line">        q &#x3D; collections.deque([root])</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        while q:</span><br><span class="line">            cur &#x3D; q.pop()</span><br><span class="line">            if cur:</span><br><span class="line">                q.append(cur.right)</span><br><span class="line">                q.append(cur.left)</span><br><span class="line">                res.append(str(cur.val))</span><br><span class="line">        return &quot;,&quot;.join(res)</span><br><span class="line"></span><br><span class="line">    def deserialize(self, data):</span><br><span class="line">        &quot;&quot;&quot;Decodes your encoded data to tree.</span><br><span class="line"></span><br><span class="line">        :type data: str</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        def build_tree(max_v, q):</span><br><span class="line">            if not q: return None</span><br><span class="line">            root &#x3D; TreeNode(q.popleft())</span><br><span class="line">            if q and root.val &gt; q[0]:</span><br><span class="line">                root.left &#x3D; build_tree(root.val, q)</span><br><span class="line">            if q and root.val &lt; q[0] &lt; max_v:</span><br><span class="line">                root.right &#x3D; build_tree(max_v, q)</span><br><span class="line">            return root</span><br><span class="line"></span><br><span class="line">        return build_tree(0x7fffffff, q&#x3D;collections.deque(map(int, data.split(&quot;,&quot;)))) if data else None</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p>更多题解可以查看： <a target="_blank" rel="noopener" href="https://www.hrwhisper.me/leetcode-algorithm-solution/">https://www.hrwhisper.me/leetcode-algorithm-solution/</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/leetcode-tree/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/public-key-encryption-from-trapdoor-permutations-integer-factorization/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Public Key Encryption from Trapdoor Permutations - Integer Factorization
          
        </div>
      </a>
    
    
      <a href="/leetcode-recursive-or-dfs/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">『leetcode』递归/DFS</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz",
    app_key: "b26lBsbwmVyxTSnNrsBrnv3U",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2013-2020
        <i class="ri-heart-fill heart_icon"></i> hrwhisper
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/site/logo.jpg" alt="细语呢喃"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog-building">博客建设</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend-link">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/leetcode-algorithm-solution">leetcode题解</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/messageboard">留言板</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about-me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/wechat_pay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3',
    hasInnerContainers: true,
    scrollSmooth: false,
	scrollSmoothDuration: 420,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
	collapseDepth: 2,
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>