<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="c,c++,java,python,leetcode,algorithm,reading,life,moods,machine-learning,data-mining,deep-learning,AI" />
       
      <meta name="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>leetcode Graph 图论 |  细语呢喃</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/site/avatar.jpg" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-69270533-1', 'auto');
ga('send', 'pageview');

</script>


 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?d6a8cb42bd9ae728375b6726daa75e95";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- mermaid -->
      
    </head>
  </html>
</html>


<body>
  <div id="app">
    
    <script data-ad-client="{{ theme.google_adsense.app_id }}" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-leetcode-graph"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  leetcode Graph 图论
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/leetcode-graph/" class="article-date">
  <time datetime="2015-06-23T02:35:42.000Z" itemprop="datePublished">2015-06-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/Leetcode/">Leetcode</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">9.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">44 分钟</span>
        </span>
    </span>
</div>
 
       
        <div class="word_count">
    <span class="post-meta-item-icon">
        <i class="ri-eye-fill"></i> 
        阅读数:<span id="/leetcode-graph/" data-flag-title="leetcode Graph 图论" class="leancloud_visitors">0</span>次
    </span>
</div>
      
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本次题解包括</p>
<ul>
<li><strong>133</strong> Clone Graph</li>
<li><strong>207</strong> Course Schedule</li>
<li><strong>210</strong> Course Schedule II</li>
<li><strong>547</strong> Number of Provinces</li>
<li><strong>684</strong> 冗余连接</li>
<li><strong>803</strong> 打砖块</li>
<li><strong>947</strong> 移除最多的同行或同列石头</li>
<li><strong>1202</strong>. Smallest String With Swaps</li>
<li><ol start="1319" type="1">
<li>连通网络的操作次数</li>
</ol></li>
</ul>
<a id="more"></a>
<h3 id="leetcode-clone-graph">133. leetcode Clone Graph</h3>
<blockquote>
<p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p>
</blockquote>
<p>题目地址： <strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/clone-graph/">leetcode Clone Graph</a></strong></p>
<p>题意：给定一张图，要求进行深拷贝</p>
<p>思路：leetcode之前唯一的图。。</p>
<p>用BFS/DFS对图进行遍历，我使用字典（c++叫Map)建立起旧结点和新结点的映射关系，这样就好复制啦。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a undirected graph node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        head=UndirectedGraphNode(node.label)</span><br><span class="line">        q,vis,dic=[],set([node]),&#123;&#125;</span><br><span class="line">        dic[node]=head</span><br><span class="line">        q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.pop()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> cur.neighbors:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                    dic[i]=UndirectedGraphNode(i.label)</span><br><span class="line">                dic[cur].neighbors.append(dic[i])</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                    q.append(i)</span><br><span class="line">                    vis.add(i)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>附上我的测试代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.neighbors = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printGraph</span>(<span class="params">node</span>):</span></span><br><span class="line">    q ,vis = [],set([node])</span><br><span class="line">    q.append(node)</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur = q.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;  &#x27;</span>,cur.label</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cur.neighbors:</span><br><span class="line">            <span class="keyword">print</span> i.label</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                q.append(i)</span><br><span class="line">                vis.add(i)</span><br><span class="line"></span><br><span class="line">s=Solution()</span><br><span class="line">one = UndirectedGraphNode(<span class="number">1</span>)</span><br><span class="line">two = UndirectedGraphNode(<span class="number">2</span>)</span><br><span class="line">three =UndirectedGraphNode(<span class="number">3</span>)</span><br><span class="line">one.neighbors.append(one)</span><br><span class="line">one.neighbors.append(two)</span><br><span class="line">two.neighbors.append(three)</span><br><span class="line"><span class="comment">#printGraph(one)</span></span><br><span class="line">printGraph( s.cloneGraph(one))</span><br></pre></td></tr></table></figure>
<p> </p>
<hr />
<h3 id="leetcode-course-schedule">207. leetcode Course Schedule</h3>
<blockquote>
<p> There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, is it possible for you to finish all courses?</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br></pre></td></tr></table></figure>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0],[0,1]]</span><br></pre></td></tr></table></figure>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
</blockquote>
<p>题目地址： <strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule/">leetcode Course Schedule</a></strong></p>
<p>题意：给定一些课程，以及他们课程之间先修的关系。如我要修课程1，必须先修完课程0，问是否有可能完成这些课程。</p>
<p>思路：很明显的问题可以转化为求<strong>拓扑排序（Topological Sort）</strong>。</p>
<p>拓扑排序的做法如下：</p>
<ol type="1">
<li>每次找入度为0的点，输出该入度为0的点，并删除与之相连接的边</li>
<li>重复1直到没有入度为0的点。之前输出入度为0的点若小于原图的结点数，那么说明图有环，即拓扑排序不存在，否则即为拓扑排序。</li>
</ol>
<p>以下面的为例：</p>
<figure>
<img src="../images/leetcode-graph/Topological-Sort.png" alt="Topological Sort" /><figcaption aria-hidden="true">Topological Sort</figcaption>
</figure>
<ol type="1">
<li><p>在(a)图中v0和v1的入度都为0，选择v0并输出，接着删去顶点v0及出边&lt;0,2&gt;，得到的结果如(b)图所示。</p></li>
<li><p>在(b)图中只有一个入度为0的顶点v1，输出v1，接着删去v1和它的三条出边&lt;1,2&gt;,&lt;1,3&gt;和&lt;1,4&gt;，得到的结果如(c)图所示。</p></li>
<li><p>在(c)图中v2和v4的入度都为0，不妨选择v2并输出之，接着删去v2及两条出边&lt;2,3&gt;和&lt;2,5&gt;，得到的结果如(d)图所示。</p></li>
<li><p>在(d)图上依次输出顶点v3,v4和v5，并在每个顶点输出后删除该顶点及出边。</p></li>
</ol>
<p><strong>C++</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in_degree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">			g[prerequisites[i].second].push_back(prerequisites[i].first);</span><br><span class="line">			in_degree[prerequisites[i].first]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) <span class="keyword">if</span> (in_degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">			<span class="keyword">int</span> cur = q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = g[cur].begin(); it != g[cur].end(); it++)</span><br><span class="line">				<span class="keyword">if</span> (--in_degree[*it] == <span class="number">0</span>) q.push(*it);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) <span class="keyword">if</span> (in_degree[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> </p>
<hr />
<h3 id="leetcode-course-schedule-ii">210. leetcode Course Schedule II</h3>
<blockquote>
<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2, [[1,0]]</span><br></pre></td></tr></table></figure>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4, [[1,0],[2,0],[3,1],[3,2]]</span><br></pre></td></tr></table></figure>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p>
</blockquote>
<p>题目地址： <strong><a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule-ii/">leetcode Course Schedule II</a></strong></p>
<p>题意：和207那题一样，给定各种课程之间依赖关系，求一个满足条件的顺序。</p>
<p>思路：其实就是输出拓扑排序啦~直接上面那题代码改改即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span>  </span>&#123;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">		<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in_degree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++)&#123;</span><br><span class="line">			g[prerequisites[i].second].push_back(prerequisites[i].first);</span><br><span class="line">			in_degree[prerequisites[i].first]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) <span class="keyword">if</span> (in_degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">			<span class="keyword">int</span> cur = q.front();</span><br><span class="line">			ans.push_back(cur);</span><br><span class="line">			q.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> it = g[cur].begin(); it != g[cur].end(); it++)</span><br><span class="line">				<span class="keyword">if</span> (--in_degree[*it] == <span class="number">0</span>) q.push(*it);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ans.size() == numCourses) <span class="keyword">return</span> ans;</span><br><span class="line">		ans.clear();</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="省份数量"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h3>
<blockquote>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">&gt;输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure>
<img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">&gt;输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>n == isConnected.length</code></li>
<li><code>n == isConnected[i].length</code></li>
<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>
<li><code>isConnected[i][i] == 1</code></li>
<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
</blockquote>
<p>方法1：dfs即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def findCircleNum(self, isConnected: List[List[int]]) -&gt; int:</span><br><span class="line">        vis = [False] * len(isConnected)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i in range(len(isConnected)):</span><br><span class="line">            <span class="keyword">if</span> vis[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            vis[i] = True</span><br><span class="line">            self.dfs(i, isConnected, vis)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    def dfs(self, cur, isConnected, vis):</span><br><span class="line">        row = isConnected[cur]</span><br><span class="line">        <span class="keyword">for</span> i in range(len(row)):</span><br><span class="line">            <span class="keyword">if</span> row[i] <span class="keyword">and</span> <span class="keyword">not</span> vis[i]:</span><br><span class="line">                vis[cur] = True</span><br><span class="line">                self.dfs(i, isConnected, vis)</span><br></pre></td></tr></table></figure>
<p>方法2： 并查集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        fa = list(range(len(isConnected)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(isConnected)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j]:</span><br><span class="line">                    root_x = self.find(i, fa)</span><br><span class="line">                    root_y = self.find(j, fa)</span><br><span class="line">                    <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">                        fa[root_y] = root_x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum([<span class="number">1</span> <span class="keyword">if</span> i == fa[i] <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(isConnected))])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, cur, fa</span>):</span></span><br><span class="line">        <span class="keyword">if</span> fa[cur] == cur: <span class="keyword">return</span> cur</span><br><span class="line">        fa[cur] = self.find(fa[cur], fa)</span><br><span class="line">        <span class="keyword">return</span> fa[cur]</span><br></pre></td></tr></table></figure>
<h3 id="冗余连接"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h3>
<blockquote>
<p>在本问题中, 树指的是一个连通且无环的<strong>无向</strong>图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以<code>边</code>组成的二维数组。每一个<code>边</code>的元素是一对<code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点<code>u</code> 和<code>v</code>的<strong>无向</strong>图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">&gt;输出: [2,3]</span><br><span class="line">&gt;解释: 给定的无向图为:</span><br><span class="line"> 1</span><br><span class="line">&#x2F; \</span><br><span class="line">&gt;2 - 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">&gt;输出: [1,4]</span><br><span class="line">&gt;解释: 给定的无向图为:</span><br><span class="line">&gt;5 - 1 - 2</span><br><span class="line">   |   |</span><br><span class="line">   4 - 3</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>输入的二维数组大小在 3 到 1000。</li>
<li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li>
</ul>
<p><strong>更新(2017-09-26):</strong> 我们已经重新检查了问题描述及测试用例，明确图是<strong><em>无向</em></strong> 图。对于有向图详见<strong><a target="_blank" rel="noopener" href="https://leetcodechina.com/problems/redundant-connection-ii/description/">冗余连接II</a>。</strong>对于造成任何不便，我们深感歉意。</p>
</blockquote>
<p>低配版本的kruskal算法（不像MST要排序），并查集即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span>(<span class="params">self, edges: List[List[int]]</span>) -&gt; List[int]:</span></span><br><span class="line">        max_n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            max_n = max(max_n, edge[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(max_n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            x, y = edge</span><br><span class="line">            root_x = self.find(x, fa)</span><br><span class="line">            root_y = self.find(y, fa)</span><br><span class="line">            <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">                fa[root_y] = root_x</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> edge</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x, fa</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != fa[x]:</span><br><span class="line">            fa[x] = self.find(fa[x], fa)</span><br><span class="line">        <span class="keyword">return</span> fa[x]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="水位上升的泳池中游泳"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swim-in-rising-water/">778. 水位上升的泳池中游泳</a></h3>
<blockquote>
<p>在一个 N x N 的坐标方格 <code>grid</code> 中，每一个方格的值 <code>grid[i][j]</code> 表示在位置 <code>(i,j)</code> 的平台高度。</p>
<p>现在开始下雨了。当时间为 <code>t</code> 时，此时雨水导致水池中任意位置的水位为 <code>t</code> 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。</p>
<p>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 <code>(N-1, N-1)</code>？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[0,2],[1,3]]</span><br><span class="line">&gt;输出: 3</span><br><span class="line">&gt;解释:</span><br><span class="line">&gt;时间为0时，你位于坐标方格的位置为 (0, 0)。</span><br><span class="line">&gt;此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。</span><br><span class="line"></span><br><span class="line">&gt;等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置</span><br></pre></td></tr></table></figure>
<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">&gt;输出: 16</span><br><span class="line">&gt;解释:</span><br><span class="line">0  1  2  3  4</span><br><span class="line">&gt;24 23 22 21  5</span><br><span class="line">&gt;12 13 14 15 16</span><br><span class="line">&gt;11 17 18 19 20</span><br><span class="line">&gt;10  9  8  7  6</span><br><span class="line"></span><br><span class="line">&gt;最终的路线用加粗进行了标记。</span><br><span class="line">&gt;我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol type="1">
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li><code>grid[i][j]</code> 是 <code>[0, ..., N*N - 1]</code> 的排列。</li>
</ol>
</blockquote>
<h4 id="方法1-最短路">方法1 最短路</h4>
<p>用dijkstra算法，能到达点b的权值为<code>max(weight_b, cur.weight)</code> ，一个是路上累计的最大，一个是当前b点的权值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    Node(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> t) : x(i), y(j), t(t) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Node&amp; o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t &gt; o.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        q.push(Node(<span class="number">0</span>, <span class="number">0</span>, grid[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node cur = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur.x == n - <span class="number">1</span> &amp;&amp; cur.y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur.t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[cur.x][cur.y]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[cur.x][cur.y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = cur.x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = cur.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx == n || ny == n || vis[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push(Node(nx, ny, max(grid[nx][ny], cur.t)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2-并查集">方法2 并查集</h4>
<p>将权值从小到大排序（由于本题为0～n*n-1，可以用类似计数排序），然后遍历权值，若当前权值大于四周的点，则可以合并两个连通分支，因为在当前的时刻t，可以到当前的点必然也能到相邻的点。若加入某个点后起点和终点连通，则找到了解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        _fa.resize(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            _fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _fa[x] == x ? x : _fa[x] = find(_fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_fa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_x = find(x);</span><br><span class="line">        <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (root_x != root_y) &#123;</span><br><span class="line">            _fa[root_x] = root_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * n)</span></span>;</span><br><span class="line">        vector&lt;pair&lt;int, int&gt;&gt; idx(n * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                idx[grid[i][j]] = <span class="built_in">std</span>::<span class="built_in">make_pair</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">max_t</span> = n * n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> <span class="keyword">cur_t</span> = <span class="number">0</span>; <span class="keyword">cur_t</span> &lt;= <span class="keyword">max_t</span>; ++<span class="keyword">cur_t</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = idx[<span class="keyword">cur_t</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx == n || ny == n || grid[nx][ny] &gt; <span class="keyword">cur_t</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                uf.union_fa(x * n + y, nx * n + ny);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uf.find(<span class="number">0</span>) == uf.find(n * n - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">cur_t</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法3 类似1631二分搜索</p>
<h3 id="打砖块"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bricks-falling-when-hit/">803. 打砖块</a></h3>
<blockquote>
<p>有一个 <code>m x n</code> 的二元网格，其中 <code>1</code> 表示砖块，<code>0</code> 表示空白。砖块 <strong>稳定</strong>（不会掉落）的前提是：</p>
<ul>
<li>一块砖直接连接到网格的顶部，或者</li>
<li>至少有一块相邻（4 个方向之一）砖块 <strong>稳定</strong> 不会掉落时</li>
</ul>
<p>给你一个数组 <code>hits</code> ，这是需要依次消除砖块的位置。每当消除 <code>hits[i] = (rowi, coli)</code> 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。</p>
<p>返回一个数组 <code>result</code> ，其中 <code>result[i]</code> 表示第 <code>i</code> 次消除操作对应掉落的砖块数目。</p>
<p><strong>注意</strong>，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：grid &#x3D; [[1,0,0,0],[1,1,1,0]], hits &#x3D; [[1,0]]</span><br><span class="line">&gt;输出：[2]</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;网格开始为：</span><br><span class="line">&gt;[[1,0,0,0]，</span><br><span class="line">[1,1,1,0]]</span><br><span class="line">&gt;消除 (1,0) 处加粗的砖块，得到网格：</span><br><span class="line">&gt;[[1,0,0,0]</span><br><span class="line">[0,1,1,0]]</span><br><span class="line">&gt;两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：</span><br><span class="line">&gt;[[1,0,0,0],</span><br><span class="line">[0,0,0,0]]</span><br><span class="line">&gt;因此，结果为 [2] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：grid &#x3D; [[1,0,0,0],[1,1,0,0]], hits &#x3D; [[1,1],[1,0]]</span><br><span class="line">&gt;输出：[0,0]</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;网格开始为：</span><br><span class="line">&gt;[[1,0,0,0],</span><br><span class="line">[1,1,0,0]]</span><br><span class="line">&gt;消除 (1,1) 处加粗的砖块，得到网格：</span><br><span class="line">&gt;[[1,0,0,0],</span><br><span class="line">[1,0,0,0]]</span><br><span class="line">&gt;剩下的砖都很稳定，所以不会掉落。网格保持不变：</span><br><span class="line">&gt;[[1,0,0,0], </span><br><span class="line">[1,0,0,0]]</span><br><span class="line">&gt;接下来消除 (1,0) 处加粗的砖块，得到网格：</span><br><span class="line">&gt;[[1,0,0,0],</span><br><span class="line">[0,0,0,0]]</span><br><span class="line">&gt;剩下的砖块仍然是稳定的，所以不会有砖块掉落。</span><br><span class="line">&gt;因此，结果为 [0,0] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
<li><code>1 &lt;= hits.length &lt;= 4 * 104</code></li>
<li><code>hits[i].length == 2</code></li>
<li><code>0 &lt;= xi &lt;= m - 1</code></li>
<li><code>0 &lt;= yi &lt;= n - 1</code></li>
<li>所有 <code>(xi, yi)</code> 互不相同</li>
</ul>
</blockquote>
<p>并查集+逆向思维法。</p>
<p>首先，一块砖是稳定的仅当与屋顶连接，或者周围4个方块有一个是稳定的。当我们消除一个砖块的时候，可能会破坏这个稳定的结构，导致一堆砖块掉落。</p>
<p>注意到一块砖是稳定的=&gt;说明它直接或间接的和屋顶连接=》其他和该砖头连接的都可以看成是一个稳定的连通子图。因此感觉可以用并查集来做。但是并查集是相当于是对两个连通子图的合并，而这道题消除砖块变成连通分量的分解，因此可以考虑逆向思维。</p>
<ol type="1">
<li>消除所有hits的砖块，即将grid中在hits数组对应的位置上都设置为0</li>
<li>可以首先将与屋顶连接的砖块看成同一个连通分量，因为和任意一个连接都没有什么区别。因此用并查集将他们合并</li>
<li>初始化其他的砖块，将数值为1的合并起来</li>
<li>经过2和3，就形成了若干个连通分量</li>
<li>逆序遍历hits数组，对位置x ,y ：
<ol type="1">
<li>首先确保这个位置原先是1，否则相当于hit了空的位置，这里不该补上1</li>
<li>如果<code>x == 0</code>说明这个砖块是和屋顶直接连接的，要先和屋顶合并一下（否则可能这个砖头连接的其他的砖头都不和屋顶连接了）</li>
<li>合并x, y周围的联通分量</li>
<li>设<code>pre_num</code>为合并前屋顶联通分量的儿子的数目，<code>after_num</code>为合并后的数量，则通过补上x,y 连接了<code>after_num - pre_num - 1</code>的数量</li>
</ol></li>
</ol>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    dx = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">    dy = [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitBricks</span>(<span class="params">self, grid: List[List[int]], hits: List[List[int]]</span>) -&gt; List[int]:</span></span><br><span class="line">        origin_grid = copy.deepcopy(grid)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> hits:</span><br><span class="line">            grid[x][y] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.m, self.n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        roof_key = self.get_key(self.m, self.n) <span class="comment"># 屋顶的key</span></span><br><span class="line">        unionfind = UnionFind(roof_key + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="keyword">if</span> grid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">                unionfind.union(self.get_key(<span class="number">0</span>, j), roof_key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> grid[i - <span class="number">1</span>][j]:</span><br><span class="line">                    unionfind.union(self.get_key(i, j), self.get_key(i - <span class="number">1</span>, j))</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">and</span> grid[i][j - <span class="number">1</span>]:</span><br><span class="line">                    unionfind.union(self.get_key(i, j), self.get_key(i, j - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> hits[::<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> origin_grid[x][y] == <span class="number">0</span>:</span><br><span class="line">                ans.append(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            cur_key = self.get_key(x, y)</span><br><span class="line">            pre_num = unionfind.get_count(roof_key)</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">                unionfind.union(cur_key, roof_key)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                nx, ny = x + self.dx[i], y + self.dy[i]</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= len(grid) <span class="keyword">or</span> ny &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> \</span><br><span class="line">                        <span class="keyword">not</span> grid[nx][ny]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                unionfind.union(cur_key, self.get_key(nx, ny))</span><br><span class="line">            </span><br><span class="line">            after_num = unionfind.get_count(roof_key)</span><br><span class="line">            cur = max(after_num - pre_num - <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            ans.append(cur)</span><br><span class="line">            grid[x][y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x * self.n + y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.counter = [<span class="number">1</span>] * n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != self.fa[x]:</span><br><span class="line">            self.fa[x] = self.find(self.fa[x])</span><br><span class="line">        <span class="keyword">return</span> self.fa[x]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.fa[root_y] = root_x</span><br><span class="line">        self.counter[root_x] += self.counter[root_y]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        <span class="keyword">return</span> self.counter[root_x]</span><br></pre></td></tr></table></figure>
<h3 id="移除最多的同行或同列石头"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h3>
<blockquote>
<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>
<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>
<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：stones &#x3D; [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">&gt;输出：5</span><br><span class="line">&gt;解释：一种移除 5 块石头的方法如下所示：</span><br><span class="line">&gt;1. 移除石头 [2,2] ，因为它和 [2,1] 同行。</span><br><span class="line">&gt;2. 移除石头 [2,1] ，因为它和 [0,1] 同列。</span><br><span class="line">&gt;3. 移除石头 [1,2] ，因为它和 [1,0] 同行。</span><br><span class="line">&gt;4. 移除石头 [1,0] ，因为它和 [0,0] 同列。</span><br><span class="line">&gt;5. 移除石头 [0,1] ，因为它和 [0,0] 同行。</span><br><span class="line">&gt;石头 [0,0] 不能移除，因为它没有与另一块石头同行&#x2F;列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：stones &#x3D; [[0,0],[0,2],[1,1],[2,0],[2,2]]</span><br><span class="line">&gt;输出：3</span><br><span class="line">&gt;解释：一种移除 3 块石头的方法如下所示：</span><br><span class="line">&gt;1. 移除石头 [2,2] ，因为它和 [2,0] 同行。</span><br><span class="line">&gt;2. 移除石头 [2,0] ，因为它和 [0,0] 同列。</span><br><span class="line">&gt;3. 移除石头 [0,2] ，因为它和 [0,0] 同行。</span><br><span class="line">&gt;石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行&#x2F;列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：stones &#x3D; [[0,0]]</span><br><span class="line">&gt;输出：0</span><br><span class="line">&gt;解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
<li><code>0 &lt;= xi, yi &lt;= 10^4</code></li>
<li>不会有两块石头放在同一个坐标点上</li>
</ul>
</blockquote>
<p>题目说，如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>
<p>容易想到，可以根据这个规则将同行或者同列的删除得剩下一个石头。比如下面的，由于同行同列可以删除，最优的做法就是删除得剩下一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 0 1</span><br><span class="line">0 1 0 0</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure>
<p>这就又是并查集的思路了：每个连通子图都可以剩下一个，那么答案就是总共的石头数目-连通子图的个数。</p>
<p>所以对于<code>x, y</code>坐标就是把横纵坐标合并为一个子图。由于x, y &lt; 10^4，因此可以将y的坐标加上10001来区分x, y坐标。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeStones</span>(<span class="params">self, stones: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        fa = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> stones:</span><br><span class="line">            root_x = self.find(fa, x)</span><br><span class="line">            root_y = self.find(fa, y + <span class="number">10001</span>)</span><br><span class="line">            <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">                fa[root_y] = root_x</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, root_x <span class="keyword">in</span> fa.items():</span><br><span class="line">            <span class="keyword">if</span> x == root_x:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(stones) - cnt</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, fa, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> fa:</span><br><span class="line">            fa[x] = x</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> x == fa[x]:</span><br><span class="line">            <span class="keyword">return</span> fa[x]</span><br><span class="line">        fa[x] = self.find(fa, fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x]</span><br></pre></td></tr></table></figure>
<h3 id="由斜杠划分区域"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></h3>
<blockquote>
<p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>
<p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>"\\"</code> 表示。）。</p>
<p>返回区域的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">&gt;[</span><br><span class="line"> &quot; &#x2F;&quot;,</span><br><span class="line"> &quot;&#x2F; &quot;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;输出：2</span><br><span class="line">&gt;解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">&gt;[</span><br><span class="line"> &quot; &#x2F;&quot;,</span><br><span class="line"> &quot;  &quot;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;输出：1</span><br><span class="line">&gt;解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">&gt;[</span><br><span class="line"> &quot;\\&#x2F;&quot;,</span><br><span class="line"> &quot;&#x2F;\\&quot;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;输出：4</span><br><span class="line">&gt;解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\&#x2F;&quot; 表示 \&#x2F;，而 &quot;&#x2F;\\&quot; 表示 &#x2F;\。）</span><br><span class="line">&gt;2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">&gt;[</span><br><span class="line"> &quot;&#x2F;\\&quot;,</span><br><span class="line"> &quot;\\&#x2F;&quot;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;输出：5</span><br><span class="line">&gt;解释：（回想一下，因为 \ 字符是转义的，所以 &quot;&#x2F;\\&quot; 表示 &#x2F;\，而 &quot;\\&#x2F;&quot; 表示 \&#x2F;。）</span><br><span class="line">&gt;2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：</span><br><span class="line">&gt;[</span><br><span class="line"> &quot;&#x2F;&#x2F;&quot;,</span><br><span class="line"> &quot;&#x2F; &quot;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;输出：3</span><br><span class="line">&gt;解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol type="1">
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> 是 <code>'/'</code>、<code>'\'</code>、或 <code>' '</code>。</li>
</ol>
</blockquote>
<p>这题很容易想到并查集，但是难的是建图，可以把一个位置分成如下四个小区域，若当前字符为：</p>
<ul>
<li>空格：则合并4个区域</li>
<li><code>/</code>： 合并<code>03, 12</code></li>
<li><code>\</code>: 合并 <code>01, 23</code></li>
</ul>
<figure>
<img src="../images/leetcode-graph/1611301988-RWjuqg-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>图片来自https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/</p>
<p>那么不同块直接处理呢？注意到当前位置的“1”和右边的“3”肯定是能连接的，不管是什么符号。而当前位置的“2”和下面的"0"也是一定能连接的，因此直接合并即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span>(<span class="params">self, grid: List[str]</span>) -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        uf = UnionFind(<span class="number">4</span> * n * n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                c = grid[i][j]</span><br><span class="line">                start = self.pos(i, j, n)</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    uf.union(start, start + <span class="number">1</span>)</span><br><span class="line">                    uf.union(start, start + <span class="number">2</span>)</span><br><span class="line">                    uf.union(start, start + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    uf.union(start, start + <span class="number">3</span>)</span><br><span class="line">                    uf.union(start + <span class="number">1</span>, start + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#\</span></span><br><span class="line">                    uf.union(start, start + <span class="number">1</span>)</span><br><span class="line">                    uf.union(start + <span class="number">2</span>, start + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> j + <span class="number">1</span> &lt; n:</span><br><span class="line">                    right_start = self.pos(i, j + <span class="number">1</span>, n)</span><br><span class="line">                    uf.union(start + <span class="number">1</span>, right_start + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; n:</span><br><span class="line">                    down_start = self.pos(i + <span class="number">1</span>, j, n)</span><br><span class="line">                    uf.union(start + <span class="number">2</span>, down_start)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> uf.get_root_count()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pos</span>(<span class="params">self, i, j, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">4</span> * n + j * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.count = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root_count</span>(<span class="params">self,</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != self.fa[x]:</span><br><span class="line">            self.fa[x] = self.find(self.fa[x])</span><br><span class="line">        <span class="keyword">return</span> self.fa[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.fa[root_y] = root_x</span><br><span class="line">            self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="交换字符串中的元素"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2]]</span><br><span class="line">&gt;输出：&quot;bacd&quot;</span><br><span class="line">&gt;解释： </span><br><span class="line">&gt;交换 s[0] 和 s[3], s &#x3D; &quot;bcad&quot;</span><br><span class="line">&gt;交换 s[1] 和 s[2], s &#x3D; &quot;bacd&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2],[0,2]]</span><br><span class="line">&gt;输出：&quot;abcd&quot;</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;交换 s[0] 和 s[3], s &#x3D; &quot;bcad&quot;</span><br><span class="line">&gt;交换 s[0] 和 s[2], s &#x3D; &quot;acbd&quot;</span><br><span class="line">&gt;交换 s[1] 和 s[2], s &#x3D; &quot;abcd&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：s &#x3D; &quot;cba&quot;, pairs &#x3D; [[0,1],[1,2]]</span><br><span class="line">&gt;输出：&quot;abc&quot;</span><br><span class="line">&gt;解释：</span><br><span class="line">&gt;交换 s[0] 和 s[1], s &#x3D; &quot;bca&quot;</span><br><span class="line">&gt;交换 s[1] 和 s[2], s &#x3D; &quot;bac&quot;</span><br><span class="line">&gt;交换 s[0] 和 s[1], s &#x3D; &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li>
<li><code>s</code> 中只含有小写英文字母</li>
</ul>
</blockquote>
<p>这题有一个pairs数组，可以任意多次交换，容易想到的是，<code>[0, 3]</code>能交换，<code>[3, 6]</code>能交换，那么<code>[0, 6]</code>也能交换（具有传递性）。</p>
<p>因此可以用一个并查集，来找到所有的连通分量，对于同一组连通分量的，进行排序，然后按大小输出即可。</p>
<p>注意这里由于只有小写字母，因此可以用计数排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fa</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> root_x = find(<span class="built_in">pair</span>[<span class="number">0</span>], fa);</span><br><span class="line">            <span class="keyword">int</span> root_y = find(<span class="built_in">pair</span>[<span class="number">1</span>], fa);</span><br><span class="line">            fa[root_y] = root_x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; counter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = find(i, fa);</span><br><span class="line">            <span class="keyword">if</span> (counter.find(root) == counter.end()) &#123;</span><br><span class="line">                counter[root] = <span class="built_in">vector</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++counter[root][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = find(i, fa);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cnt = counter[root];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt[j];</span><br><span class="line">                    ss &lt;&lt; <span class="keyword">char</span>(<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur == fa[cur]? cur : fa[cur] = find(fa[cur], fa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="连通网络的操作次数"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a></h3>
<blockquote>
<p>用以太网线缆将 <code>n</code> 台计算机连接成一个网络，计算机的编号从 <code>0</code> 到 <code>n-1</code>。线缆用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 连接了计算机 <code>a</code> 和 <code>b</code>。</p>
<p>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。</p>
<p>给你这个计算机网络的初始布线 <code>connections</code>，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png" alt="img" /></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 4, connections &#x3D; [[0,1],[0,2],[1,2]]</span><br><span class="line">&gt;输出：1</span><br><span class="line">&gt;解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png" alt="img" /></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2],[1,3]]</span><br><span class="line">&gt;输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2]]</span><br><span class="line">&gt;输出：-1</span><br><span class="line">&gt;解释：线缆数量不足。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 5, connections &#x3D; [[0,1],[0,2],[3,4],[2,3]]</span><br><span class="line">&gt;输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5)</code></li>
<li><code>connections[i].length == 2</code></li>
<li><code>0 &lt;= connections[i][0], connections[i][1] &lt; n</code></li>
<li><code>connections[i][0] != connections[i][1]</code></li>
<li>没有重复的连接。</li>
<li>两台计算机不会通过多条线缆连接。</li>
</ul>
</blockquote>
<p>将两个线断开，然后去连接没有连接的计算机，相当于连接两个连通分量。因为断开的线必然是不影响原来连通分量的连通性的，否则就不能断开。</p>
<p>因此可以用并查集，首先将所有节点合并，看有几个连通分量，只需要将多余的线断开并连接即可。因此答案为<code>连通分量数 - 1</code></p>
<p>注意无解的情况就是本身的线少于<code>n - 1</code>条的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span>(<span class="params">self, n: int, connections: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(connections) &lt; n - <span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> connections:</span><br><span class="line">            uf.union(a, b)</span><br><span class="line">        root_nodes = uf.get_root_nodes()</span><br><span class="line">        <span class="keyword">return</span> len(root_nodes) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root_nodes</span>(<span class="params">self,</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.fa)) <span class="keyword">if</span> i == self.fa[i]] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != self.fa[x]:</span><br><span class="line">            self.fa[x] = self.find(self.fa[x])</span><br><span class="line">        <span class="keyword">return</span> self.fa[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.fa[root_y] = root_x</span><br></pre></td></tr></table></figure>
<h3 id="找到最小生成树里的关键边和伪关键边"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. 找到最小生成树里的关键边和伪关键边</a></h3>
<blockquote>
<p>给你一个 <code>n</code> 个点的带权无向连通图，节点编号为 <code>0</code> 到 <code>n-1</code> ，同时还有一个数组 <code>edges</code> ，其中 <code>edges[i] = [from``i, toi, weighti]</code> 表示在 <code>fromi</code> 和 <code>toi</code> 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p>
<p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p>
<p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 5, edges &#x3D; [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]</span><br><span class="line">&gt;输出：[[0,1],[2,3,4,5]]</span><br><span class="line">&gt;解释：上图描述了给定图。</span><br><span class="line">&gt;下图是所有的最小生成树。</span><br><span class="line"></span><br><span class="line">&gt;注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。</span><br><span class="line">&gt;边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2 ：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/06/21/ex2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：n &#x3D; 4, edges &#x3D; [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]</span><br><span class="line">&gt;输出：[[],[0,1,2,3]]</span><br><span class="line">&gt;解释：可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li>
<li><code>edges[i].length == 3</code></li>
<li><code>0 &lt;= fromi &lt; toi &lt; n</code></li>
<li><code>1 &lt;= weighti &lt;= 1000</code></li>
<li>所有 <code>(fromi, toi)</code> 数对都是互不相同的。</li>
</ul>
</blockquote>
<p>首先用kruskal算法生成最小生成树，然后枚举MST的每一条边<code>mst_i</code>：</p>
<ul>
<li>初始化一个新的并查集，将除了<code>mst_i</code>外的所有边都合并</li>
<li>遍历edges，若能找不到边能生成MST或者两个连通分量的权值会增加，则说明是关键边，否则为伪关建边</li>
</ul>
<p>注意由于一开始将数组排序的，所以最后还要将排好序的数组和一开始的数组下标对应</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCriticalAndPseudoCriticalEdges</span>(<span class="params">self, n: int, edges: List[List[int]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        edges = [(i, x, y, w) <span class="keyword">for</span> i, (x, y, w) <span class="keyword">in</span> enumerate(edges)]</span><br><span class="line">        edges.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        mst_edge_index = []</span><br><span class="line">        mst_weight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, (_, x, y, w) <span class="keyword">in</span> enumerate(edges):</span><br><span class="line">            root_x = uf.find(x)</span><br><span class="line">            root_y = uf.find(y)</span><br><span class="line">            <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">                mst_weight += w</span><br><span class="line">                mst_edge_index.append(i)</span><br><span class="line">                uf.union(root_x, root_y)</span><br><span class="line">                <span class="keyword">if</span> len(mst_edge_index) &gt;= n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        key_list = []</span><br><span class="line">        fake_key_list = []</span><br><span class="line">        <span class="keyword">if</span> len(mst_edge_index) != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [key_list, fake_key_list]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> mst_i <span class="keyword">in</span> mst_edge_index:</span><br><span class="line">            temp_uf = UnionFind(n)</span><br><span class="line">            temp_w = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> mst_edge_index:</span><br><span class="line">                <span class="keyword">if</span> mst_i == i:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                _, x, y, w = edges[i]</span><br><span class="line">                temp_uf.union(x, y)</span><br><span class="line">                temp_w += w</span><br><span class="line">            </span><br><span class="line">            find_equal = <span class="literal">False</span></span><br><span class="line">            find_two_graph_edge = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(mst_i + <span class="number">1</span>, len(edges)): <span class="comment"># 从mst_i + 1 开始</span></span><br><span class="line">                _, x, y, w = edges[i]</span><br><span class="line">                root_x = temp_uf.find(x)</span><br><span class="line">                root_y = temp_uf.find(y)</span><br><span class="line">                <span class="keyword">if</span> root_x == root_y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                find_two_graph_edge = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> temp_w + w == mst_weight:</span><br><span class="line">                    find_equal = <span class="literal">True</span></span><br><span class="line">                    fake_key_list.append(i)</span><br><span class="line">                <span class="keyword">elif</span> temp_w + w &gt; mst_weight:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> find_two_graph_edge <span class="keyword">or</span> <span class="keyword">not</span> find_equal:</span><br><span class="line">                key_list.append(mst_i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fake_key_list.append(mst_i)</span><br><span class="line"></span><br><span class="line">        key_list = [edges[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> key_list]</span><br><span class="line">        fake_key_list = [edges[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> set(fake_key_list)]</span><br><span class="line">        <span class="keyword">return</span> [key_list, fake_key_list]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.fa = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> x != self.fa[x]:</span><br><span class="line">            self.fa[x] = self.find(self.fa[x])</span><br><span class="line">        <span class="keyword">return</span> self.fa[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> root_x != root_y:</span><br><span class="line">            self.fa[root_y] = root_x</span><br></pre></td></tr></table></figure>
<h3 id="最小体力消耗路径"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h3>
<blockquote>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：heights &#x3D; [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class="line">&gt;输出：2</span><br><span class="line">&gt;解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。</span><br><span class="line">&gt;这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：heights &#x3D; [[1,2,3],[3,8,4],[5,3,5]]</span><br><span class="line">&gt;输出：1</span><br><span class="line">&gt;解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：heights &#x3D; [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]</span><br><span class="line">&gt;输出：0</span><br><span class="line">&gt;解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == heights.length</code></li>
<li><code>columns == heights[i].length</code></li>
<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
<li><code>1 &lt;= heights[i][j] &lt;= 106</code></li>
</ul>
</blockquote>
<h4 id="方法1.-最短路径">方法1. 最短路径</h4>
<p>用最短路径的算法如dijkstra</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cost) : x(x), y(y), cost(cost) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; o) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cost &gt; o.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = heights.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = heights[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, INT_MAX))</span></span>;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line">        q.push(Node(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node cur = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (vis[cur.x][cur.y]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.x == m - <span class="number">1</span> &amp;&amp; cur.y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur.cost;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[cur.x][cur.y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = cur.x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = cur.y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n || vis[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">abs</span>(heights[nx][ny] - heights[cur.x][cur.y]);</span><br><span class="line">                temp = max(temp, cur.cost);</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; dis[nx][ny]) &#123;</span><br><span class="line">                    dis[nx][ny] = temp;</span><br><span class="line">                    q.push(Node(nx, ny, temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法2.二分搜索">方法2.二分搜索</h4>
<p>设答案为mid，然后遍历图，每次只能遍历权重差不大于mid的点。</p>
<p>如果能到达右下角，则设<code>right = mid</code>缩小范围，否则<code>left = mid + 1</code>增大权重</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = heights.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = heights[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">vis</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">            q.emplace(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= m || ny &gt;= n || vis[nx][ny]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(heights[nx][ny] - heights[x][y]) &lt;= mid) &#123;</span><br><span class="line">                        q.emplace(nx, ny);</span><br><span class="line">                        vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vis[m - <span class="number">1</span>][n - <span class="number">1</span>]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法3.-并查集">方法3. 并查集</h4>
<p>将一个点和它右边、下方两个点边的权值（就是相减的绝对值）放入列表中，按权值从小到大排序。</p>
<p>从小到大遍历边，用并查集合并两个点，若合并后起点和终点连通，则说明找到了答案。PS：需要注意只有一个点的情况， 返回0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UnionFind(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        _fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            _fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == _fa[x] ? x : _fa[x] = find(_fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_fa</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root_x = find(x);</span><br><span class="line">        <span class="keyword">int</span> root_y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (root_x != root_y) &#123;</span><br><span class="line">            _fa[root_y] = root_x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _fa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heights.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = heights.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = heights[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; values;</span><br><span class="line">        values.reserve(m * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> != m) &#123;</span><br><span class="line">                    values.emplace_back(<span class="built_in">abs</span>(heights[i][j] - heights[i + <span class="number">1</span>][j]), i * n + j, (i + <span class="number">1</span>) * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> != n) &#123;</span><br><span class="line">                    values.emplace_back(<span class="built_in">abs</span>(heights[i][j] - heights[i][j + <span class="number">1</span>]), i * n + j, i * n + j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(values.begin(), values.end());</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(m * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, key1, key2] : values) &#123;</span><br><span class="line">            uf.union_fa(key1, key2);</span><br><span class="line">            <span class="keyword">if</span> (uf.find(<span class="number">0</span>) == uf.find(m * n - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://www.hrwhisper.me/leetcode-graph/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/ruc-assistant/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ruc assistant
          
        </div>
      </a>
    
    
      <a href="/leetcode-linklist/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">leetcode 链表</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz",
    app_key: "b26lBsbwmVyxTSnNrsBrnv3U",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2013-2021
        <i class="ri-heart-fill heart_icon"></i> hrwhisper
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>

 
  <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="//cdn1.lncld.net/static/js/2.5.0/av-min.js"></script>
<script type="text/javascript">
var leancloud_app_id  = 'fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz';
var leancloud_app_key = 'b26lBsbwmVyxTSnNrsBrnv3U';

AV.init({
    appId: leancloud_app_id,
    appKey: leancloud_app_key
});

// https://leancloud.cn/docs/leanstorage_guide-js.html#hash1873238850
function showTime(Counter) {
  console.log("show time");
  const query = new AV.Query(Counter);
  const obj = $(".leancloud_visitors");

  let urls = [];
  obj.each(function() {
    urls.push($(this).attr('id').trim());
  });
  query.containedIn('url', urls);
  query.find().then((results) => {
      if (results.length > 0) {
        let data = results;
        obj.each(function() {
          let url = $(this).attr('id').trim();		
          for (let i = 0; i < data.length; i++) {
            let object = data[i];
            let content = object.get('time');
            let _url = object.get('url');
            if(url == _url){
              $(this).text(content);
            }
          }
        });
      }
  }).catch((error) => {
    console.error(error);
  });
}

function addCount(Counter) {
  const obj = $(".leancloud_visitors");
	url = obj.attr('id').trim();
  title = obj.attr('data-flag-title').trim();

  const query = new AV.Query(Counter);
  query.equalTo("url", url);

	query.find().then((results) => {
			if (results.length > 0) {
				var counter = results[0];
        counter.increment("time", 1);
        counter.set("title", title);
				counter.save(null, {fetchWhenSave: true}).then(() => {
          let content = counter.get('time');
          $(document.getElementById(url)).text(content);
        }, (error)=> {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
        });
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
        newcounter.set("time", 1);
        newcounter.save(null, {fetchWhenSave: true}).then(() => {
          var content = newcounter.get('time');
          $(document.getElementById(url)).text(content);
        }, (error)=> {
          console.log('Failed to create' + error.message);
        });
			}
	}).catch((error) => {
    console.error(error);
  });
}

$(function() {
  var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else {
	  showTime(Counter);
  }
}); 
</script>


      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/site/avatar.jpg" alt="细语呢喃"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend-link">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/leetcode-algorithm-solution">leetcode题解</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about-me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/wechat_pay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3',
    hasInnerContainers: true,
    scrollSmooth: false,
	  scrollSmoothDuration: 420,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
	  collapseDepth: 2,
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
  </div>
</body>

</html>