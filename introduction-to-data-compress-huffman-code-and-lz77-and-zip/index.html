<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/site/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site/avatar.jpg">
  <link rel="mask-icon" href="/images/site/avatar.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hrwhisper.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容  Huffman编码  Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等）  LZ77算法 ZIP（deflate）算法">
<meta property="og:type" content="article">
<meta property="og:title" content="从Huffman编码谈文件压缩">
<meta property="og:url" content="https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/index.html">
<meta property="og:site_name" content="细语呢喃">
<meta property="og:description" content="本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容  Huffman编码  Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等）  LZ77算法 ZIP（deflate）算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/Huffman_huff_demo.gif">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/lz77-distance-and-length.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/zip-procedure.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/two-huffman-tree-are-both-right.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-2.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-1.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/CCL-position-swap.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/deflate-data-format.png">
<meta property="article:published_time" content="2017-02-26T10:12:02.000Z">
<meta property="article:modified_time" content="2021-01-08T13:42:14.097Z">
<meta property="article:author" content="hrwhisper">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hrwhisper.me/images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/Huffman_huff_demo.gif">

<link rel="canonical" href="https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>从Huffman编码谈文件压缩 | 细语呢喃</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69270533-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-69270533-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d6a8cb42bd9ae728375b6726daa75e95";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">细语呢喃</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术改变生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="/leetcode-algorithm-solution/" rel="section"><i class="fa fa-archive fa-fw"></i>leetcode</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/friend-link/" rel="section"><i class="fa fa-link fa-fw"></i>friends</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about-me/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/site/avatar.jpg">
      <meta itemprop="name" content="hrwhisper">
      <meta itemprop="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="细语呢喃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从Huffman编码谈文件压缩
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-26 18:12:02" itemprop="dateCreated datePublished" datetime="2017-02-26T18:12:02+08:00">2017-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index"><span itemprop="name">study</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法笔记</span></a>
                </span>
            </span>

          
            <span id="/introduction-to-data-compress-huffman-code-and-lz77-and-zip/" class="post-meta-item leancloud_visitors" data-flag-title="从Huffman编码谈文件压缩" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/introduction-to-data-compress-huffman-code-and-lz77-and-zip/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/introduction-to-data-compress-huffman-code-and-lz77-and-zip/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容</p>
<ul>
<li><p>Huffman编码</p>
<ul>
<li>Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等）</li>
</ul></li>
<li><p>LZ77算法</p></li>
<li><p>ZIP（deflate）算法</p></li>
</ul>
<span id="more"></span>
<h2 id="huffman编码">Huffman编码</h2>
<h3 id="压缩过程">压缩过程</h3>
<p>每次将频率最小的两个元素进行合并，自底向上的建树。可以用优先队列来实现。建完树后，我们可以把各个结点与左儿子的边编号为0 ，和右儿子的边编号为1， 将根节点到叶子结点上路径的编号连接起来，就是对应的Huffman编码。</p>
<p>WIKI百科上有一张很好的动态图：</p>
<h3 id="section"><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/Huffman_huff_demo.gif" /></h3>
<p>解压</p>
<p>这样就完成了一棵前缀树Trie，前缀的性质也保证了一个码不会是另一个码的前缀，因此Huffman编码能被正确的解压。解压的时候只需要对于当前的bit，若为0，那么走左边，否则走右边。走到叶子结点说明该字符解码完毕，回到根节点，继续解码下一个。</p>
<h3 id="代码实现">代码实现</h3>
<p>首先定义树的结点的内容，并定义了__lt__方法，便于使用堆(python中的heapq)能进行比较元素的大小</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, cnt, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.cnt = cnt</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cnt &lt; other.cnt</span><br></pre></td></tr></table></figure>
<p>接下来定义Huffman树，该类支持如下特性</p>
<ul>
<li><p>从一个TreeNode的数组（list of TreeNode）中创建huffman树</p>
<ul>
<li>除了一开始用来建树外，在之后从文件中频率信息恢复huffman树也会用到</li>
</ul></li>
<li><p>从huffman树中获取叶子结点对应的编码</p>
<ul>
<li>就是直接进行树的遍历即可</li>
</ul></li>
<li><p>支持查找操作，给定一个字节('1' or '0')进行树根节点的移动</p>
<ul>
<li>文件读取中一个字节一个字节读入时，可以用这个方便查找</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HuffmanTree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, q</span>):</span><br><span class="line">        self._root = self.root = self._create_tree(q)  <span class="comment"># q is a list of TreeNode</span></span><br><span class="line">        self.huffman_code = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_create_tree</span>(<span class="params">q</span>):</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q) &gt; <span class="number">1</span>:</span><br><span class="line">            a, b = heapq.heappop(q), heapq.heappop(q)</span><br><span class="line">            heapq.heappush(q, TreeNode(<span class="string">&#x27;&#x27;</span>, a.cnt + b.cnt, a, b))</span><br><span class="line">        <span class="keyword">return</span> q.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_huffman_code</span>(<span class="params">self</span>):</span><br><span class="line">        self._get_huffman_code(self.root)</span><br><span class="line">        <span class="keyword">return</span> self.huffman_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_huffman_code</span>(<span class="params">self, root, cur=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># the leaf node</span></span><br><span class="line">            self.huffman_code[root.val] = cur</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left:  self._get_huffman_code(root.left, cur + <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right: self._get_huffman_code(root.right, cur + <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, c</span>):</span><br><span class="line">        self.root = self.root.right <span class="keyword">if</span> c == <span class="string">&#x27;1&#x27;</span> <span class="keyword">else</span> self.root.left</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.root.left <span class="keyword">and</span> <span class="keyword">not</span> self.root.right:</span><br><span class="line">            res = self.root.val</span><br><span class="line">            self.root = self._root</span><br><span class="line">            <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>最后时huffman编码的编码和解码过程。</p>
<p>编码过程</p>
<ul>
<li><p>为了能够进行解码，要将<strong>最后一个字节的实际位数</strong>以及“字典”存入文件中</p>
<ul>
<li>首先存入last_byte</li>
<li>紧接着存入字典的长度</li>
<li>接着对于每一个字符，存入该字符，然后是该字符出现频率v的二进制长度，接着是该频率v（转为二进制，按byte存）</li>
</ul></li>
<li><p>字典存储完毕后，才是进行huffman encode的文件内容</p></li>
</ul>
<p>解码过程</p>
<ul>
<li>读入last_byte和字典的长度</li>
<li>根据字典的存储格式为：  字符-频率的二进制长度-频率v 进行读取，然后重新构造huffman数</li>
<li>对文件内容进行decode，用到上面的HuffmanTree.find方法</li>
<li>需要对最后一个字节特殊处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Huffman</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">filename, dist=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dist:   dist = filename + <span class="string">&#x27;_compressed&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> fr, <span class="built_in">open</span>(dist, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            txt = fr.read()</span><br><span class="line">            q = [TreeNode(c, cnt) <span class="keyword">for</span> c, cnt <span class="keyword">in</span> collections.Counter(txt).items()]</span><br><span class="line">            huffman_code = HuffmanTree(q[:]).get_huffman_code()</span><br><span class="line">            txt = <span class="string">&#x27;&#x27;</span>.join([huffman_code[c] <span class="keyword">for</span> c <span class="keyword">in</span> txt])</span><br><span class="line">            f.write(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="built_in">len</span>(txt) &amp; <span class="number">7</span>), <span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># last_byte and dic_len to file</span></span><br><span class="line">            f.write(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="built_in">sum</span>([<span class="number">2</span> + ceil(<span class="built_in">len</span>(<span class="built_in">bin</span>(x.cnt)[<span class="number">2</span>:]) / <span class="number">8</span>) <span class="keyword">for</span> x <span class="keyword">in</span> q])), <span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># TODO 一样长的</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> q:</span><br><span class="line">                c, v = x.val, <span class="built_in">bin</span>(x.cnt)[<span class="number">2</span>:]</span><br><span class="line">                f.write(<span class="built_in">bytes</span>(c, <span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># current character</span></span><br><span class="line">                f.write(<span class="built_in">bytes</span>(<span class="built_in">chr</span>(<span class="built_in">len</span>(v)), <span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># current code length</span></span><br><span class="line">                f.write(<span class="built_in">bytes</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">int</span>(v[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(v), <span class="number">8</span>)), <span class="string">&quot;utf-8&quot;</span>))  <span class="comment"># cnt</span></span><br><span class="line"></span><br><span class="line">            f.write(<span class="built_in">bytes</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">int</span>(txt[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(txt), <span class="number">8</span>)), <span class="string">&quot;utf-8&quot;</span>))  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">filename, dist=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dist:  dist = filename + <span class="string">&#x27;_decode&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            txt = f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        last_byte, dic_len = <span class="built_in">ord</span>(txt[<span class="number">0</span>]), <span class="built_in">ord</span>(txt[<span class="number">1</span>])</span><br><span class="line">        i, huffman_code = <span class="number">2</span>, &#123;&#125;</span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; dic_len + <span class="number">2</span>:</span><br><span class="line">            cur, cur_len = txt[i], <span class="built_in">ord</span>(txt[i + <span class="number">1</span>])</span><br><span class="line">            bytes_num = ceil(cur_len / <span class="number">8</span>)</span><br><span class="line">            code = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">bin</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:].zfill(<span class="number">8</span>) <span class="keyword">for</span> c <span class="keyword">in</span> txt[i + <span class="number">2</span>:i + <span class="number">2</span> + bytes_num]])</span><br><span class="line">            <span class="keyword">if</span> cur_len &amp; <span class="number">7</span>: code = code[:-<span class="number">8</span>] + code[-(cur_len &amp; <span class="number">7</span>):]</span><br><span class="line">            q.append(TreeNode(cur, <span class="built_in">int</span>(code, <span class="number">2</span>)))</span><br><span class="line">            i += bytes_num + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        txt = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">bin</span>(<span class="built_in">ord</span>(c))[<span class="number">2</span>:].zfill(<span class="number">8</span>) <span class="keyword">for</span> c <span class="keyword">in</span> txt[<span class="number">2</span> + dic_len:]])</span><br><span class="line">        <span class="keyword">if</span> last_byte: txt = txt[:-<span class="number">8</span>] + txt[-last_byte:]</span><br><span class="line"></span><br><span class="line">        tree = HuffmanTree(q)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(dist, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(txt)):</span><br><span class="line">                c = tree.find(txt[i])</span><br><span class="line">                <span class="keyword">if</span> c: f.write(c)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后是文件调用的demo,并最后判断压缩前的文件和压缩后解压的文件是否一致，并算出压缩率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_paths = [<span class="string">&#x27;./Aesop_Fables.txt&#x27;</span>, <span class="string">&#x27;./graph.txt&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> cur_file <span class="keyword">in</span> file_paths:</span><br><span class="line">        h = Huffman()</span><br><span class="line">        h.encode(cur_file)</span><br><span class="line">        h.decode(cur_file + <span class="string">&#x27;_compressed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(cur_file) <span class="keyword">as</span> f, \</span><br><span class="line">                <span class="built_in">open</span>(cur_file + <span class="string">&#x27;_compressed_decode&#x27;</span>) <span class="keyword">as</span> fd, <span class="built_in">open</span>(cur_file + <span class="string">&#x27;_compressed&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;: compression ratio: &#123;:.4f&#125;, decode file equals original file is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                f.name, os.path.getsize(cur_file + <span class="string">&#x27;_compressed&#x27;</span>) / os.path.getsize(cur_file), f.read() == fd.read()))</span><br></pre></td></tr></table></figure>
<h3 id="huffman-code小结">huffman code小结</h3>
<p>上面的代码实现了huffman文件压缩的编码和解码过程，但是仍有缺陷，比如字符只有1byte并不支持中文和unicode等，此外，这样将字典写入文件的方式是高效的么？主流的压缩如zip是怎么做的？</p>
<h2 id="文件压缩">文件压缩</h2>
<p>我们可以看到上文中huffman编码能用来进行文件的压缩。</p>
<p>可以说文件压缩可以分为无损压缩和有损压缩。</p>
<p>有损压缩常见于视频、音频等数据，有损压缩意味着一些信息的损失，压缩后无法还原。如JPEG/MP3等</p>
<p>无损压缩则常用于文件压缩等必须还原的场合，所有的信息都得到保留，典型的有ZIP/PNG等。</p>
<p>下面将简单介绍LZ77算法，然后介绍ZIP算法。</p>
<h2 id="lz77-算法">LZ77 算法</h2>
<p>Jacob Ziv和Abraham Lempel 两名以色列人在1977年提出，所以该算法称为LZ77。（1978年他们又改进了一下，称为LZ78）</p>
<h3 id="压缩原理">压缩原理</h3>
<p>Huffman编码是将出现次数多的编码尽可能的短来进行压缩，而LZ77则是另外一种思路：替换重复的内容。</p>
<p>在一个文件中，如果有内容是相同的话，就可以在后一块内容中做一个标记，标示和前一块的距离和相同的长度（distance,length）。（distance,length）绝大多数情况下小于重复的内容，因此文件的体积就变小了。</p>
<h3 id="滑动窗口">滑动窗口</h3>
<p>那么，如何寻找重复的串呢？LZ77算法采用的是的滑动窗口的方法，就是只在一个大小固定的滑动窗口内的进行重复查找。</p>
<p>当前处理的字节开始，和滑动窗口中的每个串进行匹配，目标是找到最大的匹配。</p>
<ul>
<li>如果当前处理的字节开始的串有匹配，就输出一个标志，表明下面的是（distance,length）信息，然后输出（distance,length）</li>
<li>若没有匹配，则该字符称为未匹配的字符（literal），输出该字节，然后处理下一个字节。</li>
</ul>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/lz77-distance-and-length.png" /></p>
<p>此外，有几点需要注意：</p>
<ul>
<li>当匹配的长度length大于最小匹配长度才认为是一个匹配。因为有的太短，记录（distance,length）对反而增大了文件。</li>
<li>固定了窗口大小也就固定了distance和length所需要的位数</li>
<li>标准LZ77在找到重复字符串时输出三元组(length, distance, 下一个未匹配的字符)，但是ZIP中的只输出（distance,length）</li>
</ul>
<h3 id="解压缩的方法">解压缩的方法</h3>
<p>每次先读一个标记为，查看是（distance,length）对还是literal。</p>
<ul>
<li>若（distance,length），则读出相应的串并输出到当前位置</li>
<li> literal：读出并输出该字节</li>
</ul>
<p>对比压缩和解压可以发现压缩时需要进行大量的匹配，而解压时工作则少了很多。这和我们日常使用中的压缩慢解压快是一样的。</p>
<h2 id="zip算法">ZIP算法</h2>
<h3 id="zip-gzip-zlib-关系">zip gzip zlib 关系</h3>
<p>下面的内容引用自 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they">How are zlib, gzip and zip related?</a></p>
<blockquote>
<p>.zip is an archive format using, usually, the Deflate compression method. The .gz gzip format is for single files, also using the Deflate compression method. Often gzip is used in combination with tar to make a compressed archive format, .tar.gz. The zlib library provides Deflate compression and decompression code for use by zip, gzip, png (which uses the zlib wrapper on deflate data), and many other applications.</p>
</blockquote>
<p>可以看到，Gzip和zip都 了Deflate算法，下面将介绍这个算法。</p>
<h3 id="zip算法流程">zip算法流程</h3>
<p>ZIP中，首先使用LZ77编码进行压缩，然后之后再对LZ77编码之后的结果继续进行压缩（Huffman编码）,这个算法也叫做Deflate算法。</p>
<p>其实这个算法也支持静态的Huffman编码，无需记录码表，但是压缩率不高，所以大多数都采用动态的Huffman编码。</p>
<p>采用动态的Huffman编码其流程如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/zip-procedure.png" /></p>
<h3 id="zip中的lz77">ZIP中的LZ77</h3>
<p>ZIP将LZ77的滑动窗口设置为32KB。虽然设置的窗口越大，越可能有重复的内容出现，但是相应的计算量也会变得很大，可能会得不偿失。</p>
<p>ZIP中只有3个字节以上的重复字符串，才会用（distance,length） 表示。</p>
<p>我们知道，经过LZ77算法之后，文件内容表示为literal、distance + length两种形式。Phil Katz继续对这两种形式进行huffman编码，可以说这过程其实才是ZIP算法的核心。</p>
<h3 id="distance-码表">distance 码表</h3>
<p>假如对一个文件进行LZ77压缩后，得到的distance值为：3、6、4、3、4、3、4、3、5，可以根据出现的次数画出哈夫曼树如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/two-huffman-tree-are-both-right.png" /></p>
<p>上面的两个哈夫曼树（这里称为码树）都是合法的，但对应的编码不同。</p>
<p>比如第一个的6的编码为111，而第二棵码树的6的编码为011。</p>
<p>那么问题来了，实际中我们应该怎么选？有好多种情况？</p>
<p>我们知道huffman编码的本质是将出现频率高的编码尽可能的短。对于同一组数据，各种长得不同的huffman树得出的各个元素的长度是一样的，也就是说，<strong>我们只需要记录各个元素编码的长度就可以了</strong>。</p>
<p>比如上面的第一棵树，我们有：3--&gt;0；4--&gt;10；5--&gt;110；6--&gt;111。我们只需要记录：3-&gt;1 ; 4-&gt;2; 5-&gt;3; 6-&gt;3就可以了。</p>
<p>但是这样新的问题来了，在解压的时候，我们可以按照上面第一棵树那样构造huffman树，但是对于5和6来说，长度都是3，那么110表示的是5还是6？</p>
<p>一个简单的解法就是直接按照数字的大小来确定（<strong>升序</strong>），这样相同的长度下就不会混乱了。</p>
<p>但是还有问题，由于我们滑动窗口的大小为32KB，就是说我们的distance范围为1-32KB就是1-32768。 那么我们怎么知道上面的就是3、4、5、6而不是1、2、3、4或者1-32768任意的四个不重复的数字（升序排列）呢？</p>
<p>可以用一个序列来表示，没有出现的就是0，比如上面的3、4、5、6我们可以如下标记：</p>
<ul>
<li>0、0、1、2、3、3、0、0、0、。。。。。。。。。。。。</li>
</ul>
<p>考虑当时的硬件条件，如果压缩大文件的时候，distance达到上千是很正常的，计算机计算能力可能不足。Phil Katz将distance划分为多个区间，每个区间当作一个整数来看，这个称为distance code。<strong>我们对distance code进行huffman编码</strong>，然后再对该去区间的distance进行扩展即可。Phil Katz划分的区间如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-2.png" /></p>
<ul>
<li>code为编号，就是distance code。之后就是用这个进行huffman编码的</li>
<li>bits为需要在code上扩展几位。最多扩展13位（PS：说明最多的区间有2^13 = 8192个数）</li>
<li>distance表示这个区间的distance的范围。</li>
</ul>
<p>虽然使用分区得到的编码不是最优的，但是在当时计算能力不足的情况下，的确能能够大大的加快速度。</p>
<p>此外，衡量一个压缩算法的话，压缩率并不是唯一的指标。我们还应该考虑时空复杂度、稳定性和移植性等等。</p>
<h3 id="literal和length码表">literal和length码表</h3>
<p>Phil Katz把length的范围做了限制为256，因为一个重复的字符串达到256概率很小，即使超过256，就增加一个distace + length把。这样做可能也和当时硬件条件有关。</p>
<p>Phil Katz这次将literal和length合为一张表（就是一起huffman编码）。literal为0-255，256为结束标志，而257开始的为length。length同distance一样，也进行区间的划分，29个区间如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-1.png" /></p>
<p>合为一张表的好处就是，解码的时候，先按照这个表来解码，如果是0-255，就表示literal，如果是256，则表示结束，如果是257-285，就是length（也说明后面的是distance）。这样一张表就可以区分出literal或者是length，这样就可以不用加一个标志来区区分。</p>
<h3 id="再次压缩">再次压缩</h3>
<p>上面有两次的huffman编码，literal/length码表1以及distace码表2。前面提到过为了能够解码，码表用一个码字长度序列表示，称为CL（Code Length），而记录两个码表的码字长度序列分别记为CL1、CL2。对literal/length的编码比特流称为LIT比特流；对distance的编码比特流称为DIST比特流。按照上面的方法，LZ的编码结果就变成三块：CL1、CL2、LIT比特流或DIST比特流。</p>
<p>由于CL全部都是数字，Phil Katz决定对CL继续编码。这里采用了<strong>游程编码</strong>。<strong>游程的含义为一段连续相同的数</strong>，而<strong>游程编码就是一段连续相同的数，只记录这个数一次，然后记录出现多少个即可</strong>。此外，Phil Katz认为，huffman编码后的码字长度不会超过15（PS: literal/length的编码符号286个，distance的编码符号共30个）。因此Phil Katz 用16、17、18三个额外的数字来表示重复数字（游程）：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">数字</th>
<th style="text-align: left;">bits</th>
<th style="text-align: left;">表示的游程</th>
<th style="text-align: left;">表示重复的长度</th>
<th style="text-align: left;">例如</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">16</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">除了0外的</td>
<td style="text-align: left;">3-6</td>
<td style="text-align: left;">11表示重复2+3=5次（游程长从3开始）</td>
</tr>
<tr class="even">
<td style="text-align: left;">17</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">3-10</td>
<td style="text-align: left;">111表示后面有连续的3+7=10个0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">18</td>
<td style="text-align: left;">7</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">11-138</td>
<td style="text-align: left;">0111110表示连续11+62=73个0</td>
</tr>
</tbody>
</table>
<p>比如CL序列如下，</p>
<ul>
<li><p>4, 4, 4, 4, 4, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2</p></li>
<li><p>游程编码的结果为：</p>
<ul>
<li>4, 16, 01（二进制）, 3, 3, 3, 6, 16, 11（二进制）, 16, 00（二进制）, 17,011（二进制）, 2, 16, 00（二进制）</li>
<li>也就是4, 16, 1, 3, 3, 3, 6, 16, 3, 16, 0, 17, 3, 2, 16, 0</li>
</ul></li>
<li><p>注意实际中上面标注的二进制应该反过来书写（小端序），比如01其实应该写成10</p></li>
</ul>
<p>将CL进行游程编码后，我们又得到了一串0-18的整数，这个整数序列称为SQ（sequence），因为有CL1和CL2，所以我们有SQ1和SQ2。可以容易的统计出SQ中各个整数的出现次数，然后将SQ1和SQ2进行huffman编码，同理，这个码表3也用一个码字长度序列记录，称为CCL，由于最多有18个，Phil Katz认为树的深度至多为7，因此用3bit来记录。</p>
<p>得到CCL后，Phil Katz又继续折腾了一下，进行了置换，其示意图如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/CCL-position-swap.png" /></p>
<p>上面的表示置换前的，下面的表示置换后的，可以看出，16、17、18对应的CCL被放到了前面，这样如果尾部出现一些0，就可以忽略掉（因为我们记录了CCL的长度，补充0即可）</p>
<h3 id="deflate压缩数据格式">Deflate压缩数据格式</h3>
<p>ZIP的格式实际上就是Deflate压缩码流外面套了一层文件相关的信息。Deflate压缩码格式如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/deflate-data-format.png" /></p>
<p> </p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 7%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: left;">长度</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Header</td>
<td style="text-align: left;">3bit</td>
<td style="text-align: left;">第1个比特如果是1，表示此部分为最后一个压缩数据块；否则表示这是.ZIP文件的某个中间压缩数据块，但后面还有其他数据块。这是ZIP中使用分块压缩的标志之一； 第2、3比特表示3个选择：压缩数据中没有使用Huffman、使用静态Huffman、使用动态Huffman</td>
</tr>
<tr class="even">
<td style="text-align: left;">HLIT</td>
<td style="text-align: left;">5bit</td>
<td style="text-align: left;">记录literal/length码字长度序列（CL1）的个数,CL1个数为HLIT + 257（0-255个literal加上一个256结束的，length长度为变化的）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">HDIST</td>
<td style="text-align: left;">5bit</td>
<td style="text-align: left;">记录distance码字长度序列（CL2）的个数，CL2个数为HDIST+1</td>
</tr>
<tr class="even">
<td style="text-align: left;">HCLEN</td>
<td style="text-align: left;">4bit</td>
<td style="text-align: left;">记录码表3中码字长度序列（CCL）的个数，CCL个数为HCLEN+4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CCL</td>
<td style="text-align: left;">HCLEN+4</td>
<td style="text-align: left;">用来构造码表3</td>
</tr>
<tr class="even">
<td style="text-align: left;">huffman（SQ1）</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">CL1经过游程编码缩短后（SQ1），然后对其用huffman编码。解码的时候解码到HLIT +257个即可。用来构造literal/length码表(码表1)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">huffman（SQ2）</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">CL2经过游程编码缩短后（SQ2），然后对其用huffman编码。解码的时候解码到HDIST+1个即可。用来构造distance码表(码表2)</td>
</tr>
<tr class="even">
<td style="text-align: left;">LIT编码流或DIST编码流</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">对倒数第1、2内容块进行解码时，首先利用Huffman码表1进行解码，如果解码所得整数位于0-255之间，表示literal未匹配字符，用Huffman码表1解码；如果位于257-285之间，表示length匹配长度，之后需要利用Huffman码表2进行解码得到distance偏移距离；如果等于256，表示数据块解码结束。</td>
</tr>
</tbody>
</table>
<h2 id="小结">小结</h2>
<p>本来是想实现一下huffman编码，结果发现要解码的时候码表怎么保存这个问题，以及文件的格式应该怎么样的，自己想出了保存字符+频率重新构建，感觉并不是很好，于是想看看zip等压缩算法是怎么样做的，于是有了这篇blog。</p>
<p>由于我没有进行LZ77编码，所以只和Phil Katz对比 huffman的部分的主要区别。主要区别为：</p>
<ul>
<li>Phil Katz存码表的形式为CL，存的是各个字符的码字长度，而我是字符+存出现的次数。。。QAQ</li>
<li>Phil Katz 还用游标编码对CL进一步进行压缩。。。</li>
</ul>
<p> </p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/esingchan/p/3958962.html">ZIP压缩算法详细分析及解压实例解释</a></p>
<ul>
<li>本文后面zip算法基本都是参考该文章的内容</li>
</ul></li>
<li><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/7795435">gzip压缩算法</a></p></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>hrwhisper
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/" title="从Huffman编码谈文件压缩">https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        <div class="reward-container">
  <div>请我喝杯咖啡吧~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/donate/wechat_pay.png" alt="hrwhisper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/donate/alipay.jpg" alt="hrwhisper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/introduction-to-https/" rel="prev" title="HTTPS的二三事">
      <i class="fa fa-chevron-left"></i> HTTPS的二三事
    </a></div>
      <div class="post-nav-item">
    <a href="/leetcode-contest-24-solution/" rel="next" title="leetcode contest 24 solution">
      leetcode contest 24 solution <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#huffman%E7%BC%96%E7%A0%81"><span class="nav-text">Huffman编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E8%BF%87%E7%A8%8B"><span class="nav-text">压缩过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section"><span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#huffman-code%E5%B0%8F%E7%BB%93"><span class="nav-text">huffman code小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9"><span class="nav-text">文件压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lz77-%E7%AE%97%E6%B3%95"><span class="nav-text">LZ77 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86"><span class="nav-text">压缩原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">解压缩的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zip%E7%AE%97%E6%B3%95"><span class="nav-text">ZIP算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zip-gzip-zlib-%E5%85%B3%E7%B3%BB"><span class="nav-text">zip gzip zlib 关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-text">zip算法流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zip%E4%B8%AD%E7%9A%84lz77"><span class="nav-text">ZIP中的LZ77</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#distance-%E7%A0%81%E8%A1%A8"><span class="nav-text">distance 码表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#literal%E5%92%8Clength%E7%A0%81%E8%A1%A8"><span class="nav-text">literal和length码表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%AC%A1%E5%8E%8B%E7%BC%A9"><span class="nav-text">再次压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deflate%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-text">Deflate压缩数据格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hrwhisper"
      src="/images/site/avatar.jpg">
  <p class="site-author-name" itemprop="name">hrwhisper</p>
  <div class="site-description" itemprop="description">一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hrwhisper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hrwhisper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/murmured" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;murmured" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      <script data-ad-client="ca-pub-1580254183546533" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hrwhisper</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz","app_key":"b26lBsbwmVyxTSnNrsBrnv3U","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      // script.setAttribute("data-pjax", "");
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz',
      appKey     : 'b26lBsbwmVyxTSnNrsBrnv3U',
      placeholder: "在上方填上邮箱地址可以收到我回复的邮件哦~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
