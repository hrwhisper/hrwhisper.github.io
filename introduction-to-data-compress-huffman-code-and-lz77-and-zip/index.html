<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="c,c++,java,python,leetcode,algorithm,reading,life,moods,machine-learning,data-mining,deep-learning,AI" />
   
  <meta name="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    从Huffman编码谈文件压缩 |  一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-introduction-to-data-compress-huffman-code-and-lz77-and-zip"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  从Huffman编码谈文件压缩
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/introduction-to-data-compress-huffman-code-and-lz77-and-zip/" class="article-date">
  <time datetime="2017-02-26T10:12:02.000Z" itemprop="datePublished">2017-02-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/study/">study</a> / <a class="article-category-link" href="/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a> / <a class="article-category-link" href="/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">19 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容</p>
<ul>
<li>
<p>Huffman编码</p>
<ul>
<li>Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等）</li>
</ul>
</li>
<li>
<p>LZ77算法</p>
</li>
<li>
<p>ZIP（deflate）算法</p>
</li>
</ul>
<a id="more"></a>
<h2 id="huffman编码">Huffman编码</h2>
<h3 id="压缩过程">压缩过程</h3>
<p>每次将频率最小的两个元素进行合并，自底向上的建树。可以用优先队列来实现。建完树后，我们可以把各个结点与左儿子的边编号为0 ，和右儿子的边编号为1， 将根节点到叶子结点上路径的编号连接起来，就是对应的Huffman编码。</p>
<p>WIKI百科上有一张很好的动态图：</p>
<h3 id="none"><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/Huffman_huff_demo.gif" alt=""></h3>
<p>解压</p>
<p>这样就完成了一棵前缀树Trie，前缀的性质也保证了一个码不会是另一个码的前缀，因此Huffman编码能被正确的解压。解压的时候只需要对于当前的bit，若为0，那么走左边，否则走右边。走到叶子结点说明该字符解码完毕，回到根节点，继续解码下一个。</p>
<h3 id="代码实现">代码实现</h3>
<p>首先定义树的结点的内容，并定义了__lt__方法，便于使用堆(python中的heapq)能进行比较元素的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode(object):</span><br><span class="line">    def __init__(self, val, cnt, left&#x3D;None, right&#x3D;None):</span><br><span class="line">        self.cnt &#x3D; cnt</span><br><span class="line">        self.val &#x3D; val</span><br><span class="line">        self.left &#x3D; left</span><br><span class="line">        self.right &#x3D; right</span><br><span class="line"></span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return self.cnt &lt; other.cnt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来定义Huffman树，该类支持如下特性</p>
<ul>
<li>
<p>从一个TreeNode的数组（list of TreeNode）中创建huffman树</p>
<ul>
<li>除了一开始用来建树外，在之后从文件中频率信息恢复huffman树也会用到</li>
</ul>
</li>
<li>
<p>从huffman树中获取叶子结点对应的编码</p>
<ul>
<li>就是直接进行树的遍历即可</li>
</ul>
</li>
<li>
<p>支持查找操作，给定一个字节(‘1’ or ‘0’)进行树根节点的移动</p>
<ul>
<li>文件读取中一个字节一个字节读入时，可以用这个方便查找</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class HuffmanTree(object):</span><br><span class="line">    def __init__(self, q):</span><br><span class="line">        self._root &#x3D; self.root &#x3D; self._create_tree(q)  # q is a list of TreeNode</span><br><span class="line">        self.huffman_code &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def _create_tree(q):</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        while len(q) &gt; 1:</span><br><span class="line">            a, b &#x3D; heapq.heappop(q), heapq.heappop(q)</span><br><span class="line">            heapq.heappush(q, TreeNode(&#39;&#39;, a.cnt + b.cnt, a, b))</span><br><span class="line">        return q.pop()</span><br><span class="line"></span><br><span class="line">    def get_huffman_code(self):</span><br><span class="line">        self._get_huffman_code(self.root)</span><br><span class="line">        return self.huffman_code</span><br><span class="line"></span><br><span class="line">    def _get_huffman_code(self, root, cur&#x3D;&#39;&#39;):</span><br><span class="line">        if not root.left and not root.right:  # the leaf node</span><br><span class="line">            self.huffman_code[root.val] &#x3D; cur</span><br><span class="line">            return</span><br><span class="line">        if root.left:  self._get_huffman_code(root.left, cur + &#39;0&#39;)</span><br><span class="line">        if root.right: self._get_huffman_code(root.right, cur + &#39;1&#39;)</span><br><span class="line"></span><br><span class="line">    def find(self, c):</span><br><span class="line">        self.root &#x3D; self.root.right if c &#x3D;&#x3D; &#39;1&#39; else self.root.left</span><br><span class="line">        if not self.root.left and not self.root.right:</span><br><span class="line">            res &#x3D; self.root.val</span><br><span class="line">            self.root &#x3D; self._root</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后时huffman编码的编码和解码过程。</p>
<p>编码过程</p>
<ul>
<li>
<p>为了能够进行解码，要将<strong>最后一个字节的实际位数</strong>以及“字典”存入文件中</p>
<ul>
<li>首先存入last_byte</li>
<li>紧接着存入字典的长度</li>
<li>接着对于每一个字符，存入该字符，然后是该字符出现频率v的二进制长度，接着是该频率v（转为二进制，按byte存）</li>
</ul>
</li>
<li>
<p>字典存储完毕后，才是进行huffman encode的文件内容</p>
</li>
</ul>
<p>解码过程</p>
<ul>
<li>读入last_byte和字典的长度</li>
<li>根据字典的存储格式为：  字符-频率的二进制长度-频率v 进行读取，然后重新构造huffman数</li>
<li>对文件内容进行decode，用到上面的HuffmanTree.find方法</li>
<li>需要对最后一个字节特殊处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Huffman(object):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def encode(filename, dist&#x3D;None):</span><br><span class="line">        if not dist:   dist &#x3D; filename + &#39;_compressed&#39;</span><br><span class="line">        with open(filename) as fr, open(dist, &#39;wb&#39;) as f:</span><br><span class="line">            txt &#x3D; fr.read()</span><br><span class="line">            q &#x3D; [TreeNode(c, cnt) for c, cnt in collections.Counter(txt).items()]</span><br><span class="line">            huffman_code &#x3D; HuffmanTree(q[:]).get_huffman_code()</span><br><span class="line">            txt &#x3D; &#39;&#39;.join([huffman_code[c] for c in txt])</span><br><span class="line">            f.write(bytes(chr(len(txt) &amp; 7), &quot;utf-8&quot;))  # last_byte and dic_len to file</span><br><span class="line">            f.write(bytes(chr(sum([2 + ceil(len(bin(x.cnt)[2:]) &#x2F; 8) for x in q])), &quot;utf-8&quot;))  # TODO 一样长的</span><br><span class="line">            for x in q:</span><br><span class="line">                c, v &#x3D; x.val, bin(x.cnt)[2:]</span><br><span class="line">                f.write(bytes(c, &quot;utf-8&quot;))  # current character</span><br><span class="line">                f.write(bytes(chr(len(v)), &quot;utf-8&quot;))  # current code length</span><br><span class="line">                f.write(bytes(&#39;&#39;.join(chr(int(v[i:i + 8], 2)) for i in range(0, len(v), 8)), &quot;utf-8&quot;))  # cnt</span><br><span class="line"></span><br><span class="line">            f.write(bytes(&#39;&#39;.join(chr(int(txt[i:i + 8], 2)) for i in range(0, len(txt), 8)), &quot;utf-8&quot;))  #</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def decode(filename, dist&#x3D;None):</span><br><span class="line">        if not dist:  dist &#x3D; filename + &#39;_decode&#39;</span><br><span class="line">        with open(filename, &#39;rb&#39;) as f:</span><br><span class="line">            txt &#x3D; f.read().decode(&#39;utf-8&#39;)</span><br><span class="line">        last_byte, dic_len &#x3D; ord(txt[0]), ord(txt[1])</span><br><span class="line">        i, huffman_code &#x3D; 2, &#123;&#125;</span><br><span class="line">        q &#x3D; []</span><br><span class="line">        while i &lt; dic_len + 2:</span><br><span class="line">            cur, cur_len &#x3D; txt[i], ord(txt[i + 1])</span><br><span class="line">            bytes_num &#x3D; ceil(cur_len &#x2F; 8)</span><br><span class="line">            code &#x3D; &#39;&#39;.join([bin(ord(c))[2:].zfill(8) for c in txt[i + 2:i + 2 + bytes_num]])</span><br><span class="line">            if cur_len &amp; 7: code &#x3D; code[:-8] + code[-(cur_len &amp; 7):]</span><br><span class="line">            q.append(TreeNode(cur, int(code, 2)))</span><br><span class="line">            i +&#x3D; bytes_num + 2</span><br><span class="line"></span><br><span class="line">        txt &#x3D; &#39;&#39;.join([bin(ord(c))[2:].zfill(8) for c in txt[2 + dic_len:]])</span><br><span class="line">        if last_byte: txt &#x3D; txt[:-8] + txt[-last_byte:]</span><br><span class="line"></span><br><span class="line">        tree &#x3D; HuffmanTree(q)</span><br><span class="line">        with open(dist, &#39;w&#39;) as f:</span><br><span class="line">            for i in range(len(txt)):</span><br><span class="line">                c &#x3D; tree.find(txt[i])</span><br><span class="line">                if c: f.write(c)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后是文件调用的demo,并最后判断压缩前的文件和压缩后解压的文件是否一致，并算出压缩率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    file_paths &#x3D; [&#39;.&#x2F;Aesop_Fables.txt&#39;, &#39;.&#x2F;graph.txt&#39;]</span><br><span class="line">    for cur_file in file_paths:</span><br><span class="line">        h &#x3D; Huffman()</span><br><span class="line">        h.encode(cur_file)</span><br><span class="line">        h.decode(cur_file + &#39;_compressed&#39;)</span><br><span class="line"></span><br><span class="line">        with open(cur_file) as f, \</span><br><span class="line">                open(cur_file + &#39;_compressed_decode&#39;) as fd, open(cur_file + &#39;_compressed&#39;, &#39;rb&#39;) as fp:</span><br><span class="line">            print(&#39;&#123;&#125;: compression ratio: &#123;:.4f&#125;, decode file equals original file is &#123;&#125;&#39;.format(</span><br><span class="line">                f.name, os.path.getsize(cur_file + &#39;_compressed&#39;) &#x2F; os.path.getsize(cur_file), f.read() &#x3D;&#x3D; fd.read()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="huffman-code小结">huffman code小结</h3>
<p>上面的代码实现了huffman文件压缩的编码和解码过程，但是仍有缺陷，比如字符只有1byte并不支持中文和unicode等，此外，这样将字典写入文件的方式是高效的么？主流的压缩如zip是怎么做的？</p>
<h2 id="文件压缩">文件压缩</h2>
<p>我们可以看到上文中huffman编码能用来进行文件的压缩。</p>
<p>可以说文件压缩可以分为无损压缩和有损压缩。</p>
<p>有损压缩常见于视频、音频等数据，有损压缩意味着一些信息的损失，压缩后无法还原。如JPEG/MP3等</p>
<p>无损压缩则常用于文件压缩等必须还原的场合，所有的信息都得到保留，典型的有ZIP/PNG等。</p>
<p>下面将简单介绍LZ77算法，然后介绍ZIP算法。</p>
<h2 id="lz77-算法">LZ77 算法</h2>
<p>Jacob Ziv和Abraham Lempel 两名以色列人在1977年提出，所以该算法称为LZ77。（1978年他们又改进了一下，称为LZ78）</p>
<h3 id="压缩原理">压缩原理</h3>
<p>Huffman编码是将出现次数多的编码尽可能的短来进行压缩，而LZ77则是另外一种思路：替换重复的内容。</p>
<p>在一个文件中，如果有内容是相同的话，就可以在后一块内容中做一个标记，标示和前一块的距离和相同的长度（distance,length）。（distance,length）绝大多数情况下小于重复的内容，因此文件的体积就变小了。</p>
<h3 id="滑动窗口">滑动窗口</h3>
<p>那么，如何寻找重复的串呢？LZ77算法采用的是的滑动窗口的方法，就是只在一个大小固定的滑动窗口内的进行重复查找。</p>
<p>当前处理的字节开始，和滑动窗口中的每个串进行匹配，目标是找到最大的匹配。</p>
<ul>
<li>如果当前处理的字节开始的串有匹配，就输出一个标志，表明下面的是（distance,length）信息，然后输出（distance,length）</li>
<li>若没有匹配，则该字符称为未匹配的字符（literal），输出该字节，然后处理下一个字节。</li>
</ul>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/lz77-distance-and-length.png" alt=""></p>
<p>此外，有几点需要注意：</p>
<ul>
<li>当匹配的长度length大于最小匹配长度才认为是一个匹配。因为有的太短，记录（distance,length）对反而增大了文件。</li>
<li>固定了窗口大小也就固定了distance和length所需要的位数</li>
<li>标准LZ77在找到重复字符串时输出三元组(length, distance, 下一个未匹配的字符)，但是ZIP中的只输出（distance,length）</li>
</ul>
<h3 id="解压缩的方法">解压缩的方法</h3>
<p>每次先读一个标记为，查看是（distance,length）对还是literal。</p>
<ul>
<li>若（distance,length），则读出相应的串并输出到当前位置</li>
<li>literal：读出并输出该字节</li>
</ul>
<p>对比压缩和解压可以发现压缩时需要进行大量的匹配，而解压时工作则少了很多。这和我们日常使用中的压缩慢解压快是一样的。</p>
<h2 id="zip算法">ZIP算法</h2>
<h3 id="zip-gzip-zlib-关系">zip gzip zlib 关系</h3>
<p>下面的内容引用自 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/20762094/how-are-zlib-gzip-and-zip-related-what-do-they-have-in-common-and-how-are-they">How are zlib, gzip and zip related?</a></p>
<blockquote>
<p>.zip is an archive format using, usually, the Deflate compression method. The .gz gzip format is for single files, also using the Deflate compression method. Often gzip is used in combination with tar to make a compressed archive format, .tar.gz. The zlib library provides Deflate compression and decompression code for use by zip, gzip, png (which uses the zlib wrapper on deflate data), and many other applications.</p>
</blockquote>
<p>可以看到，Gzip和zip都 了Deflate算法，下面将介绍这个算法。</p>
<h3 id="zip算法流程">zip算法流程</h3>
<p>ZIP中，首先使用LZ77编码进行压缩，然后之后再对LZ77编码之后的结果继续进行压缩（Huffman编码）,这个算法也叫做Deflate算法。</p>
<p>其实这个算法也支持静态的Huffman编码，无需记录码表，但是压缩率不高，所以大多数都采用动态的Huffman编码。</p>
<p>采用动态的Huffman编码其流程如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/zip-procedure.png" alt=""></p>
<h3 id="zip中的lz77">ZIP中的LZ77</h3>
<p>ZIP将LZ77的滑动窗口设置为32KB。虽然设置的窗口越大，越可能有重复的内容出现，但是相应的计算量也会变得很大，可能会得不偿失。</p>
<p>ZIP中只有3个字节以上的重复字符串，才会用（distance,length） 表示。</p>
<p>我们知道，经过LZ77算法之后，文件内容表示为literal、distance + length两种形式。Phil Katz继续对这两种形式进行huffman编码，可以说这过程其实才是ZIP算法的核心。</p>
<h3 id="distance-码表">distance 码表</h3>
<p>假如对一个文件进行LZ77压缩后，得到的distance值为：3、6、4、3、4、3、4、3、5，可以根据出现的次数画出哈夫曼树如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/two-huffman-tree-are-both-right.png" alt=""></p>
<p>上面的两个哈夫曼树（这里称为码树）都是合法的，但对应的编码不同。</p>
<p>比如第一个的6的编码为111，而第二棵码树的6的编码为011。</p>
<p>那么问题来了，实际中我们应该怎么选？有好多种情况？</p>
<p>我们知道huffman编码的本质是将出现频率高的编码尽可能的短。对于同一组数据，各种长得不同的huffman树得出的各个元素的长度是一样的，也就是说，<strong>我们只需要记录各个元素编码的长度就可以了</strong>。</p>
<p>比如上面的第一棵树，我们有：3–&gt;0；4–&gt;10；5–&gt;110；6–&gt;111。我们只需要记录：3-&gt;1 ; 4-&gt;2; 5-&gt;3; 6-&gt;3就可以了。</p>
<p>但是这样新的问题来了，在解压的时候，我们可以按照上面第一棵树那样构造huffman树，但是对于5和6来说，长度都是3，那么110表示的是5还是6？</p>
<p>一个简单的解法就是直接按照数字的大小来确定（<strong>升序</strong>），这样相同的长度下就不会混乱了。</p>
<p>但是还有问题，由于我们滑动窗口的大小为32KB，就是说我们的distance范围为1-32KB就是1-32768。 那么我们怎么知道上面的就是3、4、5、6而不是1、2、3、4或者1-32768任意的四个不重复的数字（升序排列）呢？</p>
<p>可以用一个序列来表示，没有出现的就是0，比如上面的3、4、5、6我们可以如下标记：</p>
<ul>
<li>0、0、1、2、3、3、0、0、0、。。。。。。。。。。。。</li>
</ul>
<p>考虑当时的硬件条件，如果压缩大文件的时候，distance达到上千是很正常的，计算机计算能力可能不足。Phil Katz将distance划分为多个区间，每个区间当作一个整数来看，这个称为distance code。<strong>我们对distance code进行huffman编码</strong>，然后再对该去区间的distance进行扩展即可。Phil Katz划分的区间如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-2.png" alt=""></p>
<ul>
<li>code为编号，就是distance code。之后就是用这个进行huffman编码的</li>
<li>bits为需要在code上扩展几位。最多扩展13位（PS：说明最多的区间有2^13 = 8192个数）</li>
<li>distance表示这个区间的distance的范围。</li>
</ul>
<p>虽然使用分区得到的编码不是最优的，但是在当时计算能力不足的情况下，的确能能够大大的加快速度。</p>
<p>此外，衡量一个压缩算法的话，压缩率并不是唯一的指标。我们还应该考虑时空复杂度、稳定性和移植性等等。</p>
<h3 id="literal和length码表">literal和length码表</h3>
<p>Phil Katz把length的范围做了限制为256，因为一个重复的字符串达到256概率很小，即使超过256，就增加一个distace + length把。这样做可能也和当时硬件条件有关。</p>
<p>Phil Katz这次将literal和length合为一张表（就是一起huffman编码）。literal为0-255，256为结束标志，而257开始的为length。length同distance一样，也进行区间的划分，29个区间如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/huffman-code-table-1.png" alt=""></p>
<p>合为一张表的好处就是，解码的时候，先按照这个表来解码，如果是0-255，就表示literal，如果是256，则表示结束，如果是257-285，就是length（也说明后面的是distance）。这样一张表就可以区分出literal或者是length，这样就可以不用加一个标志来区区分。</p>
<h3 id="再次压缩">再次压缩</h3>
<p>上面有两次的huffman编码，literal/length码表1以及distace码表2。前面提到过为了能够解码，码表用一个码字长度序列表示，称为CL（Code Length），而记录两个码表的码字长度序列分别记为CL1、CL2。对literal/length的编码比特流称为LIT比特流；对distance的编码比特流称为DIST比特流。按照上面的方法，LZ的编码结果就变成三块：CL1、CL2、LIT比特流或DIST比特流。</p>
<p>由于CL全部都是数字，Phil Katz决定对CL继续编码。这里采用了<strong>游程编码</strong>。<strong>游程的含义为一段连续相同的数</strong>，而<strong>游程编码就是一段连续相同的数，只记录这个数一次，然后记录出现多少个即可</strong>。此外，Phil Katz认为，huffman编码后的码字长度不会超过15（PS: literal/length的编码符号286个，distance的编码符号共30个）。因此Phil Katz 用16、17、18三个额外的数字来表示重复数字（游程）：</p>
<p>数字</p>
<p>bits</p>
<p>表示的游程</p>
<p>表示重复的长度</p>
<p>例如</p>
<p>16</p>
<p>2</p>
<p>除了0外的</p>
<p>3-6</p>
<p>11表示重复2+3=5次（游程长从3开始）</p>
<p>17</p>
<p>3</p>
<p>0</p>
<p>3-10</p>
<p>111表示后面有连续的3+7=10个0</p>
<p>18</p>
<p>7</p>
<p>0</p>
<p>11-138</p>
<p>0111110表示连续11+62=73个0</p>
<p>比如CL序列如下，</p>
<ul>
<li>
<p>4, 4, 4, 4, 4, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2</p>
</li>
<li>
<p>游程编码的结果为：</p>
<ul>
<li>4, 16, 01（二进制）, 3, 3, 3, 6, 16, 11（二进制）, 16, 00（二进制）, 17,011（二进制）, 2, 16, 00（二进制）</li>
<li>也就是4, 16, 1, 3, 3, 3, 6, 16, 3, 16, 0, 17, 3, 2, 16, 0</li>
</ul>
</li>
<li>
<p>注意实际中上面标注的二进制应该反过来书写（小端序），比如01其实应该写成10</p>
</li>
</ul>
<p>将CL进行游程编码后，我们又得到了一串0-18的整数，这个整数序列称为SQ（sequence），因为有CL1和CL2，所以我们有SQ1和SQ2。可以容易的统计出SQ中各个整数的出现次数，然后将SQ1和SQ2进行huffman编码，同理，这个码表3也用一个码字长度序列记录，称为CCL，由于最多有18个，Phil Katz认为树的深度至多为7，因此用3bit来记录。</p>
<p>得到CCL后，Phil Katz又继续折腾了一下，进行了置换，其示意图如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/CCL-position-swap.png" alt=""></p>
<p>上面的表示置换前的，下面的表示置换后的，可以看出，16、17、18对应的CCL被放到了前面，这样如果尾部出现一些0，就可以忽略掉（因为我们记录了CCL的长度，补充0即可）</p>
<h3 id="deflate压缩数据格式">Deflate压缩数据格式</h3>
<p>ZIP的格式实际上就是Deflate压缩码流外面套了一层文件相关的信息。Deflate压缩码格式如下：</p>
<p><img src="../images/introduction-to-data-compress-huffman-code-and-lz77-and-zip/deflate-data-format.png" alt=""></p>
<p>名称</p>
<p>长度</p>
<p>说明</p>
<p>Header</p>
<p>3bit</p>
<p>第1个比特如果是1，表示此部分为最后一个压缩数据块；否则表示这是.ZIP文件的某个中间压缩数据块，但后面还有其他数据块。这是ZIP中使用分块压缩的标志之一； 第2、3比特表示3个选择：压缩数据中没有使用Huffman、使用静态Huffman、使用动态Huffman</p>
<p>HLIT</p>
<p>5bit</p>
<p>记录literal/length码字长度序列（CL1）的个数,CL1个数为HLIT + 257（0-255个literal加上一个256结束的，length长度为变化的）</p>
<p>HDIST</p>
<p>5bit</p>
<p>记录distance码字长度序列（CL2）的个数，CL2个数为HDIST+1</p>
<p>HCLEN</p>
<p>4bit</p>
<p>记录码表3中码字长度序列（CCL）的个数，CCL个数为HCLEN+4</p>
<p>CCL</p>
<p>HCLEN+4</p>
<p>用来构造码表3</p>
<p>huffman（SQ1）</p>
<p>CL1经过游程编码缩短后（SQ1），然后对其用huffman编码。解码的时候解码到HLIT +257个即可。用来构造literal/length码表(码表1)</p>
<p>huffman（SQ2）</p>
<p>CL2经过游程编码缩短后（SQ2），然后对其用huffman编码。解码的时候解码到HDIST+1个即可。用来构造distance码表(码表2)</p>
<p>LIT编码流或DIST编码流</p>
<p>对倒数第1、2内容块进行解码时，首先利用Huffman码表1进行解码，如果解码所得整数位于0-255之间，表示literal未匹配字符，用Huffman码表1解码；如果位于257-285之间，表示length匹配长度，之后需要利用Huffman码表2进行解码得到distance偏移距离；如果等于256，表示数据块解码结束。</p>
<p></p>
<h2 id="小结">小结</h2>
<p>本来是想实现一下huffman编码，结果发现要解码的时候码表怎么保存这个问题，以及文件的格式应该怎么样的，自己想出了保存字符+频率重新构建，感觉并不是很好，于是想看看zip等压缩算法是怎么样做的，于是有了这篇blog。</p>
<p>由于我没有进行LZ77编码，所以只和Phil Katz对比 huffman的部分的主要区别。主要区别为：</p>
<ul>
<li>Phil Katz存码表的形式为CL，存的是各个字符的码字长度，而我是字符+存出现的次数。。。QAQ</li>
<li>Phil Katz 还用游标编码对CL进一步进行压缩。。。</li>
</ul>
<p></p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/esingchan/p/3958962.html">ZIP压缩算法详细分析及解压实例解释</a></p>
<ul>
<li>本文后面zip算法基本都是参考该文章的内容</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/7795435">gzip压缩算法</a></p>
</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/introduction-to-data-compress-huffman-code-and-lz77-and-zip/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/leetcode-contest-24-solution/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            leetcode contest 24 solution
          
        </div>
      </a>
    
    
      <a href="/introduction-to-https/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">HTTPS的二三事</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz",
    app_key: "b26lBsbwmVyxTSnNrsBrnv3U",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2013-2020
        <i class="ri-heart-fill heart_icon"></i> hrwhisper
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/site/logo.jpg" alt="细语呢喃"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog-building">博客建设</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend-link">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/leetcode-algorithm-solution">leetcode题解</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/messageboard">留言板</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about-me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/wechat_pay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3',
    hasInnerContainers: true,
    scrollSmooth: false,
	scrollSmoothDuration: 420,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
	collapseDepth: 2,
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>