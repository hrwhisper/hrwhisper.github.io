<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/site/avatar.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site/avatar.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site/avatar.jpg">
  <link rel="mask-icon" href="/images/site/avatar.jpg" color="#222">
  <meta name="google-site-verification" content="fMKqXfnCsLFKKj0NjoZZApB_BuqLVUiJxtRkj-rznU4">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hrwhisper.me","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文将详细的介绍单纯形算法，包括但不限于  LP问题 单纯形算法原理 无界、无解、循环等情况 python代码实现">
<meta property="og:type" content="article">
<meta property="og:title" content="线性规划-单纯形算法详解">
<meta property="og:url" content="https://www.hrwhisper.me/introduction-to-simplex-algorithm/index.html">
<meta property="og:site_name" content="细语呢喃">
<meta property="og:description" content="本文将详细的介绍单纯形算法，包括但不限于  LP问题 单纯形算法原理 无界、无解、循环等情况 python代码实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_introduction_to_linear_programming_formulation.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_feasible_region.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/for-example.jpg">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_unbounded_case.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_feasible_solution.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_no_feasible_solution.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/proof-for-auxiliary_lp.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_feasible_region.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/only_consider_vertex_proof_1.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/walk_though_vertex.png">
<meta property="og:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_feasible_solution.png">
<meta property="article:published_time" content="2016-11-24T09:10:10.000Z">
<meta property="article:modified_time" content="2020-10-31T13:15:47.561Z">
<meta property="article:author" content="hrwhisper">
<meta property="article:tag" content="python">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.hrwhisper.me/images/introduction-to-simplex-algorithm/example_for_introduction_to_linear_programming_formulation.png">

<link rel="canonical" href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>线性规划-单纯形算法详解 | 细语呢喃</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69270533-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-69270533-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d6a8cb42bd9ae728375b6726daa75e95";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">细语呢喃</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">技术改变生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="/leetcode-algorithm-solution/" rel="section"><i class="fa fa-archive fa-fw"></i>leetcode</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/friend-link/" rel="section"><i class="fa fa-link fa-fw"></i>friends</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about-me/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/site/avatar.jpg">
      <meta itemprop="name" content="hrwhisper">
      <meta itemprop="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="细语呢喃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线性规划-单纯形算法详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-24 17:10:10" itemprop="dateCreated datePublished" datetime="2016-11-24T17:10:10+08:00">2016-11-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/" itemprop="url" rel="index"><span itemprop="name">study</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法笔记</span></a>
                </span>
            </span>

          
            <span id="/introduction-to-simplex-algorithm/" class="post-meta-item leancloud_visitors" data-flag-title="线性规划-单纯形算法详解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/introduction-to-simplex-algorithm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/introduction-to-simplex-algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文将详细的介绍单纯形算法，包括但不限于</p>
<ul>
<li>LP问题</li>
<li>单纯形算法原理</li>
<li>无界、无解、循环等情况</li>
<li>python代码实现 <a id="more"></a></li>
</ul>
<h2 id="线性规划问题">线性规划问题</h2>
<p>首先引入如下的问题：</p>
假设食物的各种营养成分、价格如下表：
<div class="table-responsive">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Food</th>
<th style="text-align: center;">Energy（能量）</th>
<th style="text-align: center;">Protein（蛋白质）</th>
<th style="text-align: center;">Calcium（钙）</th>
<th style="text-align: center;">Price</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Oatmeal（燕麦）</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">Whole milk（全奶）</td>
<td style="text-align: center;">160</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">285</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Cherry pie（草莓派）</td>
<td style="text-align: center;">420</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;">20</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pork with beans（猪肉）</td>
<td style="text-align: center;">260</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">19</td>
</tr>
</tbody>
</table>
</div>
<p>要求我们买的食物中，至少要有2000的能量，55的蛋白质，800的钙，怎样买最省钱？</p>
<p>设买燕麦、全奶、草莓派、猪肉为<span class="math inline">\(x_1,x_2,x_3,x_4~\)</span></p>
<p>于是我们可以写出如下的不等式组</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_introduction_to_linear_programming_formulation.png" alt="example_for_introduction_to_linear_programming_formulation.png" /><figcaption>example_for_introduction_to_linear_programming_formulation.png</figcaption>
</figure>
<p>其实这些不等式组就是线性规划方程（Linear programming formulation）。</p>
<p>简单的说，线性规划就是在给定限制的情况下，求解目标。</p>
<h3 id="可行域">可行域</h3>
<p>来看一个算法导论中的例子，考虑如下的线性规划： <span class="math display">\[
\begin{alignat}{2}
\max\quad &amp;x_1 + x_2&amp;  \\
\mbox{s.t.}\quad
&amp;4x_1 - x_2 &amp;\leq&amp;{8}  \\ 
&amp;2x_1 + x_2 &amp; \leq&amp;{10}\\ 
&amp;5x_1 - 2x_2 &amp; \geq&amp;{-2}\\ 
&amp;x_1, \quad x_2 &amp;\geq&amp;{0} \\ 
\end{alignat}
\]</span> 我们可以画出下面的图：</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_feasible_region.png" alt="example_for_feasible_region" /><figcaption>example_for_feasible_region</figcaption>
</figure>
<p>看图a，灰色的区域就是这几个约束条件要求<span class="math inline">\(x_1,x_2\)</span>所在的区域，而我们最后的解<span class="math inline">\(x_1,x_2\)</span>也要在这里面。我们把这个区域称为可行域（feasible region）</p>
<p>图b可以直观的看出，最优解为8, 而 <span class="math inline">\(x_1=2,x_2=6\)</span></p>
<h3 id="线性规划标准形式">线性规划标准形式</h3>
<p>线性规划的标准形式如下：</p>
<p><span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;&amp;&amp;&amp;c^Tx&amp;  \\
\mbox{s.t.}\quad
&amp; &amp;A&amp;x &amp;\leq{b}\\ 
&amp; &amp;&amp;x &amp; \geq{0} &amp;\\ 
\end{alignat}
\]</span></p>
<p>就是</p>
<ul>
<li>求的是min（算法导论的是max，本文为min）</li>
<li>所有的约束为&lt;=的形式</li>
<li>所有的变量均 &gt;=0</li>
</ul>
<p>如何变为标准形式？</p>
<ul>
<li>原来是max, 直接*-1求min</li>
<li>若原来约束为=，转为 &gt;= 和&lt;=</li>
<li>约束原来为 &gt;= 同样的*-1，就改变了&lt;=</li>
<li>若有变量 <span class="math inline">\(x_i &lt; 0\)</span> ，那么用 <span class="math inline">\(x^{&#39;} - x^{&#39;&#39;}\)</span>来替代，其中 <span class="math inline">\(x^{&#39;}&gt;=0, x^{&#39;&#39;}&gt;=0\)</span></li>
</ul>
<h3 id="线性规划松弛形式">线性规划松弛形式</h3>
<p>松弛形式为:</p>
<p><span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;&amp;&amp;&amp;c^Tx&amp;  \\
\mbox{s.t.}\quad
&amp; &amp;A&amp;x &amp;={b}\\ 
&amp; &amp;&amp;x &amp; \geq{0} &amp;\\ 
\end{alignat}
\]</span></p>
<p>就是通过引入变量把原来的 &lt;= ，变为=的松弛形式.</p>
<p>如：</p>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;x_1 + x_2 &amp;\leq{2}  \\ 
&amp;x_1 + x_2 &amp; \geq{1}\\ 
&amp;x_1, \quad x_2 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span> 写为松弛形式就是： <span class="math display">\[
\begin{alignat}{2}
&amp;x_1 + x_2 + x_3&amp;={2}  \\ 
&amp;x_1 + x_2 + x_4&amp; ={1}\\ 
&amp;x_1,x_2,x_3,x_4 &amp;\ge{0} &amp;\\ 
\end{alignat}
\]</span></p>
<h3 id="vs">&lt;= vs &lt;</h3>
<p>有砸场子的同学会问(╯‵□′)╯︵┻━┻，为什么我们的线性规划的形式都是可以 &lt;= 或者 &gt;=的形式的？把等号去掉可以么？</p>
<p>就是不可以(￣ε(#￣)</p>
<p>举个例子</p>
<p><span class="math display">\[
\begin{alignat}{2}
\max\quad &amp;x&amp;  \\
\mbox{s.t.}\quad
&amp; x \leq{1}&amp;\\ 
\end{alignat}
\]</span></p>
<p><span class="math display">\[
\begin{alignat}{2}
\max\quad &amp;x&amp;  \\
\mbox{s.t.}\quad
&amp; x \lt{1}&amp;\\ 
\end{alignat}
\]</span></p>
<p>显然第二个是无解的。</p>
<h2 id="单纯形算法的思想与例子">单纯形算法的思想与例子</h2>
<p>如何求解线性规划问题呢？</p>
<p>有一些工具如GLPK，Gurobi 等，不在本文的介绍范围内。</p>
<p>本文要介绍的是单纯形算法，它是求解线性规划的经典方法，虽然它的执行时间在最坏的情况下是非多项式的（指数时间复杂度），但是，在绝大部分情况下或者说实际运行过程中却是多项式时间。</p>
<p>它主要就三个步骤</p>
<ol type="1">
<li>找到一个初始的基本可行解</li>
<li>不断的进行旋转（pivot）操作</li>
<li>重复2直到结果不能改进为止</li>
</ol>
<p>以下面的线性规划为例:</p>
<p><span class="math display">\[
\begin{array}{rrrrrr}
 \min &amp; -x_1 &amp;-&amp;14x_2 &amp;-&amp;6x_3\\
 s.t. &amp;x_1&amp; +&amp;x_2&amp; +&amp;x_3 &amp;\le &amp;\quad4\\ 
 &amp;x_1&amp; &amp;&amp; &amp; &amp;\le &amp;\quad2\\ 
 &amp;&amp; &amp;&amp; &amp; x_3&amp;\le &amp;\quad3\\ 
 &amp;&amp; &amp;3x_2&amp; +&amp;x3 &amp;\le &amp;\quad6\\ 
 &amp;x_1&amp; ,&amp;x_2&amp;,&amp;x3 &amp;\ge &amp;\quad0\\ 
\end{array}
\]</span></p>
<p>将其写为松弛的形式：</p>
<p><span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;-x_1 -14x_2 - 6x_3&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2 +x_3 + x_4   \quad \quad \quad \quad \quad \quad \quad &amp;=&amp;  \quad4&amp;\\ 
&amp;x_1  \quad \quad \quad \quad \quad \quad \quad+x_5 \quad \quad\quad \quad\quad&amp;=&amp;\quad2&amp;\\ 
&amp; \quad\quad \quad \quad\quad  x_3 + \quad \quad \quad \quad + x_6&amp;=&amp;\quad3&amp;\\
&amp; \quad \quad 3x_2 +  x_3\quad\quad \quad \quad\quad \quad \quad +x_7&amp;=&amp;\quad6&amp;\\
&amp;x_1, \quad x_2 ,\quad x_3, \quad x_4, \quad x_5 ,\quad x_6, \quad x_7\quad &amp;\quad\geq{0} &amp;\\ 
\end{alignat}
\]</span></p>
<p>其实，就是等价于（仍然要求 <span class="math inline">\(x_1,x_2,x_3,x_4,x_5,x_6,x_7 \ge0\)</span>）：</p>
<p><span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-x_1  -14x_2 - 6x_3&amp;  \\
&amp; x_4 = \quad4-x_1 - x_2 -x_3 &amp;\\ 
&amp;x_5 =\quad2 - x_1&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_7=\quad6  - 3x_2 - x_3&amp;\\ 
\end{alignat}
\]</span></p>
<p>在上述的等式的左边称为<strong>基本变量</strong>，而右边称为<strong>非基本变量</strong>。</p>
<p>现在来考虑<strong>基本解</strong>就是把等式右边的所有非基本变量设为0，然后计算左边基本变量的值。</p>
<p>这里，容易得到基本解为： <span class="math inline">\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (0,0,0,4,2,3,6)\)</span>，而目标值z = 0，其实就是把基本变量<span class="math inline">\(x_i\)</span>设置为<span class="math inline">\(b_i\)</span>。</p>
<p>一般而言，基本解是可行的，我们称其为<strong>基本可行解</strong>。初始的基本解不可行的情况见后面的讨论，这里假设初始的基本解就是基本可行解，因此三个步骤中第一步完成了。</p>
<p>现在开始，来讨论上面的第二个步骤，就是旋转的操作。</p>
<p>我们每次选择一个在目标函数中的系数为负的非基本变量<span class="math inline">\(x_e\)</span>，然后尽可能的增加<span class="math inline">\(x_e\)</span>而不违反约束，并将<span class="math inline">\(x_e\)</span>用基本变量<span class="math inline">\(x_l\)</span>表示， 然后把<span class="math inline">\(x_e\)</span>变为基本变量，<span class="math inline">\(x_l\)</span>变为非基本变量。</p>
<p>这里，假设我们选择增加<span class="math inline">\(x_1\)</span>，那么在上述的等式（不包括目标函数z那行）中，第1个等式限制了<span class="math inline">\(x_1 \le 4\)</span>(因为<span class="math inline">\(x_4 \ge 0\)</span>)，第2个等式有最严格的限制，它限制了<span class="math inline">\(x_1 \le 2\)</span>，因此我们最多只能将<span class="math inline">\(x_1\)</span>增加到2，根据上面的第二个等式，我们有：<span class="math inline">\(x_1 = 2- x_5\)</span>，带入上面的等式就实现了<span class="math inline">\(x_e\)</span>和<span class="math inline">\(x_l\)</span>的替换： <span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-2  -14x_2 - 6x_3 + x_5&amp;  \\
&amp; x_4 = \quad2 - x_2 -x_3 +x_5&amp;\\ 
&amp;x_1 =\quad2 - x_5&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_7=\quad6  - 3x_2 - x_3&amp;\\ 
\end{alignat}
\]</span> 这样其实就是一个<strong>转动(pivot)</strong>的过程，一次转动选取一个非基本变量（也叫<strong>替入变量</strong>）<span class="math inline">\(x_e\)</span>和一个基本变量（也叫<strong>替出变量</strong>) <span class="math inline">\(x_l\)</span> ，然后替换二者的角色。执行一次转动的过程与之前所描述的线性规划是等价的。</p>
<p>同样的，将非基本变量设为0，于是得到：<span class="math inline">\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,0,0,2,0,3,6)\)</span>， Z = -2，说明我们的目标减少到了-2</p>
<p>接下来是单纯形算法的第三步，就是不断的进行转动，直到无法进行改进为止，继续看看刚才的例子：</p>
<p>我们接着再执行一次转动，这次我们可以选择增大<span class="math inline">\(x_2\)</span>或者<span class="math inline">\(x_3\)</span>，而不能选择<span class="math inline">\(x_5\)</span>，因为增大<span class="math inline">\(x_5\)</span>之后，z也增大，而我们要求的是最小化z。假设选择了<span class="math inline">\(x_2\)</span>，那么第1个等式限制了<span class="math inline">\(x_2 &lt;=2\)</span> , 第4个等式限制了<span class="math inline">\(x_2&lt;= 2\)</span>，假设我们选择<span class="math inline">\(x_4\)</span>替出变量，于是有： <span class="math inline">\(x_2 = 2-x_3-x_4+x_5\)</span> ，带入得： <span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-30   + 8x_3 + 14x_4 -13x_5&amp;  \\
&amp; x_2 = \quad2  -x_3 -x_4 +x_5&amp;\\ 
&amp;x_1 =\quad2 - x_5&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_7=\quad2x_3 + 3x_4 - 3x_5&amp;\\ 
\end{alignat}
\]</span> 此时，我们的基本解变为<span class="math inline">\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,2,0,0,0,3,0)\)</span>， Z = -30</p>
<p>我们可以继续的选择增大<span class="math inline">\(x_5\)</span>，第4个等式具有最严格的限制（<span class="math inline">\(0 - 3x_5 &gt;=0\)</span>），我们有<span class="math inline">\(x_5=\frac{2}{3}x_3 + x_4 - \frac{1}{3}x_7\)</span></p>
<p>带入得：</p>
<p><span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-30   - \frac{2}{3}x_3 + x_4 +\frac{13}{3}x_7&amp;  \\
&amp; x_2 = \quad2  - \frac{1}{3}x_3 -\frac{1}{3}x_7&amp;\\ 
&amp;x_1 =\quad2 - \frac{2}{3}x_3 - x_4 + \frac{1}{3}x_7&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_5=\quad\frac{2}{3}x_3 + x_4 -  \frac{1}{3}x_7&amp;\\ 
\end{alignat}
\]</span></p>
<p>此时，我们的基本解变为<span class="math inline">\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,2,0,0,0,3,0)\)</span>， Z = -30，这时候并没有增加，但是下一步，我们可以选择增加 <span class="math inline">\(x_3\)</span>。第2个和第3个有最严格的限制，我们选第2个的话，得：<span class="math inline">\(x_3=3 - \frac{3}{2}x_1 - \frac{3}{2}x_4 + \frac{1}{2}x_7\)</span>，然后老样子，继续带入：</p>
<p><span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-32 + x_1 + 2x_4 + 4x_7&amp;  \\
&amp; x_2 = \quad1  + \frac{1}{2}x_1 +\frac{1}{2}x_4  - \frac{1}{2}x_7&amp;\\ 
&amp;x_3= \quad3 - \frac{3}{2}x_1 - \frac{3}{2}x_4 + \frac{1}{2}x_7&amp;\\ 
&amp;x_6=\quad \frac{3}{2}x_1 + \frac{3}{2}x_4 -  \frac{1}{2}x_7&amp;\\
&amp; x_5=\quad 2 - x_1&amp;\\ 
\end{alignat}
\]</span></p>
<p>现在，已经没有可以继续增大的值了，停止转动，z=-32就是我们的解，而此时，基本解为：<span class="math inline">\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (0,1,3,0,2,0,0)\)</span>，看看最开始的目标函数：<span class="math inline">\(z = -x_1 - 14x_2 - 6x_3\)</span>,我们将<span class="math inline">\(x_2=1,x_3=3\)</span>带入得，z=-32，说明我们经过一系列的旋转，最后得到了目标值。</p>
<h2 id="退化degeneracy">退化(Degeneracy)</h2>
<p>在旋转的过程中，可能会存在保持目标值不变的情况，这种现象称为退化。比如上面的例子中，两次等于-30.</p>
<p>可以说退化可能会导致<strong>循环(cycling)</strong>的情况，这是使得单纯形算法不会终止的唯一原因。还好上面的例子中，我们没有产生循环的情况，再次旋转，目标值继续降低。</p>
<p>《算法导论》是这样介绍退化产生循环的：</p>
<blockquote>
<p>Degeneracy can prevent the simplex algorithm from terminating, because it can lead to a phenomenon known as cycling: the slack forms at two different iterations of SIMPLEX are identical. Because of degeneracy, SIMPLEX could choose a sequence of pivot operations that leave the objective value unchanged but repeat a slack form within the sequence. Since SIMPLEX is a deterministic algorithm, if it cycles, then it will cycle through the same series of slack forms forever, never terminating.</p>
</blockquote>
<p>如何避免退化？一个方法就是使用<strong>Bland规则</strong>：</p>
<p>在选择替入变量和替出变量的时候，我们总是选择满足条件的<strong>下标最小值</strong>。</p>
<ul>
<li>替入变量<span class="math inline">\(x_e\)</span>：目标条件中，系数为负数的第一个作为替入变量</li>
<li>替出变量<span class="math inline">\(x_l\)</span>：对所有的约束条件中，选择对<span class="math inline">\(x_e\)</span>约束最紧的第一个</li>
</ul>
<p>在上面的例子中，我也是这么做的。^ ^</p>
<p>另一个方法是加入随机扰动。</p>
<h2 id="无界unbounded的情况">无界(unbounded)的情况</h2>
<p>有的线性规划问题是无界的，举个栗子</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/for-example.jpg" alt="for example" /><figcaption>for example</figcaption>
</figure>
<p>对于下面的线性规划 <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;-x_1 - x_2&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 - x_2 &amp;\leq{1}  \\ 
-&amp;x_1 + x_2 &amp; \leq{1}\\ 
&amp;x_1, \quad x_2 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span> 画出区域为：</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_unbounded_case.png" alt="example_for_unbounded_case" /><figcaption>example_for_unbounded_case</figcaption>
</figure>
<p>显然可以不断的增大。让我们来看看单纯形算法是如何应对的：</p>
<p>上述的写成松弛形式为： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;-x_1 - x_2&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 - x_2 + &amp;x_3 &amp;&amp;={1}  \\ 
-&amp;x_1 + x_2 &amp;&amp;+x_4&amp; ={1}\\ 
&amp;x_1, x_2,x_3, x_4 \geq{0} &amp;\\ 
\end{alignat}
\]</span> 也就是， <span class="math display">\[
\begin{alignat}{2}
&amp;z &amp;=&amp;-x_1 - x_2&amp;\\
&amp; x_3 &amp;=&amp; 1 - x_1 + x_2&amp;  \\ 
&amp;x_4 &amp;=&amp;1 + x_1 - x_2 &amp; \\ 
\end{alignat}
\]</span> 选择x_1 为替入变量，x_3为替出变量，有： <span class="math display">\[
\begin{alignat}{2}
&amp;z &amp;=&amp;-1 - 2x_2 + x_3&amp;\\
&amp; x_1 &amp;=&amp; 1 + x_2  - x_3&amp;  \\ 
&amp;x_4 &amp;=&amp;2 - x_3 &amp; \\ 
\end{alignat}
\]</span> 这时候我们只能选择<span class="math inline">\(x_2\)</span> 为替入变量,才能使得目标值变小，但是我们发现，对于<span class="math inline">\(x_2\)</span>没有任何的约束，也就是说，<span class="math inline">\(x_2\)</span>可以无限大，所以这是没有边界的情况。</p>
<p>这个情况是我们有一个替入变量，但是<strong>找不到一个替出变量导致的</strong>，这时候就是无界的情况了，写算法的时候注意判断一下即可。</p>
<h2 id="单纯形算法的具体实现">单纯形算法的具体实现</h2>
<p>说了那么多，代码怎么写呢？</p>
<p>看一下最开始的线性规划的问题（已经是松弛形式）： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;-x_1 -14x_2 - 6x_3&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2 +x_3 + x_4   \quad \quad \quad \quad \quad \quad \quad &amp;=&amp;  \quad4&amp;\\ 
&amp;x_1  \quad \quad \quad \quad \quad \quad \quad+x_5 \quad \quad\quad \quad\quad&amp;=&amp;\quad2&amp;\\ 
&amp; \quad\quad \quad \quad\quad  x_3 + \quad \quad \quad \quad + x_6&amp;=&amp;\quad3&amp;\\
&amp; \quad \quad 3x_2 +  x_3\quad\quad \quad \quad\quad \quad \quad +x_7&amp;=&amp;\quad6&amp;\\
&amp;x_1, \quad x_2 ,\quad x_3, \quad x_4, \quad x_5 ,\quad x_6, \quad x_7\quad &amp;\quad\geq{0} &amp;\\ 
\end{alignat}
\]</span> 我们可以得到下面的矩阵：</p>
<p><span class="math display">\[
\begin{equation}       %开始数学环境
C = \left(                 %左括号
  \begin{array}{c}   
    -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\  %第一行元素
  \end{array}
\right)                 %右括号
\\ \quad
\\
B =\left(                
  \begin{array}{c} 
    4\\ 2\\ 3\\  6\\  
  \end{array}
\right) 
\quad
A =\left(                 %左括号
  \begin{array}{c}   %c为居中放置
    1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\  %第一行元素
    1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\  %第二行元素
    0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\  %第三行元素
    0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\   %第四行元素
  \end{array}
\right)                 %右括号
\end{equation}
\]</span></p>
<ul>
<li>矩阵A：就是约束条件的系数（等号左边的系数）</li>
<li>矩阵B：就是约束条件的值（等号右边）</li>
<li>矩阵C：目标函数的系数值</li>
</ul>
<p>我们将其拼接起来： <span class="math display">\[
\begin{equation}       %开始数学环境
S_1 = \left( 
  \begin{array}{r}
  0&amp; -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\
  4&amp; 1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\ 
  2&amp;1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\ 
  3&amp;0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\
  6&amp;0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\
  \end{array}
\right) 
\end{equation}
\]</span></p>
<p>左下角为B，右上角为C，右下角为A，那么左上角呢？我们放的是-z，初始时-z = 0！</p>
<p>将上面那个矩阵和写成 基本变量 = 非基本变量的形式对比： <span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-x_1  -14x_2 - 6x_3&amp;  \\
&amp; x_4 = \quad4-x_1 - x_2 -x_3 &amp;\\ 
&amp;x_5 =\quad2 - x_1&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_7=\quad6  - 3x_2 - x_3&amp;\\ 
\end{alignat}
\]</span> 我们发现，对于B、C就是一样的，而A取决于基本变量和非基本变量，非基本变量符号相反，基本变量符号相同。</p>
<p>接着以最开始的线性规划求解过程的第二步为例，来看看我们的矩阵是如何进行运算的，第二步我们的结果如下（我们选择了<span class="math inline">\(x_1\)</span>为替入变量，<span class="math inline">\(x_5\)</span>为替出变量）： <span class="math display">\[
\begin{alignat}{4}
&amp;z =  \quad-2  -14x_2 - 6x_3 + x_5&amp;  \\
&amp; x_4 = \quad2 - x_2 -x_3 +x_5&amp;\\ 
&amp;x_1 =\quad2 - x_5&amp;\\ 
&amp;x_6=\quad3 - x_3&amp;\\
&amp; x_7=\quad6  - 3x_2 - x_3&amp;\\ 
\end{alignat}
\]</span> 首先看看约束条件的式子，<span class="math inline">\(x_1 = 2 - x_5\)</span>我们改写成： <span class="math inline">\(2 = x_1 + x_5\)</span> , 因此这行矩阵就是： (b,a1,a2.....a7) = (2,1,0,0,0,1,0,0)，其它的类推，注意-z，因此我们的矩阵应该是如下形式的： <span class="math display">\[
\begin{equation} 
S_2 = \left( 
  \begin{array}{c}
  2&amp; 0 &amp; -14 &amp; -6&amp; 0 &amp;1 &amp;0 &amp;0\\
  2&amp; 0 &amp; 1 &amp; 1&amp; 1 &amp;-1 &amp;0 &amp;0\\ 
  2&amp; 1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\ 
  3&amp; 0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\
  6&amp; 0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\
  \end{array}
\right) 
\end{equation}
\]</span> OK，那么<span class="math inline">\(S_1\)</span> 如何变成<span class="math inline">\(S_2\)</span>的？</p>
<p>首先是第2行，我们是将 <span class="math inline">\(x_1\)</span>用<span class="math inline">\(x_5\)</span>表示(<span class="math inline">\(x_1= x_5\)</span>)，在等式的变换中，就是移项，然后每一个都除以<span class="math inline">\(x_1\)</span>的系数。其实用矩阵很简单，这里就是mat[2] /= mat[2][1] ，表示矩阵第二行都除以第二行第一个元素</p>
<p>其它行呢？只要有<span class="math inline">\(x_1\)</span>的，我们都用<span class="math inline">\(x_1 = 2- x_5\)</span>来表示，就是其它行的<span class="math inline">\(x_1\)</span>的系数 * mat[2]，然后相减，<code>mat[i]= mat[i] - mat[2] * mat[i][1]</code> ,这样就实现了约束条件中替入和替出变量的替换！比如第一行，就是<code>mat[1] = mat[1] - mat[2] * 1</code>变成两行直接相减</p>
<p>现在来看目标函数，对于目标函数，我们也是将<span class="math inline">\(x_1\)</span>用 <span class="math inline">\(2 - x_5\)</span>来表示，参照上面的思路，同样的减法：<code>mat[0] = mat[0] -  mat[2] * -1 = mat[0] + mat[2]</code>。注意到我们的其实我们的z = -2，而左上角的为 2，也就是-z，这就是我们为啥说左上角是-z的原因。</p>
<p>用矩阵的形式来表示后，可以写出simplex beta0.99代码（去除版权信息、空行等，只需要<strong>21</strong>行！）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2016/11/17</span></span><br><span class="line"><span class="comment"># @Author  : hrwhisper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simplex</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, max_mode=False</span>):</span></span><br><span class="line">        self.max_mode = max_mode  <span class="comment"># default is solve min LP, if want to solve max lp,should * -1</span></span><br><span class="line">        self.mat = np.array([[<span class="number">0</span>] + obj]) * (<span class="number">-1</span> <span class="keyword">if</span> max_mode <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_constraint</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        self.mat = np.vstack([self.mat, [b] + a])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self</span>):</span></span><br><span class="line">        m, n = self.mat.shape  <span class="comment"># m - 1 is the number slack variables we should add</span></span><br><span class="line">        temp, B = np.vstack([np.zeros((<span class="number">1</span>, m - <span class="number">1</span>)), np.eye(m - <span class="number">1</span>)]), list(range(n - <span class="number">1</span>, n + m - <span class="number">1</span>))  <span class="comment"># add diagonal array</span></span><br><span class="line">        mat = self.mat = np.hstack([self.mat, temp])  <span class="comment"># combine them!</span></span><br><span class="line">        <span class="keyword">while</span> mat[<span class="number">0</span>, <span class="number">1</span>:].min() &lt; <span class="number">0</span>:</span><br><span class="line">            col = np.where(mat[<span class="number">0</span>, <span class="number">1</span>:] &lt; <span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>  <span class="comment"># use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok?</span></span><br><span class="line">            row = np.array([mat[i][<span class="number">0</span>] / mat[i][col] <span class="keyword">if</span> mat[i][col] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0x7fffffff</span> <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                            range(<span class="number">1</span>, mat.shape[<span class="number">0</span>])]).argmin() + <span class="number">1</span>  <span class="comment"># find the theta index</span></span><br><span class="line">            <span class="keyword">if</span> mat[row][col] &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># the theta is ∞, the problem is unbounded</span></span><br><span class="line">            mat[row] /= mat[row][col]</span><br><span class="line">            ids = np.arange(mat.shape[<span class="number">0</span>]) != row</span><br><span class="line">            mat[ids] -= mat[row] * mat[ids, col:col + <span class="number">1</span>]  <span class="comment"># for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col]</span></span><br><span class="line">            B[row] = col</span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][<span class="number">0</span>] * (<span class="number">1</span> <span class="keyword">if</span> self.max_mode <span class="keyword">else</span> <span class="number">-1</span>), &#123;B[i]: mat[i, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m) <span class="keyword">if</span> B[i] &lt; n&#125;</span><br></pre></td></tr></table></figure>
<p>一个调用的例子：</p>
<pre><code>&quot;&quot;&quot;
       minimize -x1 - 14x2 - 6x3
       st
        x1 + x2 + x3 &lt;=4
        x1 &lt;= 2
        x3 &lt;= 3
        3x2 + x3 &lt;= 6
        x1 ,x2 ,x3 &gt;= 0
       answer :-32
    &quot;&quot;&quot;
t = Simplex([-1, -14, -6])
t.add_constraint([1, 1, 1], 4)
t.add_constraint([1, 0, 0], 2)
t.add_constraint([0, 0, 1], 3)
t.add_constraint([0, 3, 1], 6)
print(t.solve())
print(t.mat)</code></pre>
<p>首先初始化目标函数，然后不断的使用add_constraint添加约束条件。</p>
<p>注意在上面的Simplex类中，我们在初始化中加入了参数max_mode，处理最大值的情况。</p>
<p>然后在16~18行中，我们初始化了最开始的基本变量为B, 需要松弛的变量有m-1个，合并（m-1） *（ m-1）的一个对角阵和一行有m-1个0的数组（这是目标函数），然后将他们和原来的合并起来，这样就构成了我们的S矩阵。</p>
<p>19行判断是否还有元素可以继续被增大（就是系数为负）</p>
<p>20-22行选择合适的替入和替出变量，若无替出变量，说明原问题无界，我们在23行处理了这种情况。</p>
<p>24~27就是旋转的过程，进行矩阵的行变换。并用B数组记录替入的替入变量。</p>
<p>28行我们返回目标值z，若为最小值，则要*-1，最大值则不用（因为一开始已经*-1了）。然后最后对应x的解就是基本变量为对应的<span class="math inline">\(b_i\)</span>，非基本变量为0，注意删除我们松弛添加的变量（所以只要判断下标是否 &lt; n）</p>
<p>simplex 0.99 beta 就是这么少的代码这么容易的就实现了！</p>
<p>来，跟我一起喊：<strong>python 大法好！</strong></p>
<h2 id="初始解-基本可行解以及无解的情况">初始解 ≠ 基本可行解以及无解的情况</h2>
<p>在你高呼python大法好的时候，！</p>
<p>但是我把它称为beta 0.99版本肯定是有原因的，绝大多数情况下，初始解就是基本可行解，但是也有例外啊！</p>
<p>而且还有无解的情况。(╯‵□′)╯︵┻━┻</p>
<h3 id="栗子">栗子</h3>
<h4 id="栗子1">栗子1</h4>
<p>栗子1登场： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;x_1 + 2x_2&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2 &amp;\leq{2}  \\ 
&amp;x_1 + x_2 &amp; \geq{1}\\ 
&amp;x_1, \quad x_2 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span> 首先转化为标准形式（&gt;= 改成 &lt;=, *-1），然后再转化为松弛形式： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;x_1 + 2x_2&amp;  \\
\mbox{s.t.}\quad
&amp; x_3 = 2  - x_1 - x_2 \\ 
&amp;x_4  = -1  + x_1 + x_2\\ 
&amp;x_1, \quad x_2 , \quad x_3 , \quad x_4 \geq{0} \\ 
\end{alignat}
\]</span> 而我们假设的非基本变量全为0，于是有：<span class="math inline">\((x_1,x_2,x_3,x_4) = (0,0,2,-1)\)</span>，但是<span class="math inline">\(x_4= -1\)</span>是不满足条件的。即初始解不是基本可行解。</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_feasible_solution.png" alt="example_for_feasible_solution" /><figcaption>example_for_feasible_solution</figcaption>
</figure>
<h4 id="栗子2">栗子2</h4>
<p>再比如下面的例子（栗子2）： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;x_1 + 2x_2&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2 &amp;\geq{2}  \\ 
&amp;x_1 + x_2 &amp; \leq{1}\\ 
&amp;x_1, \quad x_2 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span> 其实这个例子就是例子1改变了个符号而已，但是要&gt;=2，然后又要&lt;=1的情况，这个例子显然是无解的。</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_no_feasible_solution.png" alt="example_for_no_feasible_solution" /><figcaption>example_for_no_feasible_solution</figcaption>
</figure>
<p>我们来看看初始解的情况，继续转化为标准形式，然后再转化为松弛形式： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;x_1 + 2x_2&amp;  \\
\mbox{s.t.}\quad
&amp; x_3 = -2  + x_1 + x_2 \\ 
&amp;x_4  = 1  - x_1 - x_2\\ 
&amp;x_1, \quad x_2 , \quad x_3 , \quad x_4 \geq{0} \\ 
\end{alignat}
\]</span> 同样的，非基本变量全为0，于是有 <span class="math inline">\((x_1,x_2,x_3,x_4) = (0,0,-2,1)\)</span>，但是<span class="math inline">\(x_3 = -2\)</span>是不满足条件的。即初始解不是基本可行解。</p>
<h3 id="simplex-beta0.99测试">simplex beta0.99测试</h3>
<p>在上面的两个例子中，用我们的simplex beta0.99跑有啥结果呢？</p>
<p>第1个栗子,第一个矩阵为初始的矩阵，接下来是结果和对应的x1,x2值，然后是最后的矩阵</p>
<blockquote>
<p>[[ 0. 1. 2. 0. 0.] [-1. -1. -1. 1. 0.] [ 2. 1. 1. 0. 1.]] (-0.0, {}) [[ 0. 1. 2. 0. 0.] [-1. -1. -1. 1. 0.] [ 2. 1. 1. 0. 1.]]</p>
</blockquote>
<p>可以看到，由于c &gt;=0，直接不迭代了，而这个问题用GLPK计算，正确的结果应该为：<span class="math inline">\(z = 1, x_1 = 1\)</span></p>
<p>第2个栗子：格式同上，结果如下</p>
<blockquote>
<p>[[ 0. 1. 2. 0. 0.] [-2. -1. -1. 1. 0.] [ 1. 1. 1. 0. 1.]] (-0.0, {}) [[ 0. 1. 2. 0. 0.] [-2. -1. -1. 1. 0.] [ 1. 1. 1. 0. 1.]]</p>
</blockquote>
<p>这个应该是无解的。</p>
<h3 id="初始化">初始化</h3>
<p>从上面的例子中，simplex beta 0.99 可以说是错误的! simplex beta 0.99产生错误的原因就是总把初始解当作基本可行解！</p>
<p>拍拍，打脸(￣ε(#￣)</p>
<p>那么如何做才是正确的呢？</p>
<p>问题回到我们的单纯形算法的第一步：找到一个初始的基本可行解。如何找？</p>
<p>我们首先思考上面的问题为什么会不可行。原因就是因为有<span class="math inline">\(b_i &lt; 0\)</span>!</p>
<p>因此，对于一个线性规划问题，有如下的情况：</p>
<ul>
<li>若所有的<span class="math inline">\(b_i &gt;=0\)</span>，说明初始的基本解就是基本可行解，在这种情况下，simplex beta 0.99是正确的。</li>
<li>若有<span class="math inline">\(b_i &lt; 0\)</span>, 我们需要进行初始化操作，判断其是否有解（如栗子2），并返回一个基本可行解，然后运行simplex beta 0.99</li>
</ul>
<p>第一种情况就是之前讨论的，这里讨论第二种情况。</p>
<p>以第一个栗子为例，构造辅助线性规划（auxiliary linear program）如下： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;x_0&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2   - x_0&amp;\leq&amp;{2}  \\ 
&amp;-x_1 - x_2 - x_0 &amp; \leq&amp;{-1}\\ 
&amp;x_1, \quad x_2,\quad x_0 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span> 然后求解这个辅助线性规划<span class="math inline">\(L_{aux}\)</span>，<strong>如果<span class="math inline">\(L_{aux}\)</span>的最优解<span class="math inline">\(x_0\)</span>为0的话，说明这个原线性方程组有解</strong>。</p>
<p>下面是算法导论的证明，它证明的是最大化 <span class="math inline">\(x_0\)</span> 和我们最小化x<span class="math inline">\(x_0\)</span> 是一样的。  </p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/proof-for-auxiliary_lp.png" alt="proof for auxiliary_lp" /><figcaption>proof for auxiliary_lp</figcaption>
</figure>
<p>把<span class="math inline">\(L_{aux}\)</span> 写成松弛形式：</p>
<p><span class="math display">\[
\begin{alignat}{2}
&amp; z  = x_0 \\
&amp;x_3 = 2 - x_1 - x_2 + x_0  \\ 
&amp;x_4 = -1 + x_1 + x_2 + x_0\\ 
&amp;x_1, \quad x_2,\quad x_3,\quad x_4,\quad x_0 &amp;\geq{0} &amp;\\ 
\end{alignat}
\]</span></p>
<p>注意到这个初始解<span class="math inline">\((x_1,x_2,x_3,x_4,x_0) = (0,0,2,-1,0)\)</span> 也不是基本可行解。现在马上就可以看到引入<span class="math inline">\(x_0\)</span>的原因了，我们把<span class="math inline">\(x_0\)</span>做为替入变量，选一个b最小的那一行的基本变量作为替出变量（这里是<span class="math inline">\(x_4\)</span>），进行一次旋转操作，得：</p>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;z = 1 - x_1 - x_2 + x_4\\
&amp;x_3 = 2 - x_1 - x_2 + x_0  \\ 
&amp;x_0 = 1 - x_1 - x_2 + x_4\\ 
\end{alignat}
\]</span></p>
<p>进行旋转之后，初始解<span class="math inline">\((x_1,x_2,x_3,x_4,x_0)\)</span> 变为 (0,0,2,0,1)，这就是因为<span class="math inline">\(x_0\)</span> 的替入 ，使得所有的b &gt;=0</p>
<p>有人可能会问，上面的例子中，只有一个负的，多个负的怎么办？还能保证么？</p>
<p>答案是可以的，因为我们选择替出的是<span class="math inline">\(b_i\)</span> 为负的最小的那一行的基本变量，而一开始，我们构建辅助函数时，<span class="math inline">\(x_0\)</span>的系数为-1，因此，旋转的时候，矩阵运算相当于其它每一行减去这一行，而b为负，负负得正，必然最后所有的b都&gt;=0。</p>
<p>现在，我们已经有一个基本可行解了，我们求解这个辅助线性规划即可。</p>
<p>和上面的思想一样，这里要么增大<span class="math inline">\(x_1\)</span>, 要么增大<span class="math inline">\(x_2\)</span>，假设选择<span class="math inline">\(x_1\)</span>，然后第二个等式有最严格的限制，选择<span class="math inline">\(x_0\)</span>为替出变量，得 <span class="math inline">\(x_1 = 1 - x_2 + x_4 - x_0\)</span> <span class="math display">\[
\begin{alignat}{2}
&amp;z = x_0\\
&amp;x_3 = 1 - x_4 + 2x_0  \\ 
&amp;x_1 = 1 - x_2 +  x_4 - x_0\\ 
\end{alignat}
\]</span></p>
<p>此时，基本解为：<span class="math inline">\((x_1,x_2,x_3,x_4,x_0)= (1,0,1,0,0)\)</span>, 此时<span class="math inline">\(z = x_0 = 0\)</span>,无法继续增大某个变量使得z继续减少，因此此时为最优解，就是z =0，说明原问题有解。</p>
<p>接下来，我们要恢复原问题的目标函数，就是用现在的基本变量替代原目标函数中的基本变量（若<span class="math inline">\(x_0\)</span>是基本变量，那就要旋转去掉它），此外由于<span class="math inline">\(x_0 = 0\)</span>,因此可以将其去掉：</p>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;z &amp;=&amp; \quad  x_1 + 2x_2 \\
&amp; &amp;=&amp; \quad 1  + x_2 + x_4  - x_0\\
&amp; &amp;=&amp; \quad 1  + x_2 + x_4\\
\end{alignat}
\]</span></p>
<p>其它的约束条件同理去掉<span class="math inline">\(x_0\)</span>可得：</p>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;z = 1  + x_2 + x_4\\
&amp;x_3 = 1 - x_4  \\ 
&amp;x_1 = 1 - x_2 +  x_4\\ 
\end{alignat}
\]</span></p>
<p>因此，现在，我们通过构造了一个辅助线性规划L<sub>aux</sub> 将原来的问题转化为上面的线性规划，并且它的初始解就是基本可行解：<span class="math inline">\((x_1,x_2,x_3,x_4 = (1,0,1,0)\)</span>，然后求解这个新的线性规划即可。</p>
<p>我们很幸运的发现（其实是博主偷懒举了个简单的例子(✿◡‿◡)），这里无法通过增大任何的变量使得目标值变小，因此此时就是结果啦，而<span class="math inline">\((x_1,x_2,x_3,x_4 = (1,0,1,0)\)</span>就是最后的解，z = 1。</p>
<p>下面总结一下上面的过程，</p>
<ol type="1">
<li>若bi都大于等于0 跳到9</li>
<li>引入<span class="math inline">\(x_0\)</span>，创建一个辅助线性规划<span class="math inline">\(L_{aux}\)</span></li>
<li>将<span class="math inline">\(L_{aux}\)</span>写成松弛形式</li>
<li>选择<span class="math inline">\(b_i\)</span>最小的那一行的基本变量为替出变量，<span class="math inline">\(x_0\)</span>为替入变量，进行一次旋转操作</li>
<li>求解<span class="math inline">\(L_{aux}\)</span></li>
<li>若<span class="math inline">\(L_{aux}\)</span>的最优解为0，那么原问题有解，否则无解，return &quot;no answer&quot;</li>
<li>在有解的情况下，若<span class="math inline">\(x_0\)</span>为基本解，那么执行一次旋转，把它变为非基本变量</li>
<li>恢复原始的目标函数，但是将其基本变量替换掉</li>
<li>运行simplex beta 0.99 对新的线性规划方程求解。</li>
</ol>
<p>PS：有兴趣的读者可以计算一下例子2，会发现辅助函数的最优解不是0,而是0.5，说明无解</p>
<h2 id="完整的单纯形算法">完整的单纯形算法</h2>
<p>结合simplex beta 0.99和初始化的过程，可以写成如下的simplex 1.0代码（去除版权信息，空行等，也只要40行左右，还是简洁^ ^）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2016/11/17</span></span><br><span class="line"><span class="comment"># @Author  : hrwhisper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simplex</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj, max_mode=False</span>):</span>  <span class="comment"># default is solve min LP, if want to solve max lp,should * -1</span></span><br><span class="line">        self.mat, self.max_mode = np.array([[<span class="number">0</span>] + obj]) * (<span class="number">-1</span> <span class="keyword">if</span> max_mode <span class="keyword">else</span> <span class="number">1</span>), max_mode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_constraint</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">        self.mat = np.vstack([self.mat, [b] + a])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_simplex</span>(<span class="params">self, mat, B, m, n</span>):</span></span><br><span class="line">        <span class="keyword">while</span> mat[<span class="number">0</span>, <span class="number">1</span>:].min() &lt; <span class="number">0</span>:</span><br><span class="line">            col = np.where(mat[<span class="number">0</span>, <span class="number">1</span>:] &lt; <span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>  <span class="comment"># use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok?</span></span><br><span class="line">            row = np.array([mat[i][<span class="number">0</span>] / mat[i][col] <span class="keyword">if</span> mat[i][col] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0x7fffffff</span> <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                            range(<span class="number">1</span>, mat.shape[<span class="number">0</span>])]).argmin() + <span class="number">1</span>  <span class="comment"># find the theta index</span></span><br><span class="line">            <span class="keyword">if</span> mat[row][col] &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># the theta is ∞, the problem is unbounded</span></span><br><span class="line">            self._pivot(mat, B, row, col)</span><br><span class="line">        <span class="keyword">return</span> mat[<span class="number">0</span>][<span class="number">0</span>] * (<span class="number">1</span> <span class="keyword">if</span> self.max_mode <span class="keyword">else</span> <span class="number">-1</span>), &#123;B[i]: mat[i, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m) <span class="keyword">if</span> B[i] &lt; n&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_pivot</span>(<span class="params">self, mat, B, row, col</span>):</span></span><br><span class="line">        mat[row] /= mat[row][col]</span><br><span class="line">        ids = np.arange(mat.shape[<span class="number">0</span>]) != row</span><br><span class="line">        mat[ids] -= mat[row] * mat[ids, col:col + <span class="number">1</span>]  <span class="comment"># for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col]</span></span><br><span class="line">        B[row] = col</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self</span>):</span></span><br><span class="line">        m, n = self.mat.shape  <span class="comment"># m - 1 is the number slack variables we should add</span></span><br><span class="line">        temp, B = np.vstack([np.zeros((<span class="number">1</span>, m - <span class="number">1</span>)), np.eye(m - <span class="number">1</span>)]), list(range(n - <span class="number">1</span>, n + m - <span class="number">1</span>))  <span class="comment"># add diagonal array</span></span><br><span class="line">        mat = self.mat = np.hstack([self.mat, temp])  <span class="comment"># combine them!</span></span><br><span class="line">        <span class="keyword">if</span> mat[<span class="number">1</span>:, <span class="number">0</span>].min() &lt; <span class="number">0</span>:  <span class="comment"># is the initial basic solution feasible?</span></span><br><span class="line">            row = mat[<span class="number">1</span>:, <span class="number">0</span>].argmin() + <span class="number">1</span>  <span class="comment"># find the index of min b</span></span><br><span class="line">            temp, mat[<span class="number">0</span>] = np.copy(mat[<span class="number">0</span>]), <span class="number">0</span>  <span class="comment"># set first row value to zero, and store the previous value</span></span><br><span class="line">            mat = np.hstack([mat, np.array([<span class="number">1</span>] + [<span class="number">-1</span>] * (m - <span class="number">1</span>)).reshape((<span class="number">-1</span>, <span class="number">1</span>))])</span><br><span class="line">            self._pivot(mat, B, row, mat.shape[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> self._simplex(mat, B, m, n)[<span class="number">0</span>] != <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># the problem has no answer</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mat.shape[<span class="number">1</span>] - <span class="number">1</span> <span class="keyword">in</span> B:  <span class="comment"># if the x0 in B, we should pivot it.</span></span><br><span class="line">                self._pivot(mat, B, B.index(mat.shape[<span class="number">1</span>] - <span class="number">1</span>), np.where(mat[<span class="number">0</span>, <span class="number">1</span>:] != <span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>)</span><br><span class="line">            self.mat = np.vstack([temp, mat[<span class="number">1</span>:, :<span class="number">-1</span>]])  <span class="comment"># recover the first line</span></span><br><span class="line">            <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(B[<span class="number">1</span>:]):</span><br><span class="line">                self.mat[<span class="number">0</span>] -= self.mat[<span class="number">0</span>, x] * self.mat[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> self._simplex(self.mat, B, m, n)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，将旋转操作独立为一个方法（23~27），将单纯形算法的核心也独立为一个方法（14~21），这是考虑到要多次调用的原因，并且代码之前的几乎没什么变化，这里不做过多的解释。</p>
<p>主要变化在于solve方法，30~32和之前是一样的，不解释 ♪(^ ∇^*)</p>
<p>33行判断是否有一个b &lt; 0 ？如果有，说明初始解不可行。否则直接执行45行，调用单纯形算法</p>
<p>34~44处理的是不可行的情况，</p>
<ul>
<li>34：首先找一个最小b的下标</li>
<li>35和36作用在于保存原来的目标函数，并将第0行设为0，然后添加<span class="math inline">\(x_0\)</span> 需要拼接矩阵，其实就是构造辅助线性规划<span class="math inline">\(L_{aux}\)</span></li>
<li>37执行旋转操作，使其初始解可行</li>
<li>38行求解<span class="math inline">\(L_{aux}\)</span> 最优值是否为0，是就是有解，否则无解</li>
<li>40-41行若最后的<span class="math inline">\(x_0\)</span>是基本解，找一个第0行不是0的元素作为替入变量，将x<sub>0</sub>替出</li>
<li>42~44 恢复初始目标函数，删除<span class="math inline">\(x_0\)</span>那一列，并且替换目标函数中的基本变量。</li>
</ul>
<p>好了，代码还是很短，其实能更短，但是会影响可读性！</p>
<p>再来高呼： <strong>Python 大法好！</strong></p>
<h2 id="从几何角度看单纯形算法">从几何角度看单纯形算法</h2>
<p>上面我们介绍单纯形算法的时候，是通过最直观的等式变换（就是旋转操作）介绍的。</p>
<p>我们知道，线性规划就是在可行域围成的多胞形中求解，现在从几何的视图来看看单纯形算法。</p>
<h3 id="只需考虑顶点">只需考虑顶点</h3>
<p>让我再次召唤之前的图：</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_feasible_region.png" alt="example_for_feasible_region" /><figcaption>example_for_feasible_region</figcaption>
</figure>
<p>直观上看，<strong>最优解就在顶点上，不需要考虑内部点</strong>。</p>
<h4 id="一个引入的证明">一个引入的证明</h4>
<figure>
<img src="../images/introduction-to-simplex-algorithm/only_consider_vertex_proof_1.png" alt="only_consider_vertex_proof_1" /><figcaption>only_consider_vertex_proof_1</figcaption>
</figure>
<p>我们假设<span class="math inline">\(x^{(0)}\)</span>是最优解，连接<span class="math inline">\(x^{(1)}\)</span>和<span class="math inline">\(x^{(0)}\)</span>与 <span class="math inline">\(x^{(2)}\)</span>和<span class="math inline">\(x^{(3)}\)</span>相交于点x'</p>
<p>我们可以把<span class="math inline">\(x^{(0)}\)</span>分解，<span class="math inline">\(x^{(0)} = λ_1 x^{(1)} + (1 - λ_1)x&#39;\)</span> 其中<span class="math inline">\(λ_1 = p / (p + q)\)</span></p>
<p>同样的把x‘ 分解，<span class="math inline">\(x&#39;= λ_2 x^{(2)} + (1 - λ_2)x^{(3)}\)</span>其中<span class="math inline">\(λ_2 = r / (r + s)\)</span></p>
<p>因此有：<span class="math inline">\(x^{(0)} = λ_1 x^{(1)} + (1 - λ_1)λ_2 x^{(2)} + (1 - λ_1) (1 - λ_2)x^{(3)}\)</span>，而<span class="math inline">\(λ_1 + (1 - λ_1)λ_2 + (1 - λ_1) (1 - λ_2) = 1\)</span></p>
<p>设 <span class="math inline">\(c^Tx^{(1)}\)</span> 小于等于 <span class="math inline">\(c^T x^{(2)}\)</span>， <span class="math inline">\(c^Tx^{(3)}\)</span>，因此有： <span class="math display">\[
\begin{alignat}{2}
C^Tx^{(0)} 
&amp;=λ_1  C^T x^{(1)} + (1 - λ_1)λ_2  C^T x^{(2)} + (1 - λ_1) (1 - λ_2) C^T x^{(3)} \\
&amp; \geq λ_1  C^T x^{(1)} + (1 - λ_1)λ_2  C^T x^{(1)} + (1 - λ_1) (1 - λ_2) C^T x^{(1)}\\ 
&amp; =C^Tx^{(1)}
\end{alignat}
\]</span> 因此，<span class="math inline">\(x^{(1)}\)</span> 并不比<span class="math inline">\(x^{(0)}\)</span>差。</p>
<p>我们可以推广到更多的情况。(见附件的68页)</p>
<h3 id="多边形的顶点等价于矩阵的基">多边形的顶点等价于矩阵的基</h3>
<p>上面提到，最优解一定在顶点上，我们不需要考虑内部的点。</p>
<p>那么，如何获得顶点呢？</p>
<p>可以证明，<strong>顶点就是基，基就是顶点</strong>。（见附件的72-78页）</p>
<p>我们只需要找到矩阵的基就好了。</p>
<h3 id="顶点的游走">顶点的游走</h3>
<p>我们知道，多边形的顶点就是基，且最优解在顶点上，我们需要做的就是，按照一定的规则沿着边遍历顶点，直到不能更新了为止。</p>
<p>如何从一个顶点到另一个顶点？更新到什么时候为止？</p>
<p>我们先讨论第一个问题。</p>
<p>还是一开始介绍单纯形算法的例子： <span class="math display">\[
\begin{alignat}{2}
\min\quad &amp;-x_1 -14x_2 - 6x_3&amp;  \\
\mbox{s.t.}\quad
&amp;x_1 + x_2 +x_3 + x_4   \quad \quad \quad \quad \quad \quad \quad &amp;=&amp;  \quad4&amp;\\ 
&amp;x_1  \quad \quad \quad \quad \quad \quad \quad+x_5 \quad \quad\quad \quad\quad&amp;=&amp;\quad2&amp;\\ 
&amp; \quad\quad \quad \quad\quad  x_3 + \quad \quad \quad \quad + x_6&amp;=&amp;\quad3&amp;\\
&amp; \quad \quad 3x_2 +  x_3\quad\quad \quad \quad\quad \quad \quad +x_7&amp;=&amp;\quad6&amp;\\
&amp;x_1, \quad x_2 ,\quad x_3, \quad x_4, \quad x_5 ,\quad x_6, \quad x_7\quad &amp;\quad\geq{0} &amp;\\ 
\end{alignat}
\]</span> 其松弛条件系数A，目标函数系数C，用矩阵表示为： <span class="math display">\[
\begin{equation}       %开始数学环境
C = \left(                 %左括号
  \begin{array}{c}   
    -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\  %第一行元素
  \end{array}
\right)                 %右括号
\\ \quad
\\
B =\left(                
  \begin{array}{c} 
    4\\ 2\\ 3\\  6\\  
  \end{array}
\right) 
\quad
A =\left(                 %左括号
  \begin{array}{c}   %c为居中放置
    1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\  %第一行元素
    1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\  %第二行元素
    0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\  %第三行元素
    0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\   %第四行元素
  \end{array}
\right)                 %右括号
\end{equation}
\]</span> 这里假设我们初始的解X设为<span class="math inline">\((x_1,x_2,x_3 ,x_4 ,x_6,x_7) = (0,0,0,4,2,3,6)\)</span>.就是我们的初始在(0,0,0)的点上。</p>
<p>我们的初始点用红点来表示，而绿色的线就是我们下一步走的边，如下图所示：</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/walk_though_vertex.png" alt="walk_though_vertex" /><figcaption>walk_though_vertex</figcaption>
</figure>
<p>要实现图中绿色的边，如何做呢？</p>
<p>其实就是之前旋转的操作！想想我们之前的旋转，我们要选择<span class="math inline">\(x_1\)</span>为替入变量，<span class="math inline">\(x_5\)</span>为替出变量，然后执行旋转。 （忘记的翻回去看，这里不赘述）然后就得到新的基本解及其值为：<span class="math inline">\((x_1,x_2....x_7) = (2,0,0,2,0,3,6)\)</span>。注意，这时候我们已经到达新的点了！可以说就是沿着那条边走的！</p>
<p>可以说，设边的方向为λ，我们沿着边走的距离是θ，那么，我们走的就是<span class="math inline">\(x &#39; = x - θλ\)</span>。</p>
<p>那么λ是什么呢？其实就是选择一个非基的列向量。</p>
<p>为了说明，我们用<span class="math inline">\(a_1 .. a_7\)</span> 来表示矩阵A的对应的列： <span class="math display">\[
\begin{equation}   
A =\left(     
  \begin{array}{c} 
    1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\
    1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\
    0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\ 
    0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\
  \end{array}
\right)
\end{equation}
\]</span> 可以看到非基向量可以用基向量表示，比如这里<span class="math inline">\(a_1 = 1a_4 + 1a_5 + 0a_6 + 0a_7\)</span>也就是 <span class="math inline">\(-a_1+ 0a_2 + 0a_3 + 1a_4 + 1a_5 + 0a_6 + 0a_7 = 0\)</span></p>
<p>我们的λ 也就等于这个系数，就是<span class="math inline">\(λ = (-1,0,0,1,1,0,0)\)</span></p>
<p>那么走多少呢？走过多会超出区域，过少会达不到顶点，答案就是2！想想我们之前选<span class="math inline">\(x_5\)</span>的原因：<span class="math inline">\(x_5\)</span>最大程度的限制了<span class="math inline">\(x_1\)</span>的值， <span class="math inline">\(x_1 &lt;= 2\)</span>，于是我们定义θ就是限制最紧的值。换句话说，在S矩阵中，就是<span class="math inline">\(bi / x[i][1]\)</span>最小的值（θ &gt; 0）。</p>
<p>让我们验算一下：</p>
<p>(0,0,0,4,2,3,6) - 2 * (-1,0,0,1,1,0,0) = (2,0,0,2,0,3,6) ! (o゜▽゜)o☆[BINGO!] 和之前的完全一样！</p>
<p>我们做一次旋转的操作，其实就是一个顶点到另一个顶点的过程！很神奇吧！</p>
<p>仔细思考一下为什么之前的旋转等价于这里的非基向量表示的边？</p>
<p>我们用原来的基向量<span class="math inline">\((a_4,a_5,a_6,a_7)\)</span> 来表示<span class="math inline">\(a_1\)</span>,其实可以换个角度想想之前的等式变换，我们在这里表示<span class="math inline">\(a_1\)</span>可以认为是之前的将每行有<span class="math inline">\(x_1\)</span>带入的过程。<span class="math inline">\(a_1\)</span>上为1，说明这一行有<span class="math inline">\(x_1\)</span>，我们需要带入。</p>
<h3 id="停止条件">停止条件</h3>
<p>现在，我们已经在顶点上，然后沿着边游走了，那么，我们游走到什么时候为止呢？</p>
<p>注意，我们的目标是最小化目标函数，即求<span class="math inline">\(\min C^Tx\)</span></p>
<p>假设我们从x沿着边到达x'，我们有： <span class="math inline">\(x&#39; = x - \theta \lambda\)</span>，我们的λ形式为：<span class="math inline">\([λ_1,λ_2,.....,-1,.....λ_m]\)</span>那么目标函数的值增加了：<span class="math inline">\(C^Tx&#39; - C^Tx = - θC^Tλ = -θ(-c_e + Σλ_ic_i) = θ(c_e - Σλ_ic_i)\)</span> 其中，最后的求和符号是对e替入前的基向量求和的。由于θ &gt;0 ,因此<span class="math inline">\(c_e - Σλ_ic_i &gt;=0\)</span> 说明我们可以停止了（x比x'不差）。我们把<span class="math inline">\(c_e - Σλ_ic_i\)</span> 称为检验数（checking number)</p>
<p>我们把检验数写成矩阵的形式就是：<span class="math inline">\(C^T - C^{T_B} B^{-1}A\)</span> (<span class="math inline">\(C^{T_B}\)</span>为基向量的C的转置)。</p>
<p>下面证明对于顶点x，若检验数 <span class="math inline">\(C^T - C^{T_B} B^{-1}A &gt;=0\)</span> ，则x为最优解。</p>
<blockquote>
<p>设y 为其它任意的可行解， 于是有Ay = b, y&gt;=0</p>
<p><span class="math inline">\(C^T y \ge C^{T_B} B^{-1}Ay = C^{T_B} B^{-1}b = C^{T_B} X_B = C^Tx.\)</span></p>
<p>就是说，其它的可行解y不比x好</p>
</blockquote>
<p>注意我们旋转的过程中，<span class="math inline">\(C^{T_B}=0\)</span>，或者说<span class="math inline">\(Σλ_ic_i = 0\)</span> 因此，若<span class="math inline">\(C_N\)</span>（非基的那些） 都 &gt;=0 ，就可以停止了。这和之前的其实还是一样的。</p>
<h3 id="小结">小结</h3>
<p>用几何的角度看待单纯形算法，主要有几点：</p>
<ol type="1">
<li>最优解可以在顶点上找到，不需考虑内部点</li>
<li>顶点 &lt;=&gt; 矩阵的基</li>
<li>一次旋转就是一个顶点沿着一条边λ走θ倍到另一个顶点的过程</li>
<li>当我们的检验数 &gt;=0 停止迭代</li>
</ol>
<p>当然也需要注意初始化单纯形算法，比如之前的情况：</p>
<figure>
<img src="../images/introduction-to-simplex-algorithm/example_for_feasible_solution.png" alt="example_for_feasible_solution" /><figcaption>example_for_feasible_solution</figcaption>
</figure>
<p>我们的顶点要在可行域才行，而不要跑到(0,0)去了。初始方法和之前的一样。</p>
<h2 id="时间复杂度">时间复杂度</h2>
<p>现在，来讨论一下单纯形算法的时间复杂度吧。</p>
<p>在之前的算法中，我们每一次查找一个 负数cx需要O(N)，(这里用N为了区分代码中的N，这里N = m + n)并且查找最小的θ所在的row需要O(m)，然后执行旋转，在旋转中，我们对于<code>i!=row</code>的执行<code>mat[i]= mat[i] - mat[row] * mat[i][col]</code>,需要O(m*N)</p>
<p>因此一次的复杂度为O(m*N)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_simplex</span>(<span class="params">self, mat, B, m, n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> mat[<span class="number">0</span>, <span class="number">1</span>:].min() &lt; <span class="number">0</span>:</span><br><span class="line">        col = np.where(mat[<span class="number">0</span>, <span class="number">1</span>:] &lt; <span class="number">0</span>)[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>  <span class="comment"># use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok?</span></span><br><span class="line">        row = np.array([mat[i][<span class="number">0</span>] / mat[i][col] <span class="keyword">if</span> mat[i][col] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0x7fffffff</span> <span class="keyword">for</span> i <span class="keyword">in</span></span><br><span class="line">                        range(<span class="number">1</span>, mat.shape[<span class="number">0</span>])]).argmin() + <span class="number">1</span>  <span class="comment"># find the theta index</span></span><br><span class="line">        <span class="keyword">if</span> mat[row][col] &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># the theta is ∞, the problem is unbounded</span></span><br><span class="line">        self._pivot(mat, B, row, col)</span><br><span class="line">    <span class="keyword">return</span> mat[<span class="number">0</span>][<span class="number">0</span>] * (<span class="number">1</span> <span class="keyword">if</span> self.max_mode <span class="keyword">else</span> <span class="number">-1</span>), &#123;B[i]: mat[i, <span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m) <span class="keyword">if</span> B[i] &lt; n&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pivot</span>(<span class="params">self, mat, B, row, col</span>):</span></span><br><span class="line">    mat[row] /= mat[row][col]</span><br><span class="line">    ids = np.arange(mat.shape[<span class="number">0</span>]) != row</span><br><span class="line">    mat[ids] -= mat[row] * mat[ids, col:col + <span class="number">1</span>]  <span class="comment"># for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col]</span></span><br><span class="line">    B[row] = col</span><br></pre></td></tr></table></figure>
<p>那么执行多少次呢？假设为k次就是O(kmN)</p>
<p>在绝大多数的情况下，单纯形算法也都是多项式时间的算法，自从1949年单纯形算法提出后，人们也一度的以为它就是多项式时间的，直到有人出来挑事情。。。。(╯‵□′)╯︵┻━┻</p>
<p>V. Klee and G. L. Minty[1972] 构造了一个例子： <span class="math display">\[
\begin{alignat}{2}
\max\quad &amp;x_n&amp;  \\
\mbox{s.t.}\quad
&amp; δ &amp;\leq&amp;\quad{x_i}\quad &amp;\leq&amp;{1}&amp;for\quad i=1...n \\ 
&amp; δx_{i-1}&amp;\leq&amp;\quad{x_i}\quad&amp;\leq&amp;1 -δx_{i-1} \quad&amp;for\quad i=2...n \\ 
&amp; &amp;&amp;\quad x_i &amp;\geq&amp;{0} &amp;for\quad i=1...n\\ 
\end{alignat}
\]</span></p>
<p>在这个例子中，单纯形算法将会遍历2<sup>n</sup>个顶点。这个例子提出，说明单纯形算法不是一个多项式时间复杂度的算法。但是为什么它实际运行时是多项式时间复杂度的？这个问题困扰了人们很久，直到2001年 Daniel A. Spielman 和 Shang-Hua Teng 提出了平滑型复杂度理论（smoothed complexity），完美的解决了这个问题。</p>
<blockquote>
<ul>
<li>Average-case analysis was first introduced to overcome the limitations of worst-case analysis, however the difficulty is saying what an average case is. The actual inputs and distribution of inputs may be different in practice from the assumptions made during the analysis.</li>
<li>Smoothed analysis is a hybrid of worst-case and average-case analyses that inherits advantages of both, by measuring the expected performance of algorithms under slight random perturbations of worst-case inputs.</li>
<li>The performance of an algorithm is measured in terms of both the input size, and the magnitude of the perturbations.</li>
<li>If the smoothed complexity of an algorithm is low, then it is unlikely that the algorithm will take long time to solve practical instances whose data are <strong>subject to slight noises and imprecisions</strong>.</li>
</ul>
</blockquote>
<p>可能原值会是非多项式时间的，但是在真实世界中，基本都是真实数据+噪声的值，或者还要加上误差，因此单纯形算法“因祸得福”，一般为多项式时间的。不同于大家做信号处理或者图像处理时，将讨厌的噪声去掉，滕老师说：“噪声是个好东西”。</p>
<h2 id="小结-1">小结</h2>
<p>给定一个线性规划L，就只有如下三种情形：</p>
<ol type="1">
<li>有一个有限目标值的最优解</li>
<li>不可行</li>
<li>无界</li>
</ol>
<p>在本文中，我们对其三种情况都进行了讨论，如果有啥疑问或错误欢迎提出。 ^ ^</p>
<p>单纯形算法本身并不难，老师上课讲的是几何的角度，听得我一愣一愣的，之后看算法导论（就是最开始的等式变换），通熟易懂，但矩阵还是跟着老师的思路写的，然后对照两者的思路发现略有不同，让我纠结不已，觉得有必要整理一下~现在看来，其实这些方法都殊途同归。</p>
<p>然后，写这个blog累死了，用typora打latex,然后blog wordpress再转成图片（现在用mathjax直接支持latex公式拉），看了一下字数9000左右了 好累/(ㄒoㄒ)/~~</p>
<p>所以觉得好的话可以进行<strong>打赏</strong> （逃</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《算法导论》第三版 第29章 线性规划</li>
<li><p>国科大计算机算法分析与设计 - <a target="_blank" rel="noopener" href="http://www.bioinfo.org.cn/%7Edbu/">Dongbo Bu</a></p>
<ul>
<li>线性规划课件 下载地址：<a target="_blank" rel="noopener" href="http://bioinfo.ict.ac.cn/%7Edbu/AlgorithmCourses/Lectures/Lec8.pdf">Lec8.pdf</a></li>
</ul></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>hrwhisper
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.hrwhisper.me/introduction-to-simplex-algorithm/" title="线性规划-单纯形算法详解">https://www.hrwhisper.me/introduction-to-simplex-algorithm/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        <div class="reward-container">
  <div>请我喝杯咖啡吧~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/donate/wechat_pay.png" alt="hrwhisper 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/donate/alipay.jpg" alt="hrwhisper 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/say-goodbye-to-the-past/" rel="prev" title="往事如烟">
      <i class="fa fa-chevron-left"></i> 往事如烟
    </a></div>
      <div class="post-nav-item">
    <a href="/diary-2016-12/" rel="next" title="还没想好标题？">
      还没想好标题？ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="nav-text">线性规划问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A1%8C%E5%9F%9F"><span class="nav-text">可行域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%A0%87%E5%87%86%E5%BD%A2%E5%BC%8F"><span class="nav-text">线性规划标准形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%9D%BE%E5%BC%9B%E5%BD%A2%E5%BC%8F"><span class="nav-text">线性规划松弛形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vs"><span class="nav-text">&lt;&#x3D; vs &lt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BE%8B%E5%AD%90"><span class="nav-text">单纯形算法的思想与例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%8C%96degeneracy"><span class="nav-text">退化(Degeneracy)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E7%95%8Cunbounded%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">无界(unbounded)的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-text">单纯形算法的具体实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E8%A7%A3-%E5%9F%BA%E6%9C%AC%E5%8F%AF%E8%A1%8C%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%97%A0%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">初始解 ≠ 基本可行解以及无解的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%97%E5%AD%90"><span class="nav-text">栗子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%97%E5%AD%901"><span class="nav-text">栗子1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%97%E5%AD%902"><span class="nav-text">栗子2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simplex-beta0.99%E6%B5%8B%E8%AF%95"><span class="nav-text">simplex beta0.99测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95"><span class="nav-text">完整的单纯形算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%87%A0%E4%BD%95%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%8D%95%E7%BA%AF%E5%BD%A2%E7%AE%97%E6%B3%95"><span class="nav-text">从几何角度看单纯形算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AA%E9%9C%80%E8%80%83%E8%99%91%E9%A1%B6%E7%82%B9"><span class="nav-text">只需考虑顶点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%BC%95%E5%85%A5%E7%9A%84%E8%AF%81%E6%98%8E"><span class="nav-text">一个引入的证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%A1%B6%E7%82%B9%E7%AD%89%E4%BB%B7%E4%BA%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E5%9F%BA"><span class="nav-text">多边形的顶点等价于矩阵的基</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E6%B8%B8%E8%B5%B0"><span class="nav-text">顶点的游走</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="nav-text">停止条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hrwhisper"
      src="/images/site/avatar.jpg">
  <p class="site-author-name" itemprop="name">hrwhisper</p>
  <div class="site-description" itemprop="description">一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">254</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hrwhisper" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hrwhisper" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/murmured" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;murmured" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
      <script data-ad-client="ca-pub-1580254183546533" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2013 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hrwhisper</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz","app_key":"b26lBsbwmVyxTSnNrsBrnv3U","server_url":null,"security":false};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      // script.setAttribute("data-pjax", "");
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz',
      appKey     : 'b26lBsbwmVyxTSnNrsBrnv3U',
      placeholder: "在上方填上邮箱地址可以收到我回复的邮件哦~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
