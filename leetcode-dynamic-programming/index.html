<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="c,c++,java,python,leetcode,algorithm,reading,life,moods,machine-learning,data-mining,deep-learning,AI" />
   
  <meta name="description" content="一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    leetcode 动态规划（DP） |  一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-leetcode-dynamic-programming"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  leetcode 动态规划（DP）
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/leetcode-dynamic-programming/" class="article-date">
  <time datetime="2015-03-08T03:04:16.000Z" itemprop="datePublished">2015-03-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/code/">code</a> / <a class="article-category-link" href="/categories/code/Leetcode/">Leetcode</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">10.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">61 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>本次题解包括</p>
<ul>
<li><strong>53</strong>. Maximum Subarray</li>
<li><strong>62</strong>. Unique Paths</li>
<li><strong>63</strong>. Unique Paths II</li>
<li><strong>64</strong>. Minimum Path Sum</li>
<li><strong>70</strong>. Climbing Stairs</li>
<li><strong>72</strong>. Edit Distance</li>
<li><strong>87</strong>. Scramble String</li>
<li><strong>91</strong> . Decode Ways</li>
<li><strong>97</strong>. Interleaving String</li>
<li><strong>115</strong> Distinct Subsequences</li>
<li><strong>120</strong>. Triangle</li>
<li><strong>139</strong>. Word Break</li>
<li><strong>140</strong>. Word Break II</li>
<li><strong>152</strong>. Maximum Product Subarray</li>
<li><strong>174</strong> . Dungeon Game</li>
<li><strong>198</strong>. House Robber</li>
<li><strong>213</strong> . House Robber II</li>
<li><strong>221</strong> . Maximal Square</li>
<li><strong>712</strong>. Minimum ASCII Delete Sum for Two Strings</li>
<li><strong>718</strong>. Maximum Length of Repeated Subarray</li>
<li><strong>799</strong>. Champagne Tower</li>
<li><strong>818</strong>. Race Car</li>
</ul>
<a id="more"></a>
<h3 id="53-maximum-subarray">53. Maximum Subarray</h3>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>
the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>
<p>More practice:</p>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">leetcode Maximum Subarray</a></p>
<p>题目大意：给定一串数字，要求求出连续的序列，使得这个连续序列的和最大</p>
<p>水水的DP~</p>
<p>当前和为sum,如果sum &gt;0,那么加上当前元素，否则sum=A[i] （即抛弃负数的sum，重新开始。因为负数的sum是累赘- -好难听的样子）</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int cur &#x3D; 0, ans &#x3D; nums[0];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            cur +&#x3D; nums[i];</span><br><span class="line">            if(cur &gt; ans)</span><br><span class="line">                ans &#x3D; cur;</span><br><span class="line">            if(cur &lt; 0)</span><br><span class="line">                cur &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ans, cur &#x3D; nums[0], 0</span><br><span class="line">        for x in nums:</span><br><span class="line">            cur +&#x3D; x</span><br><span class="line">            if cur &gt; ans:</span><br><span class="line">                ans &#x3D; cur</span><br><span class="line">            if cur &lt; 0:</span><br><span class="line">                cur &#x3D; 0</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>分治法</strong></p>
<p>《编程珠玑》里其实有讲过。 最大值要么在左边要么在中间，还有就是中间的情况</p>
<p>左右两边可以递归没什么好说的。</p>
<p>中间的就是从mid到left找最大的left_sum，以及从mid+1到right找最大的right_sum，就是left_sum + right_sum</p>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">divide_and_conquer</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> left = INT_MIN, right = left;</span><br><span class="line">		<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= l; --i) &#123;</span><br><span class="line">			cur += nums[i];</span><br><span class="line">			<span class="keyword">if</span> (cur &gt; left)</span><br><span class="line">				left = cur;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">			cur += nums[i];</span><br><span class="line">			<span class="keyword">if</span> (cur &gt; right)</span><br><span class="line">				right = cur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max(left + right, max(divide_and_conquer(l,mid,nums), divide_and_conquer(mid + <span class="number">1</span>, r, nums)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> divide_and_conquer(<span class="number">0</span>, nums.size() - <span class="number">1</span>, nums);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="62-unique-paths">62. Unique Paths</h3>
<blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt=""></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p><strong>Note:</strong><em>m</em> and <em>n</em> will be at most 100.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">leetcode Unique Paths</a></p>
<p>题目大意: :从m*n大小的图中左上方走到右下方，每次只能向右或者向下，问一共有多少种走法</p>
<p>思路：</p>
<ol>
<li>设dp[i][j]为到坐标为（i,j）的方法数，则有<code>dp[i][j]= dp[i-1][j]+dp[i][j-1]</code> 水~</li>
<li>这是看了discuss里面，有人用数学方法做的。 orz 原文如下:</li>
</ol>
<ul>
<li>It’s true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same).</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; ++i) dp[0][i] &#x3D; 1;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; ++i) dp[i][0] &#x3D; 1;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i)</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python方法1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @return an integer</span><br><span class="line">    def uniquePaths(self, m, n):</span><br><span class="line">        dp &#x3D;[[0 for i in range(n+1)]  for i in range(m+1)]</span><br><span class="line">        for i in range(1,n+1):</span><br><span class="line">            dp[1][i] &#x3D; 1</span><br><span class="line">        for i in range(2,m+1):</span><br><span class="line">            for j in range(1,n+1):</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]</span><br><span class="line">        return dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>Python 方法2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @return an integer</span><br><span class="line">    def uniquePaths(self, m, n):</span><br><span class="line">        return math.factorial(m+n-2)&#x2F;(math.factorial(n-1)*math.factorial(m-1))</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="63-unique-paths-ii">63. Unique Paths II</h3>
<blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>For example,</p>
<p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>The total number of unique paths is <code>2</code>.</p>
<p><strong>Note:</strong><em>m</em> and <em>n</em> will be at most 100.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths-ii/">leetcode Unique Paths II</a></p>
<p>题目大意: 和上面一题差不多，都是要求从左上角到右下角的方法数，只不过这题有障碍物，有障碍物的不能走。</p>
<p>思路：还是dp，就稍微改下即可。 设dp[i][j]为到坐标为（i,j）的方法数。对于(i,j):</p>
<ul>
<li>(i,j)为障碍物，则<code>dp[i][j]=0</code></li>
<li>(i,j)不为障碍物则 <code>dp[i][j]= dp[i-1][j]+dp[i][j-1]</code></li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid.empty()  obstacleGrid[0].empty()) return 0;</span><br><span class="line">        </span><br><span class="line">        int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        dp[0][0] &#x3D; obstacleGrid[0][0] ^ 1;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; ++i) dp[0][i] &#x3D; dp[0][i - 1] &amp; (!obstacleGrid[0][i]);</span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i) dp[i][0] &#x3D; dp[i - 1][0] &amp; (!obstacleGrid[i][0]);</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i)</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] &#x3D; obstacleGrid[i][j]? 0 : dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param obstacleGrid, a list of lists of integers</span><br><span class="line">    # @return an integer</span><br><span class="line">    def uniquePathsWithObstacles(self, obstacleGrid):</span><br><span class="line">        m , n &#x3D; len(obstacleGrid) , len(obstacleGrid[0])</span><br><span class="line">        dp &#x3D; [[0 for x in range(n+1)] for x in range(m+1)]</span><br><span class="line">        for j in range(1,n+1):</span><br><span class="line">            if obstacleGrid[0][j-1]:</span><br><span class="line">                break</span><br><span class="line">            else:</span><br><span class="line">                dp[1][j] &#x3D; 1</span><br><span class="line">                </span><br><span class="line">        for i in range(2,m+1):</span><br><span class="line">            for j in range(1,n+1):</span><br><span class="line">                if obstacleGrid[i-1][j-1]:</span><br><span class="line">                    dp[i][j] &#x3D; 0</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]</span><br><span class="line">        return dp[m][n]</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="64-minimum-path-sum">64. Minimum Path Sum</h3>
<blockquote>
<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">leetcode Minimum Path Sum</a></p>
<p>题目大意: m<em>n的格子中有m</em>n个非负整数，求从左上角到右下角中，经过的数字和的最小值（每次只能向右或者向下走）</p>
<p>思路:水题，其实和上面的也差不多。继续dp。</p>
<p>设dp[i][j]为当前到达坐标为(i,j)的最小和，<code>dp[i][j]=min(dp[i - 1][j], dp[i][j - 1]) + grid[i ][j ]</code>;</p>
<p>我的版本由于dp数组和grid坐标差了1所以为<code>min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</code>;</p>
<p>其实也可以O(N)的空间实现的。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        if(grid.empty()  grid[0].empty()) return 0;</span><br><span class="line">        </span><br><span class="line">        int m &#x3D; grid.size(), n &#x3D; grid[0].size(); </span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        </span><br><span class="line">        dp[0][0] &#x3D; grid[0][0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; n; ++i) dp[0][i] &#x3D; dp[0][i - 1] + grid[0][i];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i) dp[i][0] &#x3D; dp[i - 1][0] + grid[i][0];</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i)</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; ++j)</span><br><span class="line">                dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">        </span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>版本2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123;</span><br><span class="line">int m &#x3D; grid.size(), n &#x3D; grid[0].size();</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0x7ffffff));</span><br><span class="line">dp[0][1] &#x3D; dp[1][0] &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];</span><br><span class="line">return dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param grid, a list of lists of integers</span><br><span class="line">    # @return an integer</span><br><span class="line">    def minPathSum(self, grid):</span><br><span class="line">        m , n &#x3D; len(grid) , len(grid[0])</span><br><span class="line">        dp &#x3D; [[0x7fffffff for x in range(n+1)] for x in range(m+1)]</span><br><span class="line">        dp[0][1] &#x3D; dp[1][0] &#x3D; 0             </span><br><span class="line">        for i in range(1,m+1):</span><br><span class="line">            for j in range(1,n+1):</span><br><span class="line">                dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1]</span><br><span class="line">        return dp[m][n]</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="70-climbing-stairs">70. Climbing Stairs</h3>
<blockquote>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.<br>
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br>
Note: Given n will be a positive integer.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">leetcode Climbing Stairs</a></p>
<p>题目大意: 爬楼梯，每次可以爬一步或者两步，求从1爬到n的方法数</p>
<p>思路：水~  <code>dp[i] = dp[i - 1] + dp[i - 2];</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; f(n + 1, 0);</span><br><span class="line">        f[1] &#x3D; 1;</span><br><span class="line">        f[2] &#x3D; 2;</span><br><span class="line">        f[3] &#x3D; 3;</span><br><span class="line">        if(n &lt;&#x3D; 3) return f[n];</span><br><span class="line">        for(int i &#x3D; 4; i &lt;&#x3D; n; ++i)</span><br><span class="line">            f[i] &#x3D; f[i - 1] + f[i - 2];</span><br><span class="line">        return f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但只需三个变量即可。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int climbStairs(int n) &#123;</span><br><span class="line">		int zero &#x3D; 0, one &#x3D; 1, two&#x3D;1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">			two &#x3D; zero + one;</span><br><span class="line">			zero &#x3D; one;</span><br><span class="line">			one &#x3D; two;</span><br><span class="line">		&#125;</span><br><span class="line">		return two;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def climbStairs(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        zero, one, two &#x3D; 0, 1, 1</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            two &#x3D; zero + one</span><br><span class="line">            zero, one &#x3D; one, two</span><br><span class="line">        return two</span><br></pre></td></tr></table></figure>
<p>还可以用矩阵快速幂的方法:</p>
<p>设Q^n如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Q</mi><mi>n</mi></msup><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mi>n</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mi>n</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace><mtext>初始值</mtext><msup><mi>Q</mi><mn>1</mn></msup><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">Q^n = \left[
\begin{matrix}
f_{n+1} &amp; f_{n} \\
f_{n} &amp; f_{n-1} \\
\end{matrix}
\right]
\\
初始值Q^1=
\left[
\begin{matrix}
1 &amp;1 \\
1 &amp; 0 \\
\end{matrix}
\right]
\\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9088319999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">初</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">值</span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span><span class="mspace newline"></span></span></span></span></p>
<p>可以用数学归纳法证明：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: alignat at position 7: \begin{̲a̲l̲i̲g̲n̲a̲t̲}̲{2}Q^k &amp;= \left…'>\begin{alignat}{2}Q^k &amp;= \left[
\begin{matrix}
f_{k+1} &amp; f_{k} \\
f_{k} &amp; f_{k-1} \\
\end{matrix}
\right]
\end{alignat}</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: alignat at position 7: \begin{̲a̲l̲i̲g̲n̲a̲t̲}̲{2}Q^{k+1} &amp;=
\…'>\begin{alignat}{2}Q^{k+1} &amp;=
\left[
\begin{matrix}
f_{k+1} &amp; f_{k} \\
f_{k} &amp; f_{k-1} \\
\end{matrix}
\right]
\left[
\begin{matrix}
1 &amp;1 \\
1 &amp; 0 \\
\end{matrix}
\right]
\\&amp; =
\left[
\begin{matrix}
f_{k+1}+f_{k} &amp;f_{k+1} \\
f_{k+1} &amp; f_{k} \\
\end{matrix}
\right]
\\&amp; =
\left[
\begin{matrix}
f_{k+2} &amp;f_{k+1} \\
f_{k+1} &amp; f_{k} \\
\end{matrix}
\right]
\end{alignat}</p>
<p>C++ 复杂度O(Logn)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; f &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans(f);</span><br><span class="line">        while(n)&#123;</span><br><span class="line">            if(n &amp; 1)</span><br><span class="line">                ans &#x3D; mul(ans, f);</span><br><span class="line">            f &#x3D; mul(f, f);</span><br><span class="line">            n &gt;&gt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans[0][1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; mul(const vector&lt;vector&lt;int&gt;&gt; &amp;a, const vector&lt;vector&lt;int&gt;&gt; &amp;b)&#123;</span><br><span class="line">       vector&lt;vector&lt;int&gt;&gt; res(a.size(), vector&lt;int&gt;(b[0].size(), 0));</span><br><span class="line">        for(int i &#x3D; 0; i &lt; a.size(); ++i)</span><br><span class="line">            for(int j &#x3D; 0; j &lt; a[0].size(); ++j)</span><br><span class="line">                for(int k &#x3D; 0; k &lt; b.size(); ++k)</span><br><span class="line">                    res[i][j] +&#x3D; a[i][k] * b[k][j];</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="72-edit-distance">72. Edit Distance</h3>
<blockquote>
<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>
b) Delete a character<br>
c) Replace a character</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/edit-distance/">leetcode Edit Distance</a></p>
<p>题目大意：给定两个字符串，求他们的编辑距离（即可以插入、修改、删除一个字符，用最少的步数使得一个字符串变为另一个字符串）</p>
<p>思路:设dp[i][j]为以i和j结尾的字符串的编辑距离。</p>
<ul>
<li>
<p>if word[i] == word[j] ： <code>dp[i][j] = dp[i-1][j-1]</code></p>
</li>
<li>
<p>if word[i] != word[j] ： <code>dp[i][j]  </code>下面三个数的最小值+1：</p>
<ul>
<li><code>dp[i-1][j]   </code>可以看为<code>word1[i-1]</code>然后插入一个字符（<code>word2[j]</code>),或者说删掉 <code>word2[j]</code></li>
<li><code>dp[i][j-1]</code>   可以看为<code>word2[j-1]</code>然后插入一个数(<code>word1[i]</code>)，或者说删掉 <code>word1[i]</code></li>
<li><code>dp[i-1][j-1] </code>把<code>word1[i] </code>改为<code>word2[j]</code>，或者<code>word2[j]</code>改为<code>word1[i]</code></li>
</ul>
</li>
</ul>
<p>还可以只用O(n)空间, 见java版本。其他语言其实类似，不想写了。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"> public:</span><br><span class="line">	 int minDistance(string word1, string word2) &#123;</span><br><span class="line">		 int m &#x3D; word1.size(), n &#x3D; word2.size();</span><br><span class="line">		 vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0));</span><br><span class="line">		 for (int i &#x3D; 1; i &lt;&#x3D; m; i++) dp[i][0] &#x3D; i;</span><br><span class="line">		 for (int j &#x3D; 1; j &lt;&#x3D; n; j++) dp[0][j] &#x3D; j;</span><br><span class="line">		 for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		 &#123;</span><br><span class="line">			 for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			 &#123;</span><br><span class="line">				 if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])</span><br><span class="line">					 dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">				 else</span><br><span class="line">					 dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 return dp[m][n];</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minDistance(self, word1, word2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type word1: str</span><br><span class="line">        :type word2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]</span><br><span class="line">        for i in range(len(word1) + 1): dp[i][0] &#x3D; i</span><br><span class="line">        for j in range(len(word2) + 1): dp[0][j] &#x3D; j</span><br><span class="line"></span><br><span class="line">        for i in range(1, len(word1) + 1):</span><br><span class="line">            for j in range(1, len(word2) + 1):</span><br><span class="line">                if word1[i - 1] &#x3D;&#x3D; word2[j - 1]:</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] &#x3D; min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1</span><br><span class="line">        return dp[-1][-1]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<p><strong>Java</strong></p>
<p>因为只用到左上方，左边，和上边的元素，所以可以只用两个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[] dp &#x3D; new int[word2.length() + 1];</span><br><span class="line">        for (int j &#x3D; 0; j &lt;&#x3D; word2.length(); j++) dp[j] &#x3D; j;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; word1.length(); i++) &#123;</span><br><span class="line">            int[] ndp &#x3D; new int[word2.length() + 1];</span><br><span class="line">            ndp[0] &#x3D; i;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; word2.length(); j++) &#123;</span><br><span class="line">                if (word1.charAt(i - 1) &#x3D;&#x3D; word2.charAt(j - 1))</span><br><span class="line">                    ndp[j] &#x3D; dp[j - 1];</span><br><span class="line">                else</span><br><span class="line">                    ndp[j] &#x3D; Math.min(ndp[j - 1], Math.min(dp[j - 1], dp[j])) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            dp &#x3D; ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="87-scramble-string">87. Scramble String</h3>
<blockquote>
<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    great</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  gr    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    eat</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           &#x2F; \</span><br><span class="line">          a   t</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  rg    tae</span><br><span class="line"> &#x2F; \    &#x2F;  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       &#x2F; \</span><br><span class="line">      t   a</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p>
<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/scramble-string/">leetcode Scramble String</a></p>
<p>题目大意：给定两个字符串s1和s2，判断s2是否是s1经过旋转得到的。</p>
<p>思路：</p>
<p>根据题目的描述，我们可以枚举切分点i,然后递归判断:</p>
<ul>
<li>s1[0, i-1]和s2[0, i-1] 是否可以旋转得到，并且s1[i, n - 1]和s2[i, n- 1] 也要能旋转得到</li>
<li>或者s1[0, i - 1]和s2[n - i, n - 1] 是否可以旋转得到，并且s1[i, n- 1]和s2[0, n - i] 也要能旋转得到</li>
</ul>
<p>可以用记忆化搜索防止重复搜索，还可以用排序剪枝（看看当前的s1和s2排序后是否相等）</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    bool judge(string s1, string s2, unordered_map&lt;string, bool&gt; &amp;vis)&#123;</span><br><span class="line">        if(s1.size() !&#x3D; s2.size()) return false;</span><br><span class="line">        if(s1 &#x3D;&#x3D; s2) return true;</span><br><span class="line">        if(vis.find(s1 + s2) !&#x3D; vis.end()) return vis[s1 + s2];</span><br><span class="line">        </span><br><span class="line">        string t1(s1), t2(s2);</span><br><span class="line">        sort(t1.begin(), t1.end());</span><br><span class="line">        sort(t2.begin(), t2.end());</span><br><span class="line">        </span><br><span class="line">        if(t1 &#x3D;&#x3D; t2)&#123;</span><br><span class="line">            for(int i &#x3D; 1; i &lt; s2.size(); ++i)&#123;</span><br><span class="line">                if(judge(s1.substr(0, i), s2.substr(0, i), vis) &amp;&amp;</span><br><span class="line">                  judge(s1.substr(i), s2.substr(i), vis))</span><br><span class="line">                    return true;</span><br><span class="line">                if(judge(s1.substr(0, i), s2.substr(s2.size() - i), vis) &amp;&amp;</span><br><span class="line">                  judge(s1.substr(i), s2.substr(0, s2.size() - i), vis))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vis[s1 + s2] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    bool isScramble(string s1, string s2) &#123;</span><br><span class="line">        unordered_map&lt;string, bool&gt; vis;</span><br><span class="line">        return judge(s1, s2, vis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def judge(self, s1, s2, dp):</span><br><span class="line">        if (s1, s2) in dp:</span><br><span class="line">            return dp[s1, s2]</span><br><span class="line">        if s1 &#x3D;&#x3D; s2:</span><br><span class="line">            dp[s1, s2] &#x3D; True</span><br><span class="line">            return True</span><br><span class="line">        </span><br><span class="line">        if sorted(s1) !&#x3D; sorted(s2):</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        for i in range(1, len(s1)):</span><br><span class="line">            if self.judge(s1[:i], s2[:i], dp) and self.judge(s1[i:], s2[i:], dp) or \</span><br><span class="line">                    self.judge(s1[:i], s2[-i:], dp) and self.judge(s1[i:], s2[:-i], dp):</span><br><span class="line">                dp[s1, s2] &#x3D; True</span><br><span class="line">                return True</span><br><span class="line"></span><br><span class="line">        dp[s1, s2] &#x3D; False</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def isScramble(self, s1, s2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if len(s1) !&#x3D; len(s2): return False</span><br><span class="line">        dp &#x3D; &#123;&#125;</span><br><span class="line">        return self.judge(s1, s2, dp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="91-decode-ways">91. Decode Ways</h3>
<blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>
‘B’ -&gt; 2<br>
…<br>
‘Z’ -&gt; 26</p>
<p>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>
Given encoded message “12”,<br>
it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">leetcode Decode Ways</a></p>
<p>题目大意：给定一个数字组成的字符串，让你看有多少种解码方式</p>
<p>思路：</p>
<p>对于一个编码后的串s，s的所有的字符出现在0~9之间。</p>
<p>要查看其解码方式有多少种可能，主要在于因为有的字符可以被拆分，如12可以算L也可以算AB，而这样的在10~26均是可能的。</p>
<p>设dp[i]为s[0…i]最多的解码方式，因此我们有：</p>
<ul>
<li>若<code>s[i] !='0'</code> ,  <code>dp[i] += dp[i-1]</code></li>
<li>若<code>10 &lt;= s[i-1,i] &lt;=26</code> , <code>dp[i] += dp[i-2]</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def numDecodings(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not s: return 0</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        dp &#x3D; [0] * n</span><br><span class="line">        dp[0] &#x3D; 1 if s[0] !&#x3D; &#39;0&#39; else 0</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            if 10 &lt;&#x3D; int(s[i - 1:i + 1]) &lt;&#x3D; 26:</span><br><span class="line">                dp[i] +&#x3D; dp[i - 2] if i &gt;&#x3D; 2 else 1</span><br><span class="line">            if s[i] !&#x3D; &#39;0&#39;:</span><br><span class="line">                dp[i] +&#x3D; dp[i - 1]</span><br><span class="line">        return dp[n - 1]</span><br></pre></td></tr></table></figure>
<p><strong>C++</strong></p>
<p>感觉第二次写的C++版本更清晰一些。</p>
<ul>
<li>
<p>若<code>s[i] !='0' </code>,</p>
<ul>
<li><code>dp[i] += dp[i-1]</code></li>
<li>若<code>10 &lt;= s[i-1,i] &lt;=26 , dp[i] += dp[i-2]</code></li>
</ul>
</li>
<li>
<p><code>s[i] =='0'</code> ,</p>
<ul>
<li>看看是否能和前面的合并。不能就返回0，可以就是dp[i-2]</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int numDecodings(string s) &#123;</span><br><span class="line">		if (s[0] &lt;&#x3D; &#39;0&#39;)</span><br><span class="line">			return 0;</span><br><span class="line">		vector&lt;int&gt; dp(s.size(), 0);</span><br><span class="line">		dp[0] &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; s.size(); ++i) &#123;</span><br><span class="line">			if (s[i] &lt; &#39;0&#39; &amp;&amp; s[i] &gt; &#39;9&#39; || s[i] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; s[i - 1] &#x3D;&#x3D; &#39;0&#39;)</span><br><span class="line">				break;</span><br><span class="line">			if (s[i] !&#x3D; &#39;0&#39;)</span><br><span class="line">				dp[i] &#x3D; dp[i - 1];</span><br><span class="line">			if (s[i - 1] &#x3D;&#x3D; &#39;1&#39; || s[i - 1] &#x3D;&#x3D; &#39;2&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;6&#39;)</span><br><span class="line">				dp[i] +&#x3D; i &lt; 2 ? 1 : dp[i - 2];</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[s.size() - 1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="97-interleaving-string">97. Interleaving String</h3>
<blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>
Given:<br>
s1 = “aabcc”,<br>
s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>
When s3 = “aadbbbaccc”, return false.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/interleaving-string/">leetcode Interleaving String</a></p>
<p>题目大意：给定s1,s2,s3三个字符串，判断s3是否由s1和s2组成。</p>
<p>思路:设dp[i][j]为s1[i-1] , s2[j-1] 是否能组成 s3[i+j-1]</p>
<ul>
<li><code>dp[i][j] = s3[i+j-1]==s1[i-1] &amp;&amp; dp[i-1][j]   s3[i+j-1]==s2[j-1] &amp;&amp; dp[i][j-1]; </code> (尝试用<code>s1[i-1]</code>去匹配，故应该是<code>dp[i-1][j]</code>，同理用<code>s2[j-1]</code>去匹配）</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isInterleave(string s1, string s2, string s3) &#123;</span><br><span class="line">		if (s1.size() + s2.size() !&#x3D; s3.size()) return false;</span><br><span class="line">		vector&lt;vector&lt;bool&gt;&gt; dp(s1.size() + 1, vector&lt;bool&gt;(s2.size() + 1, false));</span><br><span class="line"></span><br><span class="line">		dp[0][0] &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; s1.size(); ++i)</span><br><span class="line">			dp[i][0] &#x3D; dp[i - 1][0] &amp;&amp; s3[i - 1] &#x3D;&#x3D; s1[i - 1];</span><br><span class="line"></span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; s2.size(); ++j)</span><br><span class="line">			dp[0][j] &#x3D; dp[0][j - 1] &amp;&amp; s3[j - 1] &#x3D;&#x3D; s2[j - 1];</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; s1.size(); ++i)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; s2.size(); ++j)</span><br><span class="line">				dp[i][j] &#x3D; (dp[i - 1][j] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] &#x3D;&#x3D; s2[j - 1]);</span><br><span class="line">		return dp[s1.size()][s2.size()];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isInterleave(self, s1, s2, s3):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :type s3: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        m, n &#x3D; len(s1), len(s2)</span><br><span class="line">        if len(s3) !&#x3D; m + n: return False</span><br><span class="line">        dp &#x3D; [[False] * (n + 1) for _ in range(m + 1)]</span><br><span class="line">        dp[0][0] &#x3D; True</span><br><span class="line">        for i in range(1, m + 1):</span><br><span class="line">            dp[i][0] &#x3D; dp[i - 1][0] and s1[i - 1] &#x3D;&#x3D; s3[i - 1]</span><br><span class="line">        for j in range(1, n + 1):</span><br><span class="line">            dp[0][j] &#x3D; dp[0][j - 1] and s2[j - 1] &#x3D;&#x3D; s3[j - 1]</span><br><span class="line"></span><br><span class="line">        for i in range(1, m + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                dp[i][j] &#x3D; (dp[i - 1][j] and s1[i - 1] &#x3D;&#x3D; s3[i + j - 1]) \</span><br><span class="line">                           or (dp[i][j - 1] and s2[j - 1] &#x3D;&#x3D; s3[i + j - 1])</span><br><span class="line">        return dp[m][n]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="115-distinct-subsequences">115. Distinct Subsequences</h3>
<blockquote>
<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>T</strong> in <strong>S</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>Here is an example:<br>
<strong>S</strong> = <code>&quot;rabbbit&quot;</code>, <strong>T</strong> = <code>&quot;rabbit&quot;</code></p>
<p>Return <code>3</code>.</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/distinct-subsequences/">leetcode Distinct Subsequences</a></p>
<p>题目大意：给定S和T两个字符串，问把通过删除S中的某些字符，把S变为T有几种方法？</p>
<p>思路：DP,设dp[i][j]为到S[i] T[j]位置的方法数：</p>
<ul>
<li><code>S[i]==T[j]</code>:  <code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1] </code> 两字符串相等，要么跳过不匹配，要么匹配</li>
<li><code>S[i]!=T[j]</code>:  <code>dp[i][j]= dp[i-1][j] </code>不相等只能不匹配这个</li>
</ul>
<p>初始值设置：</p>
<ul>
<li><code>dp[i][0] = dp[i - 1][0] + (s[i] == t[0])</code>  即t[0]可以被s表示的数量</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDistinct(string s, string t) &#123;</span><br><span class="line">        int m &#x3D; s.size(), n &#x3D; t.size();</span><br><span class="line">        if(n &gt; m) return 0;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 0; i &lt; m; ++i)</span><br><span class="line">            dp[i][0] &#x3D; (s[i] &#x3D;&#x3D; t[0]) + (i &gt; 0? dp[i - 1][0] : 0);</span><br><span class="line">            </span><br><span class="line">        for(int i &#x3D; 1; i &lt; m; ++i)&#123;</span><br><span class="line">            for(int j &#x3D; 1; j &lt; n; ++j)&#123;</span><br><span class="line">                if(s[i] &#x3D;&#x3D; t[j])</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种写法：</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int numDistinct(string s, string t) &#123;</span><br><span class="line">		int m &#x3D; s.size(), n &#x3D; t.size();</span><br><span class="line">		vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; m; i++) dp[i][0] &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				if (s[i - 1] &#x3D;&#x3D; t[j - 1])</span><br><span class="line">					dp[i][j] &#x3D; dp[i - 1][j] + dp[i - 1][j - 1];</span><br><span class="line">				else</span><br><span class="line">					dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[m][n];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @return an integer</span><br><span class="line">    def numDistinct(self, S, T):</span><br><span class="line">        m , n &#x3D; len(S),len(T)</span><br><span class="line">        dp &#x3D;[[0 for j in range(n+1)]for i in range(m+1)]</span><br><span class="line">        for i in xrange(0,m+1): dp[i][0]&#x3D;1</span><br><span class="line">    </span><br><span class="line">        for i in xrange(1,m+1):</span><br><span class="line">            for j in xrange(1,n+1):</span><br><span class="line">                if S[i-1]&#x3D;&#x3D;T[j-1]:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j]</span><br><span class="line"></span><br><span class="line">        return dp[m][n]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="120-triangle">120. Triangle</h3>
<blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:</p>
<ul>
<li>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</li>
</ul>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/triangle/">leetcode Triangle</a></p>
<p>题目大意：给定一个三角形，求其从顶部到底部最小的和。</p>
<p>思路：DP，可以从上往下也可以从下往上</p>
<p>从下往上的版本:</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        if(triangle.empty()  triangle[0].empty()) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(triangle.back());</span><br><span class="line">        for(int i &#x3D; triangle.size() - 2; i &gt;&#x3D; 0; --i)</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)</span><br><span class="line">                dp[j] &#x3D; min(dp[j], dp[j + 1]) + triangle[i][j];</span><br><span class="line">        </span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minimumTotal(self, triangle):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; triangle[-1]</span><br><span class="line">        for i in range(len(triangle) - 2, -1, -1):</span><br><span class="line">            next_dp &#x3D; [0] * len(triangle[i])  </span><br><span class="line">            for j in range(i + 1):</span><br><span class="line">                next_dp[j] &#x3D; min(dp[j], dp[j + 1]) + triangle[i][j]</span><br><span class="line">            dp &#x3D; next_dp</span><br><span class="line">        return dp[0]</span><br></pre></td></tr></table></figure>
<p>从下往上的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;</span><br><span class="line">        if(triangle.empty()  triangle[0].empty()) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(triangle.size() + 1, INT_MAX);</span><br><span class="line">        dp[0] &#x3D; triangle[0][0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; triangle.size(); ++i)&#123;</span><br><span class="line">            vector&lt;int&gt; next(triangle.size() + 1, INT_MAX);</span><br><span class="line">            for(int j &#x3D; 0; j &lt;&#x3D; i; ++j)</span><br><span class="line">                next[j] &#x3D; min((j &gt; 0? dp[j - 1]:INT_MAX), dp[j]) + triangle[i][j];</span><br><span class="line">            dp &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return *min_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="139-word-break">139. Word Break</h3>
<blockquote>
<p>Given a string <em>s</em> and a dictionary of words <em>dict</em>, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>
<em>s</em> = <code>&quot;leetcode&quot;</code>,<br>
<em>dict</em> = <code>[&quot;leet&quot;, &quot;code&quot;]</code>.</p>
<p>Return true because <code>&quot;leetcode&quot;</code> can be segmented as <code>&quot;leet code&quot;</code>.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/word-break/">传送门</a></p>
<p>题意：给定一个字符串s和字典，判断字符串s是否能拆成仅由字典组成的若干个单词？</p>
<p>思路：dp ，设dp[i]为 [0,i-1]是否能拆分</p>
<ul>
<li><code>dp[i+1]= true  dp[j] =true &amp;&amp; s[j,i]在字典中</code>）</li>
</ul>
<p>1A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def wordBreak(self, s, wordDict):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n , dp &#x3D; len(s),[True] + [False]*len(s)</span><br><span class="line">        for i in xrange(n):</span><br><span class="line">            for j in xrange(i+1):</span><br><span class="line">                if dp[j] and s[j:i+1] in wordDict:</span><br><span class="line">                    dp[i+1]&#x3D;True</span><br><span class="line">                    break</span><br><span class="line">        return dp[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="140-word-break-ii">140. Word Break II</h3>
<blockquote>
<p>Given a string <em>s</em> and a dictionary of words <em>dict</em>, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>
<em>s</em> = <code>&quot;catsanddog&quot;</code>,<br>
<em>dict</em> = <code>[&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</code>.</p>
<p>A solution is <code>[&quot;cats and dog&quot;, &quot;cat sand dog&quot;]</code>.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/word-break-ii/">传送门</a></p>
<p>题意：给定一个字符串s和字典，将字符串s拆成仅由字典组成的若干个单词，返回所有的解</p>
<p>思路：在DFS的过程中，判断接下来的过程中是否有解。（就是进行剪枝操作啦），判断是否有解类似139那题。</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def wordBreak(self, s, wordDict):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        if self.check(s, wordDict):</span><br><span class="line">            self.dfs(0, len(s), &#39;&#39;, s, ans, wordDict)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def check(self, s, wordDict):</span><br><span class="line">        dp &#x3D; [True] + [False] * len(s)</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        for i in xrange(n):</span><br><span class="line">            for j in xrange(i + 1):</span><br><span class="line">                if dp[j] and s[j:i + 1] in wordDict:</span><br><span class="line">                    dp[i + 1] &#x3D; True</span><br><span class="line">                    break</span><br><span class="line">        return dp[n]</span><br><span class="line"></span><br><span class="line">    def dfs(self, cur, n, path, s, ans, wordDict):</span><br><span class="line">        if cur &#x3D;&#x3D; n:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for i in xrange(cur, n):</span><br><span class="line">            if s[cur:i + 1] in wordDict and self.check(s[i + 1:n], wordDict):</span><br><span class="line">                if path:</span><br><span class="line">                    self.dfs(i + 1, n, path + &#39; &#39; + s[cur:i + 1], s, ans, wordDict)</span><br><span class="line">                else:</span><br><span class="line">                    self.dfs(i + 1, n, s[cur:i + 1], s, ans, wordDict)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="152-maximum-product-subarray">152. Maximum Product Subarray</h3>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,<br>
the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">传送门</a></p>
<p>题意：给定一个数组，求连续的乘积最大值。</p>
<p>思路：dp，设f(k)为乘积最大序列，g(k)为成绩最小序列，则有</p>
<ul>
<li><code>f(k) = max( A[k] , f(k-1) * A[k], A[k], g(k-1) * A[k] )</code></li>
<li><code>g(k) = min(A[k],   g(k-1) * A[k], A[k], f(k-1) * A[k] )</code></li>
</ul>
<p>之所以要维护一个最小的序列，是因为负数*负数变成正数，此时可能为最大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param A, a list of integers</span><br><span class="line">    # @return an integer</span><br><span class="line">    def maxProduct(self, A):</span><br><span class="line">        maxMul &#x3D; minMul &#x3D; ans &#x3D; A[0]</span><br><span class="line">        for i in range(1, len(A)):</span><br><span class="line">            t &#x3D; maxMul</span><br><span class="line">            maxMul &#x3D; max(t * A[i], minMul * A[i], A[i])</span><br><span class="line">            minMul &#x3D; min(t * A[i], minMul * A[i], A[i])</span><br><span class="line">            ans &#x3D; max(maxMul, ans)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="174-dungeon-game">174. Dungeon Game</h3>
<blockquote>
<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0’s</em>) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<table>
<thead>
<tr>
<th>-2 (K)</th>
<th>-3</th>
<th>-3</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>-10</td>
<td>30</td>
<td>-5 §</td>
</tr>
</tbody>
</table>
<p><strong>Notes:</strong></p>
<ul>
<li>The knight’s health has no upper bound.</li>
<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li>
</ul>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/dungeon-game/">leetcode Dungeon Game</a></p>
<p>题目大意：一个骑士从左上角出发，要到达右下角拯救公主，每个格子中有正数表示可以增加的生命值，负数表示减少的生命。如果生命值为0，那么骑士就死翘翘了。你的任务是帮骑士计算到达右下角的最小生命值。</p>
<p>思路：DP，设dp[i][j]为到达(i,j)需要的最少生命值。则有：</p>
<ul>
<li><code>dp[i][j]= max(1, min(dp[i+1][j],dp[i][j+1])-dungeon[i][j])</code></li>
</ul>
<p>即，从右下角到左上角进行计算。对于dungeon为正数，那么减去，说明生命值可以少一些到达这个格子（但是不能小于等于0），对于负数，减去一个负数意味着加上这个数的绝对值，即需要的生命数增加。</p>
<p>为什么是右下角到左上角而不是左上到右下呢？</p>
<p>如果途中遇到一个很大的正数，它就会覆盖掉你之前走过的所有信息。（变为0），这样的结果是错误的。</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123;</span><br><span class="line">		if (dungeon.empty())</span><br><span class="line">			return 0;</span><br><span class="line">		int m &#x3D; dungeon.size(), n &#x3D; dungeon[0].size();</span><br><span class="line">		vector&lt;vector&lt;long long&gt;&gt; dp(m + 1, vector&lt;long long&gt;(n + 1, INT_MAX));</span><br><span class="line">        dp[m - 1][n] &#x3D; dp[m][n - 1] &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; m - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">			for (int j &#x3D; n - 1; j &gt;&#x3D; 0; --j) &#123;</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j];</span><br><span class="line">                if(dp[i][j] &lt;&#x3D; 0)</span><br><span class="line">                    dp[i][j] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[0][0];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def calculateMinimumHP(self, dungeon):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type dungeon: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not dungeon: return 0</span><br><span class="line">        m, n &#x3D; len(dungeon), len(dungeon[0])</span><br><span class="line">        dp &#x3D; [[0x7ffffff] * (n + 1) for _ in range(m + 1)]</span><br><span class="line">        dp[m - 1][n] &#x3D; dp[m][n - 1] &#x3D; 1</span><br><span class="line">        for i in range(m - 1, -1, -1):</span><br><span class="line">            for j in range(n - 1, -1, -1):</span><br><span class="line">                dp[i][j] &#x3D; max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])</span><br><span class="line">        return dp[0][0]</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="198-house-robber">198. House Robber</h3>
<blockquote>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">传送门</a></p>
<p>题意：要求从一串数字中选取一些数，使得和最大（相邻不能两两）</p>
<p>思路：<code>dp[i]</code>为到i能获得的最大值</p>
<ul>
<li>i选择，那么只能<code>dp[i-2]+num[i]</code></li>
<li>i不选，那么<code>dp[i-1]</code></li>
</ul>
<p>所以有：<code>dp[i]=max(dp[i-1],dp[i-2]+num[i])</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param num, a list of integer</span><br><span class="line">    # @return an integer</span><br><span class="line">    def rob(self, num):</span><br><span class="line">        if not num: return 0</span><br><span class="line">        n &#x3D; len(num)</span><br><span class="line">        if n&#x3D;&#x3D;1: return num[0]</span><br><span class="line">        dp &#x3D; [0]*n</span><br><span class="line">        dp[0],dp[1] &#x3D; num[0],max(num[1],num[0])</span><br><span class="line">        for i in xrange(2,n):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1],dp[i-2]+num[i])</span><br><span class="line">        return dp[n-1]</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="213-house-robber-ii">213. House Robber II</h3>
<blockquote>
<p><strong>Note:</strong> This is an extension of <a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">House Robber</a>.</p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-ii/">传送门</a></p>
<p>题意：和198. House Robber差别在于，这题要求首尾不能同时取到。</p>
<p>思路：和上一题其实一样的，我们只需要考虑[0,n-2]和[1,n-1]两个中最大值即可。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;integer[]&#125; nums</span><br><span class="line">    # @return &#123;integer&#125;</span><br><span class="line">    def rob(self, num):</span><br><span class="line">        if not num: return 0</span><br><span class="line">        n &#x3D; len(num)</span><br><span class="line">        if n&#x3D;&#x3D;1: return num[0]</span><br><span class="line">        return max(self.solve(num[1:]),self.solve(num[:-1]))</span><br><span class="line">    </span><br><span class="line">    def solve(self,num):</span><br><span class="line">        if not num: return 0</span><br><span class="line">        n &#x3D; len(num)</span><br><span class="line">        if n&#x3D;&#x3D;1: return num[0]</span><br><span class="line">        dp &#x3D; [0]*n</span><br><span class="line">        dp[0],dp[1] &#x3D; num[0],max(num[1],num[0])</span><br><span class="line">        for i in xrange(2,n):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1],dp[i-2]+num[i])</span><br><span class="line">        return dp[n-1]</span><br></pre></td></tr></table></figure>
<p></p>
<h3 id="221-maximal-square">221. Maximal Square</h3>
<blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing all 1’s and return its area.</p>
<p>For example, given the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Return 4.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximal-square/">传送门</a></p>
<p>题意：给定2D矩阵，求里面1构成的正方形的最大面积。</p>
<p>思路：dp</p>
<ul>
<li><code>if matrix[i][j]=='1'  dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</code></li>
<li><code>else dp[i][j] = 0</code></li>
</ul>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # @param &#123;character[][]&#125; matrix</span><br><span class="line">    # @return &#123;integer&#125;</span><br><span class="line">    def maximalSquare(self, matrix):</span><br><span class="line">        if not matrix: return 0</span><br><span class="line">        m , n &#x3D; len(matrix),len(matrix[0])</span><br><span class="line">        dp &#x3D; [[0 if matrix[i][j]&#x3D;&#x3D;&#39;0&#39; else 1for j in xrange(n)]for i in xrange(m)]</span><br><span class="line">        </span><br><span class="line">        for i in xrange(1,m):</span><br><span class="line">            for j in xrange(1,n):</span><br><span class="line">                if matrix[i][j] &#x3D;&#x3D;&#39;1&#39;: dp[i][j] &#x3D; min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</span><br><span class="line">                else: dp[i][j] &#x3D; 0</span><br><span class="line">        </span><br><span class="line">        ans &#x3D; max([max(i) for i in dp])</span><br><span class="line">        return ans ** 2</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="712-minimum-ascii-delete-sum-for-two-strings">712. Minimum ASCII Delete Sum for Two Strings</h3>
<blockquote>
<p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**Input:** s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;</span><br><span class="line">**Output:** 231</span><br><span class="line">**Explanation:** Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.</span><br><span class="line">Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.</span><br><span class="line">At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**Input:** s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;</span><br><span class="line">**Output:** 403</span><br><span class="line">**Explanation:** Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,</span><br><span class="line">adds 100[d]+101[e]+101[e] to the sum.  Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.</span><br><span class="line">At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.</span><br><span class="line">If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li><code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</li>
<li>All elements of each string will have an ASCII value in <code>[97, 122]</code>.</li>
</ul>
<p></p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/">leetcode Minimum ASCII Delete Sum for Two Strings</a></p>
<p>题目大意：给定两个字符串，要求删掉一些字母，使得它们相等。要求删除字母的ASCII码的和最小。</p>
<p>思路：</p>
<p>显然，删掉的字母越少越好，自然就想到了求最长公共子串。这样，答案就是 两个字符串的ASCII码的和 - 公共子串ASCII码的和 * 2</p>
<p>如果有多个子串的话，就取和最大那个即可。</p>
<p>于是，可以类似LCS的解法，设dp[i][j]为s1前i个字符和s2前j个字符的最大公共子串的ASCII码的最大的和</p>
<p>于是有：</p>
<ul>
<li><code>s1[i] == s2[j] :    dp[i][j] = dp[i-1][j-1] + ascii(s1[i])</code></li>
<li><code>s1[i] != s2[j] :    dp[i][j] = max(dp[i-1][j], dp[i][j - 1])</code></li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minimumDeleteSum(string s1, string s2) &#123;</span><br><span class="line">        int two_string_sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s1.length(); i++) two_string_sum +&#x3D; s1[i];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s2.length(); i++) two_string_sum +&#x3D; s2[i];</span><br><span class="line"></span><br><span class="line">        if (s1.empty()  s2.empty())  return two_string_sum;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(s1.size(),vector&lt;int&gt;(s2.size(),0));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s1.size(); i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; s1[i] &#x3D;&#x3D; s2[0] ? s1[i] : 0;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; dp[i - 1][0] &gt; dp[i][0]) dp[i][0] &#x3D; dp[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; s2.size(); j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; s1[0] &#x3D;&#x3D; s2[j] ? s2[j] : 0;</span><br><span class="line">            if (j &gt; 0 &amp;&amp; dp[0][j - 1] &gt; dp[0][j]) dp[0][j] &#x3D; dp[0][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt; s1.size(); i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; s2.size(); j++) &#123;</span><br><span class="line">                if (s1[i] &#x3D;&#x3D; s2[j])</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1] + s1[i];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return two_string_sum - (dp[s1.size() - 1][s2.size() - 1] &lt;&lt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minimumDeleteSum(String s1, String s2) &#123;</span><br><span class="line">        int twoStringSum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s1.length(); i++) twoStringSum +&#x3D; s1.charAt(i);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s2.length(); i++) twoStringSum +&#x3D; s2.charAt(i);</span><br><span class="line"></span><br><span class="line">        if (s1.isEmpty()  s2.isEmpty())</span><br><span class="line">            return twoStringSum;</span><br><span class="line"></span><br><span class="line">        int[][] dp &#x3D; new int[s1.length()][s2.length()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            dp[i][0] &#x3D; s1.charAt(i) &#x3D;&#x3D; s2.charAt(0) ? s1.charAt(i) : 0;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; dp[i - 1][0] &gt; dp[i][0]) dp[i][0] &#x3D; dp[i - 1][0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; s2.length(); j++) &#123;</span><br><span class="line">            dp[0][j] &#x3D; s1.charAt(0) &#x3D;&#x3D; s2.charAt(j) ? s2.charAt(j) : 0;</span><br><span class="line">            if (j &gt; 0 &amp;&amp; dp[0][j - 1] &gt; dp[0][j]) dp[0][j] &#x3D; dp[0][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt; s1.length(); i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt; s2.length(); j++) &#123;</span><br><span class="line">                if (s1.charAt(i) &#x3D;&#x3D; s2.charAt(j))</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1] + s1.charAt(i);</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return twoStringSum - (dp[s1.length() - 1][s2.length() - 1] &lt;&lt; 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def minimumDeleteSum(self, s1, s2):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        two_sum &#x3D; sum(ord(c) for c in s1) + sum(ord(c) for c in s2)</span><br><span class="line">        if not s1 or not s2: return two_sum</span><br><span class="line"></span><br><span class="line">        dp &#x3D; [[0] * len(s2) for _ in range(len(s1))]</span><br><span class="line">        dp[0][0] &#x3D; ord(s1[0]) if s1[0] &#x3D;&#x3D; s2[0] else 0</span><br><span class="line"></span><br><span class="line">        for i in range(1, len(s1)):</span><br><span class="line">            dp[i][0] &#x3D; max(dp[i - 1][0], ord(s1[i])) if s1[i] &#x3D;&#x3D; s2[0] else dp[i - 1][0]</span><br><span class="line">        for j in range(1, len(s2)):</span><br><span class="line">            dp[0][j] &#x3D; max(dp[0][j - 1], ord(s2[j])) if s1[0] &#x3D;&#x3D; s2[j] else dp[0][j - 1]</span><br><span class="line"></span><br><span class="line">        for i in range(1, len(s1)):</span><br><span class="line">            for j in range(1, len(s2)):</span><br><span class="line">                if s1[i] &#x3D;&#x3D; s2[j]:</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1] + ord(s1[i])</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1])</span><br><span class="line">        return two_sum - (dp[-1][-1] &lt;&lt; 1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="718-maximum-length-of-repeated-subarray">718. Maximum Length of Repeated Subarray</h3>
<blockquote>
<p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**Input:**</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">**Output:** 3</span><br><span class="line">**Explanation:** </span><br><span class="line">The repeated subarray with maximum length is [3, 2, 1].</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ol>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/">leetcode Maximum Length of Repeated Subarray</a></p>
<p>题目大意: 给定两个数组A和B，求他们最大的公共子数组。</p>
<p>思路：</p>
<p>类似于LCS，这题也是DP</p>
<p>设<code>dp[i][j] </code>为以<code>A[i],B[j] </code>结尾的最大公共子数组的长度。</p>
<p>于是有</p>
<ul>
<li><code>if A[i - 1] == B[j - 1]   dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li><code>A[i - 1] != B[j - 1]    dp[i][j] = 0</code></li>
</ul>
<p>ans则为dp数组的最大值</p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLength(int[] A, int[] B) &#123;</span><br><span class="line">        if (A.length &#x3D;&#x3D; 0  B.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        int[][] dp &#x3D; new int[A.length + 1][B.length + 1];</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; A.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; B.length; j++) &#123;</span><br><span class="line">                dp[i][j] &#x3D; A[i - 1] &#x3D;&#x3D; B[j - 1] ? dp[i - 1][j - 1] + 1 : 0;</span><br><span class="line">                ans &#x3D; Math.max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p>
<p>还可以用滚动数组优化空间复杂度O(n)</p>
<p><strong>Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLength(int[] A, int[] B) &#123;</span><br><span class="line">        if (A.length &#x3D;&#x3D; 0  B.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        int[] dp &#x3D; new int[B.length + 1];</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; A.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; B.length; j &gt;&#x3D; 1; j--) &#123;</span><br><span class="line">                dp[j] &#x3D; A[i - 1] &#x3D;&#x3D; B[j - 1] ? dp[j - 1] + 1 : 0;</span><br><span class="line">                ans &#x3D; Math.max(ans, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def findLength(self, A, B):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type A: List[int]</span><br><span class="line">        :type B: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; [0] * (len(B) + 1)</span><br><span class="line">        ans &#x3D; 0</span><br><span class="line">        for i in range(1, len(A) + 1):</span><br><span class="line">            for j in range(len(B), 0, -1):</span><br><span class="line">                dp[j] &#x3D; (dp[j - 1] + 1) if A[i - 1] &#x3D;&#x3D; B[j - 1] else 0</span><br><span class="line">                ans &#x3D; max(ans, dp[j])</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="799-champagne-tower">799. Champagne Tower</h3>
<blockquote>
<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.</p>
<p>Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it’s excess champagne fall on the floor.)</p>
<p>For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png" alt=""></p>
<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>
<p>Example 1:<br>
Input: poured = 1, query_glass = 1, query_row = 1<br>
Output: 0.0<br>
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.</p>
<p>Example 2:<br>
Input: poured = 2, query_glass = 1, query_row = 1<br>
Output: 0.5<br>
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.</p>
<p>Note:</p>
<p>poured will be in the range of [0, 10 ^ 9].<br>
query_glass and query_row will be in the range of [0, 99].</p>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/champagne-tower/">leetcode Champagne Tower</a></p>
<p>题目大意：第0排1个杯子，第1排2个杯子以此类推。当某个杯子装满水，溢出的水均匀的向下一排的两边扩散。给定n杯水，问第i行第j个杯子的满水情况。</p>
<p>思路：直接dp</p>
<p>若<code>dp[i][j] &gt; 1</code></p>
<ul>
<li><code>dp[i + 1][j] += dp[i</code>][j]</li>
<li><code>dp[i + 1][j + 1] += dp[i][j]</code></li>
</ul>
<p>就是说当前的i,j可以流向下一行的第j个和第j+1个</p>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	double champagneTower(int poured, int query_row, int query_glass) &#123;</span><br><span class="line">		vector&lt;vector&lt;double&gt;&gt; dp(query_row + 1, vector&lt;double&gt;(query_row + 1, 0));</span><br><span class="line">		dp[0][0] &#x3D; poured;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; query_row; ++i) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; i; ++j) &#123;</span><br><span class="line">				double cur &#x3D; dp[i][j] &gt; 1 ? (dp[i][j] - 1.0) &#x2F; 2 : 0;</span><br><span class="line">				dp[i + 1][j] +&#x3D; cur;</span><br><span class="line">				dp[i + 1][j + 1] +&#x3D; cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return min(dp[query_row][query_glass], 1.0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def champagneTower(self, poured, query_row, query_glass):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type poured: int</span><br><span class="line">        :type query_row: int</span><br><span class="line">        :type query_glass: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; [[0] * (i + 1) for i in range(query_row + 1)]</span><br><span class="line">        dp[0][0] &#x3D; poured</span><br><span class="line">        for i in range(query_row):</span><br><span class="line">            for j in range(i + 1):</span><br><span class="line">                cur &#x3D; (dp[i][j] - 1) &#x2F; 2.0 if dp[i][j] &gt; 1 else 0</span><br><span class="line">                dp[i + 1][j] +&#x3D; cur</span><br><span class="line">                dp[i + 1][j + 1] +&#x3D; cur</span><br><span class="line">        return min(dp[query_row][query_glass], 1)</span><br></pre></td></tr></table></figure>
<p>另一种写法：</p>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def champagneTower(self, poured, query_row, query_glass):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type poured: int</span><br><span class="line">        :type query_row: int</span><br><span class="line">        :type query_glass: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp &#x3D; [[0 for _ in range(query_row + 1)] for i in range(query_row + 1)]</span><br><span class="line">        dp[0][0] &#x3D; poured</span><br><span class="line">        for i in range(1, query_row + 1):</span><br><span class="line">            for j in range(i + 1):</span><br><span class="line">                dp[i][j] +&#x3D; (max(dp[i - 1][j - 1] - 1, 0) &#x2F; 2.0) + (max(dp[i - 1][j] - 1, 0) &#x2F; 2.0)</span><br><span class="line">        return min(dp[query_row][query_glass], 1)</span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<h3 id="818-race-car">818. Race Car</h3>
<blockquote>
<p>Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)</p>
<p>Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).</p>
<p>When you get an instruction “A”, your car does the following: position += speed, speed *= 2.</p>
<p>When you get an instruction “R”, your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)</p>
<p>For example, after commands “AAR”, your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1.</p>
<p>Now for some target position, say the length of the shortest sequence of instructions to get there.</p>
<p>Example 1:<br>
Input:<br>
target = 3<br>
Output: 2<br>
Explanation:<br>
The shortest instruction sequence is “AA”.<br>
Your position goes from 0-&gt;1-&gt;3.</p>
<p>Example 2:<br>
Input:<br>
target = 6<br>
Output: 5<br>
Explanation:<br>
The shortest instruction sequence is “AAARA”.<br>
Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= target &lt;= 10000.</li>
</ul>
</blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/race-car/">leetcode Race Car</a></p>
<p>题目大意：你可以做两种操作’A’和‘R’, A即position += speed, speed *= 2. R即让你速度反向，并且大小为1.   问你用这两种操作到达target的最小步数。</p>
<p>思路：</p>
<p>DP,设<code>dp[i]</code>为到达i的最小步数。</p>
<p>则对于<code>i = 2^k - 1</code>，走k步即可（没有更优的了）</p>
<p>对于<code>2^(k-1) &lt; i &lt; 2^k</code></p>
<ul>
<li>先走到<code>2^(k-1) - 1</code>处(<code>A^(k-1))</code>，然后掉头，然后走<code>A^x</code>, 然后掉头，走<code>dp[i - (2^(k -1) - 1)+ 2^(x) - 1]</code>，所以总共为<code>k-1 +  1 + x + 1 + dp[i - (2^(k -1) - 1)+ 2^(x) - 1]</code></li>
<li>走到<code>2^k - 1</code>，然后掉头，走<code>dp[2^k -1 - i] </code> 总共 <code>k + 1+ dp[2^k - 1- target]</code></li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	int numer_bit(int target) &#123;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		while (target &gt; 0) &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			target &gt;&gt;&#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		return cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int racecar(int target) &#123;</span><br><span class="line">		vector&lt;int&gt; dp((target &lt;&lt; 1) + 1, INT_MAX &gt;&gt; 1);</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; target; ++i) &#123;</span><br><span class="line">			int k &#x3D; numer_bit(i);</span><br><span class="line">			if ((i &amp; (i + 1)) &#x3D;&#x3D; 0)</span><br><span class="line">				dp[i] &#x3D; k;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (int x &#x3D; 0; x &lt; k; ++x) &#123;</span><br><span class="line">					int p &#x3D; i - ((1 &lt;&lt; (k - 1)) - 1) + (1 &lt;&lt; x) - 1;</span><br><span class="line">					if (p &lt; 0) break;</span><br><span class="line">					dp[i] &#x3D; min(dp[i], k + x + 1 + dp[p]);</span><br><span class="line">				&#125;</span><br><span class="line">				dp[i] &#x3D; min(dp[i], k + 1 + dp[(1 &lt;&lt; k) - 1 - i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[target];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Python</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def DP(self, target, dp):</span><br><span class="line">        if dp[target] !&#x3D; -1: return dp[target]</span><br><span class="line">        k &#x3D; target.bit_length()</span><br><span class="line">        if target &#x3D;&#x3D; 2 ** k - 1:</span><br><span class="line">            dp[target] &#x3D; k</span><br><span class="line">        else:</span><br><span class="line">            ans &#x3D; 0x7fffffff</span><br><span class="line">            for t in range(k - 1):</span><br><span class="line">                remain &#x3D; target - ((1 &lt;&lt; (k - 1)) - 1) + ((1 &lt;&lt; t) - 1)</span><br><span class="line">                if remain &lt; 0: break</span><br><span class="line">                ans &#x3D; min(ans, self.DP(remain, dp) + k + t + 1)</span><br><span class="line">            ans &#x3D; min(ans, self.DP(((1 &lt;&lt; k) - 1) - target, dp) + k + 1)  # A^K R DP[2^k-1 - target]</span><br><span class="line">            dp[target] &#x3D; ans</span><br><span class="line">        return dp[target]</span><br><span class="line"></span><br><span class="line">    def racecar(self, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if target &lt; 1: return 0</span><br><span class="line">        dp &#x3D; [0] + [-1] * (target &lt;&lt; 1)</span><br><span class="line">        return self.DP(target, dp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p></p>
<hr>
<p>更多题解可以查看： <a target="_blank" rel="noopener" href="https://www.hrwhisper.me/leetcode-algorithm-solution/">https://www.hrwhisper.me/leetcode-algorithm-solution/</a></p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/leetcode-dynamic-programming/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/reading-notes-pinang-caichongda/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            『读书笔记』皮囊
          
        </div>
      </a>
    
    
      <a href="/leetcode-datastructure/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">leetcode 数据结构</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "fVcjWMD8aI6F0qEfKdUaHa4f-gzGzoHsz",
    app_key: "b26lBsbwmVyxTSnNrsBrnv3U",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2013-2020
        <i class="ri-heart-fill heart_icon"></i> hrwhisper
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/site/logo.jpg" alt="细语呢喃"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/blog-building">博客建设</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friend-link">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/leetcode-algorithm-solution">leetcode题解</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/messageboard">留言板</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about-me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/donate/wechat_pay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3',
    hasInnerContainers: true,
    scrollSmooth: false,
	scrollSmoothDuration: 420,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
	collapseDepth: 2,
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>